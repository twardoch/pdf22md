This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    build-release.yml
    release.yml
docs/
  PARALLEL_PROCESSING.md
issues/
  issue101.txt
  pdf22md-2025-06-23-022136.ips
src/
  AssetExtractor.h
  AssetExtractor.m
  ContentElement.h
  ContentElement.m
  main.m
  PDFMarkdownConverter.h
  PDFMarkdownConverter.m
  PDFPageProcessor.h
  PDFPageProcessor.m
test/
  README.md
.gitignore
AGENTS.md
CHANGELOG.md
CLAUDE.md
LICENSE
Makefile
README.md
release.sh
TODO.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/release.yml">
name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  build-and-release:
    runs-on: macos-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Full history for version tags
    
    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable
    
    - name: Get version from tag
      id: version
      run: |
        VERSION=${GITHUB_REF#refs/tags/v}
        echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
        echo "TAG=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
    
    - name: Build universal binary
      run: |
        # Build for Intel
        make clean
        make VERSION="${{ steps.version.outputs.VERSION }}" CFLAGS="-Wall -Wextra -O2 -fobjc-arc -arch x86_64"
        mv pdf22md pdf22md-x86_64
        
        # Build for Apple Silicon
        make clean
        make VERSION="${{ steps.version.outputs.VERSION }}" CFLAGS="-Wall -Wextra -O2 -fobjc-arc -arch arm64"
        mv pdf22md pdf22md-arm64
        
        # Create universal binary
        lipo -create -output pdf22md pdf22md-x86_64 pdf22md-arm64
        chmod +x pdf22md
        
        # Verify universal binary
        lipo -info pdf22md
        ./pdf22md -v
    
    - name: Create distribution package
      run: |
        # Create directory structure
        mkdir -p dist/usr/local/bin
        mkdir -p dist/usr/local/share/man/man1
        mkdir -p dist/usr/local/share/doc/pdf22md
        
        # Copy files
        cp pdf22md dist/usr/local/bin/
        cp LICENSE dist/usr/local/share/doc/pdf22md/
        cp README.md dist/usr/local/share/doc/pdf22md/
        cp docs/PARALLEL_PROCESSING.md dist/usr/local/share/doc/pdf22md/ || true
        
        # Create man page
        cat > dist/usr/local/share/man/man1/pdf22md.1 << EOF
        .TH PDF22MD 1 "$(date +'%B %Y')" "pdf22md ${{ steps.version.outputs.VERSION }}" "User Commands"
        .SH NAME
        pdf22md \- Convert PDF documents to Markdown format
        .SH SYNOPSIS
        .B pdf22md
        [\fB\-i\fR \fIinput.pdf\fR]
        [\fB\-o\fR \fIoutput.md\fR]
        [\fB\-a\fR \fIassets_folder\fR]
        [\fB\-d\fR \fIdpi\fR]
        [\fB\-v\fR]
        [\fB\-h\fR]
        .SH DESCRIPTION
        .B pdf22md
        is a high-performance PDF to Markdown converter for macOS that uses Grand Central Dispatch (GCD) for parallel processing.
        .SH OPTIONS
        .TP
        .BR \-i " " \fIpath\fR
        Input PDF file (default: stdin)
        .TP
        .BR \-o " " \fIpath\fR
        Output Markdown file (default: stdout)
        .TP
        .BR \-a " " \fIpath\fR
        Assets folder for extracted images
        .TP
        .BR \-d " " \fIdpi\fR
        DPI for rasterizing vector graphics (default: 144)
        .TP
        .BR \-v
        Display version information
        .TP
        .BR \-h
        Display help message
        .SH EXAMPLES
        .TP
        Convert a PDF file to Markdown:
        .B pdf22md -i document.pdf -o document.md
        .TP
        Convert with images saved to an assets folder:
        .B pdf22md -i report.pdf -o report.md -a ./assets
        .TP
        Use with pipes:
        .B cat document.pdf | pdf22md > document.md
        .SH AUTHOR
        Adam Twardoch
        .SH LICENSE
        MIT License
        EOF
    
    - name: Create installer package
      run: |
        # Create package info
        mkdir -p package_resources
        
        # Create postinstall script
        cat > package_resources/postinstall << 'EOF'
        #!/bin/bash
        # Update man database
        if command -v makewhatis >/dev/null 2>&1; then
            makewhatis /usr/local/share/man
        fi
        exit 0
        EOF
        chmod +x package_resources/postinstall
        
        # Build the package
        pkgbuild --root dist \
                 --identifier com.twardoch.pdf22md \
                 --version "${{ steps.version.outputs.VERSION }}" \
                 --scripts package_resources \
                 --ownership recommended \
                 pdf22md-${{ steps.version.outputs.VERSION }}.pkg
        
        # Create a distribution XML for productbuild (optional, for more control)
        cat > distribution.xml << EOF
        <?xml version="1.0" encoding="utf-8" standalone="yes"?>
        <installer-gui-script minSpecVersion="2.0">
            <title>pdf22md ${{ steps.version.outputs.VERSION }}</title>
            <organization>com.twardoch</organization>
            <domains enable_localSystem="true"/>
            <options customize="never" require-scripts="true" rootVolumeOnly="true"/>
            <pkg-ref id="com.twardoch.pdf22md">
                <bundle-version>
                    <bundle CFBundleVersion="${{ steps.version.outputs.VERSION }}" id="com.twardoch.pdf22md" path="pdf22md"/>
                </bundle-version>
            </pkg-ref>
            <choices-outline>
                <line choice="default">
                    <line choice="com.twardoch.pdf22md"/>
                </line>
            </choices-outline>
            <choice id="default" title="pdf22md" description="PDF to Markdown converter"/>
            <choice id="com.twardoch.pdf22md" visible="false">
                <pkg-ref id="com.twardoch.pdf22md"/>
            </choice>
            <pkg-ref id="com.twardoch.pdf22md" version="${{ steps.version.outputs.VERSION }}" onConclusion="none">pdf22md-${{ steps.version.outputs.VERSION }}.pkg</pkg-ref>
        </installer-gui-script>
        EOF
        
        # Sign the package if certificates are available
        if security find-identity -p basic -v | grep -q "Developer ID Installer"; then
            INSTALLER_CERT=$(security find-identity -p basic -v | grep "Developer ID Installer" | head -1 | awk '{print $2}')
            productsign --sign "$INSTALLER_CERT" \
                        pdf22md-${{ steps.version.outputs.VERSION }}.pkg \
                        pdf22md-${{ steps.version.outputs.VERSION }}-signed.pkg
            mv pdf22md-${{ steps.version.outputs.VERSION }}-signed.pkg pdf22md-${{ steps.version.outputs.VERSION }}.pkg
        fi
    
    - name: Create release archives
      run: |
        # Create tarball with binary and docs
        mkdir -p pdf22md-${{ steps.version.outputs.VERSION }}
        cp pdf22md pdf22md-${{ steps.version.outputs.VERSION }}/
        cp README.md LICENSE pdf22md-${{ steps.version.outputs.VERSION }}/
        cp -r docs pdf22md-${{ steps.version.outputs.VERSION }}/ || true
        tar -czf pdf22md-${{ steps.version.outputs.VERSION }}-macos.tar.gz pdf22md-${{ steps.version.outputs.VERSION }}
        
        # Create zip for those who prefer it
        zip -r pdf22md-${{ steps.version.outputs.VERSION }}-macos.zip pdf22md-${{ steps.version.outputs.VERSION }}
    
    - name: Generate release notes
      id: release_notes
      run: |
        # Get previous tag
        PREVIOUS_TAG=$(git tag -l 'v*' | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -2 | head -1)
        
        # Generate changelog
        if [ -n "$PREVIOUS_TAG" ]; then
          echo "## What's Changed" > release_notes.md
          echo "" >> release_notes.md
          git log --pretty=format:"* %s (%h)" ${PREVIOUS_TAG}..HEAD >> release_notes.md
        else
          echo "## Initial Release" > release_notes.md
          echo "" >> release_notes.md
          echo "First release of pdf22md!" >> release_notes.md
        fi
        
        echo "" >> release_notes.md
        echo "## Installation" >> release_notes.md
        echo "" >> release_notes.md
        echo "### Using the installer package (recommended):" >> release_notes.md
        echo '```bash' >> release_notes.md
        echo "curl -LO https://github.com/twardoch/pdf22md/releases/download/${{ steps.version.outputs.TAG }}/pdf22md-${{ steps.version.outputs.VERSION }}.pkg" >> release_notes.md
        echo "sudo installer -pkg pdf22md-${{ steps.version.outputs.VERSION }}.pkg -target /" >> release_notes.md
        echo '```' >> release_notes.md
        echo "" >> release_notes.md
        echo "### Manual installation:" >> release_notes.md
        echo '```bash' >> release_notes.md
        echo "curl -LO https://github.com/twardoch/pdf22md/releases/download/${{ steps.version.outputs.TAG }}/pdf22md-${{ steps.version.outputs.VERSION }}-macos.tar.gz" >> release_notes.md
        echo "tar -xzf pdf22md-${{ steps.version.outputs.VERSION }}-macos.tar.gz" >> release_notes.md
        echo "sudo cp pdf22md-${{ steps.version.outputs.VERSION }}/pdf22md /usr/local/bin/" >> release_notes.md
        echo '```' >> release_notes.md
    
    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        name: pdf22md ${{ steps.version.outputs.VERSION }}
        body_path: release_notes.md
        files: |
          pdf22md-${{ steps.version.outputs.VERSION }}.pkg
          pdf22md-${{ steps.version.outputs.VERSION }}-macos.tar.gz
          pdf22md-${{ steps.version.outputs.VERSION }}-macos.zip
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Update Homebrew formula
      run: |
        # This would typically update a homebrew tap repository
        # For now, we'll just output what should be done
        echo "To update Homebrew formula:"
        echo "1. Update the url to: https://github.com/twardoch/pdf22md/archive/refs/tags/${{ steps.version.outputs.TAG }}.tar.gz"
        echo "2. Update the sha256 hash"
        echo "3. Update the version in the formula"
</file>

<file path="docs/PARALLEL_PROCESSING.md">
# Parallel Processing in `pdf22md`

This document outlines the implementation of parallel processing in the `pdf22md` command-line tool for converting PDF documents to Markdown format.

## 1. Objective

The goal was to accelerate the conversion of multi-page PDF documents by processing multiple pages concurrently and saving extracted images in parallel.

## 2. Technology: Grand Central Dispatch (GCD)

Similar to `pdfupng`, we utilized Apple's **Grand Central Dispatch (GCD)** framework with the `dispatch_apply` function for parallel execution.

## 3. Implementation Details

### 3.1. Parallel Page Processing

The core changes were made within the `convertWithAssetsFolderPath:rasterizedDPI:completion:` method in `PDFMarkdownConverter.m`.

#### From Sequential to Concurrent

The original implementation used a sequential `for` loop:

```objc
for (NSInteger pageIndex = 0; pageIndex < pageCount; pageIndex++) {
    PDFPage *page = [self.pdfDocument pageAtIndex:pageIndex];
    // ... process page ...
}
```

This was replaced with:

```objc
dispatch_apply(pageCount, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t pageIndex) {
    @autoreleasepool {
        PDFPage *page = [self.pdfDocument pageAtIndex:pageIndex];
        // ... process page ...
    }
});
```

### 3.2. Thread Safety Measures

1. **Temporary Storage Arrays**: Instead of directly modifying shared arrays (`allElements`, `fontStats`), we create temporary per-page storage:

```objc
NSMutableArray<NSMutableArray<id<ContentElement>> *> *pageElementsArray = [NSMutableArray arrayWithCapacity:pageCount];
NSMutableArray<NSMutableDictionary *> *pageFontStatsArray = [NSMutableArray arrayWithCapacity:pageCount];
```

2. **Error Handling**: A shared boolean flag with synchronized access:

```objc
__block BOOL processingFailed = NO;
NSObject *lock = [[NSObject alloc] init];

// Inside parallel block
@synchronized(lock) {
    if (processingFailed) return;
}
```

3. **Result Merging**: After parallel processing completes, results are merged sequentially:

```objc
for (NSInteger i = 0; i < pageCount; i++) {
    [self.allElements addObjectsFromArray:pageElementsArray[i]];
    // Merge font statistics...
}
```

### 3.3. Parallel Image Saving

Image saving was also parallelized:

```objc
dispatch_apply(imageCount, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t index) {
    @autoreleasepool {
        ImageElement *imageElement = imageElements[index];
        NSString *savedPath = [assetExtractor saveImage:imageElement.image ...];
        if (savedPath) {
            @synchronized(imageElement) {
                imageElement.assetRelativePath = savedPath;
            }
        }
    }
});
```

### 3.4. Memory Management

Each parallel operation is wrapped in `@autoreleasepool` to ensure prompt deallocation of temporary objects and prevent memory spikes.

## 4. Performance Benefits

- **Multi-core Utilization**: Pages are processed on multiple CPU cores simultaneously
- **Reduced Total Time**: For PDFs with many pages, the speedup is nearly linear with the number of cores
- **Efficient Memory Usage**: Autoreleasepool prevents memory accumulation
- **Scalability**: The implementation automatically adapts to the available hardware

## 5. Considerations

- **Thread Safety**: All shared resources are protected with appropriate synchronization
- **Memory Overhead**: Each parallel task has its own memory footprint, but autoreleasepool keeps it manageable
- **I/O Bottlenecks**: Image saving may be limited by disk I/O speed rather than CPU
</file>

<file path="issues/issue101.txt">
DEBUG: PDFMarkdownConverter - Starting conversion of 2 pages
DEBUG: PDFMarkdownConverter - Starting dispatch_apply for 2 pages
DEBUG: PDFMarkdownConverter - Processing page 0
DEBUG: PDFMarkdownConverter - Processing page 1
DEBUG: PDFPageProcessor - extractContentElements starting for page 0
DEBUG: PDFPageProcessor - Creating content stream for page 0
DEBUG: PDFPageProcessor - Creating operator table for page 0
DEBUG: PDFPageProcessor - Creating scanner for page 0
DEBUG: PDFPageProcessor - Starting scan for page 0
DEBUG: PDFPageProcessor - extractContentElements starting for page 1
DEBUG: PDFPageProcessor - Creating content stream for page 1
DEBUG: PDFPageProcessor - Creating operator table for page 1
DEBUG: PDFPageProcessor - Creating scanner for page 1
DEBUG: PDFPageProcessor - Starting scan for page 1
DEBUG: PDFPageProcessor - Scan completed for page 1, result: 1
DEBUG: PDFPageProcessor - Returning 74 elements for page 1
DEBUG: PDFMarkdownConverter - Page 1 extracted 74 elements
DEBUG: PDFPageProcessor - Scan completed for page 0, result: 1
DEBUG: PDFPageProcessor - Returning 179 elements for page 0
DEBUG: PDFMarkdownConverter - Page 0 extracted 179 elements
DEBUG: PDFMarkdownConverter - dispatch_apply completed
DEBUG: PDFMarkdownConverter - Merging results from all pages
DEBUG: PDFMarkdownConverter - Analyzing font hierarchy
DEBUG: PDFMarkdownConverter - Sorting elements
DEBUG: PDFMarkdownConverter - Sort completed
DEBUG: PDFMarkdownConverter - No assets path provided, skipping image extraction
DEBUG: PDFMarkdownConverter - Starting markdown generation
DEBUG: PDFMarkdownConverter - Generating YAML frontmatter
DEBUG: PDFMarkdownConverter - Converting 253 elements to markdown
DEBUG: PDFMarkdownConverter - Markdown generation completed
</file>

<file path="issues/pdf22md-2025-06-23-022136.ips">
{"app_name":"pdf22md","timestamp":"2025-06-23 02:21:36.00 +0200","app_version":"","slice_uuid":"8cd46494-38d3-3e92-81d8-d1d7afb20c19","build_version":"","platform":1,"share_with_app_devs":0,"is_first_party":1,"bug_type":"309","os_version":"macOS 15.5 (24F74)","roots_installed":0,"incident_id":"A473A639-37D4-4523-9BB2-C0DC1FD6CDA6","name":"pdf22md"}
{
  "uptime" : 93000,
  "procRole" : "Non UI",
  "version" : 2,
  "userID" : 501,
  "deployVersion" : 210,
  "modelCode" : "MacBookPro16,1",
  "coalitionID" : 14969,
  "osVersion" : {
    "train" : "macOS 15.5",
    "build" : "24F74",
    "releaseType" : "User"
  },
  "captureTime" : "2025-06-23 02:21:34.5349 +0200",
  "codeSigningMonitor" : 0,
  "incident" : "A473A639-37D4-4523-9BB2-C0DC1FD6CDA6",
  "pid" : 65611,
  "cpuType" : "X86-64",
  "roots_installed" : 0,
  "bug_type" : "309",
  "procLaunch" : "2025-06-23 02:21:04.3216 +0200",
  "procStartAbsTime" : 93740517770127,
  "procExitAbsTime" : 93770728460189,
  "procName" : "pdf22md",
  "procPath" : "\/Users\/USER\/*\/pdf22md",
  "parentProc" : "bash",
  "parentPid" : 49056,
  "coalitionName" : "dev.warp.Warp-Stable",
  "crashReporterKey" : "8AC6CCF6-C177-38B7-4606-5085B490AB83",
  "appleIntelligenceStatus" : {"state":"unavailable","reasons":["deviceNotCapable"]},
  "responsiblePid" : 34131,
  "responsibleProc" : "stable",
  "codeSigningID" : "",
  "codeSigningTeamID" : "",
  "codeSigningValidationCategory" : 0,
  "codeSigningTrustLevel" : 4294967295,
  "codeSigningAuxiliaryInfo" : 0,
  "bootSessionUUID" : "2D559AC8-1CD6-4295-B5A9-8FB24F515CB5",
  "bridgeVersion" : {"build":"22P5072","train":"9.5"},
  "sip" : "enabled",
  "vmRegionInfo" : "0x7ffa54137f3a is not in any region.  Bytes after previous region: 465633083  Bytes before following region: 91029702\n      REGION TYPE                    START - END         [ VSIZE] PRT\/MAX SHRMOD  REGION DETAIL\n      unused __TEXT            7ffa37f41000-7ffa38528000 [ 6044K] r-x\/r-x SM=COW  unused  unknown system shared lib __TEXT\n--->  GAP OF 0x212e0000 BYTES\n      unused __TEXT            7ffa59808000-7ffa59b80750 [ 3554K] r--\/rw- SM=COW  unused  unknown system shared lib __TEXT",
  "exception" : {"codes":"0x0000000000000001, 0x00007ffa54137f3a","rawCodes":[1,140713129115450],"type":"EXC_BAD_ACCESS","signal":"SIGSEGV","subtype":"KERN_INVALID_ADDRESS at 0x00007ffa54137f3a"},
  "termination" : {"flags":1024,"code":11,"namespace":"SIGNAL","indicator":"Segmentation fault: 11","byProc":"exc handler","byPid":65611},
  "vmregioninfo" : "0x7ffa54137f3a is not in any region.  Bytes after previous region: 465633083  Bytes before following region: 91029702\n      REGION TYPE                    START - END         [ VSIZE] PRT\/MAX SHRMOD  REGION DETAIL\n      unused __TEXT            7ffa37f41000-7ffa38528000 [ 6044K] r-x\/r-x SM=COW  unused  unknown system shared lib __TEXT\n--->  GAP OF 0x212e0000 BYTES\n      unused __TEXT            7ffa59808000-7ffa59b80750 [ 3554K] r--\/rw- SM=COW  unused  unknown system shared lib __TEXT",
  "extMods" : {"caller":{"thread_create":0,"thread_set_state":0,"task_for_pid":0},"system":{"thread_create":0,"thread_set_state":0,"task_for_pid":0},"targeted":{"thread_create":0,"thread_set_state":0,"task_for_pid":0},"warnings":0},
  "faultingThread" : 3,
  "threads" : [{"id":4038374,"threadState":{"r13":{"value":105553137928384},"rax":{"value":14},"rflags":{"value":582},"cpu":{"value":0},"r14":{"value":105553137959792},"rsi":{"value":8589934595},"r8":{"value":14680198217728},"cr2":{"value":0},"rdx":{"value":171798697235},"r10":{"value":17923},"r9":{"value":8808977924096},"r15":{"value":18446744073709551615},"rbx":{"value":105553137959856},"trap":{"value":133},"err":{"value":16777252},"r11":{"value":582},"rip":{"value":140703588489926},"rbp":{"value":140701801523408},"rsp":{"value":140701801523384},"r12":{"value":105553152624576},"rcx":{"value":140701801523384},"flavor":"x86_THREAD_STATE","rdi":{"value":17923}},"queue":"com.apple.main-thread","frames":[{"imageOffset":2758,"symbol":"semaphore_wait_trap","symbolLocation":10,"imageIndex":3},{"imageOffset":11407,"symbol":"_dispatch_sema4_wait","symbolLocation":16,"imageIndex":4},{"imageOffset":12486,"symbol":"_dispatch_semaphore_wait_slow","symbolLocation":98,"imageIndex":4},{"imageOffset":7530,"symbol":"main","symbolLocation":762,"imageIndex":0},{"imageOffset":25904,"symbol":"start","symbolLocation":3056,"imageIndex":5}]},{"id":4038449,"threadState":{"r13":{"value":15},"rax":{"value":0},"rflags":{"value":582},"cpu":{"value":0},"r14":{"value":140704689807040,"symbolLocation":1152,"symbol":"_dispatch_root_queues"},"rsi":{"value":0},"r8":{"value":15},"cr2":{"value":0},"rdx":{"value":0},"r10":{"value":67111167},"r9":{"value":3416444958},"r15":{"value":105553152524800},"rbx":{"value":15},"trap":{"value":133},"err":{"value":33554800},"r11":{"value":582},"rip":{"value":140703588496006},"rbp":{"value":123145535588656},"rsp":{"value":123145535588648},"r12":{"value":0},"rcx":{"value":123145535588648},"flavor":"x86_THREAD_STATE","rdi":{"value":32}},"queue":"com.apple.root.default-qos","frames":[{"imageOffset":8838,"symbol":"__workq_kernreturn","symbolLocation":10,"imageIndex":3},{"imageOffset":10089,"symbol":"_pthread_workqueue_addthreads","symbolLocation":37,"imageIndex":7},{"imageOffset":52826,"symbol":"_dispatch_root_queue_poke_slow","symbolLocation":225,"imageIndex":4},{"imageOffset":75112,"symbol":"_dispatch_apply_with_attr_f","symbolLocation":1569,"imageIndex":4},{"imageOffset":75359,"symbol":"dispatch_apply","symbolLocation":45,"imageIndex":4},{"imageOffset":12008,"symbol":"__77-[PDFMarkdownConverter convertWithAssetsFolderPath:rasterizedDPI:completion:]_block_invoke","symbolLocation":2296,"imageIndex":0},{"imageOffset":5817,"symbol":"_dispatch_call_block_and_release","symbolLocation":12,"imageIndex":4},{"imageOffset":96764,"symbol":"_dispatch_client_callout","symbolLocation":6,"imageIndex":4},{"imageOffset":199941,"symbol":"_dispatch_queue_override_invoke.cold.3","symbolLocation":34,"imageIndex":4},{"imageOffset":20063,"symbol":"_dispatch_queue_override_invoke","symbolLocation":1060,"imageIndex":4},{"imageOffset":205630,"symbol":"_dispatch_root_queue_drain.cold.3","symbolLocation":263,"imageIndex":4},{"imageOffset":68246,"symbol":"_dispatch_root_queue_drain","symbolLocation":98,"imageIndex":4},{"imageOffset":69397,"symbol":"_dispatch_worker_thread2","symbolLocation":147,"imageIndex":4},{"imageOffset":10348,"symbol":"_pthread_wqthread","symbolLocation":233,"imageIndex":7},{"imageOffset":6211,"symbol":"start_wqthread","symbolLocation":15,"imageIndex":7}]},{"id":4038975,"threadState":{"r13":{"value":140704630818496,"symbolLocation":0,"symbol":"__kCFAllocatorSystemDefault"},"rax":{"value":1},"rflags":{"value":514},"cpu":{"value":0},"r14":{"value":48},"rsi":{"value":48},"r8":{"value":0},"cr2":{"value":0},"rdx":{"value":3473692774},"r10":{"value":140704689869640,"symbolLocation":0,"symbol":"__CFConstantStringClassReference"},"r9":{"value":0},"r15":{"value":16},"rbx":{"value":7},"trap":{"value":222},"err":{"value":0},"r11":{"value":140703616400337,"symbolLocation":0,"symbol":"-[NSString(_NSOriginalAttributedString) __baseAttributedString]"},"rip":{"value":140703590332326},"rbp":{"value":123145538272064},"rsp":{"value":123145538271976},"r12":{"value":3473692774},"rcx":{"value":1},"flavor":"x86_THREAD_STATE","rdi":{"value":140704630818496,"symbolLocation":0,"symbol":"__kCFAllocatorSystemDefault"}},"queue":"com.apple.root.default-qos","frames":[{"imageOffset":1124262,"symbol":"_CFAllocatorAllocateImpl","symbolLocation":0,"imageIndex":8},{"imageOffset":14962,"symbol":"_CFRuntimeCreateInstance","symbolLocation":397,"imageIndex":8},{"imageOffset":70204,"symbol":"CFStringCreateMutable","symbolLocation":69,"imageIndex":8},{"imageOffset":1403884,"symbol":"_CFStringCreateWithFormatAndArgumentsReturningMetadata","symbolLocation":72,"imageIndex":8},{"imageOffset":173502,"symbol":"_CFStringCreateWithFormatAndArgumentsAux2","symbolLocation":28,"imageIndex":8},{"imageOffset":46284,"symbol":"-[NSPlaceholderString initWithFormat:locale:arguments:]","symbolLocation":188,"imageIndex":9},{"imageOffset":104859,"symbol":"+[NSString stringWithFormat:]","symbolLocation":153,"imageIndex":9},{"imageOffset":3857,"symbol":"-[AssetExtractor saveImage:isVectorSource:withBaseName:]","symbolLocation":161,"imageIndex":0},{"imageOffset":14636,"symbol":"__77-[PDFMarkdownConverter convertWithAssetsFolderPath:rasterizedDPI:completion:]_block_invoke.83","symbolLocation":156,"imageIndex":0},{"imageOffset":96772,"symbol":"_dispatch_client_callout2","symbolLocation":6,"imageIndex":4},{"imageOffset":77036,"symbol":"_dispatch_apply_invoke3","symbolLocation":440,"imageIndex":4},{"imageOffset":96764,"symbol":"_dispatch_client_callout","symbolLocation":6,"imageIndex":4},{"imageOffset":14573,"symbol":"_dispatch_once_callout","symbolLocation":20,"imageIndex":4},{"imageOffset":73304,"symbol":"_dispatch_apply_invoke","symbolLocation":184,"imageIndex":4},{"imageOffset":96764,"symbol":"_dispatch_client_callout","symbolLocation":6,"imageIndex":4},{"imageOffset":206155,"symbol":"_dispatch_root_queue_drain.cold.3","symbolLocation":788,"imageIndex":4},{"imageOffset":68246,"symbol":"_dispatch_root_queue_drain","symbolLocation":98,"imageIndex":4},{"imageOffset":69397,"symbol":"_dispatch_worker_thread2","symbolLocation":147,"imageIndex":4},{"imageOffset":10348,"symbol":"_pthread_wqthread","symbolLocation":233,"imageIndex":7},{"imageOffset":6211,"symbol":"start_wqthread","symbolLocation":15,"imageIndex":7}]},{"triggered":true,"id":4038981,"instructionState":{"instructionStream":{"bytes":[73,139,67,8,72,131,248,0,116,3,76,49,208,195,235,0,49,192,195,102,102,102,102,102,102,46,15,31,132,0,0,0,0,0,102,102,102,102,102,102,46,15,31,132,0,0,0,0,0,102,15,31,68,0,0,72,133,255,46,116,114,64,246,199,1,46,117,118,73,186,248,255,255,255,255,127,0,0,76,35,23,73,137,243,69,35,90,24,73,193,227,4,77,3,90,16,73,59,51,117,10,77,139,91,8,77,49,211,65,255,227,73,131,59,1,118,19,73,131,195,16,73,59,51,117,241,77,139,91,8,77,49,211,65,255,227,114,112,77,139,91,8,235,10,73,131,59,1,118,19,73,131,195,16,73,59,51,117,241,77,139,91,8,77,49,211,65,255,227,235,79,15,31,64,0,49,192,49,210,15,87,192,15,87,201,195,65,137,251,65,131,227],"offset":96}},"threadState":{"r13":{"value":140703584649408,"symbolLocation":0,"symbol":"objc_msgSend"},"rax":{"value":1},"rflags":{"value":66054},"cpu":{"value":15},"r14":{"value":140390123503728},"rsi":{"value":140704115788183,"objc-selector":"_cfTypeID"},"r8":{"value":2038047353469503843},"cr2":{"value":140713129115450},"rdx":{"value":140704689871600,"symbolLocation":0,"symbol":"OBJC_CLASS_$___NSCFType"},"r10":{"value":140704648376208,"symbolLocation":16,"symbol":"vtable for TFPInMemoryFont"},"r9":{"value":340},"r15":{"value":140390123503728},"rbx":{"value":0},"trap":{"value":14,"description":"(no mapping for user data read)"},"err":{"value":4},"r11":{"value":140713129115450},"rip":{"value":140703584649449,"matchesCrashFrame":1},"rbp":{"value":123145541491872},"rsp":{"value":123145541491832},"r12":{"value":0},"rcx":{"value":140704648376208,"symbolLocation":16,"symbol":"vtable for TFPInMemoryFont"},"flavor":"x86_THREAD_STATE","rdi":{"value":140390123503728}},"queue":"com.apple.root.default-qos","frames":[{"imageOffset":24809,"symbol":"objc_msgSend","symbolLocation":41,"imageIndex":10},{"imageOffset":259532,"symbol":"CGImageGetAlphaInfo","symbolLocation":25,"imageIndex":11},{"imageOffset":4338,"symbol":"-[AssetExtractor shouldUseJPEGForImage:]","symbolLocation":50,"imageIndex":0},{"imageOffset":3784,"symbol":"-[AssetExtractor saveImage:isVectorSource:withBaseName:]","symbolLocation":88,"imageIndex":0},{"imageOffset":14636,"symbol":"__77-[PDFMarkdownConverter convertWithAssetsFolderPath:rasterizedDPI:completion:]_block_invoke.83","symbolLocation":156,"imageIndex":0},{"imageOffset":96772,"symbol":"_dispatch_client_callout2","symbolLocation":6,"imageIndex":4},{"imageOffset":77036,"symbol":"_dispatch_apply_invoke3","symbolLocation":440,"imageIndex":4},{"imageOffset":96764,"symbol":"_dispatch_client_callout","symbolLocation":6,"imageIndex":4},{"imageOffset":14573,"symbol":"_dispatch_once_callout","symbolLocation":20,"imageIndex":4},{"imageOffset":73304,"symbol":"_dispatch_apply_invoke","symbolLocation":184,"imageIndex":4},{"imageOffset":96764,"symbol":"_dispatch_client_callout","symbolLocation":6,"imageIndex":4},{"imageOffset":206155,"symbol":"_dispatch_root_queue_drain.cold.3","symbolLocation":788,"imageIndex":4},{"imageOffset":68246,"symbol":"_dispatch_root_queue_drain","symbolLocation":98,"imageIndex":4},{"imageOffset":69397,"symbol":"_dispatch_worker_thread2","symbolLocation":147,"imageIndex":4},{"imageOffset":10348,"symbol":"_pthread_wqthread","symbolLocation":233,"imageIndex":7},{"imageOffset":6211,"symbol":"start_wqthread","symbolLocation":15,"imageIndex":7}]},{"id":4083659,"threadState":{"r13":{"value":0},"rax":{"value":1},"rflags":{"value":518},"cpu":{"value":0},"r14":{"value":2},"rsi":{"value":140704115788969,"objc-selector":"_dynamicContextEvaluation:patternString:"},"r8":{"value":140703675056225,"symbolLocation":9,"symbol":"_OBJC_$_CATEGORY_INSTANCE_METHODS_NSString_$_UTAdditions"},"cr2":{"value":0},"rdx":{"value":140703675056225,"symbolLocation":9,"symbol":"_OBJC_$_CATEGORY_INSTANCE_METHODS_NSString_$_UTAdditions"},"r10":{"value":105553128375552},"r9":{"value":11},"r15":{"value":140703675056225,"symbolLocation":9,"symbol":"_OBJC_$_CATEGORY_INSTANCE_METHODS_NSString_$_UTAdditions"},"rbx":{"value":116362},"trap":{"value":222},"err":{"value":0},"r11":{"value":140703675056224,"symbolLocation":8,"symbol":"_OBJC_$_CATEGORY_INSTANCE_METHODS_NSString_$_UTAdditions"},"rip":{"value":140703584647334},"rbp":{"value":123145536119104},"rsp":{"value":123145536119024},"r12":{"value":6169},"rcx":{"value":12},"flavor":"x86_THREAD_STATE","rdi":{"value":12}},"queue":"com.apple.root.default-qos","frames":[{"imageOffset":22694,"symbol":"getMethodNoSuper_nolock(objc_class*, objc_selector*)","symbolLocation":978,"imageIndex":10},{"imageOffset":30090,"symbol":"lookUpImpOrForward","symbolLocation":304,"imageIndex":10},{"imageOffset":47720,"symbol":"class_respondsToSelector_inst","symbolLocation":160,"imageIndex":10},{"imageOffset":46438,"symbol":"_NSDescriptionWithStringProxyFunc","symbolLocation":41,"imageIndex":9},{"imageOffset":1417520,"symbol":"__CFSTRING_IS_CALLING_OUT_TO_AN_OBJECT_FORMAT_ARGUMENT_WITH_CONTEXT__","symbolLocation":25,"imageIndex":8},{"imageOffset":183532,"symbol":"__CFStringAppendFormatCore","symbolLocation":10018,"imageIndex":8},{"imageOffset":1403957,"symbol":"_CFStringCreateWithFormatAndArgumentsReturningMetadata","symbolLocation":145,"imageIndex":8},{"imageOffset":173502,"symbol":"_CFStringCreateWithFormatAndArgumentsAux2","symbolLocation":28,"imageIndex":8},{"imageOffset":46284,"symbol":"-[NSPlaceholderString initWithFormat:locale:arguments:]","symbolLocation":188,"imageIndex":9},{"imageOffset":104859,"symbol":"+[NSString stringWithFormat:]","symbolLocation":153,"imageIndex":9},{"imageOffset":3857,"symbol":"-[AssetExtractor saveImage:isVectorSource:withBaseName:]","symbolLocation":161,"imageIndex":0},{"imageOffset":14636,"symbol":"__77-[PDFMarkdownConverter convertWithAssetsFolderPath:rasterizedDPI:completion:]_block_invoke.83","symbolLocation":156,"imageIndex":0},{"imageOffset":96772,"symbol":"_dispatch_client_callout2","symbolLocation":6,"imageIndex":4},{"imageOffset":77036,"symbol":"_dispatch_apply_invoke3","symbolLocation":440,"imageIndex":4},{"imageOffset":96764,"symbol":"_dispatch_client_callout","symbolLocation":6,"imageIndex":4},{"imageOffset":14573,"symbol":"_dispatch_once_callout","symbolLocation":20,"imageIndex":4},{"imageOffset":73304,"symbol":"_dispatch_apply_invoke","symbolLocation":184,"imageIndex":4},{"imageOffset":96764,"symbol":"_dispatch_client_callout","symbolLocation":6,"imageIndex":4},{"imageOffset":206155,"symbol":"_dispatch_root_queue_drain.cold.3","symbolLocation":788,"imageIndex":4},{"imageOffset":68246,"symbol":"_dispatch_root_queue_drain","symbolLocation":98,"imageIndex":4},{"imageOffset":69397,"symbol":"_dispatch_worker_thread2","symbolLocation":147,"imageIndex":4},{"imageOffset":10348,"symbol":"_pthread_wqthread","symbolLocation":233,"imageIndex":7},{"imageOffset":6211,"symbol":"start_wqthread","symbolLocation":15,"imageIndex":7}]},{"id":4083660,"threadState":{"r13":{"value":105553143040897},"rax":{"value":140704630818496,"symbolLocation":0,"symbol":"__kCFAllocatorSystemDefault"},"rflags":{"value":514},"cpu":{"value":0},"r14":{"value":281474976712449},"rsi":{"value":105553143040896},"r8":{"value":1},"cr2":{"value":0},"rdx":{"value":128},"r10":{"value":6},"r9":{"value":123145536654912},"r15":{"value":1},"rbx":{"value":105553176456064},"trap":{"value":222},"err":{"value":0},"r11":{"value":1331},"rip":{"value":140703589282108},"rbp":{"value":123145536654880},"rsp":{"value":123145536654416},"r12":{"value":9},"rcx":{"value":128},"flavor":"x86_THREAD_STATE","rdi":{"value":105553143040897}},"queue":"com.apple.root.default-qos","frames":[{"imageOffset":74044,"symbol":"__CFStringChangeSizeMultiple","symbolLocation":1870,"imageIndex":8},{"imageOffset":191392,"symbol":"__CFStringAppendBytes","symbolLocation":571,"imageIndex":8},{"imageOffset":187452,"symbol":"__CFStringAppendFormatCore","symbolLocation":13938,"imageIndex":8},{"imageOffset":1403957,"symbol":"_CFStringCreateWithFormatAndArgumentsReturningMetadata","symbolLocation":145,"imageIndex":8},{"imageOffset":173502,"symbol":"_CFStringCreateWithFormatAndArgumentsAux2","symbolLocation":28,"imageIndex":8},{"imageOffset":46284,"symbol":"-[NSPlaceholderString initWithFormat:locale:arguments:]","symbolLocation":188,"imageIndex":9},{"imageOffset":104859,"symbol":"+[NSString stringWithFormat:]","symbolLocation":153,"imageIndex":9},{"imageOffset":14572,"symbol":"__77-[PDFMarkdownConverter convertWithAssetsFolderPath:rasterizedDPI:completion:]_block_invoke.83","symbolLocation":92,"imageIndex":0},{"imageOffset":96772,"symbol":"_dispatch_client_callout2","symbolLocation":6,"imageIndex":4},{"imageOffset":77036,"symbol":"_dispatch_apply_invoke3","symbolLocation":440,"imageIndex":4},{"imageOffset":96764,"symbol":"_dispatch_client_callout","symbolLocation":6,"imageIndex":4},{"imageOffset":14573,"symbol":"_dispatch_once_callout","symbolLocation":20,"imageIndex":4},{"imageOffset":73304,"symbol":"_dispatch_apply_invoke","symbolLocation":184,"imageIndex":4},{"imageOffset":96764,"symbol":"_dispatch_client_callout","symbolLocation":6,"imageIndex":4},{"imageOffset":206155,"symbol":"_dispatch_root_queue_drain.cold.3","symbolLocation":788,"imageIndex":4},{"imageOffset":68246,"symbol":"_dispatch_root_queue_drain","symbolLocation":98,"imageIndex":4},{"imageOffset":69397,"symbol":"_dispatch_worker_thread2","symbolLocation":147,"imageIndex":4},{"imageOffset":10348,"symbol":"_pthread_wqthread","symbolLocation":233,"imageIndex":7},{"imageOffset":6211,"symbol":"start_wqthread","symbolLocation":15,"imageIndex":7}]},{"id":4083661,"frames":[{"imageOffset":6196,"symbol":"start_wqthread","symbolLocation":0,"imageIndex":7}],"threadState":{"r13":{"value":0},"rax":{"value":0},"rflags":{"value":512},"cpu":{"value":0},"r14":{"value":0},"rsi":{"value":33299},"r8":{"value":2375684},"cr2":{"value":0},"rdx":{"value":123145536675840},"r10":{"value":0},"r9":{"value":0},"r15":{"value":0},"rbx":{"value":0},"trap":{"value":0},"err":{"value":0},"r11":{"value":0},"rip":{"value":140703588743220},"rbp":{"value":0},"rsp":{"value":123145537200128},"r12":{"value":0},"rcx":{"value":0},"flavor":"x86_THREAD_STATE","rdi":{"value":123145537200128}}},{"id":4083662,"frames":[{"imageOffset":6196,"symbol":"start_wqthread","symbolLocation":0,"imageIndex":7}],"threadState":{"r13":{"value":0},"rax":{"value":0},"rflags":{"value":512},"cpu":{"value":0},"r14":{"value":0},"rsi":{"value":33115},"r8":{"value":2375684},"cr2":{"value":0},"rdx":{"value":123145537212416},"r10":{"value":0},"r9":{"value":0},"r15":{"value":0},"rbx":{"value":0},"trap":{"value":0},"err":{"value":0},"r11":{"value":0},"rip":{"value":140703588743220},"rbp":{"value":0},"rsp":{"value":123145537736704},"r12":{"value":0},"rcx":{"value":0},"flavor":"x86_THREAD_STATE","rdi":{"value":123145537736704}}},{"id":4083663,"frames":[{"imageOffset":6196,"symbol":"start_wqthread","symbolLocation":0,"imageIndex":7}],"threadState":{"r13":{"value":0},"rax":{"value":0},"rflags":{"value":512},"cpu":{"value":0},"r14":{"value":0},"rsi":{"value":28439},"r8":{"value":2375684},"cr2":{"value":0},"rdx":{"value":123145538285568},"r10":{"value":0},"r9":{"value":0},"r15":{"value":0},"rbx":{"value":0},"trap":{"value":0},"err":{"value":0},"r11":{"value":0},"rip":{"value":140703588743220},"rbp":{"value":0},"rsp":{"value":123145538809856},"r12":{"value":0},"rcx":{"value":0},"flavor":"x86_THREAD_STATE","rdi":{"value":123145538809856}}},{"id":4083664,"frames":[{"imageOffset":6196,"symbol":"start_wqthread","symbolLocation":0,"imageIndex":7}],"threadState":{"r13":{"value":0},"rax":{"value":0},"rflags":{"value":512},"cpu":{"value":0},"r14":{"value":0},"rsi":{"value":43115},"r8":{"value":2375684},"cr2":{"value":0},"rdx":{"value":123145538822144},"r10":{"value":0},"r9":{"value":0},"r15":{"value":0},"rbx":{"value":0},"trap":{"value":0},"err":{"value":0},"r11":{"value":0},"rip":{"value":140703588743220},"rbp":{"value":0},"rsp":{"value":123145539346432},"r12":{"value":0},"rcx":{"value":0},"flavor":"x86_THREAD_STATE","rdi":{"value":123145539346432}}},{"id":4083665,"frames":[{"imageOffset":6196,"symbol":"start_wqthread","symbolLocation":0,"imageIndex":7}],"threadState":{"r13":{"value":0},"rax":{"value":0},"rflags":{"value":512},"cpu":{"value":0},"r14":{"value":0},"rsi":{"value":19975},"r8":{"value":2375684},"cr2":{"value":0},"rdx":{"value":123145539358720},"r10":{"value":0},"r9":{"value":0},"r15":{"value":0},"rbx":{"value":0},"trap":{"value":0},"err":{"value":0},"r11":{"value":0},"rip":{"value":140703588743220},"rbp":{"value":0},"rsp":{"value":123145539883008},"r12":{"value":0},"rcx":{"value":0},"flavor":"x86_THREAD_STATE","rdi":{"value":123145539883008}}}],
  "usedImages" : [
  {
    "source" : "P",
    "arch" : "x86_64",
    "base" : 4547244032,
    "size" : 36864,
    "uuid" : "8cd46494-38d3-3e92-81d8-d1d7afb20c19",
    "path" : "*\/pdf22md",
    "name" : "pdf22md"
  },
  {
    "source" : "P",
    "arch" : "x86_64",
    "base" : 4629454848,
    "CFBundleShortVersionString" : "23.0.26",
    "CFBundleIdentifier" : "com.apple.AppleIntelKBLGraphicsVADriver",
    "size" : 25550848,
    "uuid" : "ca870e38-79cb-36a3-8652-c8d3c9588f2c",
    "path" : "\/System\/Library\/Extensions\/AppleIntelKBLGraphicsVADriver.bundle\/Contents\/MacOS\/AppleIntelKBLGraphicsVADriver",
    "name" : "AppleIntelKBLGraphicsVADriver",
    "CFBundleVersion" : "23.0.0"
  },
  {
    "source" : "P",
    "arch" : "x86_64",
    "base" : 4602159104,
    "CFBundleShortVersionString" : "23.0.26",
    "CFBundleIdentifier" : "com.apple.AppleIntelCFLGraphicsVAME",
    "size" : 20480,
    "uuid" : "9a77c09d-d549-377e-a805-c6fbd7b0224c",
    "path" : "\/System\/Library\/Extensions\/AppleIntelCFLGraphicsVAME.bundle\/Contents\/MacOS\/AppleIntelCFLGraphicsVAME",
    "name" : "AppleIntelCFLGraphicsVAME",
    "CFBundleVersion" : "23.0.0"
  },
  {
    "source" : "P",
    "arch" : "x86_64",
    "base" : 140703588487168,
    "size" : 248656,
    "uuid" : "dab10aa4-8afa-3d02-9cde-6023554ac858",
    "path" : "\/usr\/lib\/system\/libsystem_kernel.dylib",
    "name" : "libsystem_kernel.dylib"
  },
  {
    "source" : "P",
    "arch" : "x86_64",
    "base" : 140703587004416,
    "size" : 291594,
    "uuid" : "a709554b-250f-3213-b4dd-6708dd83f622",
    "path" : "\/usr\/lib\/system\/libdispatch.dylib",
    "name" : "libdispatch.dylib"
  },
  {
    "source" : "P",
    "arch" : "x86_64",
    "base" : 140703584911360,
    "size" : 632104,
    "uuid" : "3771ea6a-0fe5-3b63-961d-c09e01d5e680",
    "path" : "\/usr\/lib\/dyld",
    "name" : "dyld"
  },
  {
    "size" : 0,
    "source" : "A",
    "base" : 0,
    "uuid" : "00000000-0000-0000-0000-000000000000"
  },
  {
    "source" : "P",
    "arch" : "x86_64",
    "base" : 140703588737024,
    "size" : 48592,
    "uuid" : "a6d1f05a-0743-31b7-9fe2-268f06ccd51a",
    "path" : "\/usr\/lib\/system\/libsystem_pthread.dylib",
    "name" : "libsystem_pthread.dylib"
  },
  {
    "source" : "P",
    "arch" : "x86_64h",
    "base" : 140703589208064,
    "CFBundleShortVersionString" : "6.9",
    "CFBundleIdentifier" : "com.apple.CoreFoundation",
    "size" : 4935667,
    "uuid" : "2f3a4185-6038-37d0-a02b-ec620bcd977b",
    "path" : "\/System\/Library\/Frameworks\/CoreFoundation.framework\/Versions\/A\/CoreFoundation",
    "name" : "CoreFoundation",
    "CFBundleVersion" : "3502.1.401"
  },
  {
    "source" : "P",
    "arch" : "x86_64",
    "base" : 140703607431168,
    "CFBundleShortVersionString" : "6.9",
    "CFBundleIdentifier" : "com.apple.Foundation",
    "size" : 14620850,
    "uuid" : "3e72de1d-c81a-3c8b-9c06-5b1e3186de47",
    "path" : "\/System\/Library\/Frameworks\/Foundation.framework\/Versions\/C\/Foundation",
    "name" : "Foundation",
    "CFBundleVersion" : "3502.1.401"
  },
  {
    "source" : "P",
    "arch" : "x86_64h",
    "base" : 140703584624640,
    "size" : 282716,
    "uuid" : "de35b5ee-5872-3e5a-a1f0-eb18c5b0434c",
    "path" : "\/usr\/lib\/libobjc.A.dylib",
    "name" : "libobjc.A.dylib"
  },
  {
    "source" : "P",
    "arch" : "x86_64",
    "base" : 140703690715136,
    "CFBundleShortVersionString" : "2.0",
    "CFBundleIdentifier" : "com.apple.CoreGraphics",
    "size" : 9383006,
    "uuid" : "d6f2e6a9-32bc-3b4d-b6e2-b8585e792541",
    "path" : "\/System\/Library\/Frameworks\/CoreGraphics.framework\/Versions\/A\/CoreGraphics",
    "name" : "CoreGraphics",
    "CFBundleVersion" : "1889.5.3"
  },
  {
    "source" : "P",
    "arch" : "x86_64",
    "base" : 140703674994688,
    "CFBundleShortVersionString" : "709",
    "CFBundleIdentifier" : "com.apple.UniformTypeIdentifiers",
    "size" : 87946,
    "uuid" : "d9b256e0-ef45-35cb-86d8-eba5d692626a",
    "path" : "\/System\/Library\/Frameworks\/UniformTypeIdentifiers.framework\/Versions\/A\/UniformTypeIdentifiers",
    "name" : "UniformTypeIdentifiers",
    "CFBundleVersion" : "709"
  }
],
  "sharedCache" : {
  "base" : 140703556468736,
  "size" : 30064771072,
  "uuid" : "57b0c2b8-36d6-3cf0-8bd0-0ac6133ec8b3"
},
  "vmSummary" : "ReadOnly portion of Libraries: Total=620.8M resident=0K(0%) swapped_out_or_unallocated=620.8M(100%)\nWritable regions: Total=2.7G written=0K(0%) resident=0K(0%) swapped_out=0K(0%) unallocated=2.7G(100%)\n\n                                VIRTUAL   REGION \nREGION TYPE                        SIZE    COUNT (non-coalesced) \n===========                     =======  ======= \nAccelerate framework               128K        1 \nActivity Tracing                   256K        1 \nColorSync                          224K       25 \nKernel Alloc Once                    8K        1 \nMALLOC                             2.6G       83 \nMALLOC guard page                   48K       12 \nSTACK GUARD                       56.0M       11 \nStack                             13.6M       13 \nStack Guard                          4K        1 \nVM_ALLOCATE                         16K        3 \n__CTF                               824        1 \n__DATA                            8939K      423 \n__DATA_CONST                      47.1M      448 \n__DATA_DIRTY                       797K      132 \n__FONT_DATA                        2352        1 \n__LINKEDIT                       162.3M        4 \n__OBJC_RO                         61.3M        1 \n__OBJC_RW                         2395K        2 \n__TEXT                           458.6M      458 \n__TPRO_CONST                         16        2 \nmapped file                       49.2M        6 \nshared memory                      784K       16 \n===========                     =======  ======= \nTOTAL                              3.5G     1645 \n",
  "legacyInfo" : {
  "threadTriggered" : {
    "queue" : "com.apple.root.default-qos"
  }
},
  "logWritingSignature" : "beb0c9cee2219e6b5edfd852342924a9e50ddb6e",
  "trialInfo" : {
  "rollouts" : [
    {
      "rolloutId" : "6761d0c9df60af01adb250fb",
      "factorPackIds" : {

      },
      "deploymentId" : 240000009
    },
    {
      "rolloutId" : "63508950b3714d3622fc77f7",
      "factorPackIds" : {
        "SIRI_MEMORY_SYNC_CONFIG" : "6526e111d0c9ce2f459b54a8"
      },
      "deploymentId" : 240000015
    }
  ],
  "experiments" : [
    {
      "treatmentId" : "4c25da6c-cb8d-40eb-9b62-a1230e80ce69",
      "experimentId" : "67f469f384eaf455d73c6092",
      "deploymentId" : 400000001
    }
  ]
}
}
</file>

<file path="src/AssetExtractor.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

@interface AssetExtractor : NSObject

- (nullable instancetype)initWithAssetFolder:(NSString *)folderPath;

- (nullable NSString *)saveImage:(CGImageRef)image
                  isVectorSource:(BOOL)isVector
                      withBaseName:(NSString *)baseName;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="src/AssetExtractor.m">
#import "AssetExtractor.h"
#import <ImageIO/ImageIO.h>

@interface AssetExtractor ()
@property (nonatomic, strong) NSString *assetFolderPath;
@property (nonatomic, strong) NSFileManager *fileManager;
@end

@implementation AssetExtractor

- (nullable instancetype)initWithAssetFolder:(NSString *)folderPath {
    self = [super init];
    if (self) {
        _assetFolderPath = folderPath;
        _fileManager = [NSFileManager defaultManager];
        
        // Create assets folder if it doesn't exist
        NSError *error = nil;
        BOOL isDirectory = NO;
        BOOL exists = [_fileManager fileExistsAtPath:folderPath isDirectory:&isDirectory];
        
        if (exists && !isDirectory) {
            NSLog(@"Asset path exists but is not a directory: %@", folderPath);
            return nil;
        }
        
        if (!exists) {
            if (![_fileManager createDirectoryAtPath:folderPath
                         withIntermediateDirectories:YES
                                          attributes:nil
                                               error:&error]) {
                NSLog(@"Failed to create assets folder: %@", error);
                return nil;
            }
        }
    }
    return self;
}

- (nullable NSString *)saveImage:(CGImageRef)image
                  isVectorSource:(BOOL)isVector
                      withBaseName:(NSString *)baseName {
    if (!image) {
        return nil;
    }
    
    // Analyze image to determine optimal format
    BOOL shouldUseJPEG = [self shouldUseJPEGForImage:image];
    
    NSString *extension = shouldUseJPEG ? @"jpg" : @"png";
    NSString *fileName = [NSString stringWithFormat:@"%@.%@", baseName, extension];
    NSString *fullPath = [self.assetFolderPath stringByAppendingPathComponent:fileName];
    
    // Create destination
    NSURL *fileURL = [NSURL fileURLWithPath:fullPath];
    CGImageDestinationRef destination = CGImageDestinationCreateWithURL((__bridge CFURLRef)fileURL,
                                                                       shouldUseJPEG ? (__bridge CFStringRef)@"public.jpeg" : (__bridge CFStringRef)@"public.png",
                                                                       1, NULL);
    if (!destination) {
        NSLog(@"Failed to create image destination");
        return nil;
    }
    
    // Set compression options
    NSDictionary *properties = nil;
    if (shouldUseJPEG) {
        properties = @{(__bridge NSString *)kCGImageDestinationLossyCompressionQuality: @0.85};
    }
    
    // Add image to destination
    CGImageDestinationAddImage(destination, image, (__bridge CFDictionaryRef)properties);
    
    // Finalize
    BOOL success = CGImageDestinationFinalize(destination);
    CFRelease(destination);
    
    if (!success) {
        NSLog(@"Failed to save image to %@", fullPath);
        return nil;
    }
    
    // Return relative path (just the filename since it's in the assets folder)
    return fileName;
}

- (BOOL)shouldUseJPEGForImage:(CGImageRef)image {
    // Get image properties
    size_t width = CGImageGetWidth(image);
    size_t height = CGImageGetHeight(image);
    CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(image);
    
    // If image has alpha channel, use PNG
    if (alphaInfo != kCGImageAlphaNone &&
        alphaInfo != kCGImageAlphaNoneSkipFirst &&
        alphaInfo != kCGImageAlphaNoneSkipLast) {
        return NO;
    }
    
    // For small images, use PNG
    if (width * height < 10000) { // Less than 100x100
        return NO;
    }
    
    // Analyze color complexity by sampling pixels
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    size_t bytesPerRow = width * 4;
    size_t sampleSize = MIN(width * height, 10000); // Sample up to 10k pixels
    
    unsigned char *pixelData = calloc(sampleSize * 4, sizeof(unsigned char));
    if (!pixelData) {
        CGColorSpaceRelease(colorSpace);
        return YES; // Default to JPEG if we can't analyze
    }
    
    CGContextRef context = CGBitmapContextCreate(pixelData, width, 1, 8, bytesPerRow, colorSpace,
                                                kCGImageAlphaNoneSkipLast | kCGBitmapByteOrder32Big);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        free(pixelData);
        return YES;
    }
    
    // Sample middle row
    CGContextDrawImage(context, CGRectMake(0, 0, width, 1), image);
    CGContextRelease(context);
    
    // Count unique colors in sample
    NSMutableSet *uniqueColors = [NSMutableSet set];
    for (size_t i = 0; i < width * 4; i += 4) {
        uint32_t color = (pixelData[i] << 24) | (pixelData[i+1] << 16) | 
                        (pixelData[i+2] << 8) | pixelData[i+3];
        [uniqueColors addObject:@(color)];
    }
    
    free(pixelData);
    
    // If we have many unique colors, it's likely a photograph - use JPEG
    return [uniqueColors count] > 256;
}

@end
</file>

<file path="src/ContentElement.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

@protocol ContentElement <NSObject>
@property (nonatomic, readonly) CGRect bounds;
@property (nonatomic, readonly) NSInteger pageIndex;
- (NSString *)markdownRepresentation;
@end

@interface TextElement : NSObject <ContentElement>
@property (nonatomic, strong) NSString *text;
@property (nonatomic, assign) CGRect bounds;
@property (nonatomic, assign) NSInteger pageIndex;
@property (nonatomic, strong, nullable) NSString *fontName;
@property (nonatomic, assign) CGFloat fontSize;
@property (nonatomic, assign) BOOL isBold;
@property (nonatomic, assign) BOOL isItalic;
@property (nonatomic, assign) NSInteger headingLevel;
@end

@interface ImageElement : NSObject <ContentElement>
@property (nonatomic, assign) CGImageRef image;
@property (nonatomic, assign) CGRect bounds;
@property (nonatomic, assign) NSInteger pageIndex;
@property (nonatomic, assign) BOOL isVectorSource;
@property (nonatomic, strong, nullable) NSString *assetRelativePath;
@end

NS_ASSUME_NONNULL_END
</file>

<file path="src/ContentElement.m">
#import "ContentElement.h"

@implementation TextElement

- (NSString *)markdownRepresentation {
    if (!self.text || [self.text length] == 0) {
        return nil;
    }
    
    NSString *trimmedText = [self.text stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    if ([trimmedText length] == 0) {
        return nil;
    }
    
    // Apply heading formatting
    if (self.headingLevel > 0 && self.headingLevel <= 6) {
        NSMutableString *heading = [NSMutableString string];
        for (NSInteger i = 0; i < self.headingLevel; i++) {
            [heading appendString:@"#"];
        }
        [heading appendString:@" "];
        [heading appendString:trimmedText];
        return heading;
    }
    
    // Apply bold/italic formatting
    NSString *formattedText = trimmedText;
    
    if (self.isBold && self.isItalic) {
        formattedText = [NSString stringWithFormat:@"***%@***", formattedText];
    } else if (self.isBold) {
        formattedText = [NSString stringWithFormat:@"**%@**", formattedText];
    } else if (self.isItalic) {
        formattedText = [NSString stringWithFormat:@"*%@*", formattedText];
    }
    
    return formattedText;
}

- (void)dealloc {
    // No need to release CGImageRef here as ARC doesn't manage it
}

@end

@implementation ImageElement

- (NSString *)markdownRepresentation {
    if (!self.assetRelativePath) {
        return @"![Image](image-not-saved)";
    }
    
    return [NSString stringWithFormat:@"![Image](%@)", self.assetRelativePath];
}

- (void)dealloc {
    if (self.image) {
        CGImageRelease(self.image);
    }
}

@end
</file>

<file path="src/PDFMarkdownConverter.h">
#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>

NS_ASSUME_NONNULL_BEGIN

@interface PDFMarkdownConverter : NSObject

- (nullable instancetype)initWithPDFData:(NSData *)pdfData;
- (nullable instancetype)initWithPDFAtURL:(NSURL *)pdfURL;

- (void)convertWithAssetsFolderPath:(nullable NSString *)assetsPath
                     rasterizedDPI:(CGFloat)dpi
                        completion:(void (^)(NSString * _Nullable markdown, NSError * _Nullable error))completion;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="src/PDFPageProcessor.h">
#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

@protocol ContentElement;

@interface PDFPageProcessor : NSObject {
    @public
    NSInteger _pageIndex;
}

- (instancetype)initWithPDFPage:(PDFPage *)pdfPage
                      pageIndex:(NSInteger)pageIndex
                            dpi:(CGFloat)dpi;

- (NSArray<id<ContentElement>> *)extractContentElements;

- (void)captureVectorGraphicsInBounds:(CGRect)bounds
                         withElements:(NSMutableArray *)elements;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="test/README.md">
---
title: "README.md"
creator: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36 Edg/137.0.0.0"
producer: "Skia/PDF m137"
created: 2025-06-23T01:33:53+02:00
modified: 2025-06-23T01:33:53+02:00
pdf_metadata:
  page_count: 2
conversion:
  tool: "pdf22md"
  version: "v1.1.0-dirty"
  date: 2025-06-23T02:28:31+02:00
---

23/06/2025, 01:33 README.md

![Image](image_000.png)

![Image](image_001.png)

pdf22md

MIT

License MIT

License

10.15+

![Image](image_002.png)

![Image](image_003.png)

macOS 10.15+

macOS

Build and Release Build and Release passing passing

A blazingly fast PDF to Markdown converter for macOS.

pdf22md is a command-line tool that extracts all text and image content from a PDF file and converts it into a

![Image](image_004.png)

![Image](image_005.png)

![Image](image_006.png)

clean Markdown document. It uses Grand Central Dispatch (GCD) to process pages and save images in

parallel, making it exceptionally fast for multi-page documents.

Key Features

High-Speed Conversion: Uses all available CPU cores to process PDF pages concurrently

Intelligent Heading Detection: Analyzes font sizes and usage frequency to automatically format titles

![Image](image_007.png)

![Image](image_008.png)

![Image](image_009.png)

and headings ( # , ## , etc.)

Asset Extraction: Saves raster and vector images into a specified assets folder and links them correctly

in the Markdown file

Smart Image Formatting: Automatically chooses between JPEG (for photos) and PNG (for graphics with

transparency) to optimize file size and quality

Flexible I/O: Reads from a PDF file or stdin and writes to a Markdown file or stdout

![Image](image_010.png)

![Image](image_011.png)

![Image](image_012.png)

Customizable Rasterization: Allows setting a custom DPI for converting vector graphics to bitmaps

Installation

Using Homebrew (Coming Soon)

brew tap twardoch/pdf22md

brew install pdf22md

![Image](image_013.png)

![Image](image_014.png)

Building from Source

To build the project manually, you need Xcode Command Line Tools installed.

# Clone the repository

git clone https://github.com/twardoch/pdf22md.git

cd pdf22md

# Compile the tool

make

# Install it to /usr/local/bin (optional)

sudo make install

Download Pre-built Binary

Pre-built binaries are available from the Releases page.

Usage

Usage: pdf22md [-i input.pdf] [-o output.md] [-a assets

_

folder] [-d dpi]

Converts PDF documents to Markdown format

-i <path>: Input PDF file (default: stdin)

-o <path>: Output Markdown file (default: stdout)

-a <path>: Assets folder for extracted images

-d <dpi>: DPI for rasterizing vector graphics (default: 144)

Examples

# Convert a PDF file to Markdown

pdf22md -i document.pdf -o document.md

# Convert with images saved to an 'assets' folder

pdf22md -i report.pdf -o report.md -a ./assets

# Convert with custom DPI for vector graphics

pdf22md -i presentation.pdf -o presentation.md -a ./images -d 300

# Use with pipes

cat document.pdf | pdf22md > document.md

# Convert and view in less

pdf22md -i manual.pdf | less

Requirements

macOS 10.15 (Catalina) or later

Xcode Command Line Tools (for building from source)

Project Structure

pdf22md/

 src/ # Source code

  main.m # Entry point

  PDFMarkdownConverter.* # Main conversion logic

  PDFPageProcessor.* # PDF page processing

  ContentElement.* # Content element definitions

  AssetExtractor.* # Image extraction logic

 docs/ # Additional documentation

 test/ # Test files

file:///Users/adam/Developer/vcs/github.twardoch/pub/pdf22md/README.md 1/2

23/06/2025, 01:33 README.md

![Image](image_015.png)

![Image](image_016.png)

 LICENSE # MIT License

 Makefile # Build configuration

 README.md # This file

Contributing

Contributions are welcome! Please feel free to submit a Pull Request. For major changes, please open an

![Image](image_017.png)

![Image](image_018.png)

![Image](image_019.png)

issue first to discuss what you

would like to change.

1. Fork the repository

2. Create your feature branch ( git checkout -b feature/AmazingFeature )

3. Commit your changes ( git commit -m 'Add some AmazingFeature' )

![Image](image_020.png)

![Image](image_021.png)

![Image](image_022.png)

4. Push to the branch ( git push origin feature/AmazingFeature )

5. Open a Pull Request

License

This project is licensed under the MIT License - see the LICENSE file for details.

Acknowledgments

![Image](image_023.png)

![Image](image_024.png)

![Image](image_025.png)

![Image](image_026.png)

![Image](image_027.png)

Built with Apples PDFKit and Core Graphics frameworks

Parallel processing powered by Grand Central Dispatch (GCD)

Inspired by the need for fast, accurate PDF to Markdown conversion

Related Projects

pdfplumber - Python library for PDF processing

![Image](image_028.png)

pdf2md - Another PDF to Markdown converter

![Image](image_029.png)

![Image](image_030.png)

![Image](image_031.png)

![Image](image_032.png)

pandoc - Universal document converter

Changelog

See CHANGELOG.md for a list of changes in each version.

Support

If you encounter any issues or have questions, please open an issue on GitHub.

![Image](image_033.png)

![Image](image_034.png)

file:///Users/adam/Developer/vcs/github.twardoch/pub/pdf22md/README.md 2/2
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2024 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="release.sh">
#!/bin/bash

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to print colored output
print_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

# Function to get the latest semver tag
get_latest_tag() {
    git tag -l 'v*' | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -n1
}

# Function to increment version
increment_version() {
    local version=$1
    local major=$(echo $version | cut -d. -f1)
    local minor=$(echo $version | cut -d. -f2)
    local patch=$(echo $version | cut -d. -f3)
    
    # Increment minor version
    minor=$((minor + 1))
    patch=0
    
    echo "${major}.${minor}.${patch}"
}

# Parse command line arguments
VERSION=""
while [[ $# -gt 0 ]]; do
    case $1 in
        --v)
            VERSION="$2"
            shift 2
            ;;
        -h|--help)
            echo "Usage: $0 [--v VERSION]"
            echo "  --v VERSION   Specify version (e.g., 1.2.3)"
            echo "  -h, --help    Show this help message"
            echo ""
            echo "If no version is specified, the script will increment the minor version"
            echo "of the latest git tag, or use 1.0.0 if no tags exist."
            exit 0
            ;;
        *)
            print_error "Unknown option: $1"
            exit 1
            ;;
    esac
done

# Determine version
if [ -z "$VERSION" ]; then
    LATEST_TAG=$(get_latest_tag)
    if [ -z "$LATEST_TAG" ]; then
        VERSION="1.0.0"
        print_info "No previous tags found. Using version $VERSION"
    else
        # Remove 'v' prefix
        CURRENT_VERSION=${LATEST_TAG#v}
        VERSION=$(increment_version $CURRENT_VERSION)
        print_info "Latest tag: $LATEST_TAG"
        print_info "New version: $VERSION"
    fi
else
    # Validate version format
    if ! echo "$VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
        print_error "Invalid version format. Please use semantic versioning (e.g., 1.2.3)"
        exit 1
    fi
fi

TAG="v$VERSION"

# Check if we're on macOS
if [[ "$OSTYPE" != "darwin"* ]]; then
    print_error "This script must be run on macOS"
    exit 1
fi

# Check if git is clean
if ! git diff-index --quiet HEAD --; then
    print_warning "You have uncommitted changes. Committing them now..."
    git add -A
    git commit -m "Release version $VERSION"
fi

# Check if tag already exists
if git rev-parse "$TAG" >/dev/null 2>&1; then
    print_error "Tag $TAG already exists"
    exit 1
fi

print_info "Building pdf22md version $VERSION..."

# Clean and build with version
make clean
make VERSION="$VERSION"

# Test the binary
if ! ./pdf22md -v | grep -q "$VERSION"; then
    print_error "Version check failed"
    exit 1
fi

print_info "Build successful!"

# Create git tag
print_info "Creating git tag $TAG..."
git tag -a "$TAG" -m "Release version $VERSION"

# Push commits and tags
print_info "Pushing to remote..."
git push origin main
git push origin "$TAG"

print_info " Release $VERSION completed successfully!"
print_info ""
print_info "The GitHub Actions workflow will now:"
print_info "  1. Build the universal binary for Intel and Apple Silicon"
print_info "  2. Create a .pkg installer"
print_info "  3. Create a GitHub release with the artifacts"
print_info ""
print_info "Check the Actions tab on GitHub to monitor the release process."
</file>

<file path=".github/workflows/build-release.yml">
name: Build and Release

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  release:
    types: [ created ]

jobs:
  build:
    runs-on: macos-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Build the tool
      run: make

    - name: Run a basic check
      run: ./pdf22md -h

  create-release:
    if: github.event_name == 'release'
    runs-on: macos-latest
    needs: build

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Build the binary
      run: make

    - name: Create Tarball Archive
      run: |
        tar -czvf pdf22md-macos-x86_64.tar.gz pdf22md

    - name: Upload Release Asset
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ github.event.release.upload_url }}
        asset_path: ./pdf22md-macos-x86_64.tar.gz
        asset_name: pdf22md-macos-x86_64.tar.gz
        asset_content_type: application/gzip
</file>

<file path=".gitignore">
# Build products
build/
*.o
pdf22md

# macOS
.DS_Store
.AppleDouble
.LSOverride

# Thumbnails
._*

# Files that might appear on external disk
.Spotlight-V100
.Trashes

# Editor-specific
.vscode/
*.swp
.idea/
*.xcodeproj/
*.xcworkspace/

# Cursor and other AI assistants
.cursor/
.cursorrules
.cursorindexingignore
.giga/
.specstory/

# Test artifacts
test/out/
*.md
!README.md
!TODO.md
!CLAUDE.md
!AGENTS.md
!CHANGELOG.md
!docs/*.md
</file>

<file path="CLAUDE.md">
# pdf22md

A blazingly fast PDF to Markdown converter for macOS.

`pdf22md` is a command-line tool that extracts all text and image content from a PDF file and converts it into a clean Markdown document. It uses Grand Central Dispatch (GCD) to process pages and save images in parallel, making it exceptionally fast for multi-page documents.

### Key Features

  * **High-Speed Conversion**: Uses all available CPU cores to process PDF pages concurrently.
  * **Intelligent Heading Detection**: Analyzes font sizes and usage frequency to automatically format titles and headings (`#`, `##`, etc.).
  * **Asset Extraction**: Saves raster and vector images into a specified assets folder and links them correctly in the Markdown file.
  * **Smart Image Formatting**: Automatically chooses between JPEG (for photos) and PNG (for graphics with transparency) to optimize file size and quality.
  * **Flexible I/O**: Reads from a PDF file or `stdin` and writes to a Markdown file or `stdout`.
  * **Customizable Rasterization**: Allows setting a custom DPI for converting vector graphics to bitmaps.

### Installation

Once the Homebrew tap is set up (see plan below), installation is simple:

```bash
brew install <your-username>/pdf22md/pdf22md
```

### Building from Source

To build the project manually, you need Xcode Command Line Tools installed.

```bash
# Clone the repository (once it's public)
git clone https://github.com/<your-username>/pdf22md.git
cd pdf22md

# Compile the tool
make

# Install it to /usr/local/bin
sudo make install
```

### Usage

```
Usage: pdf22md [-i input.pdf] [-o output.md] [-a assets_folder] [-d dpi]
  Converts PDF documents to Markdown format
  -i <path>: Input PDF file (default: stdin)
  -o <path>: Output Markdown file (default: stdout)
  -a <path>: Assets folder for extracted images
  -d <dpi>: DPI for rasterizing vector graphics (default: 144)
```

**Example:**

```bash
# Convert a local PDF file and save images to an 'assets' folder
pdf22md -i report.pdf -o report.md -a ./assets
```

---


# main-overview

## Development Guidelines

- Only modify code directly relevant to the specific request. Avoid changing unrelated functionality.
- Never replace code with placeholders like `# ... rest of the processing ...`. Always include complete code.
- Break problems into smaller steps. Think through each step separately before implementing.
- Always provide a complete PLAN with REASONING based on evidence from code and logs before making changes.
- Explain your OBSERVATIONS clearly, then provide REASONING to identify the exact issue. Add console logs when needed to gather more information.


pdf22md is a PDF to Markdown converter that transforms PDF documents while preserving their semantic structure and content relationships.

Core Business Components:

1. Document Structure Analysis (Importance: 95)
- Hierarchical heading detection using font statistics
- Document structure preservation through positional element sorting
- Automated heading level assignment (H1-H6) based on font usage patterns

2. Content Classification System (Importance: 85)
- TextElement: Handles formatted text with style attributes
- ImageElement: Manages both raster and vector graphics
- Content relationship tracking between elements

3. Asset Processing Pipeline (Importance: 80)
- Intelligent format selection between PNG/JPEG based on:
  * Transparency detection
  * Color complexity analysis
  * Dimension-based optimization
- Asset extraction with maintained document references

4. PDF Content Processing (Importance: 90)
- Text styling and formatting context preservation
- Vector graphics path construction tracking
- Coordinate system transformation management
- Element bounds calculation for layout fidelity

Key Integration Points:

1. Content Extraction Layer
- Connects PDF parsing with markdown generation
- Maintains element relationships and hierarchy
- Preserves formatting context across transformations

2. Asset Management Layer
- Links extracted images with markdown references
- Maintains asset organization structure
- Handles format conversions while preserving quality

The system organizes business logic around content transformation pipelines while maintaining document semantic structure throughout the conversion process.

 When youre done with a round of updates, update CHANGELOG.md with the changes, remove done things from TODO.md, identify new things that need to be done and add them to TODO.md. Then build the app or run ./release.sh and then continue updates.
</file>

<file path="src/main.m">
#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>
#import "PDFMarkdownConverter.h"

#ifndef VERSION
#define VERSION "dev"
#endif

void printUsage(const char *programName) {
    fprintf(stderr, "Usage: %s [-i input.pdf] [-o output.md] [-a assets_folder] [-d dpi] [-v] [-h]\n", programName);
    fprintf(stderr, "  Converts PDF documents to Markdown format\n");
    fprintf(stderr, "  -i <path>: Input PDF file (default: stdin)\n");
    fprintf(stderr, "  -o <path>: Output Markdown file (default: stdout)\n");
    fprintf(stderr, "  -a <path>: Assets folder for extracted images\n");
    fprintf(stderr, "  -d <dpi>: DPI for rasterizing vector graphics (default: 144)\n");
    fprintf(stderr, "  -v: Display version information\n");
    fprintf(stderr, "  -h: Display this help message\n");
}

void printVersion() {
    printf("pdf22md version %s\n", VERSION);
}

int main(int argc, const char *argv[]) {
    @autoreleasepool {
        NSString *inputPath = nil;
        NSString *outputPath = nil;
        NSString *assetsPath = nil;
        CGFloat dpi = 144.0;
        
        // Parse command line arguments
        int opt;
        while ((opt = getopt(argc, (char * const *)argv, "i:o:a:d:hvV")) != -1) {
            switch (opt) {
                case 'i':
                    inputPath = [NSString stringWithUTF8String:optarg];
                    break;
                case 'o':
                    outputPath = [NSString stringWithUTF8String:optarg];
                    break;
                case 'a':
                    assetsPath = [NSString stringWithUTF8String:optarg];
                    break;
                case 'd':
                    dpi = atof(optarg);
                    if (dpi <= 0) {
                        fprintf(stderr, "Invalid DPI value: %s\n", optarg);
                        return 1;
                    }
                    break;
                case 'h':
                    printUsage(argv[0]);
                    return 0;
                case 'v':
                case 'V':
                    printVersion();
                    return 0;
                default:
                    printUsage(argv[0]);
                    return 1;
            }
        }
        
        // Initialize converter
        PDFMarkdownConverter *converter = nil;
        
        if (inputPath) {
            // Read from file
            NSURL *pdfURL = [NSURL fileURLWithPath:inputPath];
            converter = [[PDFMarkdownConverter alloc] initWithPDFAtURL:pdfURL];
            if (!converter) {
                fprintf(stderr, "Failed to load PDF from: %s\n", [inputPath UTF8String]);
                return 1;
            }
        } else {
            // Read from stdin
            NSFileHandle *stdinHandle = [NSFileHandle fileHandleWithStandardInput];
            NSData *pdfData = [stdinHandle readDataToEndOfFile];
            
            if (!pdfData || [pdfData length] == 0) {
                fprintf(stderr, "No PDF data received from stdin\n");
                return 1;
            }
            
            converter = [[PDFMarkdownConverter alloc] initWithPDFData:pdfData];
            if (!converter) {
                fprintf(stderr, "Failed to create PDF document from stdin data\n");
                return 1;
            }
        }
        
        // Perform conversion
        __block NSString *markdown = nil;
        __block NSError *conversionError = nil;
        
        dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
        
        [converter convertWithAssetsFolderPath:assetsPath
                                rasterizedDPI:dpi
                                   completion:^(NSString *result, NSError *error) {
            markdown = result;
            conversionError = error;
            dispatch_semaphore_signal(semaphore);
        }];
        
        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
        
        if (conversionError) {
            fprintf(stderr, "Conversion failed: %s\n", 
                    [[conversionError localizedDescription] UTF8String]);
            return 1;
        }
        
        // Write output
        if (outputPath) {
            // Write to file
            NSError *writeError = nil;
            BOOL success = [markdown writeToFile:outputPath
                                      atomically:YES
                                        encoding:NSUTF8StringEncoding
                                           error:&writeError];
            if (!success) {
                fprintf(stderr, "Failed to write output file: %s\n",
                        [[writeError localizedDescription] UTF8String]);
                return 1;
            }
        } else {
            // Write to stdout
            NSFileHandle *stdoutHandle = [NSFileHandle fileHandleWithStandardOutput];
            NSData *markdownData = [markdown dataUsingEncoding:NSUTF8StringEncoding];
            [stdoutHandle writeData:markdownData];
        }
        
        return 0;
    }
}
</file>

<file path="src/PDFMarkdownConverter.m">
#import "PDFMarkdownConverter.h"
#import "PDFPageProcessor.h"
#import "ContentElement.h"
#import "AssetExtractor.h"

@interface PDFMarkdownConverter ()
@property (nonatomic, strong) PDFDocument *pdfDocument;
@property (nonatomic, strong) NSMutableArray<id<ContentElement>> *allElements;
@property (nonatomic, strong) NSMutableDictionary<NSString *, NSNumber *> *fontStats;
@end

@implementation PDFMarkdownConverter

- (nullable instancetype)initWithPDFData:(NSData *)pdfData {
    self = [super init];
    if (self) {
        _pdfDocument = [[PDFDocument alloc] initWithData:pdfData];
        if (!_pdfDocument) {
            return nil;
        }
        _allElements = [NSMutableArray array];
        _fontStats = [NSMutableDictionary dictionary];
    }
    return self;
}

- (nullable instancetype)initWithPDFAtURL:(NSURL *)pdfURL {
    self = [super init];
    if (self) {
        _pdfDocument = [[PDFDocument alloc] initWithURL:pdfURL];
        if (!_pdfDocument) {
            return nil;
        }
        _allElements = [NSMutableArray array];
        _fontStats = [NSMutableDictionary dictionary];
    }
    return self;
}

- (void)convertWithAssetsFolderPath:(nullable NSString *)assetsPath
                     rasterizedDPI:(CGFloat)dpi
                        completion:(void (^)(NSString * _Nullable markdown, NSError * _Nullable error))completion {
    
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSError *error = nil;
        
        // Process all pages in parallel
        NSInteger pageCount = [self.pdfDocument pageCount];
        // DEBUG log suppressed: Starting conversion of pages
        
        // Create thread-safe temporary storage
        NSMutableArray<NSMutableArray<id<ContentElement>> *> *pageElementsArray = [NSMutableArray arrayWithCapacity:pageCount];
        NSMutableArray<NSMutableDictionary *> *pageFontStatsArray = [NSMutableArray arrayWithCapacity:pageCount];
        
        // Initialize arrays
        for (NSInteger i = 0; i < pageCount; i++) {
            [pageElementsArray addObject:[NSMutableArray array]];
            [pageFontStatsArray addObject:[NSMutableDictionary dictionary]];
        }
        
        // Lock for thread safety
        NSObject *lock = [[NSObject alloc] init];
        __block BOOL processingFailed = NO;
        
        // Process pages in parallel using dispatch_apply
        // DEBUG log suppressed: Starting dispatch_apply for pages
        dispatch_apply(pageCount, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t pageIndex) {
            @autoreleasepool {
                // DEBUG log suppressed: Processing page
                // Check if processing has already failed
                @synchronized(lock) {
                    if (processingFailed) return;
                }
                
                PDFPage *page = [self.pdfDocument pageAtIndex:pageIndex];
                if (!page) {
                    @synchronized(lock) {
                        processingFailed = YES;
                    }
                    return;
                }
                
                PDFPageProcessor *processor = [[PDFPageProcessor alloc] initWithPDFPage:page
                                                                               pageIndex:pageIndex
                                                                                     dpi:dpi];
                
                NSArray<id<ContentElement>> *pageElements = [processor extractContentElements];
                // DEBUG log suppressed: Page extracted elements
                
                // Store results in thread-safe arrays
                pageElementsArray[pageIndex] = [pageElements mutableCopy];
                
                // Collect font statistics for this page
                NSMutableDictionary *pageFontStats = pageFontStatsArray[pageIndex];
                for (id<ContentElement> element in pageElements) {
                    if ([element isKindOfClass:[TextElement class]]) {
                        TextElement *textElement = (TextElement *)element;
                        NSString *fontKey = [NSString stringWithFormat:@"%.1f-%@", 
                                           textElement.fontSize, 
                                           textElement.fontName ?: @"Unknown"];
                        
                        NSNumber *count = pageFontStats[fontKey];
                        pageFontStats[fontKey] = @([count integerValue] + 1);
                    }
                }
            }
        });
        
        // DEBUG log suppressed: dispatch_apply completed
        
        // Check if processing failed
        if (processingFailed) {
            error = [NSError errorWithDomain:@"PDFMarkdownConverter"
                                       code:2
                                   userInfo:@{NSLocalizedDescriptionKey: @"Failed to process one or more PDF pages"}];
            completion(nil, error);
            return;
        }
        
        // DEBUG log suppressed: Merging results from all pages
        
        // Merge results from all pages
        for (NSInteger i = 0; i < pageCount; i++) {
            [self.allElements addObjectsFromArray:pageElementsArray[i]];
            
            // Merge font statistics
            NSDictionary *pageFontStats = pageFontStatsArray[i];
            for (NSString *fontKey in pageFontStats) {
                NSNumber *pageCount = pageFontStats[fontKey];
                NSNumber *totalCount = self.fontStats[fontKey];
                self.fontStats[fontKey] = @([totalCount integerValue] + [pageCount integerValue]);
            }
        }
        
        // DEBUG log suppressed: Analyzing font hierarchy
        
        // Analyze font hierarchy
        [self analyzeFontHierarchy];
        
        // DEBUG log suppressed: Sorting elements
        
        // Sort elements by page and position
        [self sortElements];
        
        // DEBUG log suppressed: Sort completed
        
        // Handle assets if needed
        AssetExtractor *assetExtractor = nil;
        if (assetsPath) {
            // DEBUG log suppressed: Starting asset extraction with path:
            assetExtractor = [[AssetExtractor alloc] initWithAssetFolder:assetsPath];
            if (!assetExtractor) {
                error = [NSError errorWithDomain:@"PDFMarkdownConverter"
                                           code:1
                                       userInfo:@{NSLocalizedDescriptionKey: @"Failed to create assets folder"}];
                completion(nil, error);
                return;
            }
            
            // Save images in parallel
            NSMutableArray<ImageElement *> *imageElements = [NSMutableArray array];
            for (id<ContentElement> element in self.allElements) {
                if ([element isKindOfClass:[ImageElement class]]) {
                    [imageElements addObject:(ImageElement *)element];
                }
            }
            
            NSInteger imageCount = [imageElements count];
            // DEBUG log suppressed: Found images to extract
            if (imageCount > 0) {
                // DEBUG log suppressed: Starting parallel image extraction
                dispatch_apply(imageCount, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t index) {
                    @autoreleasepool {
                        ImageElement *imageElement = imageElements[index];
                        NSString *baseName = [NSString stringWithFormat:@"image_%03zu", index];
                        NSString *savedPath = [assetExtractor saveImage:imageElement.image
                                                          isVectorSource:imageElement.isVectorSource
                                                              withBaseName:baseName];
                        if (savedPath) {
                            @synchronized(imageElement) {
                                imageElement.assetRelativePath = savedPath;
                            }
                        }
                    }
                });
                // DEBUG log suppressed: Completed parallel image extraction
            }
        } else {
            // DEBUG log suppressed: No assets path provided, skipping image extraction
        }
        
        // DEBUG log suppressed: Starting markdown generation
        
        // Generate markdown with YAML frontmatter
        NSMutableString *markdown = [NSMutableString string];
        
        // Add YAML frontmatter with metadata
        // DEBUG log suppressed: Generating YAML frontmatter
        NSString *yamlFrontmatter = [self generateYAMLFrontmatter];
        if (yamlFrontmatter) {
            [markdown appendString:yamlFrontmatter];
            [markdown appendString:@"\n"];
        }
        
        // DEBUG log suppressed: Converting elements to markdown
        for (id<ContentElement> element in self.allElements) {
            NSString *elementMarkdown = [element markdownRepresentation];
            if (elementMarkdown) {
                [markdown appendString:elementMarkdown];
                [markdown appendString:@"\n\n"];
            }
        }
        // DEBUG log suppressed: Markdown generation completed
        
        // Clean up extra newlines
        NSString *finalMarkdown = [markdown stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
        
        completion(finalMarkdown, nil);
    });
}

- (void)collectFontStatisticsFromElements:(NSArray<id<ContentElement>> *)elements {
    for (id<ContentElement> element in elements) {
        if ([element isKindOfClass:[TextElement class]]) {
            TextElement *textElement = (TextElement *)element;
            NSString *fontKey = [NSString stringWithFormat:@"%.1f-%@", 
                               textElement.fontSize, 
                               textElement.fontName ?: @"Unknown"];
            
            NSNumber *count = self.fontStats[fontKey];
            self.fontStats[fontKey] = @([count integerValue] + 1);
        }
    }
}

- (void)analyzeFontHierarchy {
    // Sort font sizes to determine heading levels
    NSMutableArray<NSNumber *> *uniqueSizes = [NSMutableArray array];
    NSMutableDictionary<NSNumber *, NSNumber *> *sizeFrequency = [NSMutableDictionary dictionary];
    
    for (NSString *fontKey in self.fontStats) {
        NSArray *components = [fontKey componentsSeparatedByString:@"-"];
        if (components.count > 0) {
            CGFloat fontSize = [components[0] floatValue];
            NSNumber *sizeNum = @(fontSize);
            
            if (![uniqueSizes containsObject:sizeNum]) {
                [uniqueSizes addObject:sizeNum];
            }
            
            NSInteger freq = [sizeFrequency[sizeNum] integerValue] + [self.fontStats[fontKey] integerValue];
            sizeFrequency[sizeNum] = @(freq);
        }
    }
    
    // Sort sizes in descending order
    [uniqueSizes sortUsingComparator:^NSComparisonResult(NSNumber *obj1, NSNumber *obj2) {
        return [obj2 compare:obj1];
    }];
    
    // Assign heading levels based on size hierarchy
    // Assume largest font is H1, second largest is H2, etc.
    NSMutableDictionary<NSNumber *, NSNumber *> *sizeToHeadingLevel = [NSMutableDictionary dictionary];
    NSInteger headingLevel = 1;
    
    for (NSNumber *size in uniqueSizes) {
        // Only assign heading levels to fonts that are significantly larger than average
        // and appear less frequently (typical of headings)
        NSInteger frequency = [sizeFrequency[size] integerValue];
        
        if (headingLevel <= 6 && frequency < 100) { // Adjust threshold as needed
            sizeToHeadingLevel[size] = @(headingLevel);
            headingLevel++;
        } else {
            sizeToHeadingLevel[size] = @(0); // Body text
        }
    }
    
    // Apply heading levels to text elements
    for (id<ContentElement> element in self.allElements) {
        if ([element isKindOfClass:[TextElement class]]) {
            TextElement *textElement = (TextElement *)element;
            NSNumber *sizeNum = @(textElement.fontSize);
            NSNumber *level = sizeToHeadingLevel[sizeNum];
            textElement.headingLevel = level ? [level integerValue] : 0;
        }
    }
}

- (void)sortElements {
    [self.allElements sortUsingComparator:^NSComparisonResult(id<ContentElement> obj1, id<ContentElement> obj2) {
        // First sort by page
        if ([obj1 respondsToSelector:@selector(pageIndex)] && [obj2 respondsToSelector:@selector(pageIndex)]) {
            NSInteger page1 = [(id)obj1 pageIndex];
            NSInteger page2 = [(id)obj2 pageIndex];
            
            if (page1 != page2) {
                return page1 < page2 ? NSOrderedAscending : NSOrderedDescending;
            }
        }
        
        // Then sort by vertical position (top to bottom)
        CGFloat y1 = CGRectGetMaxY(obj1.bounds);
        CGFloat y2 = CGRectGetMaxY(obj2.bounds);
        
        if (fabs(y1 - y2) > 5.0) { // Tolerance for same line
            return y1 > y2 ? NSOrderedAscending : NSOrderedDescending;
        }
        
        // Finally sort by horizontal position (left to right)
        CGFloat x1 = CGRectGetMinX(obj1.bounds);
        CGFloat x2 = CGRectGetMinX(obj2.bounds);
        
        return x1 < x2 ? NSOrderedAscending : NSOrderedDescending;
    }];
}

- (NSString *)generateYAMLFrontmatter {
    NSMutableString *yaml = [NSMutableString string];
    
    // Get PDF metadata
    NSDictionary *docAttributes = [self.pdfDocument documentAttributes];
    
    [yaml appendString:@"---\n"];
    
    // Title
    NSString *title = docAttributes[PDFDocumentTitleAttribute];
    if (title && title.length > 0) {
        [yaml appendFormat:@"title: \"%@\"\n", [self escapeYAMLString:title]];
    }
    
    // Author
    NSString *author = docAttributes[PDFDocumentAuthorAttribute];
    if (author && author.length > 0) {
        [yaml appendFormat:@"author: \"%@\"\n", [self escapeYAMLString:author]];
    }
    
    // Subject
    NSString *subject = docAttributes[PDFDocumentSubjectAttribute];
    if (subject && subject.length > 0) {
        [yaml appendFormat:@"subject: \"%@\"\n", [self escapeYAMLString:subject]];
    }
    
    // Keywords
    NSArray *keywords = docAttributes[PDFDocumentKeywordsAttribute];
    if (keywords && [keywords isKindOfClass:[NSArray class]] && keywords.count > 0) {
        [yaml appendString:@"keywords:\n"];
        for (NSString *keyword in keywords) {
            if ([keyword isKindOfClass:[NSString class]]) {
                [yaml appendFormat:@"  - \"%@\"\n", [self escapeYAMLString:keyword]];
            }
        }
    }
    
    // Creator (PDF producer software)
    NSString *creator = docAttributes[PDFDocumentCreatorAttribute];
    if (creator && creator.length > 0) {
        [yaml appendFormat:@"creator: \"%@\"\n", [self escapeYAMLString:creator]];
    }
    
    // Producer
    NSString *producer = docAttributes[PDFDocumentProducerAttribute];
    if (producer && producer.length > 0) {
        [yaml appendFormat:@"producer: \"%@\"\n", [self escapeYAMLString:producer]];
    }
    
    // Creation date
    NSDate *creationDate = docAttributes[PDFDocumentCreationDateAttribute];
    if (creationDate) {
        NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
        [formatter setDateFormat:@"yyyy-MM-dd'T'HH:mm:ssZZZZZ"];
        [yaml appendFormat:@"created: %@\n", [formatter stringFromDate:creationDate]];
    }
    
    // Modification date
    NSDate *modDate = docAttributes[PDFDocumentModificationDateAttribute];
    if (modDate) {
        NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
        [formatter setDateFormat:@"yyyy-MM-dd'T'HH:mm:ssZZZZZ"];
        [yaml appendFormat:@"modified: %@\n", [formatter stringFromDate:modDate]];
    }
    
    // PDF specific metadata
    [yaml appendString:@"pdf_metadata:\n"];
    [yaml appendFormat:@"  page_count: %ld\n", (long)[self.pdfDocument pageCount]];
    
    // PDF version
    NSString *pdfVersion = [self extractPDFVersion];
    if (pdfVersion) {
        [yaml appendFormat:@"  version: \"%@\"\n", pdfVersion];
    }
    
    // PDF outline (bookmarks/TOC)
    PDFOutline *outline = [self.pdfDocument outlineRoot];
    if (outline && [outline numberOfChildren] > 0) {
        [yaml appendString:@"  outline:\n"];
        [self appendOutlineToYAML:yaml outline:outline indent:@"    "];
    }
    
    // Conversion metadata
    [yaml appendString:@"conversion:\n"];
    [yaml appendString:@"  tool: \"pdf22md\"\n"];
    [yaml appendFormat:@"  version: \"%s\"\n", VERSION];
    
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateFormat:@"yyyy-MM-dd'T'HH:mm:ssZZZZZ"];
    [yaml appendFormat:@"  date: %@\n", [formatter stringFromDate:[NSDate date]]];
    
    [yaml appendString:@"---\n"];
    
    return yaml;
}

- (NSString *)escapeYAMLString:(NSString *)string {
    // Escape quotes and backslashes for YAML
    NSString *escaped = [string stringByReplacingOccurrencesOfString:@"\\" withString:@"\\\\"];
    escaped = [escaped stringByReplacingOccurrencesOfString:@"\"" withString:@"\\\""];
    escaped = [escaped stringByReplacingOccurrencesOfString:@"\n" withString:@"\\n"];
    escaped = [escaped stringByReplacingOccurrencesOfString:@"\r" withString:@"\\r"];
    return escaped;
}

- (NSString *)extractPDFVersion {
    // Try to extract PDF version from document attributes or metadata
    // This is a simplified approach - actual PDF version extraction might require
    // reading the PDF header directly
    NSDictionary *attributes = [self.pdfDocument documentAttributes];
    for (NSString *key in attributes) {
        id value = attributes[key];
        if ([value isKindOfClass:[NSString class]] && 
            [value rangeOfString:@"PDF-" options:NSCaseInsensitiveSearch].location != NSNotFound) {
            return value;
        }
    }
    return nil;
}

- (void)appendOutlineToYAML:(NSMutableString *)yaml outline:(PDFOutline *)outline indent:(NSString *)indent {
    for (NSUInteger i = 0; i < [outline numberOfChildren]; i++) {
        PDFOutline *child = [outline childAtIndex:i];
        NSString *label = [child label];
        if (label && label.length > 0) {
            [yaml appendFormat:@"%@- title: \"%@\"\n", indent, [self escapeYAMLString:label]];
            
            PDFDestination *destination = [child destination];
            if (destination) {
                PDFPage *page = [destination page];
                NSInteger pageIndex = [self.pdfDocument indexForPage:page];
                [yaml appendFormat:@"%@  page: %ld\n", indent, (long)(pageIndex + 1)];
            }
            
            if ([child numberOfChildren] > 0) {
                [yaml appendFormat:@"%@  children:\n", indent];
                NSString *newIndent = [indent stringByAppendingString:@"    "];
                [self appendOutlineToYAML:yaml outline:child indent:newIndent];
            }
        }
    }
}

@end
</file>

<file path="AGENTS.md">
# pdf22md

A blazingly fast PDF to Markdown converter for macOS.

`pdf22md` is a command-line tool that extracts all text and image content from a PDF file and converts it into a clean Markdown document. It uses Grand Central Dispatch (GCD) to process pages and save images in parallel, making it exceptionally fast for multi-page documents.

### Key Features

  * **High-Speed Conversion**: Uses all available CPU cores to process PDF pages concurrently.
  * **Intelligent Heading Detection**: Analyzes font sizes and usage frequency to automatically format titles and headings (`#`, `##`, etc.).
  * **Asset Extraction**: Saves raster and vector images into a specified assets folder and links them correctly in the Markdown file.
  * **Smart Image Formatting**: Automatically chooses between JPEG (for photos) and PNG (for graphics with transparency) to optimize file size and quality.
  * **Flexible I/O**: Reads from a PDF file or `stdin` and writes to a Markdown file or `stdout`.
  * **Customizable Rasterization**: Allows setting a custom DPI for converting vector graphics to bitmaps.

### Installation

Once the Homebrew tap is set up (see plan below), installation is simple:

```bash
brew install <your-username>/pdf22md/pdf22md
```

### Building from Source

To build the project manually, you need Xcode Command Line Tools installed.

```bash
# Clone the repository (once it's public)
git clone https://github.com/<your-username>/pdf22md.git
cd pdf22md

# Compile the tool
make

# Install it to /usr/local/bin
sudo make install
```

### Usage

```
Usage: pdf22md [-i input.pdf] [-o output.md] [-a assets_folder] [-d dpi]
  Converts PDF documents to Markdown format
  -i <path>: Input PDF file (default: stdin)
  -o <path>: Output Markdown file (default: stdout)
  -a <path>: Assets folder for extracted images
  -d <dpi>: DPI for rasterizing vector graphics (default: 144)
```

**Example:**

```bash
# Convert a local PDF file and save images to an 'assets' folder
pdf22md -i report.pdf -o report.md -a ./assets
```

---


# main-overview

## Development Guidelines

- Only modify code directly relevant to the specific request. Avoid changing unrelated functionality.
- Never replace code with placeholders like `# ... rest of the processing ...`. Always include complete code.
- Break problems into smaller steps. Think through each step separately before implementing.
- Always provide a complete PLAN with REASONING based on evidence from code and logs before making changes.
- Explain your OBSERVATIONS clearly, then provide REASONING to identify the exact issue. Add console logs when needed to gather more information.


pdf22md is a PDF to Markdown converter that transforms PDF documents while preserving their semantic structure and content relationships.

Core Business Components:

1. Document Structure Analysis (Importance: 95)
- Hierarchical heading detection using font statistics
- Document structure preservation through positional element sorting
- Automated heading level assignment (H1-H6) based on font usage patterns

2. Content Classification System (Importance: 85)
- TextElement: Handles formatted text with style attributes
- ImageElement: Manages both raster and vector graphics
- Content relationship tracking between elements

3. Asset Processing Pipeline (Importance: 80)
- Intelligent format selection between PNG/JPEG based on:
  * Transparency detection
  * Color complexity analysis
  * Dimension-based optimization
- Asset extraction with maintained document references

4. PDF Content Processing (Importance: 90)
- Text styling and formatting context preservation
- Vector graphics path construction tracking
- Coordinate system transformation management
- Element bounds calculation for layout fidelity

Key Integration Points:

1. Content Extraction Layer
- Connects PDF parsing with markdown generation
- Maintains element relationships and hierarchy
- Preserves formatting context across transformations

2. Asset Management Layer
- Links extracted images with markdown references
- Maintains asset organization structure
- Handles format conversions while preserving quality

The system organizes business logic around content transformation pipelines while maintaining document semantic structure throughout the conversion process.

 When youre done with a round of updates, update CHANGELOG.md with the changes, remove done things from TODO.md, identify new things that need to be done and add them to TODO.md. Then build the app or run ./release.sh and then continue updates.
</file>

<file path="CHANGELOG.md">
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added
- Semantic versioning support based on git tags
- Version display option (-v, -V) in the command-line tool
- Release automation script (release.sh) for macOS
- GitHub Actions workflow for automated releases
- Package installer (.pkg) generation for macOS
- Universal binary support (Intel and Apple Silicon)
- Man page generation in release packages
- MIT License file for open-source compliance
- GitHub issue templates for bug reports and feature requests
- Comprehensive .gitignore file with proper exclusions
- Build directory structure to separate source from build artifacts
- CHANGELOG.md to track version history
- Professional project documentation standards

### Changed
- Makefile now supports VERSION variable for build-time versioning
- Makefile now uses a dedicated `build/` directory for object files
- .gitignore updated to properly exclude build artifacts and editor files
- GitHub Actions workflow fixed to use correct binary name
- Project structure reorganized following professional standards

### Fixed
- Build artifacts (.o files) no longer pollute the repository root
- GitHub Actions workflow now correctly references the pdf22md binary
- Make variable in .gitignore replaced with actual filename
- Removed all DEBUG logging statements from production code.
- Fixed CLI deadlock caused by main-queue dispatch in `PDFMarkdownConverter`; completions now called directly.
- Fixed hanging issue on certain malformed PDFs by replacing low-level CGPDFScanner-based extraction with PDFKit high-level API (see `PDFPageProcessor`).
- Removed unused CGPDFScanner operator callback functions and PDFScannerState struct that were part of the deprecated implementation.
- Fixed segmentation fault during asset extraction (Phase 1a): removed premature CGImageRelease calls in `PDFPageProcessor` that deallocated images still in use.

### Removed
- Object files from repository root (moved to build directory)

## [1.0.0] - 2024-01-01

### Added
- Initial release of pdf22md
- PDF to Markdown conversion with parallel processing
- Intelligent heading detection based on font size analysis
- Asset extraction with smart image format selection (JPEG/PNG)
- Support for both file and stdin/stdout I/O
- Customizable DPI for vector graphics rasterization
- Grand Central Dispatch (GCD) for multi-core performance
- Comprehensive documentation
</file>

<file path="Makefile">
CC = clang
CFLAGS = -Wall -Wextra -O2 -fobjc-arc
FRAMEWORKS = -framework Foundation -framework PDFKit -framework CoreGraphics -framework ImageIO -framework CoreServices
TARGET = pdf22md

# Version from git tag or fallback
VERSION ?= $(shell git describe --tags --always --dirty 2>/dev/null || echo "dev")

# Define directories
SRC_DIR = src
BUILD_DIR = build

# Source and object files
SOURCES = $(wildcard $(SRC_DIR)/*.m)
OBJECTS = $(patsubst $(SRC_DIR)/%.m,$(BUILD_DIR)/%.o,$(SOURCES))

# Default prefix for installation
PREFIX ?= /usr/local

all: $(BUILD_DIR) $(TARGET)

$(BUILD_DIR):
	mkdir -p $(BUILD_DIR)

$(TARGET): $(OBJECTS)
	$(CC) $(CFLAGS) $(FRAMEWORKS) -o $(TARGET) $(OBJECTS)

$(BUILD_DIR)/%.o: $(SRC_DIR)/%.m | $(BUILD_DIR)
	$(CC) $(CFLAGS) -DVERSION=\"$(VERSION)\" -c $< -o $@

clean:
	rm -rf $(BUILD_DIR) $(TARGET)

install: $(TARGET)
	install -d $(DESTDIR)$(PREFIX)/bin
	install -m 755 $(TARGET) $(DESTDIR)$(PREFIX)/bin/

uninstall:
	rm -f $(DESTDIR)$(PREFIX)/bin/$(TARGET)

.PHONY: all clean install uninstall
</file>

<file path="src/PDFPageProcessor.m">
#import "PDFPageProcessor.h"
#import "ContentElement.h"

@interface PDFPageProcessor ()
@property (nonatomic, strong) PDFPage *pdfPage;
@property (nonatomic, assign) NSInteger pageIndex;
@property (nonatomic, assign) CGFloat dpi;
@property (nonatomic, assign) CGPDFPageRef cgPdfPage;
@end

@implementation PDFPageProcessor

- (instancetype)initWithPDFPage:(PDFPage *)pdfPage
                      pageIndex:(NSInteger)pageIndex
                            dpi:(CGFloat)dpi {
    self = [super init];
    if (self) {
        _pdfPage = pdfPage;
        _pageIndex = pageIndex;
        _dpi = dpi;
        _cgPdfPage = [pdfPage pageRef];
    }
    return self;
}

- (NSArray<id<ContentElement>> *)extractContentElements {
    // -------------------------------------------------------------------------
    // NEW IMPLEMENTATION (2025-06-22)
    // -------------------------------------------------------------------------
    // The previous version relied on low-level CGPDFScanner APIs which could
    // enter an infinite loop on some malformed PDFs, causing the whole tool to
    // hang. We now use PDFKit's high-level API which is both safer and faster
    // for common text extraction tasks. Vector graphics and images will be
    // handled separately in future improvements.
    // -------------------------------------------------------------------------
    
    NSMutableArray<id<ContentElement>> *elements = [NSMutableArray array];
    
    // 1. Extract plain text for the entire page.
    NSString *pageText = [self.pdfPage string]; // PDFKit handles parsing
    if (!pageText || pageText.length == 0) {
        return elements; // Nothing to do
    }
    
    // 2. Split into paragraphs so we keep some structure.
    NSArray<NSString *> *paragraphs = [pageText componentsSeparatedByCharactersInSet:[NSCharacterSet newlineCharacterSet]];
    
    // 3. Prepare some default typography metadata. We no longer have direct
    //    font info  set conservative defaults so later heading detection logic
    //    can still run (all body text will share the same size, which is fine
    //    for now; future work can re-introduce advanced heuristics).
    NSString *defaultFontName = @"Helvetica";
    CGFloat   defaultFontSize = 12.0;
    
    // 4. Create a rough vertical cursor so elements have distinct Y positions.
    //    This keeps the existing (page, y, x) sort logic intact.
    CGFloat pageHeight = CGRectGetHeight([self.pdfPage boundsForBox:kPDFDisplayBoxMediaBox]);
    CGFloat cursorY    = pageHeight; // start at the top
    CGFloat lineHeight = defaultFontSize * 1.4; // simple approximation
    
    for (NSString *rawParagraph in paragraphs) {
        NSString *trimmed = [rawParagraph stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
        if (trimmed.length == 0) { continue; }
        
        TextElement *element = [[TextElement alloc] init];
        element.text      = trimmed;
        element.fontName  = defaultFontName;
        element.fontSize  = defaultFontSize;
        element.isBold    = NO;
        element.isItalic  = NO;
        element.pageIndex = self.pageIndex;
        
        CGRect bounds = CGRectMake(0, cursorY - lineHeight, 400, lineHeight);
        element.bounds = bounds;
        
        cursorY -= (lineHeight + 2.0); // simple spacing
        
        [elements addObject:element];
    }
    
    // 5. Extract images using PDFKit annotations
    [self extractImagesFromPageWithElements:elements];
    
    return elements;
}

- (void)captureVectorGraphicsInBounds:(CGRect)bounds
                         withElements:(NSMutableArray *)elements {
    // Expand bounds slightly to ensure we capture everything
    bounds = CGRectInset(bounds, -5, -5);
    
    // Calculate size at specified DPI
    CGFloat scale = self.dpi / 72.0;
    size_t width = (size_t)(CGRectGetWidth(bounds) * scale);
    size_t height = (size_t)(CGRectGetHeight(bounds) * scale);
    
    if (width == 0 || height == 0) {
        return;
    }
    
    // Create bitmap context
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, colorSpace,
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        return;
    }
    
    // Set white background
    CGContextSetRGBFillColor(context, 1.0, 1.0, 1.0, 1.0);
    CGContextFillRect(context, CGRectMake(0, 0, width, height));
    
    // Set up transformation to render just the bounds area
    CGContextSaveGState(context);
    CGContextScaleCTM(context, scale, scale);
    CGContextTranslateCTM(context, -bounds.origin.x, -bounds.origin.y);
    
    // Draw the PDF page
    CGContextDrawPDFPage(context, self.cgPdfPage);
    
    CGContextRestoreGState(context);
    
    // Create image
    CGImageRef image = CGBitmapContextCreateImage(context);
    CGContextRelease(context);
    
    if (image) {
        ImageElement *element = [[ImageElement alloc] init];
        element.image = image;
        element.bounds = bounds;
        element.pageIndex = self.pageIndex;
        element.isVectorSource = YES;
        [elements addObject:element];
    }
}

- (void)extractImagesFromPageWithElements:(NSMutableArray *)elements {
    // Method 1: Extract images from annotations (for embedded images)
    NSArray<PDFAnnotation *> *annotations = [self.pdfPage annotations];
    NSInteger imageIndex = 0;
    
    for (PDFAnnotation *annotation in annotations) {
        // Skip text annotations and other non-image types
        if (![annotation isKindOfClass:[PDFAnnotation class]]) {
            continue;
        }
        
        // Try to get image from annotation appearance
        CGImageRef image = [self imageFromAnnotation:annotation];
        if (image) {
            ImageElement *element = [[ImageElement alloc] init];
            element.image = image;
            element.bounds = [annotation bounds];
            element.pageIndex = self.pageIndex;
            element.isVectorSource = NO;
            [elements addObject:element];
            imageIndex++;
        }
    }
    
    // Method 2: Render page areas that likely contain images
    // This is a fallback approach - render page in sections and detect image-like content
    [self extractImagesByRenderingPageSections:elements startingIndex:imageIndex];
}

- (CGImageRef)imageFromAnnotation:(PDFAnnotation *)annotation {
    // Try to extract image from annotation's appearance stream
    CGRect bounds = [annotation bounds];
    if (CGRectIsEmpty(bounds) || bounds.size.width < 10 || bounds.size.height < 10) {
        return NULL;
    }
    
    // Create a bitmap context to render the annotation
    CGFloat scale = self.dpi / 72.0;
    size_t width = (size_t)(bounds.size.width * scale);
    size_t height = (size_t)(bounds.size.height * scale);
    
    if (width == 0 || height == 0) {
        return NULL;
    }
    
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, colorSpace,
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        return NULL;
    }
    
    // Set white background
    CGContextSetRGBFillColor(context, 1.0, 1.0, 1.0, 1.0);
    CGContextFillRect(context, CGRectMake(0, 0, width, height));
    
    // Transform context to match annotation bounds
    CGContextSaveGState(context);
    CGContextScaleCTM(context, scale, scale);
    
    // Draw just the annotation area from the page
    CGContextClipToRect(context, CGRectMake(0, 0, bounds.size.width, bounds.size.height));
    CGContextTranslateCTM(context, -bounds.origin.x, -bounds.origin.y);
    CGContextDrawPDFPage(context, self.cgPdfPage);
    
    CGContextRestoreGState(context);
    
    // Create image
    CGImageRef image = CGBitmapContextCreateImage(context);
    CGContextRelease(context);
    
    return image;
}

- (void)extractImagesByRenderingPageSections:(NSMutableArray *)elements startingIndex:(NSInteger)startIndex {
    // This method divides the page into a grid and analyzes each section
    // to detect areas that contain primarily image content vs text content
    
    CGRect pageRect = [self.pdfPage boundsForBox:kPDFDisplayBoxMediaBox];
    CGFloat sectionSize = 100.0; // 100 point sections
    
    NSInteger gridX = (NSInteger)ceil(pageRect.size.width / sectionSize);
    NSInteger gridY = (NSInteger)ceil(pageRect.size.height / sectionSize);
    
    NSInteger imageIndex = startIndex;
    
    for (NSInteger x = 0; x < gridX; x++) {
        for (NSInteger y = 0; y < gridY; y++) {
            CGRect sectionRect = CGRectMake(x * sectionSize, y * sectionSize, 
                                          sectionSize, sectionSize);
            
            // Intersect with page bounds
            sectionRect = CGRectIntersection(sectionRect, pageRect);
            if (CGRectIsEmpty(sectionRect) || sectionRect.size.width < 20 || sectionRect.size.height < 20) {
                continue;
            }
            
            // Check if this section contains primarily image content
            if ([self sectionContainsImageContent:sectionRect]) {
                CGImageRef sectionImage = [self renderPageSection:sectionRect];
                if (sectionImage) {
                    ImageElement *element = [[ImageElement alloc] init];
                    element.image = sectionImage;
                    element.bounds = sectionRect;
                    element.pageIndex = self.pageIndex;
                    element.isVectorSource = YES; // Since we're rendering from vector
                    [elements addObject:element];
                    imageIndex++;
                }
            }
        }
    }
}

- (BOOL)sectionContainsImageContent:(CGRect)sectionRect {
    // Simple heuristic: if a section doesn't contain much text, it might be an image
    // This is a simplified approach - we could improve this with more sophisticated analysis
    
    // Get text in this section
    PDFSelection *selection = [self.pdfPage selectionForRect:sectionRect];
    NSString *sectionText = [selection string];
    
    // If there's very little text, it might be an image area
    NSString *trimmedText = [sectionText stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    
    // Threshold: if less than 10 characters, consider it potentially an image area
    return [trimmedText length] < 10;
}

- (CGImageRef)renderPageSection:(CGRect)sectionRect {
    // Render just the specified section of the page
    CGFloat scale = self.dpi / 72.0;
    size_t width = (size_t)(sectionRect.size.width * scale);
    size_t height = (size_t)(sectionRect.size.height * scale);
    
    if (width == 0 || height == 0) {
        return NULL;
    }
    
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, colorSpace,
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        return NULL;
    }
    
    // Set white background
    CGContextSetRGBFillColor(context, 1.0, 1.0, 1.0, 1.0);
    CGContextFillRect(context, CGRectMake(0, 0, width, height));
    
    // Transform context to render just the section
    CGContextSaveGState(context);
    CGContextScaleCTM(context, scale, scale);
    CGContextTranslateCTM(context, -sectionRect.origin.x, -sectionRect.origin.y);
    
    // Draw the PDF page
    CGContextDrawPDFPage(context, self.cgPdfPage);
    
    CGContextRestoreGState(context);
    
    // Create image
    CGImageRef image = CGBitmapContextCreateImage(context);
    CGContextRelease(context);
    
    return image;
}

@end
</file>

<file path="README.md">
# pdf22md

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![macOS](https://img.shields.io/badge/macOS-10.15+-blue.svg)](https://www.apple.com/macos/)
[![Build Status](https://github.com/twardoch/pdf22md/workflows/Build%20and%20Release/badge.svg)](https://github.com/twardoch/pdf22md/actions)

A blazingly fast PDF to Markdown converter for macOS.

`pdf22md` is a command-line tool that extracts all text and image content from a PDF file and converts it into a clean Markdown document. It uses Grand Central Dispatch (GCD) to process pages and save images in parallel, making it exceptionally fast for multi-page documents.

## Key Features

- **High-Speed Conversion**: Uses all available CPU cores to process PDF pages concurrently
- **Intelligent Heading Detection**: Analyzes font sizes and usage frequency to automatically format titles and headings (`#`, `##`, etc.)
- **Asset Extraction**: Saves raster and vector images into a specified assets folder and links them correctly in the Markdown file
- **Smart Image Formatting**: Automatically chooses between JPEG (for photos) and PNG (for graphics with transparency) to optimize file size and quality
- **Flexible I/O**: Reads from a PDF file or `stdin` and writes to a Markdown file or `stdout`
- **Customizable Rasterization**: Allows setting a custom DPI for converting vector graphics to bitmaps
- **Clean Output**: Runs without verbose debug logging for a noise-free CLI experience

## Installation

### Using Homebrew (Coming Soon)

```bash
brew tap twardoch/pdf22md
brew install pdf22md
```

### Building from Source

To build the project manually, you need Xcode Command Line Tools installed.

```bash
# Clone the repository
git clone https://github.com/twardoch/pdf22md.git
cd pdf22md

# Compile the tool
make

# Install it to /usr/local/bin (optional)
sudo make install
```

### Download Pre-built Binary

Pre-built binaries are available from the [Releases](https://github.com/twardoch/pdf22md/releases) page.

## Usage

```
Usage: pdf22md [-i input.pdf] [-o output.md] [-a assets_folder] [-d dpi]
  Converts PDF documents to Markdown format
  -i <path>: Input PDF file (default: stdin)
  -o <path>: Output Markdown file (default: stdout)
  -a <path>: Assets folder for extracted images
  -d <dpi>: DPI for rasterizing vector graphics (default: 144)
```

### Examples

```bash
# Convert a PDF file to Markdown
pdf22md -i document.pdf -o document.md

# Convert with images saved to an 'assets' folder
pdf22md -i report.pdf -o report.md -a ./assets

# Convert with custom DPI for vector graphics
pdf22md -i presentation.pdf -o presentation.md -a ./images -d 300

# Use with pipes
cat document.pdf | pdf22md > document.md

# Convert and view in less
pdf22md -i manual.pdf | less
```

## Requirements

- macOS 10.15 (Catalina) or later
- Xcode Command Line Tools (for building from source)

## Project Structure

```
pdf22md/
 src/                    # Source code
    main.m             # Entry point
    PDFMarkdownConverter.*  # Main conversion logic
    PDFPageProcessor.*      # PDF page processing
    ContentElement.*        # Content element definitions
    AssetExtractor.*        # Image extraction logic
 docs/                   # Additional documentation
 test/                   # Test files
 LICENSE                 # MIT License
 Makefile               # Build configuration
 README.md              # This file
```

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request. For major changes, please open an issue first to discuss what you would like to change.

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/AmazingFeature`)
3. Commit your changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Acknowledgments

- Built with Apple's PDFKit and Core Graphics frameworks
- Parallel processing powered by Grand Central Dispatch (GCD)
- Inspired by the need for fast, accurate PDF to Markdown conversion

## Related Projects

- [pdfplumber](https://github.com/jsvine/pdfplumber) - Python library for PDF processing
- [pdf2md](https://github.com/axllent/pdf2md) - Another PDF to Markdown converter
- [pandoc](https://pandoc.org/) - Universal document converter

## Changelog

See [CHANGELOG.md](CHANGELOG.md) for a list of changes in each version.

## Support

If you encounter any issues or have questions, please [open an issue](https://github.com/twardoch/pdf22md/issues/new/choose) on GitHub.
</file>

<file path="TODO.md">
# TODO

##  Phase 1a: Asset extraction (Done)

```
./pdf22md -i ./test/digitallegacies-twardoch2018.pdf -o ./test/output.md -a ./test/out
```

Segmentation fault fixed. The tool now extracts all embedded images (PNG/JPG chosen automatically) and rasterizes vector graphics into appropriately named files (`image_001.png`, `image_002.jpg`, ...).

## Phase 2: Distribution

- [ ] Create Homebrew formula and tap for easy installation (`brew install twardoch/pdf22md/pdf22md`)
- [ ] Test Homebrew installation process on clean macOS system
- [ ] Add Homebrew installation verification to CI/CD

## Phase 3: Documentation Improvements

- [ ] Add usage examples for different PDF types to README.md
- [ ] Create man page for the tool (`man pdf22md`)
- [ ] Document known limitations and workarounds
- [ ] Add troubleshooting section to README.md

## Core Features

- [ ] Preserve PDF bookmarks/outline structure and extracting metadata (author, title, creation date) into YAML frontmatter
- [ ] Improve heading detection algorithm
- [ ] Better handling of tables and lists
- [ ] Support for PDF forms and annotations

### Code Quality

- [ ] Add unit tests for core functionality
- [ ] Implement proper error handling with descriptive messages
- [ ] Add code comments and documentation
- [ ] Create man page for the tool
- [ ] Add performance benchmarks

### Advanced Distribution

- [ ] Set up automated nightly builds
- [ ] Add support for Linux (using GNUstep)
- [ ] Create Docker image for cross-platform usage
- [ ] Add Windows support via WSL or native compilation

### Advanced Documentation

- [ ] Add detailed API documentation for developers
- [ ] Write technical blog post about the implementation
- [ ] Create video tutorials for common use cases
- [ ] Add performance benchmarking documentation
</file>

</files>
