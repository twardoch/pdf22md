This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    build-release.yml
    release.yml
docs/
  PARALLEL_PROCESSING.md
  pdf22md.1
issues/
  issue102-resolution.txt
  issue102.txt
  issue201.txt
pdf22md-objc/
  archived-old-implementation/
    AssetExtractor.h
    AssetExtractor.m
    ContentElement.h
    ContentElement.m
    main.m
    PDF22MDErrorHelper.h
    PDF22MDErrorHelper.m
    PDFMarkdownConverter.h
    PDFMarkdownConverter.m
    PDFPageProcessor.h
    PDFPageProcessor.m
  docs/
    pdf22md.1
  src/
    CLI/
      main.m
      pdf22md-benchmark.m
    Core/
      PDF22MDConversionOptions.h
      PDF22MDConversionOptions.m
      PDF22MDConverter.h
      PDF22MDConverter.m
      PDF22MDError.h
      PDF22MDError.m
      PDF22MDFontAnalyzer.h
      PDF22MDFontAnalyzer.m
      PDF22MDPageProcessor.h
      PDF22MDPageProcessor.m
    Models/
      PDF22MDContentElement.h
      PDF22MDImageElement.h
      PDF22MDImageElement.m
      PDF22MDTextElement.h
      PDF22MDTextElement.m
    Services/
      PDF22MDAssetManager.h
      PDF22MDAssetManager.m
      PDF22MDMarkdownGenerator.h
      PDF22MDMarkdownGenerator.m
  test/
    README.md
  Tests/
    Integration/
      EndToEndConversionTests.m
    Unit/
      AssetExtractorTests.m
      ContentElementTests.m
      PDF22MDAssetManagerTests.m
      PDF22MDConverterTests.m
      PDF22MDFontAnalyzerTests.m
      PDFMarkdownConverterTests.m
      SimpleConverterTest.m
  build.sh
  llms.txt
  Makefile
  README.md
  release.sh
  run-tests.sh
pdf22md-swift/
  docs/
    pdf22md.1
  test/
    README.md
  Tests/
    PDF22MDTests/
      PDF22MDTests.swift
  build.sh
  Package.swift
  README.md
  release.sh
test/
  README.md
.gitignore
AGENTS.md
build.sh
CHANGELOG.md
CLAUDE.md
LICENSE
README.md
TODO.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/release.yml">
name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  build-and-release:
    runs-on: macos-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Full history for version tags
    
    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable
    
    - name: Get version from tag
      id: version
      run: |
        VERSION=${GITHUB_REF#refs/tags/v}
        echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
        echo "TAG=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
    
    - name: Build universal binary
      run: |
        # Build for Intel
        make clean
        make VERSION="${{ steps.version.outputs.VERSION }}" CFLAGS="-Wall -Wextra -O2 -fobjc-arc -arch x86_64"
        mv pdf22md pdf22md-x86_64
        
        # Build for Apple Silicon
        make clean
        make VERSION="${{ steps.version.outputs.VERSION }}" CFLAGS="-Wall -Wextra -O2 -fobjc-arc -arch arm64"
        mv pdf22md pdf22md-arm64
        
        # Create universal binary
        lipo -create -output pdf22md pdf22md-x86_64 pdf22md-arm64
        chmod +x pdf22md
        
        # Verify universal binary
        lipo -info pdf22md
        ./pdf22md -v
    
    - name: Create distribution package
      run: |
        # Create directory structure
        mkdir -p dist/usr/local/bin
        mkdir -p dist/usr/local/share/man/man1
        mkdir -p dist/usr/local/share/doc/pdf22md
        
        # Copy files
        cp pdf22md dist/usr/local/bin/
        cp LICENSE dist/usr/local/share/doc/pdf22md/
        cp README.md dist/usr/local/share/doc/pdf22md/
        cp docs/PARALLEL_PROCESSING.md dist/usr/local/share/doc/pdf22md/ || true
        
        # Create man page
        cat > dist/usr/local/share/man/man1/pdf22md.1 << EOF
        .TH PDF22MD 1 "$(date +'%B %Y')" "pdf22md ${{ steps.version.outputs.VERSION }}" "User Commands"
        .SH NAME
        pdf22md \- Convert PDF documents to Markdown format
        .SH SYNOPSIS
        .B pdf22md
        [\fB\-i\fR \fIinput.pdf\fR]
        [\fB\-o\fR \fIoutput.md\fR]
        [\fB\-a\fR \fIassets_folder\fR]
        [\fB\-d\fR \fIdpi\fR]
        [\fB\-v\fR]
        [\fB\-h\fR]
        .SH DESCRIPTION
        .B pdf22md
        is a high-performance PDF to Markdown converter for macOS that uses Grand Central Dispatch (GCD) for parallel processing.
        .SH OPTIONS
        .TP
        .BR \-i " " \fIpath\fR
        Input PDF file (default: stdin)
        .TP
        .BR \-o " " \fIpath\fR
        Output Markdown file (default: stdout)
        .TP
        .BR \-a " " \fIpath\fR
        Assets folder for extracted images
        .TP
        .BR \-d " " \fIdpi\fR
        DPI for rasterizing vector graphics (default: 144)
        .TP
        .BR \-v
        Display version information
        .TP
        .BR \-h
        Display help message
        .SH EXAMPLES
        .TP
        Convert a PDF file to Markdown:
        .B pdf22md -i document.pdf -o document.md
        .TP
        Convert with images saved to an assets folder:
        .B pdf22md -i report.pdf -o report.md -a ./assets
        .TP
        Use with pipes:
        .B cat document.pdf | pdf22md > document.md
        .SH AUTHOR
        Adam Twardoch
        .SH LICENSE
        MIT License
        EOF
    
    - name: Create installer package
      run: |
        # Create package info
        mkdir -p package_resources
        
        # Create postinstall script
        cat > package_resources/postinstall << 'EOF'
        #!/bin/bash
        # Update man database
        if command -v makewhatis >/dev/null 2>&1; then
            makewhatis /usr/local/share/man
        fi
        exit 0
        EOF
        chmod +x package_resources/postinstall
        
        # Build the package
        pkgbuild --root dist \
                 --identifier com.twardoch.pdf22md \
                 --version "${{ steps.version.outputs.VERSION }}" \
                 --scripts package_resources \
                 --ownership recommended \
                 pdf22md-${{ steps.version.outputs.VERSION }}.pkg
        
        # Create a distribution XML for productbuild (optional, for more control)
        cat > distribution.xml << EOF
        <?xml version="1.0" encoding="utf-8" standalone="yes"?>
        <installer-gui-script minSpecVersion="2.0">
            <title>pdf22md ${{ steps.version.outputs.VERSION }}</title>
            <organization>com.twardoch</organization>
            <domains enable_localSystem="true"/>
            <options customize="never" require-scripts="true" rootVolumeOnly="true"/>
            <pkg-ref id="com.twardoch.pdf22md">
                <bundle-version>
                    <bundle CFBundleVersion="${{ steps.version.outputs.VERSION }}" id="com.twardoch.pdf22md" path="pdf22md"/>
                </bundle-version>
            </pkg-ref>
            <choices-outline>
                <line choice="default">
                    <line choice="com.twardoch.pdf22md"/>
                </line>
            </choices-outline>
            <choice id="default" title="pdf22md" description="PDF to Markdown converter"/>
            <choice id="com.twardoch.pdf22md" visible="false">
                <pkg-ref id="com.twardoch.pdf22md"/>
            </choice>
            <pkg-ref id="com.twardoch.pdf22md" version="${{ steps.version.outputs.VERSION }}" onConclusion="none">pdf22md-${{ steps.version.outputs.VERSION }}.pkg</pkg-ref>
        </installer-gui-script>
        EOF
        
        # Sign the package if certificates are available
        if security find-identity -p basic -v | grep -q "Developer ID Installer"; then
            INSTALLER_CERT=$(security find-identity -p basic -v | grep "Developer ID Installer" | head -1 | awk '{print $2}')
            productsign --sign "$INSTALLER_CERT" \
                        pdf22md-${{ steps.version.outputs.VERSION }}.pkg \
                        pdf22md-${{ steps.version.outputs.VERSION }}-signed.pkg
            mv pdf22md-${{ steps.version.outputs.VERSION }}-signed.pkg pdf22md-${{ steps.version.outputs.VERSION }}.pkg
        fi
    
    - name: Create release archives
      run: |
        # Create tarball with binary and docs
        mkdir -p pdf22md-${{ steps.version.outputs.VERSION }}
        cp pdf22md pdf22md-${{ steps.version.outputs.VERSION }}/
        cp README.md LICENSE pdf22md-${{ steps.version.outputs.VERSION }}/
        cp -r docs pdf22md-${{ steps.version.outputs.VERSION }}/ || true
        tar -czf pdf22md-${{ steps.version.outputs.VERSION }}-macos.tar.gz pdf22md-${{ steps.version.outputs.VERSION }}
        
        # Create zip for those who prefer it
        zip -r pdf22md-${{ steps.version.outputs.VERSION }}-macos.zip pdf22md-${{ steps.version.outputs.VERSION }}
    
    - name: Generate release notes
      id: release_notes
      run: |
        # Get previous tag
        PREVIOUS_TAG=$(git tag -l 'v*' | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -2 | head -1)
        
        # Generate changelog
        if [ -n "$PREVIOUS_TAG" ]; then
          echo "## What's Changed" > release_notes.md
          echo "" >> release_notes.md
          git log --pretty=format:"* %s (%h)" ${PREVIOUS_TAG}..HEAD >> release_notes.md
        else
          echo "## Initial Release" > release_notes.md
          echo "" >> release_notes.md
          echo "First release of pdf22md!" >> release_notes.md
        fi
        
        echo "" >> release_notes.md
        echo "## Installation" >> release_notes.md
        echo "" >> release_notes.md
        echo "### Using the installer package (recommended):" >> release_notes.md
        echo '```bash' >> release_notes.md
        echo "curl -LO https://github.com/twardoch/pdf22md/releases/download/${{ steps.version.outputs.TAG }}/pdf22md-${{ steps.version.outputs.VERSION }}.pkg" >> release_notes.md
        echo "sudo installer -pkg pdf22md-${{ steps.version.outputs.VERSION }}.pkg -target /" >> release_notes.md
        echo '```' >> release_notes.md
        echo "" >> release_notes.md
        echo "### Manual installation:" >> release_notes.md
        echo '```bash' >> release_notes.md
        echo "curl -LO https://github.com/twardoch/pdf22md/releases/download/${{ steps.version.outputs.TAG }}/pdf22md-${{ steps.version.outputs.VERSION }}-macos.tar.gz" >> release_notes.md
        echo "tar -xzf pdf22md-${{ steps.version.outputs.VERSION }}-macos.tar.gz" >> release_notes.md
        echo "sudo cp pdf22md-${{ steps.version.outputs.VERSION }}/pdf22md /usr/local/bin/" >> release_notes.md
        echo '```' >> release_notes.md
    
    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        name: pdf22md ${{ steps.version.outputs.VERSION }}
        body_path: release_notes.md
        files: |
          pdf22md-${{ steps.version.outputs.VERSION }}.pkg
          pdf22md-${{ steps.version.outputs.VERSION }}-macos.tar.gz
          pdf22md-${{ steps.version.outputs.VERSION }}-macos.zip
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Update Homebrew formula
      run: |
        # This would typically update a homebrew tap repository
        # For now, we'll just output what should be done
        echo "To update Homebrew formula:"
        echo "1. Update the url to: https://github.com/twardoch/pdf22md/archive/refs/tags/${{ steps.version.outputs.TAG }}.tar.gz"
        echo "2. Update the sha256 hash"
        echo "3. Update the version in the formula"
</file>

<file path="docs/PARALLEL_PROCESSING.md">
# Parallel Processing in `pdf22md`

This document outlines the implementation of parallel processing in the `pdf22md` command-line tool for converting PDF documents to Markdown format.

## 1. Objective

The goal was to accelerate the conversion of multi-page PDF documents by processing multiple pages concurrently and saving extracted images in parallel.

## 2. Technology: Grand Central Dispatch (GCD)

Similar to `pdfupng`, we utilized Apple's **Grand Central Dispatch (GCD)** framework with the `dispatch_apply` function for parallel execution.

## 3. Implementation Details

### 3.1. Parallel Page Processing

The core changes were made within the `convertWithAssetsFolderPath:rasterizedDPI:completion:` method in `PDFMarkdownConverter.m`.

#### From Sequential to Concurrent

The original implementation used a sequential `for` loop:

```objc
for (NSInteger pageIndex = 0; pageIndex < pageCount; pageIndex++) {
    PDFPage *page = [self.pdfDocument pageAtIndex:pageIndex];
    // ... process page ...
}
```

This was replaced with:

```objc
dispatch_apply(pageCount, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t pageIndex) {
    @autoreleasepool {
        PDFPage *page = [self.pdfDocument pageAtIndex:pageIndex];
        // ... process page ...
    }
});
```

### 3.2. Thread Safety Measures

1. **Temporary Storage Arrays**: Instead of directly modifying shared arrays (`allElements`, `fontStats`), we create temporary per-page storage:

```objc
NSMutableArray<NSMutableArray<id<ContentElement>> *> *pageElementsArray = [NSMutableArray arrayWithCapacity:pageCount];
NSMutableArray<NSMutableDictionary *> *pageFontStatsArray = [NSMutableArray arrayWithCapacity:pageCount];
```

2. **Error Handling**: A shared boolean flag with synchronized access:

```objc
__block BOOL processingFailed = NO;
NSObject *lock = [[NSObject alloc] init];

// Inside parallel block
@synchronized(lock) {
    if (processingFailed) return;
}
```

3. **Result Merging**: After parallel processing completes, results are merged sequentially:

```objc
for (NSInteger i = 0; i < pageCount; i++) {
    [self.allElements addObjectsFromArray:pageElementsArray[i]];
    // Merge font statistics...
}
```

### 3.3. Parallel Image Saving

Image saving was also parallelized:

```objc
dispatch_apply(imageCount, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t index) {
    @autoreleasepool {
        ImageElement *imageElement = imageElements[index];
        NSString *savedPath = [assetExtractor saveImage:imageElement.image ...];
        if (savedPath) {
            @synchronized(imageElement) {
                imageElement.assetRelativePath = savedPath;
            }
        }
    }
});
```

### 3.4. Memory Management

Each parallel operation is wrapped in `@autoreleasepool` to ensure prompt deallocation of temporary objects and prevent memory spikes.

## 4. Performance Benefits

- **Multi-core Utilization**: Pages are processed on multiple CPU cores simultaneously
- **Reduced Total Time**: For PDFs with many pages, the speedup is nearly linear with the number of cores
- **Efficient Memory Usage**: Autoreleasepool prevents memory accumulation
- **Scalability**: The implementation automatically adapts to the available hardware

## 5. Considerations

- **Thread Safety**: All shared resources are protected with appropriate synchronization
- **Memory Overhead**: Each parallel task has its own memory footprint, but autoreleasepool keeps it manageable
- **I/O Bottlenecks**: Image saving may be limited by disk I/O speed rather than CPU
</file>

<file path="docs/pdf22md.1">
.TH PDF22MD 1 "June 2025" "pdf22md v1.0" "User Commands"
.SH NAME
pdf22md \- high-performance PDF to Markdown converter
.SH SYNOPSIS
.B pdf22md
[\fB\-i\fR \fIinput.pdf\fR]
[\fB\-o\fR \fIoutput.md\fR]
[\fB\-a\fR \fIassets_folder\fR]
[\fB\-d\fR \fIdpi\fR]
[\fB\-v\fR]
[\fB\-h\fR]
.SH DESCRIPTION
.B pdf22md
is a blazingly fast PDF to Markdown converter that extracts text and images from PDF documents and converts them into clean, structured Markdown format. It uses parallel processing to achieve high performance on multi-page documents.

The tool automatically detects heading hierarchy based on font size analysis, extracts images with intelligent format optimization (PNG/JPEG), and generates YAML frontmatter with document metadata.

.SH OPTIONS
.TP
\fB\-i\fR \fIinput.pdf\fR
Specify the input PDF file to convert. If not provided, pdf22md reads from standard input (stdin).
.TP
\fB\-o\fR \fIoutput.md\fR
Specify the output Markdown file. If not provided, pdf22md writes to standard output (stdout).
.TP
\fB\-a\fR \fIassets_folder\fR
Specify the folder where extracted images will be saved. The folder will be created if it doesn't exist. Images are automatically referenced in the generated Markdown with relative paths.
.TP
\fB\-d\fR \fIdpi\fR
Set the DPI (dots per inch) for rasterizing vector graphics. Default is 144. Higher values produce better quality but larger file sizes. Common values: 72 (screen), 144 (default), 300 (print quality).
.TP
\fB\-v\fR, \fB\-\-version\fR
Display version information and exit.
.TP
\fB\-h\fR, \fB\-\-help\fR
Display usage information and exit.

.SH EXAMPLES
.TP
Convert a PDF file to Markdown:
.B pdf22md \-i document.pdf \-o document.md

.TP
Extract images to an assets folder:
.B pdf22md \-i document.pdf \-o document.md \-a ./assets

.TP
Use higher DPI for better image quality:
.B pdf22md \-i document.pdf \-o document.md \-a ./assets \-d 300

.TP
Convert using pipes (stdin/stdout):
.B cat document.pdf | pdf22md > document.md

.TP
Process a document with custom settings:
.B pdf22md \-i report.pdf \-o report.md \-a ./images \-d 200

.SH INPUT/OUTPUT
.SS Input Sources
.B pdf22md
accepts PDF input from:
.IP • 2
File path specified with \fB\-i\fR flag
.IP • 2
Standard input (stdin) when no \fB\-i\fR flag is provided

.SS Output Destinations
Markdown output is written to:
.IP • 2
File path specified with \fB\-o\fR flag
.IP • 2
Standard output (stdout) when no \fB\-o\fR flag is provided

.SS Image Assets
When the \fB\-a\fR flag is used:
.IP • 2
Images are extracted and saved to the specified folder
.IP • 2
Filenames follow the pattern: image_001.png, image_002.jpg, etc.
.IP • 2
Format selection is automatic (PNG for graphics, JPEG for photos)
.IP • 2
Markdown contains relative references to the images

.SH FEATURES
.SS Intelligent Content Processing
.IP • 2
\fBHeading Detection\fR: Automatically identifies headings (H1-H6) based on font size analysis
.IP • 2
\fBText Extraction\fR: Preserves text formatting and structure
.IP • 2
\fBImage Processing\fR: Extracts both raster and vector graphics
.IP • 2
\fBSmart Formatting\fR: Maintains document hierarchy and readability

.SS Performance Optimizations
.IP • 2
\fBParallel Processing\fR: Uses all available CPU cores for maximum speed
.IP • 2
\fBMemory Efficiency\fR: Processes large documents without excessive memory usage
.IP • 2
\fBFormat Optimization\fR: Automatic PNG/JPEG selection based on image content

.SS Output Features
.IP • 2
\fBYAML Frontmatter\fR: Includes document metadata (title, author, creation date)
.IP • 2
\fBClean Markdown\fR: Well-structured output compatible with all Markdown processors
.IP • 2
\fBAsset Management\fR: Organized image extraction with proper linking

.SH FILE FORMATS
.SS Supported Input
.IP • 2
PDF files (version 1.4 and higher)
.IP • 2
Unencrypted PDFs (password-protected PDFs are not supported)
.IP • 2
PDFs with text, images, and vector graphics
.IP • 2
Multi-page documents of any size

.SS Generated Output
.IP • 2
\fBMarkdown (.md)\fR: GitHub Flavored Markdown compatible
.IP • 2
\fBImages (.png/.jpg)\fR: Extracted graphics in optimal formats
.IP • 2
\fBYAML Frontmatter\fR: Document metadata in standard format

.SH PERFORMANCE
Typical conversion speeds on modern hardware:
.IP • 2
Simple text documents: <1 second per page
.IP • 2
Complex documents with images: 2-5 seconds per page
.IP • 2
Large documents (100+ pages): Scales linearly with parallel processing

Memory usage is optimized for documents up to 1000 pages. Very large documents may require additional system memory.

.SH ERROR HANDLING
.B pdf22md
provides detailed error messages with suggestions for common issues:

.SS Common Errors and Solutions
.TP
\fBInvalid PDF file\fR
.IP • 2
Verify the file exists and is a valid PDF
.IP • 2
Check if the file is corrupted
.IP • 2
Ensure you have read permissions

.TP
\fBCannot create assets folder\fR
.IP • 2
Check if the parent directory exists
.IP • 2
Verify you have write permissions
.IP • 2
Ensure sufficient disk space

.TP
\fBPassword-protected PDF\fR
.IP • 2
Remove password protection using another tool first
.IP • 2
Use: qpdf \-\-decrypt input.pdf output.pdf

.TP
\fBMemory pressure\fR
.IP • 2
Close other applications to free memory
.IP • 2
Try using a lower DPI setting (\-d 72)
.IP • 2
Process smaller sections of large documents

.SH EXIT STATUS
.TP
.B 0
Successful conversion
.TP
.B 1
Error occurred (invalid input, processing failure, I/O error)

.SH ENVIRONMENT
No special environment variables are required. The tool uses standard macOS frameworks (PDFKit, CoreGraphics) and runs on macOS 10.15 and later.

.SH LIMITATIONS
.IP • 2
Password-protected PDFs are not supported
.IP • 2
Scanned PDFs without OCR text layer will only extract images
.IP • 2
Complex table layouts may not convert perfectly
.IP • 2
Some advanced PDF features (forms, annotations) are not preserved

.SH COMPATIBILITY
.SS Platform Support
.IP • 2
macOS 10.15 (Catalina) and later
.IP • 2
Intel and Apple Silicon processors
.IP • 2
Universal binary for optimal performance

.SS Markdown Compatibility
Output is compatible with:
.IP • 2
GitHub Flavored Markdown
.IP • 2
CommonMark specification
.IP • 2
Popular Markdown processors (pandoc, Jekyll, etc.)
.IP • 2
Static site generators (Hugo, Jekyll, Gatsby)

.SH FILES
.TP
.I ~/.pdf22md/
User configuration directory (future use)
.TP
.I /usr/local/bin/pdf22md
Default installation location
.TP
.I /usr/local/share/man/man1/pdf22md.1
This manual page

.SH EXAMPLES WORKFLOW
.SS Basic Document Conversion
.nf
# Convert a simple document
pdf22md \-i report.pdf \-o report.md

# Result: clean Markdown with YAML frontmatter
# Output includes: title, headings, body text, metadata
.fi

.SS Academic Paper with Images
.nf
# Convert research paper with figure extraction
pdf22md \-i paper.pdf \-o paper.md \-a figures \-d 300

# Result: 
# - paper.md with structured content
# - figures/ folder with high-quality images
# - Proper cross-references to figures
.fi

.SS Batch Processing
.nf
# Process multiple documents
for pdf in *.pdf; do
    pdf22md \-i "$pdf" \-o "${pdf%.pdf}.md" \-a "assets_${pdf%.pdf}"
done
.fi

.SS Integration with Other Tools
.nf
# Combine with pandoc for further processing
pdf22md \-i document.pdf | pandoc \-f markdown \-t html \-o document.html

# Use with static site generators
pdf22md \-i post.pdf \-o content/posts/post.md \-a static/images
.fi

.SH TROUBLESHOOTING
.SS Performance Issues
If conversion is slow:
.IP • 2
Check available memory and CPU usage
.IP • 2
Close unnecessary applications
.IP • 2
Try lower DPI setting for faster processing
.IP • 2
Process documents in smaller batches

.SS Quality Issues
If output quality is poor:
.IP • 2
Increase DPI setting (\-d 300) for better images
.IP • 2
Verify the source PDF has good quality text
.IP • 2
Check if the PDF has a proper text layer (not just scanned images)

.SS Memory Errors
For large documents:
.IP • 2
Ensure sufficient RAM (8GB+ recommended for large PDFs)
.IP • 2
Close other memory-intensive applications
.IP • 2
Split very large PDFs into smaller parts first

.SH REPORTING BUGS
Report bugs and feature requests at:
.UR https://github.com/twardoch/pdf22md/issues
.UE

Include in your report:
.IP • 2
pdf22md version (\fBpdf22md \-v\fR)
.IP • 2
macOS version
.IP • 2
Sample PDF file (if possible)
.IP • 2
Complete error message
.IP • 2
Steps to reproduce the issue

.SH AUTHORS
Written by Adam Twardoch and contributors.

.SH LICENSE
MIT License. See the LICENSE file for details.

.SH SEE ALSO
.BR pandoc (1),
.BR qpdf (1),
.BR pdftotext (1),
.BR markdown (7)

Project homepage: 
.UR https://github.com/twardoch/pdf22md
.UE
</file>

<file path="issues/issue102-resolution.txt">
ISSUE 102 RESOLUTION
===================

Problem:
--------
Two build script issues were preventing successful builds:

1. `declare -A` bash incompatibility error
   - Error: "declare: -A: invalid option"
   - Root cause: Bash 3.x doesn't support associative arrays

2. SWBBuildService framework loading issue in Swift build
   - Error: "Library not loaded: @rpath/SWBBuildService.framework"
   - Root cause: Corrupted or incomplete Swift toolchain installation

Solutions Implemented:
---------------------

1. Fixed bash incompatibility:
   - Replaced associative array `declare -A build_results` with simple variables
   - Changed from `build_results["objc"]` to `build_results_objc`
   - Updated all references throughout build.sh

2. Enhanced Swift build resilience:
   - Added Swift toolchain health check before attempting build
   - Implemented graceful fallback when Swift toolchain is corrupted
   - Added informative error messages with recovery instructions
   - Modified build.sh to continue with Objective-C when Swift fails

Results:
--------
- Objective-C build: ✓ WORKING
- Swift build: ✗ BLOCKED (system Swift toolchain issue)
- Build script: ✓ ROBUST (handles mixed success gracefully)

The build script now:
- Detects and reports Swift toolchain issues clearly
- Provides recovery instructions (xcode-select --install)
- Continues with successful builds when one implementation fails
- Gives clear status reporting for both implementations

Note: The Swift toolchain issue requires system-level resolution by the user:
`xcode-select --install` or reinstalling Xcode Command Line Tools.
</file>

<file path="issues/issue102.txt">
Othello:pdf22md adam$ ./build.sh
./build.sh: line 17: declare: -A: invalid option
declare: usage: declare [-afFirtx] [-p] [name[=value] ...]
[BUILD] pdf22md - Multi-Implementation Build System
[INFO] Building Objective-C Swift implementations
[BUILD] Building pdf22md-objc...
[INFO] Starting pdf22md-objc build process...
[INFO] Building pdf22md (Objective-C implementation)...
rm -rf build pdf22md
mkdir -p build
clang -Wall -Wextra -O2 -fobjc-arc -DVERSION=\"v1.2.0-1-gba7a7a8-dirty\" -Isrc -c src/CLI/main.m -o build/CLI/main.o
clang -Wall -Wextra -O2 -fobjc-arc -DVERSION=\"v1.2.0-1-gba7a7a8-dirty\" -Isrc -c src/Core/PDF22MDConversionOptions.m -o build/Core/PDF22MDConversionOptions.o
clang -Wall -Wextra -O2 -fobjc-arc -DVERSION=\"v1.2.0-1-gba7a7a8-dirty\" -Isrc -c src/Core/PDF22MDConverter.m -o build/Core/PDF22MDConverter.o
clang -Wall -Wextra -O2 -fobjc-arc -DVERSION=\"v1.2.0-1-gba7a7a8-dirty\" -Isrc -c src/Core/PDF22MDError.m -o build/Core/PDF22MDError.o
clang -Wall -Wextra -O2 -fobjc-arc -DVERSION=\"v1.2.0-1-gba7a7a8-dirty\" -Isrc -c src/Core/PDF22MDFontAnalyzer.m -o build/Core/PDF22MDFontAnalyzer.o
clang -Wall -Wextra -O2 -fobjc-arc -DVERSION=\"v1.2.0-1-gba7a7a8-dirty\" -Isrc -c src/Core/PDF22MDPageProcessor.m -o build/Core/PDF22MDPageProcessor.o
clang -Wall -Wextra -O2 -fobjc-arc -DVERSION=\"v1.2.0-1-gba7a7a8-dirty\" -Isrc -c src/Models/PDF22MDImageElement.m -o build/Models/PDF22MDImageElement.o
clang -Wall -Wextra -O2 -fobjc-arc -DVERSION=\"v1.2.0-1-gba7a7a8-dirty\" -Isrc -c src/Models/PDF22MDTextElement.m -o build/Models/PDF22MDTextElement.o
clang -Wall -Wextra -O2 -fobjc-arc -DVERSION=\"v1.2.0-1-gba7a7a8-dirty\" -Isrc -c src/Services/PDF22MDAssetManager.m -o build/Services/PDF22MDAssetManager.o
clang -Wall -Wextra -O2 -fobjc-arc -DVERSION=\"v1.2.0-1-gba7a7a8-dirty\" -Isrc -c src/Services/PDF22MDMarkdownGenerator.m -o build/Services/PDF22MDMarkdownGenerator.o
clang -Wall -Wextra -O2 -fobjc-arc -framework Foundation -framework PDFKit -framework CoreGraphics -framework ImageIO -framework CoreServices -o pdf22md build/CLI/main.o build/Core/PDF22MDConversionOptions.o build/Core/PDF22MDConverter.o build/Core/PDF22MDError.o build/Core/PDF22MDFontAnalyzer.o build/Core/PDF22MDPageProcessor.o build/Models/PDF22MDImageElement.o build/Models/PDF22MDTextElement.o build/Services/PDF22MDAssetManager.o build/Services/PDF22MDMarkdownGenerator.o
[INFO] ✓ pdf22md-objc built successfully
[INFO] Build complete!
[INFO] Run './pdf22md --help' for usage information
[INFO] ✓ pdf22md-objc built successfully
[BUILD] Building pdf22md-swift...
[INFO] Starting pdf22md-swift build process...
[INFO] Building pdf22md (Swift implementation)...
dyld[5982]: Library not loaded: @rpath/SWBBuildService.framework/Versions/A/SWBBuildService
  Referenced from: <DAAB41B3-19E5-3A14-8AFB-1A3635185E81> /Library/Developer/CommandLineTools/usr/bin/swift-package
  Reason: tried: '/Library/../SharedFrameworks/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/../SharedFrameworks/SwiftBuild.framework/Versions/A/PlugIns/SWBBuildService.bundle/Contents/Frameworks/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/../SharedFrameworks/SwiftBuild.framework/Versions/A/PlugIns/SWBBuildSystem.bundle/Contents/Frameworks/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/../Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/../Developer/Toolchains/XcodeDefault.xctoolchain/usr/local/include/SwiftToolsSupport/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/Developer/CommandLineTools/usr/lib/swift/pm/llbuild/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/Developer/CommandLineTools/usr/lib/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/Developer/CommandLineTools/usr/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/../SharedFrameworks/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/../SharedFrameworks/SwiftBuild.framework/Versions/A/PlugIns/SWBBuildService.bundle/Contents/Frameworks/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/../SharedFrameworks/SwiftBuild.framework/Versions/A/PlugIns/SWBBuildSystem.bundle/Contents/Frameworks/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/../Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/../Developer/Toolchains/XcodeDefault.xctoolchain/usr/local/include/SwiftToolsSupport/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/Developer/CommandLineTools/usr/lib/swift/pm/llbuild/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/Developer/CommandLineTools/usr/lib/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/Developer/CommandLineTools/usr/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file)
./build.sh: line 31:  5982 Abort trap: 6           swift build -c release
[ERROR] Failed to build pdf22md-swift
[ERROR] ✗ pdf22md-swift build failed
[BUILD] Build Summary
[ERROR] ✗ pdf22md-0: FAILED

[ERROR] Some builds failed (0/1 successful)
Othello:pdf22md adam$
</file>

<file path="pdf22md-objc/archived-old-implementation/AssetExtractor.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

@interface AssetExtractor : NSObject

- (nullable instancetype)initWithAssetFolder:(NSString *)folderPath;

- (nullable NSString *)saveImage:(CGImageRef)image
                  isVectorSource:(BOOL)isVector
                      withBaseName:(NSString *)baseName;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/archived-old-implementation/AssetExtractor.m">
#import "AssetExtractor.h"
#import <ImageIO/ImageIO.h>

@interface AssetExtractor ()
@property (nonatomic, strong) NSString *assetFolderPath;
@property (nonatomic, strong) NSFileManager *fileManager;
@end

@implementation AssetExtractor

- (nullable instancetype)initWithAssetFolder:(NSString *)folderPath {
    self = [super init];
    if (self) {
        _assetFolderPath = folderPath;
        _fileManager = [NSFileManager defaultManager];
        
        // Create assets folder if it doesn't exist
        NSError *error = nil;
        BOOL isDirectory = NO;
        BOOL exists = [_fileManager fileExistsAtPath:folderPath isDirectory:&isDirectory];
        
        if (exists && !isDirectory) {
            NSLog(@"Asset path exists but is not a directory: %@", folderPath);
            return nil;
        }
        
        if (!exists) {
            if (![_fileManager createDirectoryAtPath:folderPath
                         withIntermediateDirectories:YES
                                          attributes:nil
                                               error:&error]) {
                NSLog(@"Failed to create assets folder: %@", error);
                return nil;
            }
        }
    }
    return self;
}

- (nullable NSString *)saveImage:(CGImageRef)image
                  isVectorSource:(BOOL)isVector
                      withBaseName:(NSString *)baseName {
    if (!image) {
        return nil;
    }
    
    // Analyze image to determine optimal format
    BOOL shouldUseJPEG = [self shouldUseJPEGForImage:image];
    
    NSString *extension = shouldUseJPEG ? @"jpg" : @"png";
    NSString *fileName = [NSString stringWithFormat:@"%@.%@", baseName, extension];
    NSString *fullPath = [self.assetFolderPath stringByAppendingPathComponent:fileName];
    
    // Create destination
    NSURL *fileURL = [NSURL fileURLWithPath:fullPath];
    CGImageDestinationRef destination = CGImageDestinationCreateWithURL((__bridge CFURLRef)fileURL,
                                                                       shouldUseJPEG ? (__bridge CFStringRef)@"public.jpeg" : (__bridge CFStringRef)@"public.png",
                                                                       1, NULL);
    if (!destination) {
        NSLog(@"Failed to create image destination");
        return nil;
    }
    
    // Set compression options
    NSDictionary *properties = nil;
    if (shouldUseJPEG) {
        properties = @{(__bridge NSString *)kCGImageDestinationLossyCompressionQuality: @0.85};
    }
    
    // Add image to destination
    CGImageDestinationAddImage(destination, image, (__bridge CFDictionaryRef)properties);
    
    // Finalize
    BOOL success = CGImageDestinationFinalize(destination);
    CFRelease(destination);
    
    if (!success) {
        NSLog(@"Failed to save image to %@", fullPath);
        return nil;
    }
    
    // Return relative path (just the filename since it's in the assets folder)
    return fileName;
}

- (BOOL)shouldUseJPEGForImage:(CGImageRef)image {
    // Get image properties
    size_t width = CGImageGetWidth(image);
    size_t height = CGImageGetHeight(image);
    CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(image);
    
    // If image has alpha channel, use PNG
    if (alphaInfo != kCGImageAlphaNone &&
        alphaInfo != kCGImageAlphaNoneSkipFirst &&
        alphaInfo != kCGImageAlphaNoneSkipLast) {
        return NO;
    }
    
    // For small images, use PNG
    if (width * height < 10000) { // Less than 100x100
        return NO;
    }
    
    // Analyze color complexity by sampling pixels
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    size_t bytesPerRow = width * 4;
    size_t sampleSize = MIN(width * height, 10000); // Sample up to 10k pixels
    
    unsigned char *pixelData = calloc(sampleSize * 4, sizeof(unsigned char));
    if (!pixelData) {
        CGColorSpaceRelease(colorSpace);
        return YES; // Default to JPEG if we can't analyze
    }
    
    CGContextRef context = CGBitmapContextCreate(pixelData, width, 1, 8, bytesPerRow, colorSpace,
                                                kCGImageAlphaNoneSkipLast | kCGBitmapByteOrder32Big);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        free(pixelData);
        return YES;
    }
    
    // Sample middle row
    CGContextDrawImage(context, CGRectMake(0, 0, width, 1), image);
    CGContextRelease(context);
    
    // Count unique colors in sample
    NSMutableSet *uniqueColors = [NSMutableSet set];
    for (size_t i = 0; i < width * 4; i += 4) {
        uint32_t color = (pixelData[i] << 24) | (pixelData[i+1] << 16) | 
                        (pixelData[i+2] << 8) | pixelData[i+3];
        [uniqueColors addObject:@(color)];
    }
    
    free(pixelData);
    
    // If we have many unique colors, it's likely a photograph - use JPEG
    return [uniqueColors count] > 256;
}

@end
</file>

<file path="pdf22md-objc/archived-old-implementation/ContentElement.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

@protocol ContentElement <NSObject>
@property (nonatomic, readonly) CGRect bounds;
@property (nonatomic, readonly) NSInteger pageIndex;
- (NSString *)markdownRepresentation;
@end

@interface TextElement : NSObject <ContentElement>
@property (nonatomic, strong) NSString *text;
@property (nonatomic, assign) CGRect bounds;
@property (nonatomic, assign) NSInteger pageIndex;
@property (nonatomic, strong, nullable) NSString *fontName;
@property (nonatomic, assign) CGFloat fontSize;
@property (nonatomic, assign) BOOL isBold;
@property (nonatomic, assign) BOOL isItalic;
@property (nonatomic, assign) NSInteger headingLevel;
@end

@interface ImageElement : NSObject <ContentElement>
@property (nonatomic, assign) CGImageRef image;
@property (nonatomic, assign) CGRect bounds;
@property (nonatomic, assign) NSInteger pageIndex;
@property (nonatomic, assign) BOOL isVectorSource;
@property (nonatomic, strong, nullable) NSString *assetRelativePath;
@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/archived-old-implementation/ContentElement.m">
#import "ContentElement.h"

@implementation TextElement

- (NSString *)markdownRepresentation {
    if (!self.text || [self.text length] == 0) {
        return nil;
    }
    
    NSString *trimmedText = [self.text stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    if ([trimmedText length] == 0) {
        return nil;
    }
    
    // Apply heading formatting
    if (self.headingLevel > 0 && self.headingLevel <= 6) {
        NSMutableString *heading = [NSMutableString string];
        for (NSInteger i = 0; i < self.headingLevel; i++) {
            [heading appendString:@"#"];
        }
        [heading appendString:@" "];
        [heading appendString:trimmedText];
        return heading;
    }
    
    // Apply bold/italic formatting
    NSString *formattedText = trimmedText;
    
    if (self.isBold && self.isItalic) {
        formattedText = [NSString stringWithFormat:@"***%@***", formattedText];
    } else if (self.isBold) {
        formattedText = [NSString stringWithFormat:@"**%@**", formattedText];
    } else if (self.isItalic) {
        formattedText = [NSString stringWithFormat:@"*%@*", formattedText];
    }
    
    return formattedText;
}

- (void)dealloc {
    // No need to release CGImageRef here as ARC doesn't manage it
}

@end

@implementation ImageElement

- (NSString *)markdownRepresentation {
    if (!self.assetRelativePath) {
        return @"![Image](image-not-saved)";
    }
    
    return [NSString stringWithFormat:@"![Image](%@)", self.assetRelativePath];
}

- (void)dealloc {
    if (self.image) {
        CGImageRelease(self.image);
    }
}

@end
</file>

<file path="pdf22md-objc/archived-old-implementation/main.m">
#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>
#import "PDFMarkdownConverter.h"
#import "PDF22MDErrorHelper.h"

#ifndef VERSION
#define VERSION "dev"
#endif

void printUsage(const char *programName) {
    fprintf(stderr, "Usage: %s [-i input.pdf] [-o output.md] [-a assets_folder] [-d dpi] [-v] [-h]\n", programName);
    fprintf(stderr, "  Converts PDF documents to Markdown format\n");
    fprintf(stderr, "  -i <path>: Input PDF file (default: stdin)\n");
    fprintf(stderr, "  -o <path>: Output Markdown file (default: stdout)\n");
    fprintf(stderr, "  -a <path>: Assets folder for extracted images\n");
    fprintf(stderr, "  -d <dpi>: DPI for rasterizing vector graphics (default: 144)\n");
    fprintf(stderr, "  -v: Display version information\n");
    fprintf(stderr, "  -h: Display this help message\n");
}

void printVersion() {
    printf("pdf22md version %s\n", VERSION);
}

int main(int argc, const char *argv[]) {
    @autoreleasepool {
        NSString *inputPath = nil;
        NSString *outputPath = nil;
        NSString *assetsPath = nil;
        CGFloat dpi = 144.0;
        
        // Parse command line arguments
        int opt;
        while ((opt = getopt(argc, (char * const *)argv, "i:o:a:d:hvV")) != -1) {
            switch (opt) {
                case 'i':
                    inputPath = [NSString stringWithUTF8String:optarg];
                    break;
                case 'o':
                    outputPath = [NSString stringWithUTF8String:optarg];
                    break;
                case 'a':
                    assetsPath = [NSString stringWithUTF8String:optarg];
                    break;
                case 'd':
                    dpi = atof(optarg);
                    if (dpi <= 0) {
                        fprintf(stderr, "Invalid DPI value: %s\n", optarg);
                        return 1;
                    }
                    break;
                case 'h':
                    printUsage(argv[0]);
                    return 0;
                case 'v':
                case 'V':
                    printVersion();
                    return 0;
                default:
                    printUsage(argv[0]);
                    return 1;
            }
        }
        
        // Initialize converter
        PDFMarkdownConverter *converter = nil;
        
        if (inputPath) {
            // Read from file
            NSURL *pdfURL = [NSURL fileURLWithPath:inputPath];
            converter = [[PDFMarkdownConverter alloc] initWithPDFAtURL:pdfURL];
            if (!converter) {
                NSError *error = [PDF22MDErrorHelper invalidPDFErrorWithPath:inputPath];
                NSString *userMessage = [PDF22MDErrorHelper userFriendlyMessageForError:error];
                fprintf(stderr, "%s\n", [userMessage UTF8String]);
                return 1;
            }
        } else {
            // Read from stdin
            NSFileHandle *stdinHandle = [NSFileHandle fileHandleWithStandardInput];
            NSData *pdfData = [stdinHandle readDataToEndOfFile];
            
            if (!pdfData || [pdfData length] == 0) {
                NSError *error = [PDF22MDErrorHelper errorWithCode:PDF22MDErrorIOError
                                                        description:@"No PDF data received from stdin"
                                                         suggestion:@"• Pipe a valid PDF file to stdin\n"
                                                                   @"• Example: cat document.pdf | pdf22md > output.md\n"
                                                                   @"• Check that the input source contains PDF data"];
                NSString *userMessage = [PDF22MDErrorHelper userFriendlyMessageForError:error];
                fprintf(stderr, "%s\n", [userMessage UTF8String]);
                return 1;
            }
            
            converter = [[PDFMarkdownConverter alloc] initWithPDFData:pdfData];
            if (!converter) {
                NSError *error = [PDF22MDErrorHelper errorWithCode:PDF22MDErrorInvalidPDF
                                                        description:@"Failed to create PDF document from stdin data"
                                                         suggestion:@"• Ensure the piped data is a valid PDF file\n"
                                                                   @"• Verify the PDF is not corrupted\n"
                                                                   @"• Check if the PDF is password-protected"];
                NSString *userMessage = [PDF22MDErrorHelper userFriendlyMessageForError:error];
                fprintf(stderr, "%s\n", [userMessage UTF8String]);
                return 1;
            }
        }
        
        // Perform conversion
        __block NSString *markdown = nil;
        __block NSError *conversionError = nil;
        
        dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
        
        [converter convertWithAssetsFolderPath:assetsPath
                                rasterizedDPI:dpi
                                   completion:^(NSString *result, NSError *error) {
            markdown = result;
            conversionError = error;
            dispatch_semaphore_signal(semaphore);
        }];
        
        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
        
        if (conversionError) {
            NSString *userMessage = [PDF22MDErrorHelper userFriendlyMessageForError:conversionError];
            fprintf(stderr, "%s\n", [userMessage UTF8String]);
            return 1;
        }
        
        // Write output
        if (outputPath) {
            // Write to file
            NSError *writeError = nil;
            BOOL success = [markdown writeToFile:outputPath
                                      atomically:YES
                                        encoding:NSUTF8StringEncoding
                                           error:&writeError];
            if (!success) {
                NSError *enhancedError = [PDF22MDErrorHelper ioErrorWithPath:outputPath operation:@"write"];
                if (writeError) {
                    enhancedError = [PDF22MDErrorHelper errorWithCode:PDF22MDErrorIOError
                                                           description:[NSString stringWithFormat:@"Failed to write output file: %@", outputPath]
                                                            suggestion:@"• Check if you have write permissions for the directory\n"
                                                                      @"• Ensure sufficient disk space\n"
                                                                      @"• Verify the path is correct and accessible\n"
                                                                      @"• Check if the file is locked by another application"
                                                       underlyingError:writeError];
                }
                NSString *userMessage = [PDF22MDErrorHelper userFriendlyMessageForError:enhancedError];
                fprintf(stderr, "%s\n", [userMessage UTF8String]);
                return 1;
            }
        } else {
            // Write to stdout
            NSFileHandle *stdoutHandle = [NSFileHandle fileHandleWithStandardOutput];
            NSData *markdownData = [markdown dataUsingEncoding:NSUTF8StringEncoding];
            [stdoutHandle writeData:markdownData];
        }
        
        return 0;
    }
}
</file>

<file path="pdf22md-objc/archived-old-implementation/PDF22MDErrorHelper.h">
//
//  PDF22MDErrorHelper.h
//  pdf22md
//
//  Enhanced error handling with user-friendly messages and suggestions
//

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

// Error domain for pdf22md errors
extern NSErrorDomain const PDF22MDErrorDomain;

// Specific error codes with clear meanings
typedef NS_ENUM(NSInteger, PDF22MDError) {
    PDF22MDErrorInvalidPDF = 1000,          // PDF file is corrupted or invalid
    PDF22MDErrorAssetFolderCreation,        // Cannot create assets folder
    PDF22MDErrorMemoryPressure,            // Insufficient memory
    PDF22MDErrorProcessingTimeout,         // Processing took too long
    PDF22MDErrorEncryptedPDF,              // Password-protected PDF
    PDF22MDErrorEmptyDocument,             // PDF has no readable content
    PDF22MDErrorIOError,                   // File I/O error
    PDF22MDErrorPermissionDenied,          // Insufficient permissions
    PDF22MDErrorUnsupportedFormat          // PDF format not supported
};

/**
 * Helper class for creating user-friendly error messages with actionable suggestions
 */
@interface PDF22MDErrorHelper : NSObject

/**
 * Creates a user-friendly error with description and suggestion
 */
+ (NSError *)errorWithCode:(PDF22MDError)code
               description:(NSString *)description
                suggestion:(NSString *)suggestion;

/**
 * Creates a user-friendly error with underlying error context
 */
+ (NSError *)errorWithCode:(PDF22MDError)code
               description:(NSString *)description
                suggestion:(NSString *)suggestion
           underlyingError:(nullable NSError *)underlyingError;

/**
 * Common error factory methods
 */
+ (NSError *)invalidPDFErrorWithPath:(NSString *)path;
+ (NSError *)assetFolderErrorWithPath:(NSString *)path reason:(NSString *)reason;
+ (NSError *)memoryPressureError;
+ (NSError *)encryptedPDFError;
+ (NSError *)emptyDocumentError;
+ (NSError *)ioErrorWithPath:(NSString *)path operation:(NSString *)operation;
+ (NSError *)permissionErrorWithPath:(NSString *)path;

/**
 * Formats error for command-line display
 */
+ (NSString *)userFriendlyMessageForError:(NSError *)error;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/archived-old-implementation/PDF22MDErrorHelper.m">
//
//  PDF22MDErrorHelper.m
//  pdf22md
//
//  Enhanced error handling with user-friendly messages and suggestions
//

#import "PDF22MDErrorHelper.h"

NSErrorDomain const PDF22MDErrorDomain = @"com.twardoch.pdf22md.error";

@implementation PDF22MDErrorHelper

+ (NSError *)errorWithCode:(PDF22MDError)code
               description:(NSString *)description
                suggestion:(NSString *)suggestion {
    return [self errorWithCode:code
                   description:description
                    suggestion:suggestion
               underlyingError:nil];
}

+ (NSError *)errorWithCode:(PDF22MDError)code
               description:(NSString *)description
                suggestion:(NSString *)suggestion
           underlyingError:(nullable NSError *)underlyingError {
    
    NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];
    
    userInfo[NSLocalizedDescriptionKey] = description;
    userInfo[NSLocalizedRecoverySuggestionErrorKey] = suggestion;
    
    if (underlyingError) {
        userInfo[NSUnderlyingErrorKey] = underlyingError;
    }
    
    // Add additional context based on error code
    switch (code) {
        case PDF22MDErrorInvalidPDF:
            userInfo[NSLocalizedFailureReasonErrorKey] = @"The PDF file appears to be corrupted or in an unsupported format";
            break;
        case PDF22MDErrorAssetFolderCreation:
            userInfo[NSLocalizedFailureReasonErrorKey] = @"Unable to create the specified assets folder";
            break;
        case PDF22MDErrorMemoryPressure:
            userInfo[NSLocalizedFailureReasonErrorKey] = @"Insufficient memory to process this PDF";
            break;
        case PDF22MDErrorProcessingTimeout:
            userInfo[NSLocalizedFailureReasonErrorKey] = @"PDF processing timed out";
            break;
        case PDF22MDErrorEncryptedPDF:
            userInfo[NSLocalizedFailureReasonErrorKey] = @"The PDF is password-protected";
            break;
        case PDF22MDErrorEmptyDocument:
            userInfo[NSLocalizedFailureReasonErrorKey] = @"The PDF contains no readable content";
            break;
        case PDF22MDErrorIOError:
            userInfo[NSLocalizedFailureReasonErrorKey] = @"File input/output error occurred";
            break;
        case PDF22MDErrorPermissionDenied:
            userInfo[NSLocalizedFailureReasonErrorKey] = @"Insufficient permissions to access the file or folder";
            break;
        case PDF22MDErrorUnsupportedFormat:
            userInfo[NSLocalizedFailureReasonErrorKey] = @"The PDF format or version is not supported";
            break;
    }
    
    return [NSError errorWithDomain:PDF22MDErrorDomain code:code userInfo:userInfo];
}

#pragma mark - Factory Methods

+ (NSError *)invalidPDFErrorWithPath:(NSString *)path {
    NSString *description = [NSString stringWithFormat:@"Cannot open PDF file: %@", path];
    NSString *suggestion = @"• Verify the file exists and is a valid PDF\n"
                          @"• Check if the file is corrupted\n"
                          @"• Ensure you have read permissions for the file";
    
    return [self errorWithCode:PDF22MDErrorInvalidPDF
                   description:description
                    suggestion:suggestion];
}

+ (NSError *)assetFolderErrorWithPath:(NSString *)path reason:(NSString *)reason {
    NSString *description = [NSString stringWithFormat:@"Cannot create assets folder: %@", path];
    NSString *suggestion = [NSString stringWithFormat:@"• Check if the parent directory exists\n"
                                                      @"• Verify you have write permissions\n"
                                                      @"• Ensure sufficient disk space\n"
                                                      @"• Error details: %@", reason];
    
    return [self errorWithCode:PDF22MDErrorAssetFolderCreation
                   description:description
                    suggestion:suggestion];
}

+ (NSError *)memoryPressureError {
    NSString *description = @"Insufficient memory to process this PDF";
    NSString *suggestion = @"• Close other applications to free memory\n"
                          @"• Try processing a smaller PDF file\n"
                          @"• Consider using a lower DPI setting (-d 72)\n"
                          @"• If the PDF is very large, split it into smaller parts";
    
    return [self errorWithCode:PDF22MDErrorMemoryPressure
                   description:description
                    suggestion:suggestion];
}

+ (NSError *)encryptedPDFError {
    NSString *description = @"Cannot process password-protected PDF";
    NSString *suggestion = @"• Remove password protection using another tool first\n"
                          @"• Use Adobe Acrobat or similar to unlock the PDF\n"
                          @"• Try: qpdf --decrypt input.pdf output.pdf";
    
    return [self errorWithCode:PDF22MDErrorEncryptedPDF
                   description:description
                    suggestion:suggestion];
}

+ (NSError *)emptyDocumentError {
    NSString *description = @"PDF contains no readable text or content";
    NSString *suggestion = @"• Check if the PDF has text (not just scanned images)\n"
                          @"• For scanned documents, use OCR software first\n"
                          @"• Verify the PDF is not corrupted";
    
    return [self errorWithCode:PDF22MDErrorEmptyDocument
                   description:description
                    suggestion:suggestion];
}

+ (NSError *)ioErrorWithPath:(NSString *)path operation:(NSString *)operation {
    NSString *description = [NSString stringWithFormat:@"Failed to %@ file: %@", operation, path];
    NSString *suggestion = @"• Check if the file path is correct\n"
                          @"• Verify you have appropriate permissions\n"
                          @"• Ensure sufficient disk space\n"
                          @"• Check if the file is in use by another application";
    
    return [self errorWithCode:PDF22MDErrorIOError
                   description:description
                    suggestion:suggestion];
}

+ (NSError *)permissionErrorWithPath:(NSString *)path {
    NSString *description = [NSString stringWithFormat:@"Permission denied accessing: %@", path];
    NSString *suggestion = @"• Check file permissions with: ls -la\n"
                          @"• Use: chmod 644 for files, chmod 755 for directories\n"
                          @"• Ensure you own the file or have appropriate access\n"
                          @"• Try running with sudo if appropriate";
    
    return [self errorWithCode:PDF22MDErrorPermissionDenied
                   description:description
                    suggestion:suggestion];
}

#pragma mark - User-Friendly Formatting

+ (NSString *)userFriendlyMessageForError:(NSError *)error {
    if (![error.domain isEqualToString:PDF22MDErrorDomain]) {
        // For non-PDF22MD errors, provide basic formatting
        return [NSString stringWithFormat:@"Error: %@", error.localizedDescription];
    }
    
    NSMutableString *message = [NSMutableString string];
    
    // Add main description
    [message appendFormat:@"❌ %@\n", error.localizedDescription];
    
    // Add failure reason if available
    NSString *failureReason = error.userInfo[NSLocalizedFailureReasonErrorKey];
    if (failureReason) {
        [message appendFormat:@"\n💡 %@\n", failureReason];
    }
    
    // Add suggestions if available
    NSString *suggestion = error.userInfo[NSLocalizedRecoverySuggestionErrorKey];
    if (suggestion) {
        [message appendFormat:@"\n🔧 Try these solutions:\n%@\n", suggestion];
    }
    
    // Add underlying error details if available
    NSError *underlyingError = error.userInfo[NSUnderlyingErrorKey];
    if (underlyingError) {
        [message appendFormat:@"\n📋 Technical details: %@", underlyingError.localizedDescription];
    }
    
    return message;
}

@end
</file>

<file path="pdf22md-objc/archived-old-implementation/PDFMarkdownConverter.h">
#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>

NS_ASSUME_NONNULL_BEGIN

@interface PDFMarkdownConverter : NSObject

- (nullable instancetype)initWithPDFData:(NSData *)pdfData;
- (nullable instancetype)initWithPDFAtURL:(NSURL *)pdfURL;

- (void)convertWithAssetsFolderPath:(nullable NSString *)assetsPath
                     rasterizedDPI:(CGFloat)dpi
                        completion:(void (^)(NSString * _Nullable markdown, NSError * _Nullable error))completion;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/archived-old-implementation/PDFMarkdownConverter.m">
#import "PDFMarkdownConverter.h"
#import "PDFPageProcessor.h"
#import "ContentElement.h"
#import "AssetExtractor.h"

@interface PDFMarkdownConverter ()
@property (nonatomic, strong) PDFDocument *pdfDocument;
@property (nonatomic, strong) NSMutableArray<id<ContentElement>> *allElements;
@property (nonatomic, strong) NSMutableDictionary<NSString *, NSNumber *> *fontStats;
@end

@implementation PDFMarkdownConverter

- (nullable instancetype)initWithPDFData:(NSData *)pdfData {
    self = [super init];
    if (self) {
        _pdfDocument = [[PDFDocument alloc] initWithData:pdfData];
        if (!_pdfDocument) {
            return nil;
        }
        _allElements = [NSMutableArray array];
        _fontStats = [NSMutableDictionary dictionary];
    }
    return self;
}

- (nullable instancetype)initWithPDFAtURL:(NSURL *)pdfURL {
    self = [super init];
    if (self) {
        _pdfDocument = [[PDFDocument alloc] initWithURL:pdfURL];
        if (!_pdfDocument) {
            return nil;
        }
        _allElements = [NSMutableArray array];
        _fontStats = [NSMutableDictionary dictionary];
    }
    return self;
}

- (void)convertWithAssetsFolderPath:(nullable NSString *)assetsPath
                     rasterizedDPI:(CGFloat)dpi
                        completion:(void (^)(NSString * _Nullable markdown, NSError * _Nullable error))completion {
    
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSError *error = nil;
        
        // Process all pages in parallel
        NSInteger pageCount = [self.pdfDocument pageCount];
        // DEBUG log suppressed: Starting conversion of pages
        
        // Create thread-safe temporary storage
        NSMutableArray<NSMutableArray<id<ContentElement>> *> *pageElementsArray = [NSMutableArray arrayWithCapacity:pageCount];
        NSMutableArray<NSMutableDictionary *> *pageFontStatsArray = [NSMutableArray arrayWithCapacity:pageCount];
        
        // Initialize arrays
        for (NSInteger i = 0; i < pageCount; i++) {
            [pageElementsArray addObject:[NSMutableArray array]];
            [pageFontStatsArray addObject:[NSMutableDictionary dictionary]];
        }
        
        // Lock for thread safety
        NSObject *lock = [[NSObject alloc] init];
        __block BOOL processingFailed = NO;
        
        // Process pages in parallel using dispatch_apply
        // DEBUG log suppressed: Starting dispatch_apply for pages
        dispatch_apply(pageCount, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t pageIndex) {
            @autoreleasepool {
                // DEBUG log suppressed: Processing page
                // Check if processing has already failed
                @synchronized(lock) {
                    if (processingFailed) return;
                }
                
                PDFPage *page = [self.pdfDocument pageAtIndex:pageIndex];
                if (!page) {
                    @synchronized(lock) {
                        processingFailed = YES;
                    }
                    return;
                }
                
                PDFPageProcessor *processor = [[PDFPageProcessor alloc] initWithPDFPage:page
                                                                               pageIndex:pageIndex
                                                                                     dpi:dpi];
                
                NSArray<id<ContentElement>> *pageElements = [processor extractContentElements];
                // DEBUG log suppressed: Page extracted elements
                
                // Store results in thread-safe arrays
                pageElementsArray[pageIndex] = [pageElements mutableCopy];
                
                // Collect font statistics for this page
                NSMutableDictionary *pageFontStats = pageFontStatsArray[pageIndex];
                for (id<ContentElement> element in pageElements) {
                    if ([element isKindOfClass:[TextElement class]]) {
                        TextElement *textElement = (TextElement *)element;
                        NSString *fontKey = [NSString stringWithFormat:@"%.1f-%@", 
                                           textElement.fontSize, 
                                           textElement.fontName ?: @"Unknown"];
                        
                        NSNumber *count = pageFontStats[fontKey];
                        pageFontStats[fontKey] = @([count integerValue] + 1);
                    }
                }
            }
        });
        
        // DEBUG log suppressed: dispatch_apply completed
        
        // Check if processing failed
        if (processingFailed) {
            error = [NSError errorWithDomain:@"PDFMarkdownConverter"
                                       code:2
                                   userInfo:@{NSLocalizedDescriptionKey: @"Failed to process one or more PDF pages"}];
            completion(nil, error);
            return;
        }
        
        // DEBUG log suppressed: Merging results from all pages
        
        // Merge results from all pages
        for (NSInteger i = 0; i < pageCount; i++) {
            [self.allElements addObjectsFromArray:pageElementsArray[i]];
            
            // Merge font statistics
            NSDictionary *pageFontStats = pageFontStatsArray[i];
            for (NSString *fontKey in pageFontStats) {
                NSNumber *pageCount = pageFontStats[fontKey];
                NSNumber *totalCount = self.fontStats[fontKey];
                self.fontStats[fontKey] = @([totalCount integerValue] + [pageCount integerValue]);
            }
        }
        
        // DEBUG log suppressed: Analyzing font hierarchy
        
        // Analyze font hierarchy
        [self analyzeFontHierarchy];
        
        // DEBUG log suppressed: Sorting elements
        
        // Sort elements by page and position
        [self sortElements];
        
        // DEBUG log suppressed: Sort completed
        
        // Handle assets if needed
        AssetExtractor *assetExtractor = nil;
        if (assetsPath) {
            // DEBUG log suppressed: Starting asset extraction with path:
            assetExtractor = [[AssetExtractor alloc] initWithAssetFolder:assetsPath];
            if (!assetExtractor) {
                error = [NSError errorWithDomain:@"PDFMarkdownConverter"
                                           code:1
                                       userInfo:@{NSLocalizedDescriptionKey: @"Failed to create assets folder"}];
                completion(nil, error);
                return;
            }
            
            // Save images in parallel
            NSMutableArray<ImageElement *> *imageElements = [NSMutableArray array];
            for (id<ContentElement> element in self.allElements) {
                if ([element isKindOfClass:[ImageElement class]]) {
                    [imageElements addObject:(ImageElement *)element];
                }
            }
            
            NSInteger imageCount = [imageElements count];
            // DEBUG log suppressed: Found images to extract
            if (imageCount > 0) {
                // DEBUG log suppressed: Starting parallel image extraction
                dispatch_apply(imageCount, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t index) {
                    @autoreleasepool {
                        ImageElement *imageElement = imageElements[index];
                        NSString *baseName = [NSString stringWithFormat:@"image_%03zu", index];
                        NSString *savedPath = [assetExtractor saveImage:imageElement.image
                                                          isVectorSource:imageElement.isVectorSource
                                                              withBaseName:baseName];
                        if (savedPath) {
                            @synchronized(imageElement) {
                                imageElement.assetRelativePath = savedPath;
                            }
                        }
                    }
                });
                // DEBUG log suppressed: Completed parallel image extraction
            }
        } else {
            // DEBUG log suppressed: No assets path provided, skipping image extraction
        }
        
        // DEBUG log suppressed: Starting markdown generation
        
        // Generate markdown with YAML frontmatter
        NSMutableString *markdown = [NSMutableString string];
        
        // Add YAML frontmatter with metadata
        // DEBUG log suppressed: Generating YAML frontmatter
        NSString *yamlFrontmatter = [self generateYAMLFrontmatter];
        if (yamlFrontmatter) {
            [markdown appendString:yamlFrontmatter];
            [markdown appendString:@"\n"];
        }
        
        // DEBUG log suppressed: Converting elements to markdown
        for (id<ContentElement> element in self.allElements) {
            NSString *elementMarkdown = [element markdownRepresentation];
            if (elementMarkdown) {
                [markdown appendString:elementMarkdown];
                [markdown appendString:@"\n\n"];
            }
        }
        // DEBUG log suppressed: Markdown generation completed
        
        // Clean up extra newlines
        NSString *finalMarkdown = [markdown stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
        
        completion(finalMarkdown, nil);
    });
}

- (void)collectFontStatisticsFromElements:(NSArray<id<ContentElement>> *)elements {
    for (id<ContentElement> element in elements) {
        if ([element isKindOfClass:[TextElement class]]) {
            TextElement *textElement = (TextElement *)element;
            NSString *fontKey = [NSString stringWithFormat:@"%.1f-%@", 
                               textElement.fontSize, 
                               textElement.fontName ?: @"Unknown"];
            
            NSNumber *count = self.fontStats[fontKey];
            self.fontStats[fontKey] = @([count integerValue] + 1);
        }
    }
}

- (void)analyzeFontHierarchy {
    // Sort font sizes to determine heading levels
    NSMutableArray<NSNumber *> *uniqueSizes = [NSMutableArray array];
    NSMutableDictionary<NSNumber *, NSNumber *> *sizeFrequency = [NSMutableDictionary dictionary];
    
    for (NSString *fontKey in self.fontStats) {
        NSArray *components = [fontKey componentsSeparatedByString:@"-"];
        if (components.count > 0) {
            CGFloat fontSize = [components[0] floatValue];
            NSNumber *sizeNum = @(fontSize);
            
            if (![uniqueSizes containsObject:sizeNum]) {
                [uniqueSizes addObject:sizeNum];
            }
            
            NSInteger freq = [sizeFrequency[sizeNum] integerValue] + [self.fontStats[fontKey] integerValue];
            sizeFrequency[sizeNum] = @(freq);
        }
    }
    
    // Sort sizes in descending order
    [uniqueSizes sortUsingComparator:^NSComparisonResult(NSNumber *obj1, NSNumber *obj2) {
        return [obj2 compare:obj1];
    }];
    
    // Assign heading levels based on size hierarchy
    // Assume largest font is H1, second largest is H2, etc.
    NSMutableDictionary<NSNumber *, NSNumber *> *sizeToHeadingLevel = [NSMutableDictionary dictionary];
    NSInteger headingLevel = 1;
    
    for (NSNumber *size in uniqueSizes) {
        // Only assign heading levels to fonts that are significantly larger than average
        // and appear less frequently (typical of headings)
        NSInteger frequency = [sizeFrequency[size] integerValue];
        
        if (headingLevel <= 6 && frequency < 100) { // Adjust threshold as needed
            sizeToHeadingLevel[size] = @(headingLevel);
            headingLevel++;
        } else {
            sizeToHeadingLevel[size] = @(0); // Body text
        }
    }
    
    // Apply heading levels to text elements
    for (id<ContentElement> element in self.allElements) {
        if ([element isKindOfClass:[TextElement class]]) {
            TextElement *textElement = (TextElement *)element;
            NSNumber *sizeNum = @(textElement.fontSize);
            NSNumber *level = sizeToHeadingLevel[sizeNum];
            textElement.headingLevel = level ? [level integerValue] : 0;
        }
    }
}

- (void)sortElements {
    [self.allElements sortUsingComparator:^NSComparisonResult(id<ContentElement> obj1, id<ContentElement> obj2) {
        // First sort by page
        if ([obj1 respondsToSelector:@selector(pageIndex)] && [obj2 respondsToSelector:@selector(pageIndex)]) {
            NSInteger page1 = [(id)obj1 pageIndex];
            NSInteger page2 = [(id)obj2 pageIndex];
            
            if (page1 != page2) {
                return page1 < page2 ? NSOrderedAscending : NSOrderedDescending;
            }
        }
        
        // Then sort by vertical position (top to bottom)
        CGFloat y1 = CGRectGetMaxY(obj1.bounds);
        CGFloat y2 = CGRectGetMaxY(obj2.bounds);
        
        if (fabs(y1 - y2) > 5.0) { // Tolerance for same line
            return y1 > y2 ? NSOrderedAscending : NSOrderedDescending;
        }
        
        // Finally sort by horizontal position (left to right)
        CGFloat x1 = CGRectGetMinX(obj1.bounds);
        CGFloat x2 = CGRectGetMinX(obj2.bounds);
        
        return x1 < x2 ? NSOrderedAscending : NSOrderedDescending;
    }];
}

- (NSString *)generateYAMLFrontmatter {
    NSMutableString *yaml = [NSMutableString string];
    
    // Get PDF metadata
    NSDictionary *docAttributes = [self.pdfDocument documentAttributes];
    
    [yaml appendString:@"---\n"];
    
    // Title
    NSString *title = docAttributes[PDFDocumentTitleAttribute];
    if (title && title.length > 0) {
        [yaml appendFormat:@"title: \"%@\"\n", [self escapeYAMLString:title]];
    }
    
    // Author
    NSString *author = docAttributes[PDFDocumentAuthorAttribute];
    if (author && author.length > 0) {
        [yaml appendFormat:@"author: \"%@\"\n", [self escapeYAMLString:author]];
    }
    
    // Subject
    NSString *subject = docAttributes[PDFDocumentSubjectAttribute];
    if (subject && subject.length > 0) {
        [yaml appendFormat:@"subject: \"%@\"\n", [self escapeYAMLString:subject]];
    }
    
    // Keywords
    NSArray *keywords = docAttributes[PDFDocumentKeywordsAttribute];
    if (keywords && [keywords isKindOfClass:[NSArray class]] && keywords.count > 0) {
        [yaml appendString:@"keywords:\n"];
        for (NSString *keyword in keywords) {
            if ([keyword isKindOfClass:[NSString class]]) {
                [yaml appendFormat:@"  - \"%@\"\n", [self escapeYAMLString:keyword]];
            }
        }
    }
    
    // Creator (PDF producer software)
    NSString *creator = docAttributes[PDFDocumentCreatorAttribute];
    if (creator && creator.length > 0) {
        [yaml appendFormat:@"creator: \"%@\"\n", [self escapeYAMLString:creator]];
    }
    
    // Producer
    NSString *producer = docAttributes[PDFDocumentProducerAttribute];
    if (producer && producer.length > 0) {
        [yaml appendFormat:@"producer: \"%@\"\n", [self escapeYAMLString:producer]];
    }
    
    // Creation date
    NSDate *creationDate = docAttributes[PDFDocumentCreationDateAttribute];
    if (creationDate) {
        NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
        [formatter setDateFormat:@"yyyy-MM-dd'T'HH:mm:ssZZZZZ"];
        [yaml appendFormat:@"created: %@\n", [formatter stringFromDate:creationDate]];
    }
    
    // Modification date
    NSDate *modDate = docAttributes[PDFDocumentModificationDateAttribute];
    if (modDate) {
        NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
        [formatter setDateFormat:@"yyyy-MM-dd'T'HH:mm:ssZZZZZ"];
        [yaml appendFormat:@"modified: %@\n", [formatter stringFromDate:modDate]];
    }
    
    // PDF specific metadata
    [yaml appendString:@"pdf_metadata:\n"];
    [yaml appendFormat:@"  page_count: %ld\n", (long)[self.pdfDocument pageCount]];
    
    // PDF version
    NSString *pdfVersion = [self extractPDFVersion];
    if (pdfVersion) {
        [yaml appendFormat:@"  version: \"%@\"\n", pdfVersion];
    }
    
    // PDF outline (bookmarks/TOC)
    PDFOutline *outline = [self.pdfDocument outlineRoot];
    if (outline && [outline numberOfChildren] > 0) {
        [yaml appendString:@"  outline:\n"];
        [self appendOutlineToYAML:yaml outline:outline indent:@"    "];
    }
    
    // Conversion metadata
    [yaml appendString:@"conversion:\n"];
    [yaml appendString:@"  tool: \"pdf22md\"\n"];
    [yaml appendFormat:@"  version: \"%s\"\n", VERSION];
    
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateFormat:@"yyyy-MM-dd'T'HH:mm:ssZZZZZ"];
    [yaml appendFormat:@"  date: %@\n", [formatter stringFromDate:[NSDate date]]];
    
    [yaml appendString:@"---\n"];
    
    return yaml;
}

- (NSString *)escapeYAMLString:(NSString *)string {
    // Escape quotes and backslashes for YAML
    NSString *escaped = [string stringByReplacingOccurrencesOfString:@"\\" withString:@"\\\\"];
    escaped = [escaped stringByReplacingOccurrencesOfString:@"\"" withString:@"\\\""];
    escaped = [escaped stringByReplacingOccurrencesOfString:@"\n" withString:@"\\n"];
    escaped = [escaped stringByReplacingOccurrencesOfString:@"\r" withString:@"\\r"];
    return escaped;
}

- (NSString *)extractPDFVersion {
    // Try to extract PDF version from document attributes or metadata
    // This is a simplified approach - actual PDF version extraction might require
    // reading the PDF header directly
    NSDictionary *attributes = [self.pdfDocument documentAttributes];
    for (NSString *key in attributes) {
        id value = attributes[key];
        if ([value isKindOfClass:[NSString class]] && 
            [value rangeOfString:@"PDF-" options:NSCaseInsensitiveSearch].location != NSNotFound) {
            return value;
        }
    }
    return nil;
}

- (void)appendOutlineToYAML:(NSMutableString *)yaml outline:(PDFOutline *)outline indent:(NSString *)indent {
    for (NSUInteger i = 0; i < [outline numberOfChildren]; i++) {
        PDFOutline *child = [outline childAtIndex:i];
        NSString *label = [child label];
        if (label && label.length > 0) {
            [yaml appendFormat:@"%@- title: \"%@\"\n", indent, [self escapeYAMLString:label]];
            
            PDFDestination *destination = [child destination];
            if (destination) {
                PDFPage *page = [destination page];
                NSInteger pageIndex = [self.pdfDocument indexForPage:page];
                [yaml appendFormat:@"%@  page: %ld\n", indent, (long)(pageIndex + 1)];
            }
            
            if ([child numberOfChildren] > 0) {
                [yaml appendFormat:@"%@  children:\n", indent];
                NSString *newIndent = [indent stringByAppendingString:@"    "];
                [self appendOutlineToYAML:yaml outline:child indent:newIndent];
            }
        }
    }
}

@end
</file>

<file path="pdf22md-objc/archived-old-implementation/PDFPageProcessor.h">
#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

@protocol ContentElement;

@interface PDFPageProcessor : NSObject {
    @public
    NSInteger _pageIndex;
}

- (instancetype)initWithPDFPage:(PDFPage *)pdfPage
                      pageIndex:(NSInteger)pageIndex
                            dpi:(CGFloat)dpi;

- (NSArray<id<ContentElement>> *)extractContentElements;

- (void)captureVectorGraphicsInBounds:(CGRect)bounds
                         withElements:(NSMutableArray *)elements;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/archived-old-implementation/PDFPageProcessor.m">
#import "PDFPageProcessor.h"
#import "ContentElement.h"

@interface PDFPageProcessor ()
@property (nonatomic, strong) PDFPage *pdfPage;
@property (nonatomic, assign) NSInteger pageIndex;
@property (nonatomic, assign) CGFloat dpi;
@property (nonatomic, assign) CGPDFPageRef cgPdfPage;
@end

@implementation PDFPageProcessor

- (instancetype)initWithPDFPage:(PDFPage *)pdfPage
                      pageIndex:(NSInteger)pageIndex
                            dpi:(CGFloat)dpi {
    self = [super init];
    if (self) {
        _pdfPage = pdfPage;
        _pageIndex = pageIndex;
        _dpi = dpi;
        _cgPdfPage = [pdfPage pageRef];
    }
    return self;
}

- (NSArray<id<ContentElement>> *)extractContentElements {
    // -------------------------------------------------------------------------
    // NEW IMPLEMENTATION (2025-06-22)
    // -------------------------------------------------------------------------
    // The previous version relied on low-level CGPDFScanner APIs which could
    // enter an infinite loop on some malformed PDFs, causing the whole tool to
    // hang. We now use PDFKit's high-level API which is both safer and faster
    // for common text extraction tasks. Vector graphics and images will be
    // handled separately in future improvements.
    // -------------------------------------------------------------------------
    
    NSMutableArray<id<ContentElement>> *elements = [NSMutableArray array];
    
    // 1. Extract plain text for the entire page.
    NSString *pageText = [self.pdfPage string]; // PDFKit handles parsing
    if (!pageText || pageText.length == 0) {
        return elements; // Nothing to do
    }
    
    // 2. Split into paragraphs so we keep some structure.
    NSArray<NSString *> *paragraphs = [pageText componentsSeparatedByCharactersInSet:[NSCharacterSet newlineCharacterSet]];
    
    // 3. Prepare some default typography metadata. We no longer have direct
    //    font info – set conservative defaults so later heading detection logic
    //    can still run (all body text will share the same size, which is fine
    //    for now; future work can re-introduce advanced heuristics).
    NSString *defaultFontName = @"Helvetica";
    CGFloat   defaultFontSize = 12.0;
    
    // 4. Create a rough vertical cursor so elements have distinct Y positions.
    //    This keeps the existing (page, y, x) sort logic intact.
    CGFloat pageHeight = CGRectGetHeight([self.pdfPage boundsForBox:kPDFDisplayBoxMediaBox]);
    CGFloat cursorY    = pageHeight; // start at the top
    CGFloat lineHeight = defaultFontSize * 1.4; // simple approximation
    
    for (NSString *rawParagraph in paragraphs) {
        NSString *trimmed = [rawParagraph stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
        if (trimmed.length == 0) { continue; }
        
        TextElement *element = [[TextElement alloc] init];
        element.text      = trimmed;
        element.fontName  = defaultFontName;
        element.fontSize  = defaultFontSize;
        element.isBold    = NO;
        element.isItalic  = NO;
        element.pageIndex = self.pageIndex;
        
        CGRect bounds = CGRectMake(0, cursorY - lineHeight, 400, lineHeight);
        element.bounds = bounds;
        
        cursorY -= (lineHeight + 2.0); // simple spacing
        
        [elements addObject:element];
    }
    
    // 5. Extract images using PDFKit annotations
    [self extractImagesFromPageWithElements:elements];
    
    return elements;
}

- (void)captureVectorGraphicsInBounds:(CGRect)bounds
                         withElements:(NSMutableArray *)elements {
    // Expand bounds slightly to ensure we capture everything
    bounds = CGRectInset(bounds, -5, -5);
    
    // Calculate size at specified DPI
    CGFloat scale = self.dpi / 72.0;
    size_t width = (size_t)(CGRectGetWidth(bounds) * scale);
    size_t height = (size_t)(CGRectGetHeight(bounds) * scale);
    
    if (width == 0 || height == 0) {
        return;
    }
    
    // Create bitmap context
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, colorSpace,
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        return;
    }
    
    // Set white background
    CGContextSetRGBFillColor(context, 1.0, 1.0, 1.0, 1.0);
    CGContextFillRect(context, CGRectMake(0, 0, width, height));
    
    // Set up transformation to render just the bounds area
    CGContextSaveGState(context);
    CGContextScaleCTM(context, scale, scale);
    CGContextTranslateCTM(context, -bounds.origin.x, -bounds.origin.y);
    
    // Draw the PDF page
    CGContextDrawPDFPage(context, self.cgPdfPage);
    
    CGContextRestoreGState(context);
    
    // Create image
    CGImageRef image = CGBitmapContextCreateImage(context);
    CGContextRelease(context);
    
    if (image) {
        ImageElement *element = [[ImageElement alloc] init];
        element.image = image;
        element.bounds = bounds;
        element.pageIndex = self.pageIndex;
        element.isVectorSource = YES;
        [elements addObject:element];
    }
}

- (void)extractImagesFromPageWithElements:(NSMutableArray *)elements {
    // Method 1: Extract images from annotations (for embedded images)
    NSArray<PDFAnnotation *> *annotations = [self.pdfPage annotations];
    NSInteger imageIndex = 0;
    
    for (PDFAnnotation *annotation in annotations) {
        // Skip text annotations and other non-image types
        if (![annotation isKindOfClass:[PDFAnnotation class]]) {
            continue;
        }
        
        // Try to get image from annotation appearance
        CGImageRef image = [self imageFromAnnotation:annotation];
        if (image) {
            ImageElement *element = [[ImageElement alloc] init];
            element.image = image;
            element.bounds = [annotation bounds];
            element.pageIndex = self.pageIndex;
            element.isVectorSource = NO;
            [elements addObject:element];
            imageIndex++;
        }
    }
    
    // Method 2: Render page areas that likely contain images
    // This is a fallback approach - render page in sections and detect image-like content
    [self extractImagesByRenderingPageSections:elements startingIndex:imageIndex];
}

- (CGImageRef)imageFromAnnotation:(PDFAnnotation *)annotation {
    // Try to extract image from annotation's appearance stream
    CGRect bounds = [annotation bounds];
    if (CGRectIsEmpty(bounds) || bounds.size.width < 10 || bounds.size.height < 10) {
        return NULL;
    }
    
    // Create a bitmap context to render the annotation
    CGFloat scale = self.dpi / 72.0;
    size_t width = (size_t)(bounds.size.width * scale);
    size_t height = (size_t)(bounds.size.height * scale);
    
    if (width == 0 || height == 0) {
        return NULL;
    }
    
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, colorSpace,
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        return NULL;
    }
    
    // Set white background
    CGContextSetRGBFillColor(context, 1.0, 1.0, 1.0, 1.0);
    CGContextFillRect(context, CGRectMake(0, 0, width, height));
    
    // Transform context to match annotation bounds
    CGContextSaveGState(context);
    CGContextScaleCTM(context, scale, scale);
    
    // Draw just the annotation area from the page
    CGContextClipToRect(context, CGRectMake(0, 0, bounds.size.width, bounds.size.height));
    CGContextTranslateCTM(context, -bounds.origin.x, -bounds.origin.y);
    CGContextDrawPDFPage(context, self.cgPdfPage);
    
    CGContextRestoreGState(context);
    
    // Create image
    CGImageRef image = CGBitmapContextCreateImage(context);
    CGContextRelease(context);
    
    return image;
}

- (void)extractImagesByRenderingPageSections:(NSMutableArray *)elements startingIndex:(NSInteger)startIndex {
    // This method divides the page into a grid and analyzes each section
    // to detect areas that contain primarily image content vs text content
    
    CGRect pageRect = [self.pdfPage boundsForBox:kPDFDisplayBoxMediaBox];
    CGFloat sectionSize = 100.0; // 100 point sections
    
    NSInteger gridX = (NSInteger)ceil(pageRect.size.width / sectionSize);
    NSInteger gridY = (NSInteger)ceil(pageRect.size.height / sectionSize);
    
    NSInteger imageIndex = startIndex;
    
    for (NSInteger x = 0; x < gridX; x++) {
        for (NSInteger y = 0; y < gridY; y++) {
            CGRect sectionRect = CGRectMake(x * sectionSize, y * sectionSize, 
                                          sectionSize, sectionSize);
            
            // Intersect with page bounds
            sectionRect = CGRectIntersection(sectionRect, pageRect);
            if (CGRectIsEmpty(sectionRect) || sectionRect.size.width < 20 || sectionRect.size.height < 20) {
                continue;
            }
            
            // Check if this section contains primarily image content
            if ([self sectionContainsImageContent:sectionRect]) {
                CGImageRef sectionImage = [self renderPageSection:sectionRect];
                if (sectionImage) {
                    ImageElement *element = [[ImageElement alloc] init];
                    element.image = sectionImage;
                    element.bounds = sectionRect;
                    element.pageIndex = self.pageIndex;
                    element.isVectorSource = YES; // Since we're rendering from vector
                    [elements addObject:element];
                    imageIndex++;
                }
            }
        }
    }
}

- (BOOL)sectionContainsImageContent:(CGRect)sectionRect {
    // Simple heuristic: if a section doesn't contain much text, it might be an image
    // This is a simplified approach - we could improve this with more sophisticated analysis
    
    // Get text in this section
    PDFSelection *selection = [self.pdfPage selectionForRect:sectionRect];
    NSString *sectionText = [selection string];
    
    // If there's very little text, it might be an image area
    NSString *trimmedText = [sectionText stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    
    // Threshold: if less than 10 characters, consider it potentially an image area
    return [trimmedText length] < 10;
}

- (CGImageRef)renderPageSection:(CGRect)sectionRect {
    // Render just the specified section of the page
    CGFloat scale = self.dpi / 72.0;
    size_t width = (size_t)(sectionRect.size.width * scale);
    size_t height = (size_t)(sectionRect.size.height * scale);
    
    if (width == 0 || height == 0) {
        return NULL;
    }
    
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, colorSpace,
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        return NULL;
    }
    
    // Set white background
    CGContextSetRGBFillColor(context, 1.0, 1.0, 1.0, 1.0);
    CGContextFillRect(context, CGRectMake(0, 0, width, height));
    
    // Transform context to render just the section
    CGContextSaveGState(context);
    CGContextScaleCTM(context, scale, scale);
    CGContextTranslateCTM(context, -sectionRect.origin.x, -sectionRect.origin.y);
    
    // Draw the PDF page
    CGContextDrawPDFPage(context, self.cgPdfPage);
    
    CGContextRestoreGState(context);
    
    // Create image
    CGImageRef image = CGBitmapContextCreateImage(context);
    CGContextRelease(context);
    
    return image;
}

@end
</file>

<file path="pdf22md-objc/docs/pdf22md.1">
.TH PDF22MD 1 "June 2025" "pdf22md v1.0" "User Commands"
.SH NAME
pdf22md \- high-performance PDF to Markdown converter
.SH SYNOPSIS
.B pdf22md
[\fB\-i\fR \fIinput.pdf\fR]
[\fB\-o\fR \fIoutput.md\fR]
[\fB\-a\fR \fIassets_folder\fR]
[\fB\-d\fR \fIdpi\fR]
[\fB\-v\fR]
[\fB\-h\fR]
.SH DESCRIPTION
.B pdf22md
is a blazingly fast PDF to Markdown converter that extracts text and images from PDF documents and converts them into clean, structured Markdown format. It uses parallel processing to achieve high performance on multi-page documents.

The tool automatically detects heading hierarchy based on font size analysis, extracts images with intelligent format optimization (PNG/JPEG), and generates YAML frontmatter with document metadata.

.SH OPTIONS
.TP
\fB\-i\fR \fIinput.pdf\fR
Specify the input PDF file to convert. If not provided, pdf22md reads from standard input (stdin).
.TP
\fB\-o\fR \fIoutput.md\fR
Specify the output Markdown file. If not provided, pdf22md writes to standard output (stdout).
.TP
\fB\-a\fR \fIassets_folder\fR
Specify the folder where extracted images will be saved. The folder will be created if it doesn't exist. Images are automatically referenced in the generated Markdown with relative paths.
.TP
\fB\-d\fR \fIdpi\fR
Set the DPI (dots per inch) for rasterizing vector graphics. Default is 144. Higher values produce better quality but larger file sizes. Common values: 72 (screen), 144 (default), 300 (print quality).
.TP
\fB\-v\fR, \fB\-\-version\fR
Display version information and exit.
.TP
\fB\-h\fR, \fB\-\-help\fR
Display usage information and exit.

.SH EXAMPLES
.TP
Convert a PDF file to Markdown:
.B pdf22md \-i document.pdf \-o document.md

.TP
Extract images to an assets folder:
.B pdf22md \-i document.pdf \-o document.md \-a ./assets

.TP
Use higher DPI for better image quality:
.B pdf22md \-i document.pdf \-o document.md \-a ./assets \-d 300

.TP
Convert using pipes (stdin/stdout):
.B cat document.pdf | pdf22md > document.md

.TP
Process a document with custom settings:
.B pdf22md \-i report.pdf \-o report.md \-a ./images \-d 200

.SH INPUT/OUTPUT
.SS Input Sources
.B pdf22md
accepts PDF input from:
.IP • 2
File path specified with \fB\-i\fR flag
.IP • 2
Standard input (stdin) when no \fB\-i\fR flag is provided

.SS Output Destinations
Markdown output is written to:
.IP • 2
File path specified with \fB\-o\fR flag
.IP • 2
Standard output (stdout) when no \fB\-o\fR flag is provided

.SS Image Assets
When the \fB\-a\fR flag is used:
.IP • 2
Images are extracted and saved to the specified folder
.IP • 2
Filenames follow the pattern: image_001.png, image_002.jpg, etc.
.IP • 2
Format selection is automatic (PNG for graphics, JPEG for photos)
.IP • 2
Markdown contains relative references to the images

.SH FEATURES
.SS Intelligent Content Processing
.IP • 2
\fBHeading Detection\fR: Automatically identifies headings (H1-H6) based on font size analysis
.IP • 2
\fBText Extraction\fR: Preserves text formatting and structure
.IP • 2
\fBImage Processing\fR: Extracts both raster and vector graphics
.IP • 2
\fBSmart Formatting\fR: Maintains document hierarchy and readability

.SS Performance Optimizations
.IP • 2
\fBParallel Processing\fR: Uses all available CPU cores for maximum speed
.IP • 2
\fBMemory Efficiency\fR: Processes large documents without excessive memory usage
.IP • 2
\fBFormat Optimization\fR: Automatic PNG/JPEG selection based on image content

.SS Output Features
.IP • 2
\fBYAML Frontmatter\fR: Includes document metadata (title, author, creation date)
.IP • 2
\fBClean Markdown\fR: Well-structured output compatible with all Markdown processors
.IP • 2
\fBAsset Management\fR: Organized image extraction with proper linking

.SH FILE FORMATS
.SS Supported Input
.IP • 2
PDF files (version 1.4 and higher)
.IP • 2
Unencrypted PDFs (password-protected PDFs are not supported)
.IP • 2
PDFs with text, images, and vector graphics
.IP • 2
Multi-page documents of any size

.SS Generated Output
.IP • 2
\fBMarkdown (.md)\fR: GitHub Flavored Markdown compatible
.IP • 2
\fBImages (.png/.jpg)\fR: Extracted graphics in optimal formats
.IP • 2
\fBYAML Frontmatter\fR: Document metadata in standard format

.SH PERFORMANCE
Typical conversion speeds on modern hardware:
.IP • 2
Simple text documents: <1 second per page
.IP • 2
Complex documents with images: 2-5 seconds per page
.IP • 2
Large documents (100+ pages): Scales linearly with parallel processing

Memory usage is optimized for documents up to 1000 pages. Very large documents may require additional system memory.

.SH ERROR HANDLING
.B pdf22md
provides detailed error messages with suggestions for common issues:

.SS Common Errors and Solutions
.TP
\fBInvalid PDF file\fR
.IP • 2
Verify the file exists and is a valid PDF
.IP • 2
Check if the file is corrupted
.IP • 2
Ensure you have read permissions

.TP
\fBCannot create assets folder\fR
.IP • 2
Check if the parent directory exists
.IP • 2
Verify you have write permissions
.IP • 2
Ensure sufficient disk space

.TP
\fBPassword-protected PDF\fR
.IP • 2
Remove password protection using another tool first
.IP • 2
Use: qpdf \-\-decrypt input.pdf output.pdf

.TP
\fBMemory pressure\fR
.IP • 2
Close other applications to free memory
.IP • 2
Try using a lower DPI setting (\-d 72)
.IP • 2
Process smaller sections of large documents

.SH EXIT STATUS
.TP
.B 0
Successful conversion
.TP
.B 1
Error occurred (invalid input, processing failure, I/O error)

.SH ENVIRONMENT
No special environment variables are required. The tool uses standard macOS frameworks (PDFKit, CoreGraphics) and runs on macOS 10.15 and later.

.SH LIMITATIONS
.IP • 2
Password-protected PDFs are not supported
.IP • 2
Scanned PDFs without OCR text layer will only extract images
.IP • 2
Complex table layouts may not convert perfectly
.IP • 2
Some advanced PDF features (forms, annotations) are not preserved

.SH COMPATIBILITY
.SS Platform Support
.IP • 2
macOS 10.15 (Catalina) and later
.IP • 2
Intel and Apple Silicon processors
.IP • 2
Universal binary for optimal performance

.SS Markdown Compatibility
Output is compatible with:
.IP • 2
GitHub Flavored Markdown
.IP • 2
CommonMark specification
.IP • 2
Popular Markdown processors (pandoc, Jekyll, etc.)
.IP • 2
Static site generators (Hugo, Jekyll, Gatsby)

.SH FILES
.TP
.I ~/.pdf22md/
User configuration directory (future use)
.TP
.I /usr/local/bin/pdf22md
Default installation location
.TP
.I /usr/local/share/man/man1/pdf22md.1
This manual page

.SH EXAMPLES WORKFLOW
.SS Basic Document Conversion
.nf
# Convert a simple document
pdf22md \-i report.pdf \-o report.md

# Result: clean Markdown with YAML frontmatter
# Output includes: title, headings, body text, metadata
.fi

.SS Academic Paper with Images
.nf
# Convert research paper with figure extraction
pdf22md \-i paper.pdf \-o paper.md \-a figures \-d 300

# Result: 
# - paper.md with structured content
# - figures/ folder with high-quality images
# - Proper cross-references to figures
.fi

.SS Batch Processing
.nf
# Process multiple documents
for pdf in *.pdf; do
    pdf22md \-i "$pdf" \-o "${pdf%.pdf}.md" \-a "assets_${pdf%.pdf}"
done
.fi

.SS Integration with Other Tools
.nf
# Combine with pandoc for further processing
pdf22md \-i document.pdf | pandoc \-f markdown \-t html \-o document.html

# Use with static site generators
pdf22md \-i post.pdf \-o content/posts/post.md \-a static/images
.fi

.SH TROUBLESHOOTING
.SS Performance Issues
If conversion is slow:
.IP • 2
Check available memory and CPU usage
.IP • 2
Close unnecessary applications
.IP • 2
Try lower DPI setting for faster processing
.IP • 2
Process documents in smaller batches

.SS Quality Issues
If output quality is poor:
.IP • 2
Increase DPI setting (\-d 300) for better images
.IP • 2
Verify the source PDF has good quality text
.IP • 2
Check if the PDF has a proper text layer (not just scanned images)

.SS Memory Errors
For large documents:
.IP • 2
Ensure sufficient RAM (8GB+ recommended for large PDFs)
.IP • 2
Close other memory-intensive applications
.IP • 2
Split very large PDFs into smaller parts first

.SH REPORTING BUGS
Report bugs and feature requests at:
.UR https://github.com/twardoch/pdf22md/issues
.UE

Include in your report:
.IP • 2
pdf22md version (\fBpdf22md \-v\fR)
.IP • 2
macOS version
.IP • 2
Sample PDF file (if possible)
.IP • 2
Complete error message
.IP • 2
Steps to reproduce the issue

.SH AUTHORS
Written by Adam Twardoch and contributors.

.SH LICENSE
MIT License. See the LICENSE file for details.

.SH SEE ALSO
.BR pandoc (1),
.BR qpdf (1),
.BR pdftotext (1),
.BR markdown (7)

Project homepage: 
.UR https://github.com/twardoch/pdf22md
.UE
</file>

<file path="pdf22md-objc/src/CLI/main.m">
#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>
#import "../Core/PDF22MDConverter.h"
#import "../Core/PDF22MDConversionOptions.h"

#ifndef VERSION
#define VERSION "1.0.0"
#endif

void printUsage(const char *programName) {
    fprintf(stderr, "Usage: %s [-i input.pdf] [-o output.md] [-a assets_folder] [-d dpi] [-v] [-h]\n", programName);
    fprintf(stderr, "  Converts PDF documents to Markdown format\n");
    fprintf(stderr, "  -i <path>: Input PDF file (default: stdin)\n");
    fprintf(stderr, "  -o <path>: Output Markdown file (default: stdout)\n");
    fprintf(stderr, "  -a <path>: Assets folder for extracted images\n");
    fprintf(stderr, "  -d <dpi>: DPI for rasterizing vector graphics (default: 144)\n");
    fprintf(stderr, "  -v: Display version information\n");
    fprintf(stderr, "  -h: Display this help message\n");
}

void printVersion() {
    printf("pdf22md version %s\n", VERSION);
}

int main(int argc, const char *argv[]) {
    @autoreleasepool {
        NSString *inputPath = nil;
        NSString *outputPath = nil;
        NSString *assetsPath = nil;
        CGFloat dpi = 144.0;
        
        // Parse command line arguments
        int opt;
        while ((opt = getopt(argc, (char * const *)argv, "i:o:a:d:hvV")) != -1) {
            switch (opt) {
                case 'i':
                    inputPath = [NSString stringWithUTF8String:optarg];
                    break;
                case 'o':
                    outputPath = [NSString stringWithUTF8String:optarg];
                    break;
                case 'a':
                    assetsPath = [NSString stringWithUTF8String:optarg];
                    break;
                case 'd':
                    dpi = atof(optarg);
                    if (dpi <= 0) {
                        fprintf(stderr, "Invalid DPI value: %s\n", optarg);
                        return 1;
                    }
                    break;
                case 'h':
                    printUsage(argv[0]);
                    return 0;
                case 'v':
                case 'V':
                    printVersion();
                    return 0;
                default:
                    printUsage(argv[0]);
                    return 1;
            }
        }
        
        // Initialize converter
        PDF22MDConverter *converter = nil;
        
        if (inputPath) {
            // Read from file
            NSURL *pdfURL = [NSURL fileURLWithPath:inputPath];
            converter = [[PDF22MDConverter alloc] initWithPDFURL:pdfURL];
            if (!converter) {
                fprintf(stderr, "Failed to load PDF from: %s\n", [inputPath UTF8String]);
                return 1;
            }
        } else {
            // Read from stdin
            NSFileHandle *stdinHandle = [NSFileHandle fileHandleWithStandardInput];
            NSData *pdfData = [stdinHandle readDataToEndOfFile];
            
            if (!pdfData || [pdfData length] == 0) {
                fprintf(stderr, "No PDF data received from stdin\n");
                return 1;
            }
            
            converter = [[PDF22MDConverter alloc] initWithPDFData:pdfData];
            if (!converter) {
                fprintf(stderr, "Failed to create PDF document from stdin data\n");
                return 1;
            }
        }
        
        // Create conversion options
        PDF22MDConversionOptionsBuilder *builder = [[PDF22MDConversionOptionsBuilder alloc] init];
        builder.assetsFolderPath = assetsPath;
        builder.rasterizationDPI = dpi;
        builder.extractImages = (assetsPath != nil);
        
        // Add progress handler for interactive terminals
        if (isatty(STDERR_FILENO)) {
            builder.progressHandler = ^(NSInteger currentPage, NSInteger totalPages) {
                fprintf(stderr, "\rProcessing page %ld of %ld...", (long)currentPage, (long)totalPages);
                fflush(stderr);
            };
        }
        
        PDF22MDConversionOptions *options = [builder build];
        
        // Perform conversion
        __block NSString *markdown = nil;
        __block NSError *conversionError = nil;
        
        dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
        
        [converter convertWithOptions:options
                           completion:^(NSString *result, NSError *error) {
            markdown = result;
            conversionError = error;
            dispatch_semaphore_signal(semaphore);
        }];
        
        // Wait for completion
        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
        
        if (isatty(STDERR_FILENO) && options.progressHandler) {
            fprintf(stderr, "\n"); // Clear progress line
        }
        
        if (conversionError) {
            fprintf(stderr, "Conversion failed: %s\n", 
                    [[conversionError localizedDescription] UTF8String]);
            return 1;
        }
        
        // Write output
        if (outputPath) {
            // Write to file
            NSError *writeError = nil;
            BOOL success = [markdown writeToFile:outputPath
                                      atomically:YES
                                        encoding:NSUTF8StringEncoding
                                           error:&writeError];
            if (!success) {
                fprintf(stderr, "Failed to write output file: %s\n",
                        [[writeError localizedDescription] UTF8String]);
                return 1;
            }
        } else {
            // Write to stdout
            NSFileHandle *stdoutHandle = [NSFileHandle fileHandleWithStandardOutput];
            NSData *markdownData = [markdown dataUsingEncoding:NSUTF8StringEncoding];
            [stdoutHandle writeData:markdownData];
            
            // Add newline if not present
            if (![markdown hasSuffix:@"\n"]) {
                [stdoutHandle writeData:[@"\n" dataUsingEncoding:NSUTF8StringEncoding]];
            }
        }
        
        return 0;
    }
}
</file>

<file path="pdf22md-objc/src/Core/PDF22MDConversionOptions.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

/**
 * Configuration options for PDF to Markdown conversion.
 * This class uses the builder pattern for convenient configuration.
 */
@interface PDF22MDConversionOptions : NSObject <NSCopying>

/**
 * Path to the folder where extracted assets (images) should be saved.
 * If nil, images will not be extracted.
 */
@property (nonatomic, copy, nullable) NSString *assetsFolderPath;

/**
 * DPI for rasterizing vector graphics.
 * Default is 144.0
 */
@property (nonatomic, assign) CGFloat rasterizationDPI;

/**
 * Maximum number of concurrent page processing operations.
 * Default is NSProcessInfo.processInfo.processorCount
 */
@property (nonatomic, assign) NSInteger maxConcurrentPages;

/**
 * Whether to include YAML frontmatter with metadata.
 * Default is YES
 */
@property (nonatomic, assign) BOOL includeMetadata;

/**
 * Whether to extract images from the PDF.
 * Default is YES (if assetsFolderPath is set)
 */
@property (nonatomic, assign) BOOL extractImages;

/**
 * Whether to preserve the PDF outline/bookmarks structure.
 * Default is YES
 */
@property (nonatomic, assign) BOOL preserveOutline;

/**
 * Minimum font size difference to consider for heading detection.
 * Default is 2.0 points
 */
@property (nonatomic, assign) CGFloat headingFontSizeThreshold;

/**
 * Maximum heading level to detect (1-6).
 * Default is 6
 */
@property (nonatomic, assign) NSInteger maxHeadingLevel;

/**
 * Progress handler called during conversion.
 * The handler receives the current page index and total page count.
 */
@property (nonatomic, copy, nullable) void (^progressHandler)(NSInteger currentPage, NSInteger totalPages);

/**
 * Creates default conversion options.
 */
+ (instancetype)defaultOptions;

/**
 * Validates the current options configuration.
 * @param error Set if validation fails
 * @return YES if valid, NO otherwise
 */
- (BOOL)validateWithError:(NSError * _Nullable * _Nullable)error;

@end

/**
 * Builder class for creating PDF22MDConversionOptions instances.
 */
@interface PDF22MDConversionOptionsBuilder : NSObject

@property (nonatomic, copy, nullable) NSString *assetsFolderPath;
@property (nonatomic, assign) CGFloat rasterizationDPI;
@property (nonatomic, assign) NSInteger maxConcurrentPages;
@property (nonatomic, assign) BOOL includeMetadata;
@property (nonatomic, assign) BOOL extractImages;
@property (nonatomic, assign) BOOL preserveOutline;
@property (nonatomic, assign) CGFloat headingFontSizeThreshold;
@property (nonatomic, assign) NSInteger maxHeadingLevel;
@property (nonatomic, copy, nullable) void (^progressHandler)(NSInteger currentPage, NSInteger totalPages);

- (PDF22MDConversionOptions *)build;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/Core/PDF22MDConverter.h">
#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>

NS_ASSUME_NONNULL_BEGIN

@class PDF22MDConversionOptions;

/**
 * Main converter class that coordinates the PDF to Markdown conversion process.
 * This class manages the entire conversion pipeline including parallel processing,
 * content extraction, and markdown generation.
 */
@interface PDF22MDConverter : NSObject

/**
 * The PDF document being converted.
 */
@property (nonatomic, strong, readonly) PDFDocument *document;

/**
 * Progress object for tracking conversion progress.
 */
@property (nonatomic, strong, readonly) NSProgress *progress;

/**
 * Initializes a converter with PDF data.
 *
 * @param pdfData The PDF data to convert
 * @return A new converter instance, or nil if the PDF is invalid
 */
- (nullable instancetype)initWithPDFData:(NSData *)pdfData;

/**
 * Initializes a converter with a PDF file URL.
 *
 * @param pdfURL The URL of the PDF file to convert
 * @return A new converter instance, or nil if the PDF is invalid
 */
- (nullable instancetype)initWithPDFURL:(NSURL *)pdfURL;

/**
 * Designated initializer that creates a converter with both URL and document.
 * This is the real designated initializer that other initializers should call.
 *
 * @param pdfURL The URL of the PDF file (may be nil for data-based PDFs)
 * @param document The PDF document instance
 * @return A new converter instance, or nil if invalid
 */
- (nullable instancetype)initWithPDFURL:(nullable NSURL *)pdfURL document:(PDFDocument *)document NS_DESIGNATED_INITIALIZER;

- (instancetype)init NS_UNAVAILABLE;

/**
 * Converts the PDF to Markdown with the given options.
 * This method performs the conversion asynchronously on a background queue.
 *
 * @param options Conversion options (uses defaults if nil)
 * @param completion Completion handler called with the result or error
 */
- (void)convertWithOptions:(nullable PDF22MDConversionOptions *)options
                completion:(void (^)(NSString * _Nullable markdown, NSError * _Nullable error))completion;

/**
 * Cancels an ongoing conversion.
 * The completion handler will be called with a cancellation error.
 */
- (void)cancelConversion;

/**
 * Validates that the PDF can be converted.
 *
 * @param error Set if validation fails
 * @return YES if the PDF is valid for conversion, NO otherwise
 */
- (BOOL)validateDocumentWithError:(NSError * _Nullable * _Nullable)error;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/Core/PDF22MDFontAnalyzer.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

@protocol PDF22MDContentElement;
@class PDF22MDTextElement;

/**
 * Font statistics for a particular font and size combination.
 */
@interface PDF22MDFontStatistics : NSObject
@property (nonatomic, copy, readonly) NSString *fontKey;
@property (nonatomic, copy, readonly) NSString *fontName;
@property (nonatomic, assign, readonly) CGFloat fontSize;
@property (nonatomic, assign, readonly) NSUInteger occurrenceCount;
@property (nonatomic, assign) NSInteger assignedHeadingLevel; // 0 for body text, 1-6 for headings

- (instancetype)initWithFontKey:(NSString *)fontKey
                       fontName:(NSString *)fontName
                       fontSize:(CGFloat)fontSize;

- (void)incrementOccurrenceCount;
- (void)addOccurrenceCount:(NSUInteger)count;

@end

/**
 * Analyzes font usage in PDF documents to detect heading hierarchy.
 */
@interface PDF22MDFontAnalyzer : NSObject

/**
 * The font size threshold for detecting headings.
 * Text with font size differences greater than this value may be considered headings.
 */
@property (nonatomic, assign) CGFloat fontSizeThreshold;

/**
 * Maximum heading level to assign (1-6).
 */
@property (nonatomic, assign) NSInteger maxHeadingLevel;

/**
 * Dictionary of font statistics keyed by font identifier.
 */
@property (nonatomic, strong, readonly) NSDictionary<NSString *, PDF22MDFontStatistics *> *fontStatistics;

/**
 * Initializes the analyzer with default settings.
 */
- (instancetype)init;

/**
 * Analyzes an array of content elements to build font statistics.
 * This should be called before assignHeadingLevels.
 *
 * @param elements Array of content elements to analyze
 */
- (void)analyzeElements:(NSArray<id<PDF22MDContentElement>> *)elements;

/**
 * Assigns heading levels to text elements based on font analysis.
 * Call this after analyzeElements.
 *
 * @param elements Array of content elements to process
 */
- (void)assignHeadingLevels:(NSArray<id<PDF22MDContentElement>> *)elements;

/**
 * Merges font statistics from another analyzer.
 * Useful for combining statistics from multiple pages.
 *
 * @param otherAnalyzer The analyzer to merge from
 */
- (void)mergeFontStatisticsFromAnalyzer:(PDF22MDFontAnalyzer *)otherAnalyzer;

/**
 * Resets all collected statistics.
 */
- (void)reset;

/**
 * Gets a sorted array of font statistics by size (largest first).
 */
- (NSArray<PDF22MDFontStatistics *> *)sortedFontStatistics;

/**
 * Creates a font key identifier from font properties.
 */
+ (NSString *)fontKeyForFontName:(nullable NSString *)fontName fontSize:(CGFloat)fontSize;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/Core/PDF22MDFontAnalyzer.m">
#import "PDF22MDFontAnalyzer.h"
#import "../Models/PDF22MDContentElement.h"
#import "../Models/PDF22MDTextElement.h"

@implementation PDF22MDFontStatistics

- (instancetype)initWithFontKey:(NSString *)fontKey
                       fontName:(NSString *)fontName
                       fontSize:(CGFloat)fontSize {
    self = [super init];
    if (self) {
        _fontKey = [fontKey copy];
        _fontName = [fontName copy];
        _fontSize = fontSize;
        _occurrenceCount = 0;
        _assignedHeadingLevel = 0;
    }
    return self;
}

- (void)incrementOccurrenceCount {
    _occurrenceCount++;
}

- (void)addOccurrenceCount:(NSUInteger)count {
    _occurrenceCount += count;
}

- (NSString *)description {
    return [NSString stringWithFormat:@"<FontStats: %@ size=%.1f count=%lu level=%ld>",
            self.fontName, self.fontSize, (unsigned long)self.occurrenceCount, (long)self.assignedHeadingLevel];
}

@end

@interface PDF22MDFontAnalyzer ()
@property (nonatomic, strong) NSMutableDictionary<NSString *, PDF22MDFontStatistics *> *mutableFontStatistics;
@end

@implementation PDF22MDFontAnalyzer

#pragma mark - Initialization

- (instancetype)init {
    self = [super init];
    if (self) {
        _fontSizeThreshold = 2.0;
        _maxHeadingLevel = 6;
        _mutableFontStatistics = [NSMutableDictionary dictionary];
    }
    return self;
}

#pragma mark - Public Methods

- (void)analyzeElements:(NSArray<id<PDF22MDContentElement>> *)elements {
    for (id<PDF22MDContentElement> element in elements) {
        if ([element isKindOfClass:[PDF22MDTextElement class]]) {
            PDF22MDTextElement *textElement = (PDF22MDTextElement *)element;
            [self addTextElementToStatistics:textElement];
        }
    }
}

- (void)assignHeadingLevels:(NSArray<id<PDF22MDContentElement>> *)elements {
    // Get sorted font statistics
    NSArray<PDF22MDFontStatistics *> *sortedStats = [self sortedFontStatistics];
    
    if (sortedStats.count == 0) {
        return;
    }
    
    // Find the most common font size (likely body text)
    PDF22MDFontStatistics *mostCommonFont = nil;
    NSUInteger highestCount = 0;
    
    for (PDF22MDFontStatistics *stats in sortedStats) {
        if (stats.occurrenceCount > highestCount) {
            highestCount = stats.occurrenceCount;
            mostCommonFont = stats;
        }
    }
    
    CGFloat bodyFontSize = mostCommonFont ? mostCommonFont.fontSize : 12.0;
    
    // Assign heading levels based on size hierarchy
    NSInteger currentHeadingLevel = 1;
    CGFloat lastHeadingSize = CGFLOAT_MAX;
    
    for (PDF22MDFontStatistics *stats in sortedStats) {
        // Skip if this is likely body text
        if (stats == mostCommonFont) {
            stats.assignedHeadingLevel = 0;
            continue;
        }
        
        // Check if this font is significantly larger than body text
        CGFloat sizeDifference = stats.fontSize - bodyFontSize;
        
        if (sizeDifference >= self.fontSizeThreshold) {
            // This is a potential heading
            // Check if it's significantly different from the last heading size
            if (lastHeadingSize - stats.fontSize >= self.fontSizeThreshold) {
                currentHeadingLevel++;
            }
            
            if (currentHeadingLevel <= self.maxHeadingLevel) {
                stats.assignedHeadingLevel = currentHeadingLevel;
                lastHeadingSize = stats.fontSize;
            } else {
                // Too many heading levels, treat as body text
                stats.assignedHeadingLevel = 0;
            }
        } else {
            // Not large enough to be a heading
            stats.assignedHeadingLevel = 0;
        }
        
        // Additional heuristic: if occurrence count is very high, it's probably not a heading
        if (stats.occurrenceCount > highestCount * 0.5) {
            stats.assignedHeadingLevel = 0;
        }
    }
    
    // Apply heading levels to text elements
    for (id<PDF22MDContentElement> element in elements) {
        if ([element isKindOfClass:[PDF22MDTextElement class]]) {
            PDF22MDTextElement *textElement = (PDF22MDTextElement *)element;
            NSString *fontKey = [[self class] fontKeyForFontName:textElement.fontName 
                                                        fontSize:textElement.fontSize];
            PDF22MDFontStatistics *stats = self.mutableFontStatistics[fontKey];
            if (stats) {
                textElement.headingLevel = stats.assignedHeadingLevel;
            }
        }
    }
}

- (void)mergeFontStatisticsFromAnalyzer:(PDF22MDFontAnalyzer *)otherAnalyzer {
    [otherAnalyzer.fontStatistics enumerateKeysAndObjectsUsingBlock:^(NSString *key, PDF22MDFontStatistics *otherStats, BOOL * __unused stop) {
        PDF22MDFontStatistics *existingStats = self.mutableFontStatistics[key];
        
        if (existingStats) {
            // Merge occurrence counts
            [existingStats addOccurrenceCount:otherStats.occurrenceCount];
        } else {
            // Add new statistics
            PDF22MDFontStatistics *newStats = [[PDF22MDFontStatistics alloc] initWithFontKey:otherStats.fontKey
                                                                                    fontName:otherStats.fontName
                                                                                    fontSize:otherStats.fontSize];
            [newStats addOccurrenceCount:otherStats.occurrenceCount];
            self.mutableFontStatistics[key] = newStats;
        }
    }];
}

- (void)reset {
    [self.mutableFontStatistics removeAllObjects];
}

- (NSArray<PDF22MDFontStatistics *> *)sortedFontStatistics {
    NSArray<PDF22MDFontStatistics *> *allStats = [self.mutableFontStatistics allValues];
    
    // Sort by font size in descending order
    return [allStats sortedArrayUsingComparator:^NSComparisonResult(PDF22MDFontStatistics *obj1, PDF22MDFontStatistics *obj2) {
        if (obj1.fontSize > obj2.fontSize) {
            return NSOrderedAscending;
        } else if (obj1.fontSize < obj2.fontSize) {
            return NSOrderedDescending;
        } else {
            // Same size, sort by occurrence count
            if (obj1.occurrenceCount > obj2.occurrenceCount) {
                return NSOrderedAscending;
            } else if (obj1.occurrenceCount < obj2.occurrenceCount) {
                return NSOrderedDescending;
            }
            return NSOrderedSame;
        }
    }];
}

+ (NSString *)fontKeyForFontName:(nullable NSString *)fontName fontSize:(CGFloat)fontSize {
    NSString *name = fontName ?: @"Unknown";
    return [NSString stringWithFormat:@"%.1f-%@", fontSize, name];
}

#pragma mark - Properties

- (NSDictionary<NSString *, PDF22MDFontStatistics *> *)fontStatistics {
    return [self.mutableFontStatistics copy];
}

#pragma mark - Private Methods

- (void)addTextElementToStatistics:(PDF22MDTextElement *)textElement {
    // Skip empty text
    NSString *trimmedText = [textElement.text stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    if (trimmedText.length == 0) {
        return;
    }
    
    NSString *fontKey = [[self class] fontKeyForFontName:textElement.fontName fontSize:textElement.fontSize];
    
    PDF22MDFontStatistics *stats = self.mutableFontStatistics[fontKey];
    if (!stats) {
        stats = [[PDF22MDFontStatistics alloc] initWithFontKey:fontKey
                                                      fontName:textElement.fontName ?: @"Unknown"
                                                      fontSize:textElement.fontSize];
        self.mutableFontStatistics[fontKey] = stats;
    }
    
    [stats incrementOccurrenceCount];
}

@end
</file>

<file path="pdf22md-objc/src/Core/PDF22MDPageProcessor.h">
#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

@protocol PDF22MDContentElement;
@class PDF22MDFontAnalyzer;

/**
 * Processes individual PDF pages to extract content elements.
 * Uses PDFKit's high-level API for safe and reliable content extraction.
 */
@interface PDF22MDPageProcessor : NSObject

/**
 * The PDF page being processed.
 */
@property (nonatomic, strong, readonly) PDFPage *pdfPage;

/**
 * The zero-based index of the page.
 */
@property (nonatomic, assign, readonly) NSInteger pageIndex;

/**
 * DPI for rasterizing vector graphics.
 */
@property (nonatomic, assign, readonly) CGFloat dpi;

/**
 * Font analyzer for this page (optional).
 */
@property (nonatomic, strong, nullable) PDF22MDFontAnalyzer *fontAnalyzer;

/**
 * Initializes a page processor for the given PDF page.
 *
 * @param pdfPage The PDF page to process
 * @param pageIndex The zero-based page index
 * @param dpi DPI for rasterization (default: 144)
 * @return A new page processor instance
 */
- (instancetype)initWithPDFPage:(PDFPage *)pdfPage
                      pageIndex:(NSInteger)pageIndex
                            dpi:(CGFloat)dpi NS_DESIGNATED_INITIALIZER;

- (instancetype)init NS_UNAVAILABLE;

/**
 * Extracts all content elements from the page.
 * This includes text and images.
 *
 * @return Array of content elements in reading order
 */
- (NSArray<id<PDF22MDContentElement>> *)extractContentElements;

/**
 * Extracts only text elements from the page.
 *
 * @return Array of text elements
 */
- (NSArray<id<PDF22MDContentElement>> *)extractTextElements;

/**
 * Extracts only image elements from the page.
 *
 * @return Array of image elements
 */
- (NSArray<id<PDF22MDContentElement>> *)extractImageElements;

/**
 * Captures vector graphics in the specified bounds as a rasterized image.
 *
 * @param bounds The area to capture
 * @param elements Array to add the captured image element to
 */
- (void)captureVectorGraphicsInBounds:(CGRect)bounds
                         withElements:(NSMutableArray<id<PDF22MDContentElement>> *)elements;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/Core/PDF22MDPageProcessor.m">
#import "PDF22MDPageProcessor.h"
#import "../Models/PDF22MDTextElement.h"
#import "../Models/PDF22MDImageElement.h"
#import "PDF22MDFontAnalyzer.h"
#import <CoreGraphics/CoreGraphics.h>

#if TARGET_OS_MAC && !TARGET_OS_IPHONE
#import <AppKit/AppKit.h>
#else
#import <UIKit/UIKit.h>
#endif

@interface PDF22MDPageProcessor ()
@property (nonatomic, assign) CGPDFPageRef cgPdfPage;
@end

@implementation PDF22MDPageProcessor

#pragma mark - Initialization

- (instancetype)initWithPDFPage:(PDFPage *)pdfPage
                      pageIndex:(NSInteger)pageIndex
                            dpi:(CGFloat)dpi {
    self = [super init];
    if (self) {
        _pdfPage = pdfPage;
        _pageIndex = pageIndex;
        _dpi = dpi;
        _cgPdfPage = [pdfPage pageRef];
    }
    return self;
}

#pragma mark - Public Methods

- (NSArray<id<PDF22MDContentElement>> *)extractContentElements {
    NSMutableArray<id<PDF22MDContentElement>> *elements = [NSMutableArray array];
    
    // Extract text elements
    NSArray *textElements = [self extractTextElements];
    [elements addObjectsFromArray:textElements];
    
    // Extract image elements
    NSArray *imageElements = [self extractImageElements];
    [elements addObjectsFromArray:imageElements];
    
    // Sort elements by position
    [self sortElementsByPosition:elements];
    
    return elements;
}

- (NSArray<id<PDF22MDContentElement>> *)extractTextElements {
    NSMutableArray<id<PDF22MDContentElement>> *elements = [NSMutableArray array];
    
    // Extract text using PDFKit's high-level API
    NSString *pageText = [self.pdfPage string];
    if (!pageText || pageText.length == 0) {
        return elements;
    }
    
    // Get page bounds for positioning
    CGRect pageRect = [self.pdfPage boundsForBox:kPDFDisplayBoxMediaBox];
    CGFloat pageHeight = CGRectGetHeight(pageRect);
    
    // Split into paragraphs while preserving structure
    NSArray<NSString *> *paragraphs = [self extractParagraphsFromPageText:pageText];
    
    // Create text elements with approximate positioning
    CGFloat cursorY = pageHeight - 20; // Start near top with margin
    CGFloat lineHeight = 14.0; // Default line height
    CGFloat paragraphSpacing = lineHeight * 0.5;
    
    for (NSString *paragraph in paragraphs) {
        NSString *trimmed = [paragraph stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
        if (trimmed.length == 0) {
            cursorY -= paragraphSpacing;
            continue;
        }
        
        // Try to extract font information from PDF selections
        PDFSelection *selection = [self.pdfPage selectionForRange:NSMakeRange(0, trimmed.length)];
        NSDictionary *fontInfo = [self extractFontInfoFromSelection:selection];
        
        PDF22MDTextElement *element = [[PDF22MDTextElement alloc] initWithText:trimmed
                                                                        bounds:CGRectMake(20, cursorY - lineHeight, pageRect.size.width - 40, lineHeight)
                                                                     pageIndex:self.pageIndex
                                                                      fontName:fontInfo[@"fontName"]
                                                                      fontSize:[fontInfo[@"fontSize"] doubleValue]
                                                                        isBold:[fontInfo[@"isBold"] boolValue]
                                                                      isItalic:[fontInfo[@"isItalic"] boolValue]];
        
        [elements addObject:element];
        
        // Update cursor position
        NSInteger lineCount = [self estimateLineCountForText:trimmed inWidth:pageRect.size.width - 40];
        cursorY -= (lineHeight * lineCount + paragraphSpacing);
    }
    
    return elements;
}

- (NSArray<id<PDF22MDContentElement>> *)extractImageElements {
    NSMutableArray<id<PDF22MDContentElement>> *elements = [NSMutableArray array];
    
    // Method 1: Extract images from annotations
    NSArray<PDFAnnotation *> *annotations = [self.pdfPage annotations];
    
    for (PDFAnnotation *annotation in annotations) {
        // Check if annotation might contain an image
        if ([self annotationMayContainImage:annotation]) {
            CGImageRef image = [self imageFromAnnotation:annotation];
            if (image) {
                PDF22MDImageElement *element = [[PDF22MDImageElement alloc] initWithImage:image
                                                                                   bounds:[annotation bounds]
                                                                                pageIndex:self.pageIndex
                                                                           isVectorSource:NO];
                [elements addObject:element];
                CGImageRelease(image);
            }
        }
    }
    
    // Method 2: Detect image regions by analyzing page content
    NSArray *imageRegions = [self detectImageRegionsInPage];
    for (NSData *regionData in imageRegions) {
        CGRect region;
        [regionData getBytes:&region length:sizeof(CGRect)];
        [self captureVectorGraphicsInBounds:region withElements:elements];
    }
    
    return elements;
}

- (void)captureVectorGraphicsInBounds:(CGRect)bounds
                         withElements:(NSMutableArray<id<PDF22MDContentElement>> *)elements {
    // Expand bounds slightly to ensure we capture everything
    bounds = CGRectInset(bounds, -5, -5);
    
    // Calculate size at specified DPI
    CGFloat scale = self.dpi / 72.0;
    size_t width = (size_t)(CGRectGetWidth(bounds) * scale);
    size_t height = (size_t)(CGRectGetHeight(bounds) * scale);
    
    if (width == 0 || height == 0 || width > 4096 || height > 4096) {
        return;
    }
    
    // Create bitmap context
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, colorSpace,
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        return;
    }
    
    // Set white background
    CGContextSetRGBFillColor(context, 1.0, 1.0, 1.0, 1.0);
    CGContextFillRect(context, CGRectMake(0, 0, width, height));
    
    // Set up transformation to render just the bounds area
    CGContextSaveGState(context);
    CGContextScaleCTM(context, scale, scale);
    CGContextTranslateCTM(context, -bounds.origin.x, -bounds.origin.y);
    
    // Draw the PDF page
    CGContextDrawPDFPage(context, self.cgPdfPage);
    
    CGContextRestoreGState(context);
    
    // Create image
    CGImageRef image = CGBitmapContextCreateImage(context);
    CGContextRelease(context);
    
    if (image) {
        PDF22MDImageElement *element = [[PDF22MDImageElement alloc] initWithImage:image
                                                                           bounds:bounds
                                                                        pageIndex:self.pageIndex
                                                                   isVectorSource:YES];
        [elements addObject:element];
        CGImageRelease(image);
    }
}

#pragma mark - Private Methods

- (NSArray<NSString *> *)extractParagraphsFromPageText:(NSString *)pageText {
    // Split by multiple newlines to get paragraphs
    NSArray *components = [pageText componentsSeparatedByString:@"\n\n"];
    NSMutableArray *paragraphs = [NSMutableArray array];
    
    for (NSString *component in components) {
        // Further split by single newlines but join short lines
        NSArray *lines = [component componentsSeparatedByString:@"\n"];
        NSMutableString *paragraph = [NSMutableString string];
        
        for (NSString *line in lines) {
            NSString *trimmedLine = [line stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
            if (trimmedLine.length > 0) {
                if (paragraph.length > 0) {
                    // Add space between lines
                    [paragraph appendString:@" "];
                }
                [paragraph appendString:trimmedLine];
            }
        }
        
        if (paragraph.length > 0) {
            [paragraphs addObject:[paragraph copy]];
        }
    }
    
    return paragraphs;
}

- (NSDictionary *)extractFontInfoFromSelection:(PDFSelection *)selection {
    // Default font info
    NSMutableDictionary *fontInfo = [@{
        @"fontName": @"Helvetica",
        @"fontSize": @(12.0),
        @"isBold": @(NO),
        @"isItalic": @(NO)
    } mutableCopy];
    
    // PDFKit doesn't provide direct access to font information
    // This would require lower-level Core Graphics analysis
    // For now, we'll use heuristics based on the text content
    
    NSString *text = [selection string];
    if (text) {
        // Simple heuristic: all caps might indicate a heading
        if ([text isEqualToString:[text uppercaseString]] && text.length > 3) {
            fontInfo[@"fontSize"] = @(14.0);
            fontInfo[@"isBold"] = @(YES);
        }
    }
    
    return fontInfo;
}

- (BOOL)annotationMayContainImage:(PDFAnnotation *)annotation {
    // Check annotation type and bounds
    CGRect bounds = [annotation bounds];
    
    // Images typically have reasonable dimensions
    if (CGRectIsEmpty(bounds) || bounds.size.width < 10 || bounds.size.height < 10) {
        return NO;
    }
    
    // Check if it's not a text annotation
    NSString *contents = [annotation contents];
    if (contents && contents.length > 0) {
        return NO;
    }
    
    return YES;
}

- (CGImageRef)imageFromAnnotation:(PDFAnnotation *)annotation {
    CGRect bounds = [annotation bounds];
    
    // Create a bitmap context to render the annotation
    CGFloat scale = self.dpi / 72.0;
    size_t width = (size_t)(bounds.size.width * scale);
    size_t height = (size_t)(bounds.size.height * scale);
    
    if (width == 0 || height == 0 || width > 4096 || height > 4096) {
        return NULL;
    }
    
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, colorSpace,
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        return NULL;
    }
    
    // Set white background
    CGContextSetRGBFillColor(context, 1.0, 1.0, 1.0, 1.0);
    CGContextFillRect(context, CGRectMake(0, 0, width, height));
    
    // Transform context to match annotation bounds
    CGContextSaveGState(context);
    CGContextScaleCTM(context, scale, scale);
    
    // Draw just the annotation area from the page
    CGContextClipToRect(context, CGRectMake(0, 0, bounds.size.width, bounds.size.height));
    CGContextTranslateCTM(context, -bounds.origin.x, -bounds.origin.y);
    CGContextDrawPDFPage(context, self.cgPdfPage);
    
    CGContextRestoreGState(context);
    
    // Create image
    CGImageRef image = CGBitmapContextCreateImage(context);
    CGContextRelease(context);
    
    return image;
}

- (NSArray *)detectImageRegionsInPage {
    NSMutableArray *regions = [NSMutableArray array];
    
    // Simple heuristic: divide page into grid and check for non-text regions
    CGRect pageRect = [self.pdfPage boundsForBox:kPDFDisplayBoxMediaBox];
    CGFloat gridSize = 100.0;
    
    NSInteger gridX = (NSInteger)ceil(pageRect.size.width / gridSize);
    NSInteger gridY = (NSInteger)ceil(pageRect.size.height / gridSize);
    
    for (NSInteger x = 0; x < gridX; x++) {
        for (NSInteger y = 0; y < gridY; y++) {
            CGRect gridRect = CGRectMake(x * gridSize, y * gridSize, gridSize, gridSize);
            gridRect = CGRectIntersection(gridRect, pageRect);
            
            if (CGRectIsEmpty(gridRect) || gridRect.size.width < 20 || gridRect.size.height < 20) {
                continue;
            }
            
            // Check if this region contains primarily non-text content
            PDFSelection *selection = [self.pdfPage selectionForRect:gridRect];
            NSString *regionText = [[selection string] stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
            
            // If very little text, might be an image region
            if (regionText.length < 10) {
                NSData *rectData = [NSData dataWithBytes:&gridRect length:sizeof(CGRect)];
                [regions addObject:rectData];
            }
        }
    }
    
    // Merge adjacent regions
    return [self mergeAdjacentRegions:regions];
}

- (NSArray *)mergeAdjacentRegions:(NSArray *)regions {
    if (regions.count <= 1) {
        return regions;
    }
    
    NSMutableArray *mergedRegions = [NSMutableArray array];
    NSMutableSet *processedIndices = [NSMutableSet set];
    
    for (NSUInteger i = 0; i < regions.count; i++) {
        if ([processedIndices containsObject:@(i)]) {
            continue;
        }
        
        CGRect currentRect;
        [regions[i] getBytes:&currentRect length:sizeof(CGRect)];
        [processedIndices addObject:@(i)];
        
        // Try to merge with adjacent regions
        BOOL merged = YES;
        while (merged) {
            merged = NO;
            
            for (NSUInteger j = 0; j < regions.count; j++) {
                if ([processedIndices containsObject:@(j)]) {
                    continue;
                }
                
                CGRect otherRect;
                [regions[j] getBytes:&otherRect length:sizeof(CGRect)];
                
                // Check if rectangles are adjacent
                if (CGRectIntersectsRect(CGRectInset(currentRect, -10, -10), otherRect)) {
                    currentRect = CGRectUnion(currentRect, otherRect);
                    [processedIndices addObject:@(j)];
                    merged = YES;
                }
            }
        }
        
        NSData *rectData = [NSData dataWithBytes:&currentRect length:sizeof(CGRect)];
        [mergedRegions addObject:rectData];
    }
    
    return mergedRegions;
}

- (NSInteger)estimateLineCountForText:(NSString *)text inWidth:(CGFloat)width {
    // Simple estimation based on average character width
    CGFloat avgCharWidth = 7.0; // Approximate for 12pt font
    NSInteger charsPerLine = (NSInteger)(width / avgCharWidth);
    
    if (charsPerLine <= 0) {
        return 1;
    }
    
    return MAX(1, (text.length + charsPerLine - 1) / charsPerLine);
}

- (void)sortElementsByPosition:(NSMutableArray<id<PDF22MDContentElement>> *)elements {
    [elements sortUsingComparator:^NSComparisonResult(id<PDF22MDContentElement> obj1, id<PDF22MDContentElement> obj2) {
        // Sort by vertical position (top to bottom)
        CGFloat y1 = CGRectGetMaxY(obj1.bounds);
        CGFloat y2 = CGRectGetMaxY(obj2.bounds);
        
        if (fabs(y1 - y2) > 5.0) { // Tolerance for same line
            return y1 > y2 ? NSOrderedAscending : NSOrderedDescending;
        }
        
        // Same line, sort by horizontal position (left to right)
        CGFloat x1 = CGRectGetMinX(obj1.bounds);
        CGFloat x2 = CGRectGetMinX(obj2.bounds);
        
        return x1 < x2 ? NSOrderedAscending : NSOrderedDescending;
    }];
}

@end
</file>

<file path="pdf22md-objc/src/Models/PDF22MDContentElement.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

/**
 * Protocol defining the interface for all content elements extracted from a PDF.
 * This includes text elements, image elements, and potentially other content types.
 */
@protocol PDF22MDContentElement <NSObject>

@required
/**
 * The bounding rectangle of this element in PDF coordinate space.
 */
@property (nonatomic, readonly) CGRect bounds;

/**
 * The zero-based index of the page this element was extracted from.
 */
@property (nonatomic, readonly) NSInteger pageIndex;

/**
 * Generates the Markdown representation of this element.
 * @return A string containing the Markdown formatted content, or nil if the element has no valid representation.
 */
- (nullable NSString *)markdownRepresentation;

@optional
/**
 * Additional metadata associated with this element.
 * The dictionary keys and values are element-type specific.
 */
- (NSDictionary<NSString *, id> *)metadata;

/**
 * The original extraction context for debugging purposes.
 */
- (NSString *)debugDescription;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/Models/PDF22MDImageElement.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>
#import "PDF22MDContentElement.h"

NS_ASSUME_NONNULL_BEGIN

/**
 * Represents an image element extracted from a PDF page.
 * Handles both raster and vector graphics.
 */
@interface PDF22MDImageElement : NSObject <PDF22MDContentElement>

/**
 * The extracted image. Ownership is transferred to this object.
 */
@property (nonatomic, readonly) CGImageRef image;

/**
 * The bounding rectangle of this image in the PDF.
 */
@property (nonatomic, assign, readonly) CGRect bounds;

/**
 * The page index where this image was found.
 */
@property (nonatomic, assign, readonly) NSInteger pageIndex;

/**
 * Indicates whether this image was originally vector graphics.
 */
@property (nonatomic, assign, readonly) BOOL isVectorSource;

/**
 * The relative path to the saved asset file, if any.
 * This is set after the image has been extracted and saved.
 */
@property (nonatomic, copy, nullable) NSString *assetRelativePath;

/**
 * Designated initializer for creating an image element.
 *
 * @param image The CGImage (ownership is transferred)
 * @param bounds The bounding rectangle
 * @param pageIndex The page index
 * @param isVectorSource Whether this was originally vector graphics
 * @return A new image element instance
 */
- (instancetype)initWithImage:(CGImageRef)image
                       bounds:(CGRect)bounds
                    pageIndex:(NSInteger)pageIndex
               isVectorSource:(BOOL)isVectorSource NS_DESIGNATED_INITIALIZER;

- (instancetype)init NS_UNAVAILABLE;

/**
 * Analyzes the image to determine if JPEG compression would be suitable.
 * @return YES if JPEG is recommended, NO for PNG
 */
- (BOOL)shouldUseJPEGCompression;

/**
 * Gets the dimensions of the image.
 * @return The size in pixels
 */
- (CGSize)imageDimensions;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/Models/PDF22MDImageElement.m">
#import "PDF22MDImageElement.h"

@implementation PDF22MDImageElement

#pragma mark - Initialization

- (instancetype)initWithImage:(CGImageRef)image
                       bounds:(CGRect)bounds
                    pageIndex:(NSInteger)pageIndex
               isVectorSource:(BOOL)isVectorSource {
    self = [super init];
    if (self) {
        _image = CGImageRetain(image);
        _bounds = bounds;
        _pageIndex = pageIndex;
        _isVectorSource = isVectorSource;
    }
    return self;
}

- (void)dealloc {
    if (_image) {
        CGImageRelease(_image);
    }
}

#pragma mark - PDF22MDContentElement Protocol

- (nullable NSString *)markdownRepresentation {
    if (!self.assetRelativePath) {
        return @"![Image](image-not-saved)";
    }
    
    return [NSString stringWithFormat:@"![Image](%@)", self.assetRelativePath];
}

- (NSDictionary<NSString *, id> *)metadata {
    CGSize dimensions = [self imageDimensions];
    
    return @{
        @"width": @(dimensions.width),
        @"height": @(dimensions.height),
        @"isVectorSource": @(self.isVectorSource),
        @"hasAlpha": @([self imageHasAlpha]),
        @"shouldUseJPEG": @([self shouldUseJPEGCompression])
    };
}

#pragma mark - Public Methods

- (CGSize)imageDimensions {
    if (!self.image) {
        return CGSizeZero;
    }
    
    return CGSizeMake(CGImageGetWidth(self.image), CGImageGetHeight(self.image));
}

- (BOOL)shouldUseJPEGCompression {
    if (!self.image) {
        return NO;
    }
    
    // If image has alpha channel, use PNG
    if ([self imageHasAlpha]) {
        return NO;
    }
    
    // For small images, use PNG
    CGSize dimensions = [self imageDimensions];
    if (dimensions.width * dimensions.height < 10000) { // Less than 100x100
        return NO;
    }
    
    // For vector sources, prefer PNG to maintain quality
    if (self.isVectorSource) {
        return NO;
    }
    
    // Analyze color complexity
    NSUInteger uniqueColors = [self estimateUniqueColorCount];
    
    // If we have many unique colors, it's likely a photograph - use JPEG
    return uniqueColors > 256;
}

#pragma mark - Private Methods

- (BOOL)imageHasAlpha {
    if (!self.image) {
        return NO;
    }
    
    CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(self.image);
    
    return alphaInfo != kCGImageAlphaNone &&
           alphaInfo != kCGImageAlphaNoneSkipFirst &&
           alphaInfo != kCGImageAlphaNoneSkipLast;
}

- (NSUInteger)estimateUniqueColorCount {
    if (!self.image) {
        return 0;
    }
    
    size_t width = CGImageGetWidth(self.image);
    size_t height = CGImageGetHeight(self.image);
    
    // Sample a subset of pixels for performance
    size_t sampleWidth = MIN(width, 100);
    size_t sampleHeight = MIN(height, 100);
    size_t __unused stepX = MAX(1, width / sampleWidth);
    size_t __unused stepY = MAX(1, height / sampleHeight);
    
    // Create a small bitmap context for sampling
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    size_t bytesPerRow = sampleWidth * 4;
    unsigned char *pixelData = calloc(sampleHeight * bytesPerRow, sizeof(unsigned char));
    
    if (!pixelData) {
        CGColorSpaceRelease(colorSpace);
        return 256; // Default to medium complexity
    }
    
    CGContextRef context = CGBitmapContextCreate(pixelData, sampleWidth, sampleHeight, 8, bytesPerRow, colorSpace,
                                                kCGImageAlphaNoneSkipLast | kCGBitmapByteOrder32Big);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        free(pixelData);
        return 256;
    }
    
    // Draw scaled image
    CGContextDrawImage(context, CGRectMake(0, 0, sampleWidth, sampleHeight), self.image);
    CGContextRelease(context);
    
    // Count unique colors
    NSMutableSet *uniqueColors = [NSMutableSet set];
    
    for (size_t y = 0; y < sampleHeight; y++) {
        for (size_t x = 0; x < sampleWidth; x++) {
            size_t offset = (y * bytesPerRow) + (x * 4);
            uint32_t color = (pixelData[offset] << 24) | 
                           (pixelData[offset + 1] << 16) | 
                           (pixelData[offset + 2] << 8) | 
                           pixelData[offset + 3];
            [uniqueColors addObject:@(color)];
            
            // Early exit if we already have many colors
            if (uniqueColors.count > 1000) {
                free(pixelData);
                return uniqueColors.count;
            }
        }
    }
    
    free(pixelData);
    return uniqueColors.count;
}

#pragma mark - NSObject

- (NSString *)description {
    CGSize dimensions = [self imageDimensions];
    return [NSString stringWithFormat:@"<%@: %p, size=%.0fx%.0f, bounds=%@, page=%ld>",
            NSStringFromClass([self class]),
            self,
            dimensions.width,
            dimensions.height,
            [NSString stringWithFormat:@"{{%.1f,%.1f},{%.1f,%.1f}}", self.bounds.origin.x, self.bounds.origin.y, self.bounds.size.width, self.bounds.size.height],
            (long)self.pageIndex];
}

- (NSString *)debugDescription {
    CGSize dimensions = [self imageDimensions];
    return [NSString stringWithFormat:@"<%@: %p> {\n  dimensions: %.0fx%.0f\n  bounds: %@\n  page: %ld\n  vector: %@\n  alpha: %@\n  path: %@\n}",
            NSStringFromClass([self class]),
            self,
            dimensions.width,
            dimensions.height,
            [NSString stringWithFormat:@"{{%.1f,%.1f},{%.1f,%.1f}}", self.bounds.origin.x, self.bounds.origin.y, self.bounds.size.width, self.bounds.size.height],
            (long)self.pageIndex,
            self.isVectorSource ? @"YES" : @"NO",
            [self imageHasAlpha] ? @"YES" : @"NO",
            self.assetRelativePath ?: @"<not saved>"];
}

- (BOOL)isEqual:(id)object {
    if (self == object) {
        return YES;
    }
    
    if (![object isKindOfClass:[PDF22MDImageElement class]]) {
        return NO;
    }
    
    PDF22MDImageElement *other = (PDF22MDImageElement *)object;
    
    return CGRectEqualToRect(self.bounds, other.bounds) &&
           self.pageIndex == other.pageIndex &&
           self.isVectorSource == other.isVectorSource &&
           (self.assetRelativePath == other.assetRelativePath || 
            [self.assetRelativePath isEqualToString:other.assetRelativePath]);
}

- (NSUInteger)hash {
    NSUInteger prime = 31;
    NSUInteger result = 1;
    
    result = prime * result + (NSUInteger)(self.bounds.origin.x + self.bounds.origin.y + self.bounds.size.width + self.bounds.size.height);
    result = prime * result + self.pageIndex;
    result = prime * result + (self.isVectorSource ? 1 : 0);
    result = prime * result + [self.assetRelativePath hash];
    
    return result;
}

@end
</file>

<file path="pdf22md-objc/src/Models/PDF22MDTextElement.h">
#import <Foundation/Foundation.h>
#import "PDF22MDContentElement.h"

NS_ASSUME_NONNULL_BEGIN

/**
 * Represents a text element extracted from a PDF page.
 * Includes text content and associated styling information.
 */
@interface PDF22MDTextElement : NSObject <PDF22MDContentElement>

/**
 * The extracted text content. Never nil, but may be empty.
 */
@property (nonatomic, copy, readonly) NSString *text;

/**
 * The bounding rectangle of this text element.
 */
@property (nonatomic, assign, readonly) CGRect bounds;

/**
 * The page index where this text was found.
 */
@property (nonatomic, assign, readonly) NSInteger pageIndex;

/**
 * The font name used for this text, if available.
 */
@property (nonatomic, copy, nullable, readonly) NSString *fontName;

/**
 * The font size in points.
 */
@property (nonatomic, assign, readonly) CGFloat fontSize;

/**
 * Indicates if the text appears to be bold.
 */
@property (nonatomic, assign, readonly) BOOL isBold;

/**
 * Indicates if the text appears to be italic.
 */
@property (nonatomic, assign, readonly) BOOL isItalic;

/**
 * The detected heading level (0 for body text, 1-6 for headings).
 */
@property (nonatomic, assign) NSInteger headingLevel;

/**
 * Designated initializer for creating a text element.
 *
 * @param text The text content (required)
 * @param bounds The bounding rectangle
 * @param pageIndex The page index
 * @return A new text element instance
 */
- (instancetype)initWithText:(NSString *)text
                      bounds:(CGRect)bounds
                   pageIndex:(NSInteger)pageIndex;

/**
 * Convenience initializer with full styling information.
 *
 * @param text The text content
 * @param bounds The bounding rectangle
 * @param pageIndex The page index
 * @param fontName The font name (optional)
 * @param fontSize The font size
 * @param isBold Bold style flag
 * @param isItalic Italic style flag
 * @return A new text element instance
 */
- (instancetype)initWithText:(NSString *)text
                      bounds:(CGRect)bounds
                   pageIndex:(NSInteger)pageIndex
                    fontName:(nullable NSString *)fontName
                    fontSize:(CGFloat)fontSize
                      isBold:(BOOL)isBold
                    isItalic:(BOOL)isItalic NS_DESIGNATED_INITIALIZER;

- (instancetype)init NS_UNAVAILABLE;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/Models/PDF22MDTextElement.m">
#import "PDF22MDTextElement.h"

@implementation PDF22MDTextElement

#pragma mark - Initialization

- (instancetype)initWithText:(NSString *)text
                      bounds:(CGRect)bounds
                   pageIndex:(NSInteger)pageIndex {
    return [self initWithText:text
                       bounds:bounds
                    pageIndex:pageIndex
                     fontName:nil
                     fontSize:12.0
                       isBold:NO
                     isItalic:NO];
}

- (instancetype)initWithText:(NSString *)text
                      bounds:(CGRect)bounds
                   pageIndex:(NSInteger)pageIndex
                    fontName:(nullable NSString *)fontName
                    fontSize:(CGFloat)fontSize
                      isBold:(BOOL)isBold
                    isItalic:(BOOL)isItalic {
    self = [super init];
    if (self) {
        _text = [text copy];
        _bounds = bounds;
        _pageIndex = pageIndex;
        _fontName = [fontName copy];
        _fontSize = fontSize;
        _isBold = isBold;
        _isItalic = isItalic;
        _headingLevel = 0; // Default to body text
    }
    return self;
}

#pragma mark - PDF22MDContentElement Protocol

- (nullable NSString *)markdownRepresentation {
    if (!self.text || self.text.length == 0) {
        return nil;
    }
    
    NSString *trimmedText = [self.text stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    if (trimmedText.length == 0) {
        return nil;
    }
    
    // Apply heading formatting
    if (self.headingLevel > 0 && self.headingLevel <= 6) {
        NSMutableString *heading = [NSMutableString string];
        for (NSInteger i = 0; i < self.headingLevel; i++) {
            [heading appendString:@"#"];
        }
        [heading appendString:@" "];
        [heading appendString:trimmedText];
        return heading;
    }
    
    // Apply bold/italic formatting
    NSString *formattedText = trimmedText;
    
    if (self.isBold && self.isItalic) {
        formattedText = [NSString stringWithFormat:@"***%@***", formattedText];
    } else if (self.isBold) {
        formattedText = [NSString stringWithFormat:@"**%@**", formattedText];
    } else if (self.isItalic) {
        formattedText = [NSString stringWithFormat:@"*%@*", formattedText];
    }
    
    return formattedText;
}

- (NSDictionary<NSString *, id> *)metadata {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    if (self.fontName) {
        metadata[@"fontName"] = self.fontName;
    }
    metadata[@"fontSize"] = @(self.fontSize);
    metadata[@"isBold"] = @(self.isBold);
    metadata[@"isItalic"] = @(self.isItalic);
    metadata[@"headingLevel"] = @(self.headingLevel);
    
    return [metadata copy];
}

#pragma mark - NSObject

- (NSString *)description {
    return [NSString stringWithFormat:@"<%@: %p, text='%@', bounds=%@, page=%ld>",
            NSStringFromClass([self class]),
            self,
            [self.text length] > 50 ? [[self.text substringToIndex:50] stringByAppendingString:@"..."] : self.text,
            [NSString stringWithFormat:@"{{%.1f,%.1f},{%.1f,%.1f}}", self.bounds.origin.x, self.bounds.origin.y, self.bounds.size.width, self.bounds.size.height],
            (long)self.pageIndex];
}

- (NSString *)debugDescription {
    return [NSString stringWithFormat:@"<%@: %p> {\n  text: '%@'\n  bounds: %@\n  page: %ld\n  font: %@\n  size: %.1f\n  bold: %@\n  italic: %@\n  heading: %ld\n}",
            NSStringFromClass([self class]),
            self,
            self.text,
            [NSString stringWithFormat:@"{{%.1f,%.1f},{%.1f,%.1f}}", self.bounds.origin.x, self.bounds.origin.y, self.bounds.size.width, self.bounds.size.height],
            (long)self.pageIndex,
            self.fontName ?: @"<unknown>",
            self.fontSize,
            self.isBold ? @"YES" : @"NO",
            self.isItalic ? @"YES" : @"NO",
            (long)self.headingLevel];
}

- (BOOL)isEqual:(id)object {
    if (self == object) {
        return YES;
    }
    
    if (![object isKindOfClass:[PDF22MDTextElement class]]) {
        return NO;
    }
    
    PDF22MDTextElement *other = (PDF22MDTextElement *)object;
    
    return [self.text isEqualToString:other.text] &&
           CGRectEqualToRect(self.bounds, other.bounds) &&
           self.pageIndex == other.pageIndex &&
           (self.fontName == other.fontName || [self.fontName isEqualToString:other.fontName]) &&
           self.fontSize == other.fontSize &&
           self.isBold == other.isBold &&
           self.isItalic == other.isItalic &&
           self.headingLevel == other.headingLevel;
}

- (NSUInteger)hash {
    NSUInteger prime = 31;
    NSUInteger result = 1;
    
    result = prime * result + [self.text hash];
    result = prime * result + (NSUInteger)(self.bounds.origin.x + self.bounds.origin.y + self.bounds.size.width + self.bounds.size.height);
    result = prime * result + self.pageIndex;
    result = prime * result + [self.fontName hash];
    result = prime * result + (NSUInteger)self.fontSize;
    result = prime * result + (self.isBold ? 1 : 0);
    result = prime * result + (self.isItalic ? 1 : 0);
    result = prime * result + self.headingLevel;
    
    return result;
}

@end
</file>

<file path="pdf22md-objc/src/Services/PDF22MDAssetManager.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

@class PDF22MDImageElement;

/**
 * Manages the extraction and saving of assets (images) from PDF documents.
 * Thread-safe for concurrent image saving operations.
 */
@interface PDF22MDAssetManager : NSObject

/**
 * The base folder path where assets will be saved.
 */
@property (nonatomic, copy, readonly) NSString *assetsFolderPath;

/**
 * Initializes the asset manager with a folder path.
 * Creates the folder if it doesn't exist.
 *
 * @param folderPath The path where assets will be saved
 * @return A new instance, or nil if folder creation fails
 */
- (nullable instancetype)initWithAssetFolder:(NSString *)folderPath NS_DESIGNATED_INITIALIZER;

- (instancetype)init NS_UNAVAILABLE;

/**
 * Saves an image to the assets folder with automatic format selection.
 *
 * @param image The CGImage to save
 * @param isVectorSource Whether this image originated from vector graphics
 * @param baseName The base filename (without extension)
 * @return The relative path to the saved file, or nil on failure
 */
- (nullable NSString *)saveImage:(CGImageRef)image
                  isVectorSource:(BOOL)isVectorSource
                    withBaseName:(NSString *)baseName;

/**
 * Saves an image element to the assets folder.
 * Updates the element's assetRelativePath property on success.
 *
 * @param imageElement The image element to save
 * @param baseName The base filename (without extension)
 * @return The relative path to the saved file, or nil on failure
 */
- (nullable NSString *)saveImageElement:(PDF22MDImageElement *)imageElement
                           withBaseName:(NSString *)baseName;

/**
 * Determines the optimal image format for the given image.
 *
 * @param image The image to analyze
 * @param isVectorSource Whether this originated from vector graphics
 * @return YES for JPEG, NO for PNG
 */
- (BOOL)shouldUseJPEGForImage:(CGImageRef)image
                isVectorSource:(BOOL)isVectorSource;

/**
 * Gets the next available filename for the given base name.
 * Handles conflicts by appending numbers.
 *
 * @param baseName The desired base filename
 * @param extension The file extension (without dot)
 * @return A unique filename
 */
- (NSString *)uniqueFilenameForBaseName:(NSString *)baseName
                          withExtension:(NSString *)extension;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/Services/PDF22MDAssetManager.m">
#import "PDF22MDAssetManager.h"
#import "../Models/PDF22MDImageElement.h"
#import <ImageIO/ImageIO.h>

@interface PDF22MDAssetManager ()
@property (nonatomic, strong) NSFileManager *fileManager;
@property (nonatomic, strong) dispatch_queue_t fileAccessQueue;
@property (nonatomic, strong) NSMutableSet<NSString *> *usedFilenames;
@end

@implementation PDF22MDAssetManager

#pragma mark - Initialization

- (nullable instancetype)initWithAssetFolder:(NSString *)folderPath {
    self = [super init];
    if (self) {
        _assetsFolderPath = [folderPath copy];
        _fileManager = [[NSFileManager alloc] init];
        _fileAccessQueue = dispatch_queue_create("com.twardoch.pdf22md.assetmanager", DISPATCH_QUEUE_SERIAL);
        _usedFilenames = [NSMutableSet set];
        
        // Create assets folder if it doesn't exist
        NSError *error = nil;
        BOOL isDirectory = NO;
        BOOL exists = [_fileManager fileExistsAtPath:folderPath isDirectory:&isDirectory];
        
        if (exists && !isDirectory) {
            NSLog(@"Asset path exists but is not a directory: %@", folderPath);
            return nil;
        }
        
        if (!exists) {
            if (![_fileManager createDirectoryAtPath:folderPath
                         withIntermediateDirectories:YES
                                          attributes:nil
                                               error:&error]) {
                NSLog(@"Failed to create assets folder: %@", error);
                return nil;
            }
        }
    }
    return self;
}

#pragma mark - Public Methods

- (nullable NSString *)saveImage:(CGImageRef)image
                  isVectorSource:(BOOL)isVectorSource
                    withBaseName:(NSString *)baseName {
    if (!image) {
        return nil;
    }
    
    // Determine optimal format
    BOOL shouldUseJPEG = [self shouldUseJPEGForImage:image isVectorSource:isVectorSource];
    
    NSString *extension = shouldUseJPEG ? @"jpg" : @"png";
    NSString *fileName = [self uniqueFilenameForBaseName:baseName withExtension:extension];
    NSString *fullPath = [self.assetsFolderPath stringByAppendingPathComponent:fileName];
    
    // Create destination
    NSURL *fileURL = [NSURL fileURLWithPath:fullPath];
    CGImageDestinationRef destination = CGImageDestinationCreateWithURL(
        (__bridge CFURLRef)fileURL,
        shouldUseJPEG ? (__bridge CFStringRef)@"public.jpeg" : (__bridge CFStringRef)@"public.png",
        1,
        NULL
    );
    
    if (!destination) {
        NSLog(@"Failed to create image destination for %@", fullPath);
        return nil;
    }
    
    // Set compression options
    NSDictionary *properties = nil;
    if (shouldUseJPEG) {
        properties = @{(__bridge NSString *)kCGImageDestinationLossyCompressionQuality: @(0.85)};
    } else {
        // For PNG, we can set compression level
        properties = @{(__bridge NSString *)kCGImagePropertyPNGCompressionFilter: @(1)}; // Best compression
    }
    
    // Add image to destination
    CGImageDestinationAddImage(destination, image, (__bridge CFDictionaryRef)properties);
    
    // Finalize
    BOOL success = CGImageDestinationFinalize(destination);
    CFRelease(destination);
    
    if (!success) {
        NSLog(@"Failed to save image to %@", fullPath);
        return nil;
    }
    
    // Return relative path (just the filename since it's in the assets folder)
    return fileName;
}

- (nullable NSString *)saveImageElement:(PDF22MDImageElement *)imageElement
                           withBaseName:(NSString *)baseName {
    NSString *savedPath = [self saveImage:imageElement.image
                           isVectorSource:imageElement.isVectorSource
                             withBaseName:baseName];
    
    if (savedPath) {
        imageElement.assetRelativePath = savedPath;
    }
    
    return savedPath;
}

- (BOOL)shouldUseJPEGForImage:(CGImageRef)image
                isVectorSource:(BOOL)isVectorSource {
    if (!image) {
        return NO;
    }
    
    // Get image properties
    size_t width = CGImageGetWidth(image);
    size_t height = CGImageGetHeight(image);
    CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(image);
    
    // If image has alpha channel, use PNG
    if (alphaInfo != kCGImageAlphaNone &&
        alphaInfo != kCGImageAlphaNoneSkipFirst &&
        alphaInfo != kCGImageAlphaNoneSkipLast) {
        return NO;
    }
    
    // For small images, use PNG
    if (width * height < 10000) { // Less than 100x100
        return NO;
    }
    
    // For vector sources, prefer PNG to maintain quality
    if (isVectorSource) {
        return NO;
    }
    
    // Analyze color complexity
    NSUInteger uniqueColors = [self estimateUniqueColorCountForImage:image];
    
    // If we have many unique colors, it's likely a photograph - use JPEG
    return uniqueColors > 256;
}

- (NSString *)uniqueFilenameForBaseName:(NSString *)baseName
                          withExtension:(NSString *)extension {
    __block NSString *filename = nil;
    
    dispatch_sync(self.fileAccessQueue, ^{
        NSString *candidate = [NSString stringWithFormat:@"%@.%@", baseName, extension];
        NSInteger counter = 1;
        
        // Check if filename is already used
        while ([self.usedFilenames containsObject:candidate] ||
               [self.fileManager fileExistsAtPath:[self.assetsFolderPath stringByAppendingPathComponent:candidate]]) {
            candidate = [NSString stringWithFormat:@"%@_%03ld.%@", baseName, (long)counter, extension];
            counter++;
        }
        
        [self.usedFilenames addObject:candidate];
        filename = candidate;
    });
    
    return filename;
}

#pragma mark - Private Methods

- (NSUInteger)estimateUniqueColorCountForImage:(CGImageRef)image {
    size_t width = CGImageGetWidth(image);
    size_t height = CGImageGetHeight(image);
    
    // Sample a subset of pixels for performance
    size_t __unused sampleSize = MIN(width * height, 10000);
    size_t stepX = MAX(1, width / 100);
    size_t stepY = MAX(1, height / 100);
    
    // Create a small bitmap context for sampling
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    size_t bytesPerRow = 4; // Single pixel
    unsigned char *pixelData = calloc(4, sizeof(unsigned char));
    
    if (!pixelData) {
        CGColorSpaceRelease(colorSpace);
        return 256; // Default to medium complexity
    }
    
    CGContextRef context = CGBitmapContextCreate(pixelData, 1, 1, 8, bytesPerRow, colorSpace,
                                                kCGImageAlphaNoneSkipLast | kCGBitmapByteOrder32Big);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        free(pixelData);
        return 256;
    }
    
    // Count unique colors by sampling
    NSMutableSet *uniqueColors = [NSMutableSet set];
    
    for (size_t y = 0; y < height; y += stepY) {
        for (size_t x = 0; x < width; x += stepX) {
            // Draw a single pixel
            CGRect __unused sourceRect = CGRectMake(x, y, 1, 1);
            CGContextClearRect(context, CGRectMake(0, 0, 1, 1));
            CGContextDrawImage(context, CGRectMake(-x, -y, width, height), image);
            
            uint32_t color = (pixelData[0] << 24) | (pixelData[1] << 16) | 
                           (pixelData[2] << 8) | pixelData[3];
            [uniqueColors addObject:@(color)];
            
            // Early exit if we already have many colors
            if (uniqueColors.count > 1000) {
                break;
            }
        }
        
        if (uniqueColors.count > 1000) {
            break;
        }
    }
    
    CGContextRelease(context);
    free(pixelData);
    
    return uniqueColors.count;
}

@end
</file>

<file path="pdf22md-objc/src/Services/PDF22MDMarkdownGenerator.h">
#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>

NS_ASSUME_NONNULL_BEGIN

@protocol PDF22MDContentElement;
@class PDF22MDConversionOptions;

/**
 * Metadata structure for YAML frontmatter generation.
 */
@interface PDF22MDDocumentMetadata : NSObject
@property (nonatomic, copy, nullable) NSString *title;
@property (nonatomic, copy, nullable) NSString *author;
@property (nonatomic, copy, nullable) NSString *subject;
@property (nonatomic, copy, nullable) NSArray<NSString *> *keywords;
@property (nonatomic, copy, nullable) NSString *creator;
@property (nonatomic, copy, nullable) NSString *producer;
@property (nonatomic, strong, nullable) NSDate *creationDate;
@property (nonatomic, strong, nullable) NSDate *modificationDate;
@property (nonatomic, assign) NSInteger pageCount;
@property (nonatomic, copy, nullable) NSString *pdfVersion;
@property (nonatomic, strong, nullable) PDFOutline *outline;
@end

/**
 * Generates Markdown output from PDF content elements.
 */
@interface PDF22MDMarkdownGenerator : NSObject

/**
 * Conversion options affecting markdown generation.
 */
@property (nonatomic, strong, readonly) PDF22MDConversionOptions *options;

/**
 * Initializes the generator with conversion options.
 *
 * @param options The conversion options to use
 * @return A new generator instance
 */
- (instancetype)initWithOptions:(PDF22MDConversionOptions *)options NS_DESIGNATED_INITIALIZER;

- (instancetype)init NS_UNAVAILABLE;

/**
 * Generates a complete markdown document from content elements.
 *
 * @param elements Array of content elements in reading order
 * @param metadata Document metadata for frontmatter
 * @return The generated markdown string
 */
- (NSString *)generateMarkdownFromElements:(NSArray<id<PDF22MDContentElement>> *)elements
                              withMetadata:(nullable PDF22MDDocumentMetadata *)metadata;

/**
 * Generates YAML frontmatter from document metadata.
 *
 * @param metadata The document metadata
 * @return YAML frontmatter string, or nil if includeMetadata is NO
 */
- (nullable NSString *)generateYAMLFrontmatter:(PDF22MDDocumentMetadata *)metadata;

/**
 * Generates markdown content from elements without frontmatter.
 *
 * @param elements Array of content elements
 * @return The markdown content
 */
- (NSString *)generateMarkdownContent:(NSArray<id<PDF22MDContentElement>> *)elements;

/**
 * Extracts metadata from a PDF document.
 *
 * @param document The PDF document
 * @return Populated metadata object
 */
+ (PDF22MDDocumentMetadata *)extractMetadataFromDocument:(PDFDocument *)document;

/**
 * Escapes a string for safe inclusion in YAML.
 *
 * @param string The string to escape
 * @return The escaped string
 */
+ (NSString *)escapeYAMLString:(NSString *)string;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/Services/PDF22MDMarkdownGenerator.m">
#import "PDF22MDMarkdownGenerator.h"
#import "../Core/PDF22MDConversionOptions.h"
#import "../Models/PDF22MDContentElement.h"
#import "../Models/PDF22MDTextElement.h"

// Version string - should match the compiled version
#ifndef PDF22MD_VERSION
#define PDF22MD_VERSION "1.0.0"
#endif

@implementation PDF22MDDocumentMetadata
@end

@implementation PDF22MDMarkdownGenerator

#pragma mark - Initialization

- (instancetype)initWithOptions:(PDF22MDConversionOptions *)options {
    self = [super init];
    if (self) {
        _options = options;
    }
    return self;
}

#pragma mark - Public Methods

- (NSString *)generateMarkdownFromElements:(NSArray<id<PDF22MDContentElement>> *)elements
                              withMetadata:(nullable PDF22MDDocumentMetadata *)metadata {
    NSMutableString *markdown = [NSMutableString string];
    
    // Add YAML frontmatter if enabled
    if (self.options.includeMetadata && metadata) {
        NSString *frontmatter = [self generateYAMLFrontmatter:metadata];
        if (frontmatter) {
            [markdown appendString:frontmatter];
            [markdown appendString:@"\n"];
        }
    }
    
    // Generate content
    NSString *content = [self generateMarkdownContent:elements];
    [markdown appendString:content];
    
    // Clean up extra newlines
    NSString *finalMarkdown = [markdown stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    
    return finalMarkdown;
}

- (nullable NSString *)generateYAMLFrontmatter:(PDF22MDDocumentMetadata *)metadata {
    if (!self.options.includeMetadata) {
        return nil;
    }
    
    NSMutableString *yaml = [NSMutableString string];
    [yaml appendString:@"---\n"];
    
    // Basic metadata
    if (metadata.title && metadata.title.length > 0) {
        [yaml appendFormat:@"title: \"%@\"\n", [[self class] escapeYAMLString:metadata.title]];
    }
    
    if (metadata.author && metadata.author.length > 0) {
        [yaml appendFormat:@"author: \"%@\"\n", [[self class] escapeYAMLString:metadata.author]];
    }
    
    if (metadata.subject && metadata.subject.length > 0) {
        [yaml appendFormat:@"subject: \"%@\"\n", [[self class] escapeYAMLString:metadata.subject]];
    }
    
    // Keywords
    if (metadata.keywords && metadata.keywords.count > 0) {
        [yaml appendString:@"keywords:\n"];
        for (NSString *keyword in metadata.keywords) {
            [yaml appendFormat:@"  - \"%@\"\n", [[self class] escapeYAMLString:keyword]];
        }
    }
    
    // Creator and producer
    if (metadata.creator && metadata.creator.length > 0) {
        [yaml appendFormat:@"creator: \"%@\"\n", [[self class] escapeYAMLString:metadata.creator]];
    }
    
    if (metadata.producer && metadata.producer.length > 0) {
        [yaml appendFormat:@"producer: \"%@\"\n", [[self class] escapeYAMLString:metadata.producer]];
    }
    
    // Dates
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateFormat:@"yyyy-MM-dd'T'HH:mm:ssZZZZZ"];
    [formatter setLocale:[NSLocale localeWithLocaleIdentifier:@"en_US_POSIX"]];
    
    if (metadata.creationDate) {
        [yaml appendFormat:@"created: %@\n", [formatter stringFromDate:metadata.creationDate]];
    }
    
    if (metadata.modificationDate) {
        [yaml appendFormat:@"modified: %@\n", [formatter stringFromDate:metadata.modificationDate]];
    }
    
    // PDF specific metadata
    [yaml appendString:@"pdf_metadata:\n"];
    [yaml appendFormat:@"  page_count: %ld\n", (long)metadata.pageCount];
    
    if (metadata.pdfVersion && metadata.pdfVersion.length > 0) {
        [yaml appendFormat:@"  version: \"%@\"\n", metadata.pdfVersion];
    }
    
    // Outline/bookmarks
    if (self.options.preserveOutline && metadata.outline && [metadata.outline numberOfChildren] > 0) {
        [yaml appendString:@"  outline:\n"];
        [self appendOutlineToYAML:yaml outline:metadata.outline indent:@"    "];
    }
    
    // Conversion metadata
    [yaml appendString:@"conversion:\n"];
    [yaml appendString:@"  tool: \"pdf22md\"\n"];
    [yaml appendFormat:@"  version: \"%s\"\n", PDF22MD_VERSION];
    [yaml appendFormat:@"  date: %@\n", [formatter stringFromDate:[NSDate date]]];
    
    [yaml appendString:@"---\n"];
    
    return yaml;
}

- (NSString *)generateMarkdownContent:(NSArray<id<PDF22MDContentElement>> *)elements {
    NSMutableString *content = [NSMutableString string];
    
    id<PDF22MDContentElement> previousElement = nil;
    
    for (id<PDF22MDContentElement> element in elements) {
        NSString *elementMarkdown = [element markdownRepresentation];
        
        if (elementMarkdown && elementMarkdown.length > 0) {
            // Add appropriate spacing between elements
            if (previousElement) {
                // Check if we need extra spacing (e.g., between paragraphs)
                if ([self shouldAddExtraSpacingBetween:previousElement and:element]) {
                    [content appendString:@"\n\n"];
                } else {
                    [content appendString:@"\n"];
                }
            }
            
            [content appendString:elementMarkdown];
            previousElement = element;
        }
    }
    
    return content;
}

+ (PDF22MDDocumentMetadata *)extractMetadataFromDocument:(PDFDocument *)document {
    PDF22MDDocumentMetadata *metadata = [[PDF22MDDocumentMetadata alloc] init];
    
    // Get document attributes
    NSDictionary *attributes = [document documentAttributes];
    
    metadata.title = attributes[PDFDocumentTitleAttribute];
    metadata.author = attributes[PDFDocumentAuthorAttribute];
    metadata.subject = attributes[PDFDocumentSubjectAttribute];
    metadata.keywords = attributes[PDFDocumentKeywordsAttribute];
    metadata.creator = attributes[PDFDocumentCreatorAttribute];
    metadata.producer = attributes[PDFDocumentProducerAttribute];
    metadata.creationDate = attributes[PDFDocumentCreationDateAttribute];
    metadata.modificationDate = attributes[PDFDocumentModificationDateAttribute];
    
    metadata.pageCount = [document pageCount];
    metadata.outline = [document outlineRoot];
    
    // Try to extract PDF version
    metadata.pdfVersion = [self extractPDFVersionFromAttributes:attributes];
    
    return metadata;
}

+ (NSString *)escapeYAMLString:(NSString *)string {
    // Escape quotes and backslashes for YAML
    NSString *escaped = [string stringByReplacingOccurrencesOfString:@"\\" withString:@"\\\\"];
    escaped = [escaped stringByReplacingOccurrencesOfString:@"\"" withString:@"\\\""];
    escaped = [escaped stringByReplacingOccurrencesOfString:@"\n" withString:@"\\n"];
    escaped = [escaped stringByReplacingOccurrencesOfString:@"\r" withString:@"\\r"];
    escaped = [escaped stringByReplacingOccurrencesOfString:@"\t" withString:@"\\t"];
    return escaped;
}

#pragma mark - Private Methods

- (void)appendOutlineToYAML:(NSMutableString *)yaml outline:(PDFOutline *)outline indent:(NSString *)indent {
    for (NSUInteger i = 0; i < [outline numberOfChildren]; i++) {
        PDFOutline *child = [outline childAtIndex:i];
        NSString *label = [child label];
        
        if (label && label.length > 0) {
            [yaml appendFormat:@"%@- title: \"%@\"\n", indent, [[self class] escapeYAMLString:label]];
            
            PDFDestination *destination = [child destination];
            if (destination) {
                PDFPage *page = [destination page];
                if (page) {
                    // Note: We need the document to get page index, so this is an approximation
                    [yaml appendFormat:@"%@  page: %ld\n", indent, (long)1];
                }
            }
            
            if ([child numberOfChildren] > 0) {
                [yaml appendFormat:@"%@  children:\n", indent];
                NSString *newIndent = [indent stringByAppendingString:@"    "];
                [self appendOutlineToYAML:yaml outline:child indent:newIndent];
            }
        }
    }
}

+ (NSString *)extractPDFVersionFromAttributes:(NSDictionary *)attributes {
    // Look for PDF version in various attribute keys
    for (NSString *key in attributes) {
        id value = attributes[key];
        if ([value isKindOfClass:[NSString class]]) {
            NSString *stringValue = (NSString *)value;
            
            // Look for PDF version patterns
            NSRange pdfRange = [stringValue rangeOfString:@"PDF-" options:NSCaseInsensitiveSearch];
            if (pdfRange.location != NSNotFound) {
                // Extract version number after "PDF-"
                NSString *versionPart = [stringValue substringFromIndex:pdfRange.location];
                NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"PDF-?(\\d+\\.\\d+)"
                                                                                       options:NSRegularExpressionCaseInsensitive
                                                                                         error:nil];
                NSTextCheckingResult *match = [regex firstMatchInString:versionPart
                                                               options:0
                                                                 range:NSMakeRange(0, versionPart.length)];
                if (match && match.numberOfRanges > 1) {
                    return [versionPart substringWithRange:[match rangeAtIndex:1]];
                }
            }
        }
    }
    
    return nil;
}

- (BOOL)shouldAddExtraSpacingBetween:(id<PDF22MDContentElement>)element1 
                                 and:(id<PDF22MDContentElement>)element2 {
    // Add extra spacing between different element types
    if ([element1 class] != [element2 class]) {
        return YES;
    }
    
    // Add extra spacing after headings
    if ([element1 isKindOfClass:[PDF22MDTextElement class]]) {
        PDF22MDTextElement *textElement = (PDF22MDTextElement *)element1;
        if (textElement.headingLevel > 0) {
            return YES;
        }
    }
    
    // Add extra spacing between elements on different pages
    if (element1.pageIndex != element2.pageIndex) {
        return YES;
    }
    
    // Check vertical distance between elements
    CGFloat verticalDistance = fabs(CGRectGetMinY(element1.bounds) - CGRectGetMaxY(element2.bounds));
    if (verticalDistance > 20.0) { // Significant gap
        return YES;
    }
    
    return NO;
}

@end
</file>

<file path="pdf22md-objc/test/README.md">
---
title: "README.md"
creator: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36 Edg/137.0.0.0"
producer: "Skia/PDF m137"
created: 2025-06-23T01:33:53+02:00
modified: 2025-06-23T01:33:53+02:00
pdf_metadata:
  page_count: 2
conversion:
  tool: "pdf22md"
  version: "v1.1.0-dirty"
  date: 2025-06-23T02:28:31+02:00
---

23/06/2025, 01:33 README.md

![Image](image_000.png)

![Image](image_001.png)

pdf22md

MIT

License MIT

License

10.15+

![Image](image_002.png)

![Image](image_003.png)

macOS 10.15+

macOS

Build and Release Build and Release passing passing

A blazingly fast PDF to Markdown converter for macOS.

pdf22md is a command-line tool that extracts all text and image content from a PDF file and converts it into a

![Image](image_004.png)

![Image](image_005.png)

![Image](image_006.png)

clean Markdown document. It uses Grand Central Dispatch (GCD) to process pages and save images in

parallel, making it exceptionally fast for multi-page documents.

Key Features

High-Speed Conversion: Uses all available CPU cores to process PDF pages concurrently

Intelligent Heading Detection: Analyzes font sizes and usage frequency to automatically format titles

![Image](image_007.png)

![Image](image_008.png)

![Image](image_009.png)

and headings ( # , ## , etc.)

Asset Extraction: Saves raster and vector images into a specified assets folder and links them correctly

in the Markdown file

Smart Image Formatting: Automatically chooses between JPEG (for photos) and PNG (for graphics with

transparency) to optimize file size and quality

Flexible I/O: Reads from a PDF file or stdin and writes to a Markdown file or stdout

![Image](image_010.png)

![Image](image_011.png)

![Image](image_012.png)

Customizable Rasterization: Allows setting a custom DPI for converting vector graphics to bitmaps

Installation

Using Homebrew (Coming Soon)

brew tap twardoch/pdf22md

brew install pdf22md

![Image](image_013.png)

![Image](image_014.png)

Building from Source

To build the project manually, you need Xcode Command Line Tools installed.

# Clone the repository

git clone https://github.com/twardoch/pdf22md.git

cd pdf22md

# Compile the tool

make

# Install it to /usr/local/bin (optional)

sudo make install

Download Pre-built Binary

Pre-built binaries are available from the Releases page.

Usage

Usage: pdf22md [-i input.pdf] [-o output.md] [-a assets

_

folder] [-d dpi]

Converts PDF documents to Markdown format

-i <path>: Input PDF file (default: stdin)

-o <path>: Output Markdown file (default: stdout)

-a <path>: Assets folder for extracted images

-d <dpi>: DPI for rasterizing vector graphics (default: 144)

Examples

# Convert a PDF file to Markdown

pdf22md -i document.pdf -o document.md

# Convert with images saved to an 'assets' folder

pdf22md -i report.pdf -o report.md -a ./assets

# Convert with custom DPI for vector graphics

pdf22md -i presentation.pdf -o presentation.md -a ./images -d 300

# Use with pipes

cat document.pdf | pdf22md > document.md

# Convert and view in less

pdf22md -i manual.pdf | less

Requirements

macOS 10.15 (Catalina) or later

Xcode Command Line Tools (for building from source)

Project Structure

pdf22md/

├── src/ # Source code

│ ├── main.m # Entry point

│ ├── PDFMarkdownConverter.* # Main conversion logic

│ ├── PDFPageProcessor.* # PDF page processing

│ ├── ContentElement.* # Content element definitions

│ └── AssetExtractor.* # Image extraction logic

├── docs/ # Additional documentation

├── test/ # Test files

file:///Users/adam/Developer/vcs/github.twardoch/pub/pdf22md/README.md 1/2

23/06/2025, 01:33 README.md

![Image](image_015.png)

![Image](image_016.png)

├── LICENSE # MIT License

├── Makefile # Build configuration

└── README.md # This file

Contributing

Contributions are welcome! Please feel free to submit a Pull Request. For major changes, please open an

![Image](image_017.png)

![Image](image_018.png)

![Image](image_019.png)

issue first to discuss what you

would like to change.

1. Fork the repository

2. Create your feature branch ( git checkout -b feature/AmazingFeature )

3. Commit your changes ( git commit -m 'Add some AmazingFeature' )

![Image](image_020.png)

![Image](image_021.png)

![Image](image_022.png)

4. Push to the branch ( git push origin feature/AmazingFeature )

5. Open a Pull Request

License

This project is licensed under the MIT License - see the LICENSE file for details.

Acknowledgments

![Image](image_023.png)

![Image](image_024.png)

![Image](image_025.png)

![Image](image_026.png)

![Image](image_027.png)

Built with Apple’s PDFKit and Core Graphics frameworks

Parallel processing powered by Grand Central Dispatch (GCD)

Inspired by the need for fast, accurate PDF to Markdown conversion

Related Projects

pdfplumber - Python library for PDF processing

![Image](image_028.png)

pdf2md - Another PDF to Markdown converter

![Image](image_029.png)

![Image](image_030.png)

![Image](image_031.png)

![Image](image_032.png)

pandoc - Universal document converter

Changelog

See CHANGELOG.md for a list of changes in each version.

Support

If you encounter any issues or have questions, please open an issue on GitHub.

![Image](image_033.png)

![Image](image_034.png)

file:///Users/adam/Developer/vcs/github.twardoch/pub/pdf22md/README.md 2/2
</file>

<file path="pdf22md-objc/Tests/Integration/EndToEndConversionTests.m">
//
//  EndToEndConversionTests.m
//  pdf22md-objc
//
//  Integration tests for complete PDF to Markdown conversion pipeline
//

#import <XCTest/XCTest.h>
#import "PDF22MDConverter.h"
#import "PDF22MDConversionOptions.h"
#import "PDF22MDError.h"

@interface EndToEndConversionTests : XCTestCase
@property (nonatomic, strong) PDF22MDConverter *converter;
@property (nonatomic, strong) NSString *testResourcesPath;
@property (nonatomic, strong) NSString *tempOutputPath;
@end

@implementation EndToEndConversionTests

- (void)setUp {
    [super setUp];
    self.converter = [[PDF22MDConverter alloc] init];
    
    // Set up test resources path
    NSBundle *bundle = [NSBundle bundleForClass:[self class]];
    self.testResourcesPath = [bundle.resourcePath stringByAppendingPathComponent:@"Tests/Resources"];
    
    // Create temporary output directory
    self.tempOutputPath = [NSTemporaryDirectory() stringByAppendingPathComponent:@"pdf22md-test-output"];
    [[NSFileManager defaultManager] createDirectoryAtPath:self.tempOutputPath 
                              withIntermediateDirectories:YES 
                                               attributes:nil 
                                                    error:nil];
}

- (void)tearDown {
    // Clean up temporary directory
    [[NSFileManager defaultManager] removeItemAtPath:self.tempOutputPath error:nil];
    self.converter = nil;
    [super tearDown];
}

#pragma mark - Complete Workflow Tests

- (void)testSimpleTextDocumentConversion {
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"simple-text.pdf"];
    
    // Skip test if resource file doesn't exist
    if (![self fileExistsAtPath:testPDFPath]) {
        NSLog(@"Test PDF 'simple-text.pdf' not found, skipping test");
        return;
    }
    
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    options.assetsPath = [self.tempOutputPath stringByAppendingPathComponent:@"assets"];
    
    NSError *error = nil;
    NSString *markdown = [self.converter convertPDFAtPath:testPDFPath 
                                              withOptions:options 
                                                    error:&error];
    
    XCTAssertNotNil(markdown, @"Should successfully convert simple text PDF");
    XCTAssertNil(error, @"Should not return error for valid PDF conversion");
    
    // Validate markdown structure
    [self validateBasicMarkdownStructure:markdown];
    
    // Check that assets directory was created (even if empty)
    BOOL isDirectory;
    BOOL assetsExist = [[NSFileManager defaultManager] fileExistsAtPath:options.assetsPath 
                                                            isDirectory:&isDirectory];
    XCTAssertTrue(assetsExist && isDirectory, @"Assets directory should be created");
}

- (void)testComplexDocumentWithImages {
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"complex-with-images.pdf"];
    
    if (![self fileExistsAtPath:testPDFPath]) {
        NSLog(@"Test PDF 'complex-with-images.pdf' not found, skipping test");
        return;
    }
    
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    options.assetsPath = [self.tempOutputPath stringByAppendingPathComponent:@"assets"];
    options.dpi = 200; // Higher DPI for quality
    
    NSError *error = nil;
    NSString *markdown = [self.converter convertPDFAtPath:testPDFPath 
                                              withOptions:options 
                                                    error:&error];
    
    XCTAssertNotNil(markdown, @"Should successfully convert complex PDF with images");
    XCTAssertNil(error, @"Should not return error for valid PDF conversion");
    
    // Validate markdown structure
    [self validateBasicMarkdownStructure:markdown];
    
    // Check for image references in markdown
    XCTAssertTrue([markdown containsString:@"!["], @"Should contain image references");
    XCTAssertTrue([markdown containsString:@"assets/"], @"Should reference assets directory");
    
    // Verify that image files were actually created
    NSArray *assetFiles = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:options.assetsPath error:nil];
    XCTAssertTrue(assetFiles.count > 0, @"Should extract at least one asset file");
    
    // Verify image file formats
    for (NSString *filename in assetFiles) {
        XCTAssertTrue([filename hasSuffix:@".png"] || [filename hasSuffix:@".jpg"], 
                      @"Asset files should be PNG or JPG format");
    }
}

- (void)testLargeDocumentPerformance {
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"large-document.pdf"];
    
    if (![self fileExistsAtPath:testPDFPath]) {
        NSLog(@"Test PDF 'large-document.pdf' not found, skipping test");
        return;
    }
    
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    options.assetsPath = [self.tempOutputPath stringByAppendingPathComponent:@"assets"];
    
    NSDate *startTime = [NSDate date];
    
    NSError *error = nil;
    NSString *markdown = [self.converter convertPDFAtPath:testPDFPath 
                                              withOptions:options 
                                                    error:&error];
    
    NSTimeInterval elapsed = [[NSDate date] timeIntervalSinceDate:startTime];
    
    XCTAssertNotNil(markdown, @"Should successfully convert large PDF");
    XCTAssertNil(error, @"Should not return error for valid large PDF");
    XCTAssertLessThan(elapsed, 30.0, @"Large document conversion should complete within 30 seconds");
    
    NSLog(@"Large document conversion time: %.2f seconds", elapsed);
}

#pragma mark - Error Handling Integration Tests

- (void)testMalformedPDFHandling {
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"malformed.pdf"];
    
    if (![self fileExistsAtPath:testPDFPath]) {
        NSLog(@"Test PDF 'malformed.pdf' not found, skipping test");
        return;
    }
    
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    
    NSError *error = nil;
    NSString *markdown = [self.converter convertPDFAtPath:testPDFPath 
                                              withOptions:options 
                                                    error:&error];
    
    // Should either succeed with partial content or fail gracefully
    if (markdown) {
        XCTAssertNil(error, @"If conversion succeeds, should not return error");
        XCTAssertTrue(markdown.length > 0, @"If conversion succeeds, should return content");
    } else {
        XCTAssertNotNil(error, @"If conversion fails, should return meaningful error");
        XCTAssertNotEqual(error.code, 0, @"Error should have meaningful error code");
        XCTAssertTrue(error.localizedDescription.length > 0, @"Error should have description");
    }
}

- (void)testEncryptedPDFHandling {
    // This test would require an encrypted PDF sample
    // For now, we'll test the expected behavior
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"encrypted.pdf"];
    
    if (![self fileExistsAtPath:testPDFPath]) {
        NSLog(@"Test PDF 'encrypted.pdf' not found, skipping test");
        return;
    }
    
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    
    NSError *error = nil;
    NSString *markdown = [self.converter convertPDFAtPath:testPDFPath 
                                              withOptions:options 
                                                    error:&error];
    
    XCTAssertNil(markdown, @"Should not convert encrypted PDF without password");
    XCTAssertNotNil(error, @"Should return error for encrypted PDF");
    XCTAssertEqual(error.code, PDF22MDErrorEncryptedPDF, @"Should return encrypted PDF error code");
}

#pragma mark - Memory Stress Tests

- (void)testMemoryStabilityUnderLoad {
    // Test multiple conversions to ensure memory stability
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    options.assetsPath = [self.tempOutputPath stringByAppendingPathComponent:@"stress-assets"];
    
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"simple-text.pdf"];
    
    if (![self fileExistsAtPath:testPDFPath]) {
        NSLog(@"Test PDF not found, creating minimal test for memory stability");
        return;
    }
    
    // Run multiple conversions
    for (int i = 0; i < 5; i++) {
        @autoreleasepool {
            NSError *error = nil;
            NSString *markdown = [self.converter convertPDFAtPath:testPDFPath 
                                                      withOptions:options 
                                                            error:&error];
            
            XCTAssertNotNil(markdown, @"Conversion %d should succeed", i + 1);
            XCTAssertNil(error, @"Conversion %d should not return error", i + 1);
        }
    }
}

#pragma mark - Output Validation Tests

- (void)testMarkdownOutputQuality {
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"simple-text.pdf"];
    
    if (![self fileExistsAtPath:testPDFPath]) {
        NSLog(@"Test PDF not found, skipping output quality test");
        return;
    }
    
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    
    NSError *error = nil;
    NSString *markdown = [self.converter convertPDFAtPath:testPDFPath 
                                              withOptions:options 
                                                    error:&error];
    
    XCTAssertNotNil(markdown, @"Should produce markdown output");
    
    if (markdown) {
        [self validateAdvancedMarkdownStructure:markdown];
    }
}

- (void)testExpectedOutputComparison {
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"simple-text.pdf"];
    NSString *expectedPath = [self.testResourcesPath stringByAppendingPathComponent:@"expected-outputs/simple-text.md"];
    
    if (![self fileExistsAtPath:testPDFPath] || ![self fileExistsAtPath:expectedPath]) {
        NSLog(@"Test files not found, skipping expected output comparison");
        return;
    }
    
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    
    NSError *error = nil;
    NSString *actualMarkdown = [self.converter convertPDFAtPath:testPDFPath 
                                                    withOptions:options 
                                                          error:&error];
    
    NSString *expectedMarkdown = [NSString stringWithContentsOfFile:expectedPath 
                                                           encoding:NSUTF8StringEncoding 
                                                              error:nil];
    
    XCTAssertNotNil(actualMarkdown, @"Should produce actual markdown");
    XCTAssertNotNil(expectedMarkdown, @"Should load expected markdown");
    
    if (actualMarkdown && expectedMarkdown) {
        // Normalize whitespace for comparison
        NSString *normalizedActual = [self normalizeWhitespace:actualMarkdown];
        NSString *normalizedExpected = [self normalizeWhitespace:expectedMarkdown];
        
        XCTAssertEqualObjects(normalizedActual, normalizedExpected, 
                              @"Actual output should match expected output");
    }
}

#pragma mark - Helper Methods

- (BOOL)fileExistsAtPath:(NSString *)path {
    return [[NSFileManager defaultManager] fileExistsAtPath:path];
}

- (void)validateBasicMarkdownStructure:(NSString *)markdown {
    XCTAssertTrue(markdown.length > 0, @"Markdown should not be empty");
    
    // Should not contain raw PDF artifacts
    XCTAssertFalse([markdown containsString:@"%%PDF"], @"Should not contain PDF header");
    XCTAssertFalse([markdown containsString:@"endobj"], @"Should not contain PDF objects");
    
    // Should be valid UTF-8
    NSData *data = [markdown dataUsingEncoding:NSUTF8StringEncoding];
    XCTAssertNotNil(data, @"Markdown should be valid UTF-8");
}

- (void)validateAdvancedMarkdownStructure:(NSString *)markdown {
    [self validateBasicMarkdownStructure:markdown];
    
    // Check for proper markdown formatting
    NSArray *lines = [markdown componentsSeparatedByString:@"\n"];
    
    BOOL hasHeadings = NO;
    BOOL hasContent = NO;
    
    for (NSString *line in lines) {
        NSString *trimmed = [line stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
        
        if ([trimmed hasPrefix:@"#"]) {
            hasHeadings = YES;
            // Validate heading format
            XCTAssertTrue([trimmed rangeOfString:@"# "].location != NSNotFound ||
                         [trimmed rangeOfString:@"## "].location != NSNotFound ||
                         [trimmed rangeOfString:@"### "].location != NSNotFound,
                         @"Headings should have proper spacing");
        }
        
        if (trimmed.length > 0 && ![trimmed hasPrefix:@"#"] && ![trimmed hasPrefix:@"!"]) {
            hasContent = YES;
        }
    }
    
    // Don't require headings for all documents, but if present, they should be formatted correctly
    if (hasHeadings) {
        XCTAssertTrue(hasContent, @"Document with headings should also have content");
    }
}

- (NSString *)normalizeWhitespace:(NSString *)text {
    // Normalize line endings and excessive whitespace for comparison
    NSString *normalized = [text stringByReplacingOccurrencesOfString:@"\r\n" withString:@"\n"];
    normalized = [normalized stringByReplacingOccurrencesOfString:@"\r" withString:@"\n"];
    
    // Remove trailing whitespace from lines
    NSMutableArray *lines = [[normalized componentsSeparatedByString:@"\n"] mutableCopy];
    for (NSInteger i = 0; i < lines.count; i++) {
        lines[i] = [lines[i] stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
    }
    
    return [lines componentsJoinedByString:@"\n"];
}

@end
</file>

<file path="pdf22md-objc/Tests/Unit/AssetExtractorTests.m">
//
//  AssetExtractorTests.m
//  pdf22md
//
//  Unit tests for asset extraction and image processing functionality
//

#import <XCTest/XCTest.h>
#import <CoreGraphics/CoreGraphics.h>
#import <ImageIO/ImageIO.h>
#import "../../src/AssetExtractor.h"

@interface AssetExtractorTests : XCTestCase
@property (nonatomic, strong) AssetExtractor *extractor;
@property (nonatomic, strong) NSString *testAssetsPath;
@end

@implementation AssetExtractorTests

- (void)setUp {
    [super setUp];
    self.extractor = [[AssetExtractor alloc] init];
    
    // Create temporary test assets directory
    NSString *tempDir = NSTemporaryDirectory();
    self.testAssetsPath = [tempDir stringByAppendingPathComponent:@"pdf22md-test-assets"];
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    [fileManager createDirectoryAtPath:self.testAssetsPath 
           withIntermediateDirectories:YES 
                            attributes:nil 
                                 error:nil];
}

- (void)tearDown {
    // Clean up test assets directory
    NSFileManager *fileManager = [NSFileManager defaultManager];
    [fileManager removeItemAtPath:self.testAssetsPath error:nil];
    
    self.extractor = nil;
    self.testAssetsPath = nil;
    [super tearDown];
}

#pragma mark - Basic Functionality Tests

- (void)testExtractorInitialization {
    XCTAssertNotNil(self.extractor, @"AssetExtractor should initialize successfully");
}

- (void)testSetAssetsFolderPath {
    NSString *testPath = @"/tmp/test-assets";
    [self.extractor setAssetsFolderPath:testPath];
    
    // Note: We can't directly test the private property, but we can test that the method doesn't crash
    // and that subsequent operations work as expected
    XCTAssertTrue(YES, @"setAssetsFolderPath should complete without crashing");
}

#pragma mark - Image Format Detection Tests

- (void)testFormatOptimizationLogic {
    // Test the format optimization logic with synthetic images
    
    // Create a simple test image
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, 100, 100, 8, 0, colorSpace, 
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (context) {
        // Fill with a simple color
        CGContextSetRGBFillColor(context, 1.0, 0.0, 0.0, 1.0);
        CGContextFillRect(context, CGRectMake(0, 0, 100, 100));
        
        CGImageRef testImage = CGBitmapContextCreateImage(context);
        CGContextRelease(context);
        
        if (testImage) {
            // Test format decision logic
            BOOL shouldUseJPEG = [self.extractor shouldUseJPEGForImage:testImage];
            
            // For a simple solid color image, PNG should be preferred
            // (though the exact logic depends on implementation)
            XCTAssertTrue(shouldUseJPEG == YES || shouldUseJPEG == NO, 
                         @"shouldUseJPEGForImage should return a boolean value");
            
            CGImageRelease(testImage);
        }
    }
}

- (void)testImageSaving {
    // Test image saving functionality
    
    // Create a minimal test image
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, 50, 50, 8, 0, colorSpace, 
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (context) {
        // Create a gradient pattern for testing
        CGContextSetRGBFillColor(context, 0.5, 0.5, 1.0, 1.0);
        CGContextFillRect(context, CGRectMake(0, 0, 50, 50));
        
        CGImageRef testImage = CGBitmapContextCreateImage(context);
        CGContextRelease(context);
        
        if (testImage) {
            [self.extractor setAssetsFolderPath:self.testAssetsPath];
            
            NSString *savedPath = [self.extractor saveImage:testImage withBaseName:@"test_image"];
            
            if (savedPath) {
                // Verify the file was created
                NSString *fullPath = [self.testAssetsPath stringByAppendingPathComponent:savedPath];
                NSFileManager *fileManager = [NSFileManager defaultManager];
                XCTAssertTrue([fileManager fileExistsAtPath:fullPath], 
                             @"Saved image file should exist at path: %@", fullPath);
                
                // Verify it's a valid image file
                NSData *imageData = [NSData dataWithContentsOfFile:fullPath];
                XCTAssertNotNil(imageData, @"Should be able to read saved image data");
                XCTAssertTrue(imageData.length > 0, @"Saved image should have non-zero size");
            } else {
                XCTFail(@"saveImage should return a non-nil path");
            }
            
            CGImageRelease(testImage);
        }
    }
}

#pragma mark - File Naming Tests

- (void)testUniqueFileNaming {
    // Test that the extractor generates unique filenames
    [self.extractor setAssetsFolderPath:self.testAssetsPath];
    
    // Create multiple test images and verify unique naming
    for (int i = 0; i < 3; i++) {
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        CGContextRef context = CGBitmapContextCreate(NULL, 20, 20, 8, 0, colorSpace, 
                                                    kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
        CGColorSpaceRelease(colorSpace);
        
        if (context) {
            // Use different colors for each image
            CGFloat red = (i == 0) ? 1.0 : 0.0;
            CGFloat green = (i == 1) ? 1.0 : 0.0;
            CGFloat blue = (i == 2) ? 1.0 : 0.0;
            
            CGContextSetRGBFillColor(context, red, green, blue, 1.0);
            CGContextFillRect(context, CGRectMake(0, 0, 20, 20));
            
            CGImageRef testImage = CGBitmapContextCreateImage(context);
            CGContextRelease(context);
            
            if (testImage) {
                NSString *savedPath = [self.extractor saveImage:testImage withBaseName:@"test"];
                XCTAssertNotNil(savedPath, @"Should get a valid filename for image %d", i);
                
                CGImageRelease(testImage);
            }
        }
    }
    
    // Verify multiple files were created
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSArray *contents = [fileManager contentsOfDirectoryAtPath:self.testAssetsPath error:nil];
    XCTAssertTrue(contents.count >= 1, @"Should have created at least one image file");
}

#pragma mark - Error Handling Tests

- (void)testNilImageHandling {
    [self.extractor setAssetsFolderPath:self.testAssetsPath];
    
    NSString *result = [self.extractor saveImage:NULL withBaseName:@"test"];
    XCTAssertNil(result, @"Should return nil for NULL image");
}

- (void)testInvalidAssetsFolderHandling {
    // Test with invalid assets folder path
    NSString *invalidPath = @"/invalid/path/that/cannot/be/created";
    [self.extractor setAssetsFolderPath:invalidPath];
    
    // Create a test image
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, 10, 10, 8, 0, colorSpace, 
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (context) {
        CGContextSetRGBFillColor(context, 1.0, 1.0, 1.0, 1.0);
        CGContextFillRect(context, CGRectMake(0, 0, 10, 10));
        
        CGImageRef testImage = CGBitmapContextCreateImage(context);
        CGContextRelease(context);
        
        if (testImage) {
            NSString *result = [self.extractor saveImage:testImage withBaseName:@"test"];
            // Should handle the error gracefully (exact behavior depends on implementation)
            // At minimum, should not crash
            
            CGImageRelease(testImage);
        }
    }
}

#pragma mark - Performance Tests

- (void)testImageSavingPerformance {
    [self.extractor setAssetsFolderPath:self.testAssetsPath];
    
    [self measureBlock:^{
        // Create and save a test image
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        CGContextRef context = CGBitmapContextCreate(NULL, 100, 100, 8, 0, colorSpace, 
                                                    kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
        CGColorSpaceRelease(colorSpace);
        
        if (context) {
            CGContextSetRGBFillColor(context, 0.5, 0.5, 0.5, 1.0);
            CGContextFillRect(context, CGRectMake(0, 0, 100, 100));
            
            CGImageRef testImage = CGBitmapContextCreateImage(context);
            CGContextRelease(context);
            
            if (testImage) {
                [self.extractor saveImage:testImage withBaseName:@"perf_test"];
                CGImageRelease(testImage);
            }
        }
    }];
}

#pragma mark - Memory Management Tests

- (void)testMemoryManagement {
    // Test that multiple image operations don't cause memory issues
    [self.extractor setAssetsFolderPath:self.testAssetsPath];
    
    for (int i = 0; i < 10; i++) {
        @autoreleasepool {
            CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
            CGContextRef context = CGBitmapContextCreate(NULL, 50, 50, 8, 0, colorSpace, 
                                                        kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
            CGColorSpaceRelease(colorSpace);
            
            if (context) {
                CGContextSetRGBFillColor(context, (i % 3) / 3.0, ((i + 1) % 3) / 3.0, ((i + 2) % 3) / 3.0, 1.0);
                CGContextFillRect(context, CGRectMake(0, 0, 50, 50));
                
                CGImageRef testImage = CGBitmapContextCreateImage(context);
                CGContextRelease(context);
                
                if (testImage) {
                    NSString *baseName = [NSString stringWithFormat:@"memory_test_%d", i];
                    [self.extractor saveImage:testImage withBaseName:baseName];
                    CGImageRelease(testImage);
                }
            }
        }
    }
    
    // Verify files were created
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSArray *contents = [fileManager contentsOfDirectoryAtPath:self.testAssetsPath error:nil];
    XCTAssertTrue(contents.count > 0, @"Should have created image files during memory test");
}

@end
</file>

<file path="pdf22md-objc/Tests/Unit/ContentElementTests.m">
//
//  ContentElementTests.m
//  pdf22md
//
//  Unit tests for ContentElement model and text/image element functionality
//

#import <XCTest/XCTest.h>
#import <CoreGraphics/CoreGraphics.h>
#import "../../src/ContentElement.h"

@interface ContentElementTests : XCTestCase
@end

@implementation ContentElementTests

- (void)setUp {
    [super setUp];
}

- (void)tearDown {
    [super tearDown];
}

#pragma mark - ContentElement Protocol Tests

- (void)testContentElementProtocolExists {
    // Verify that the ContentElement protocol exists and can be referenced
    Protocol *contentElementProtocol = @protocol(ContentElement);
    XCTAssertNotNil(contentElementProtocol, @"ContentElement protocol should exist");
}

#pragma mark - Text Element Tests

- (void)testTextElementCreation {
    // Test creation of text elements
    NSString *testText = @"Sample text content";
    CGRect testBounds = CGRectMake(10, 20, 200, 30);
    NSInteger testPage = 1;
    
    // Check if TextElement class exists and can be instantiated
    Class textElementClass = NSClassFromString(@"TextElement");
    if (textElementClass) {
        // Test basic instantiation
        id textElement = [[textElementClass alloc] init];
        XCTAssertNotNil(textElement, @"TextElement should be instantiable");
        
        // Test that it conforms to ContentElement protocol
        XCTAssertTrue([textElement conformsToProtocol:@protocol(ContentElement)], 
                     @"TextElement should conform to ContentElement protocol");
    } else {
        XCTFail(@"TextElement class should be available");
    }
}

- (void)testTextElementProperties {
    Class textElementClass = NSClassFromString(@"TextElement");
    if (textElementClass) {
        id textElement = [[textElementClass alloc] init];
        
        // Test basic property access (using KVC since we don't have direct access to the interface)
        NSString *testText = @"Test content";
        
        // Check if text property exists and can be set/get
        if ([textElement respondsToSelector:@selector(setText:)]) {
            [textElement performSelector:@selector(setText:) withObject:testText];
            
            if ([textElement respondsToSelector:@selector(text)]) {
                NSString *retrievedText = [textElement performSelector:@selector(text)];
                XCTAssertEqualObjects(retrievedText, testText, @"Text property should store and retrieve correctly");
            }
        }
        
        // Test bounds property if available
        if ([textElement respondsToSelector:@selector(setBounds:)]) {
            CGRect testBounds = CGRectMake(5, 10, 100, 20);
            NSValue *boundsValue = [NSValue valueWithCGRect:testBounds];
            [textElement performSelector:@selector(setBounds:) withObject:boundsValue];
            
            if ([textElement respondsToSelector:@selector(bounds)]) {
                NSValue *retrievedBounds = [textElement performSelector:@selector(bounds)];
                CGRect retrievedRect = [retrievedBounds CGRectValue];
                XCTAssertTrue(CGRectEqualToRect(retrievedRect, testBounds), 
                             @"Bounds property should store and retrieve correctly");
            }
        }
    }
}

#pragma mark - Image Element Tests

- (void)testImageElementCreation {
    Class imageElementClass = NSClassFromString(@"ImageElement");
    if (imageElementClass) {
        // Test basic instantiation
        id imageElement = [[imageElementClass alloc] init];
        XCTAssertNotNil(imageElement, @"ImageElement should be instantiable");
        
        // Test that it conforms to ContentElement protocol
        XCTAssertTrue([imageElement conformsToProtocol:@protocol(ContentElement)], 
                     @"ImageElement should conform to ContentElement protocol");
    } else {
        XCTFail(@"ImageElement class should be available");
    }
}

- (void)testImageElementWithCGImage {
    Class imageElementClass = NSClassFromString(@"ImageElement");
    if (imageElementClass) {
        // Create a test CGImage
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        CGContextRef context = CGBitmapContextCreate(NULL, 50, 50, 8, 0, colorSpace, 
                                                    kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
        CGColorSpaceRelease(colorSpace);
        
        if (context) {
            CGContextSetRGBFillColor(context, 1.0, 0.0, 0.0, 1.0);
            CGContextFillRect(context, CGRectMake(0, 0, 50, 50));
            
            CGImageRef testImage = CGBitmapContextCreateImage(context);
            CGContextRelease(context);
            
            if (testImage) {
                id imageElement = [[imageElementClass alloc] init];
                
                // Test image property if available
                if ([imageElement respondsToSelector:@selector(setImage:)]) {
                    // Note: CGImageRef is not an object, so we need to handle it appropriately
                    // This test may need adjustment based on the actual implementation
                    XCTAssertTrue(YES, @"Image element should be able to handle CGImageRef");
                }
                
                CGImageRelease(testImage);
            }
        }
    }
}

#pragma mark - Markdown Generation Tests

- (void)testMarkdownGeneration {
    // Test that elements can generate markdown representation
    Class textElementClass = NSClassFromString(@"TextElement");
    if (textElementClass) {
        id textElement = [[textElementClass alloc] init];
        
        if ([textElement respondsToSelector:@selector(markdownRepresentation)]) {
            NSString *markdown = [textElement performSelector:@selector(markdownRepresentation)];
            XCTAssertTrue([markdown isKindOfClass:[NSString class]], 
                         @"markdownRepresentation should return an NSString");
        } else {
            XCTFail(@"TextElement should implement markdownRepresentation method");
        }
    }
}

#pragma mark - Bounds and Positioning Tests

- (void)testBoundsHandling {
    // Test bounds property across different element types
    NSArray *elementClassNames = @[@"TextElement", @"ImageElement"];
    
    for (NSString *className in elementClassNames) {
        Class elementClass = NSClassFromString(className);
        if (elementClass) {
            id element = [[elementClass alloc] init];
            
            // Test bounds property
            if ([element respondsToSelector:@selector(bounds)]) {
                // Default bounds should be valid
                CGRect bounds = CGRectZero;
                if ([element respondsToSelector:@selector(bounds)]) {
                    NSValue *boundsValue = [element performSelector:@selector(bounds)];
                    if (boundsValue) {
                        bounds = [boundsValue CGRectValue];
                    }
                }
                
                // Bounds should be a valid rectangle (finite values)
                XCTAssertTrue(isfinite(bounds.origin.x) && isfinite(bounds.origin.y) && 
                             isfinite(bounds.size.width) && isfinite(bounds.size.height),
                             @"%@ bounds should have finite values", className);
            }
        }
    }
}

#pragma mark - Page Index Tests

- (void)testPageIndexProperty {
    // Test page index property across element types
    NSArray *elementClassNames = @[@"TextElement", @"ImageElement"];
    
    for (NSString *className in elementClassNames) {
        Class elementClass = NSClassFromString(className);
        if (elementClass) {
            id element = [[elementClass alloc] init];
            
            if ([element respondsToSelector:@selector(pageIndex)]) {
                NSInteger pageIndex = [[element performSelector:@selector(pageIndex)] integerValue];
                XCTAssertTrue(pageIndex >= 0, @"%@ pageIndex should be non-negative", className);
            }
            
            // Test setting page index if setter exists
            if ([element respondsToSelector:@selector(setPageIndex:)]) {
                NSInteger testPageIndex = 5;
                [element performSelector:@selector(setPageIndex:) withObject:@(testPageIndex)];
                
                if ([element respondsToSelector:@selector(pageIndex)]) {
                    NSInteger retrievedIndex = [[element performSelector:@selector(pageIndex)] integerValue];
                    XCTAssertEqual(retrievedIndex, testPageIndex, 
                                  @"%@ should store and retrieve pageIndex correctly", className);
                }
            }
        }
    }
}

#pragma mark - Memory Management Tests

- (void)testElementMemoryManagement {
    // Test that elements can be created and destroyed without memory issues
    for (int i = 0; i < 100; i++) {
        @autoreleasepool {
            Class textElementClass = NSClassFromString(@"TextElement");
            if (textElementClass) {
                id textElement = [[textElementClass alloc] init];
                
                // Set some properties to test memory handling
                if ([textElement respondsToSelector:@selector(setText:)]) {
                    NSString *testText = [NSString stringWithFormat:@"Test text %d", i];
                    [textElement performSelector:@selector(setText:) withObject:testText];
                }
                
                textElement = nil;
            }
            
            Class imageElementClass = NSClassFromString(@"ImageElement");
            if (imageElementClass) {
                id imageElement = [[imageElementClass alloc] init];
                imageElement = nil;
            }
        }
    }
    
    XCTAssertTrue(YES, @"Memory management test completed without crashes");
}

#pragma mark - Performance Tests

- (void)testElementCreationPerformance {
    [self measureBlock:^{
        for (int i = 0; i < 1000; i++) {
            @autoreleasepool {
                Class textElementClass = NSClassFromString(@"TextElement");
                if (textElementClass) {
                    id textElement = [[textElementClass alloc] init];
                    textElement = nil;
                }
            }
        }
    }];
}

- (void)testMarkdownGenerationPerformance {
    Class textElementClass = NSClassFromString(@"TextElement");
    if (textElementClass) {
        id textElement = [[textElementClass alloc] init];
        
        if ([textElement respondsToSelector:@selector(setText:)]) {
            [textElement performSelector:@selector(setText:) withObject:@"Sample text for performance testing"];
        }
        
        [self measureBlock:^{
            for (int i = 0; i < 1000; i++) {
                if ([textElement respondsToSelector:@selector(markdownRepresentation)]) {
                    [textElement performSelector:@selector(markdownRepresentation)];
                }
            }
        }];
    }
}

@end
</file>

<file path="pdf22md-objc/Tests/Unit/PDF22MDAssetManagerTests.m">
//
//  PDF22MDAssetManagerTests.m
//  pdf22md-objc
//
//  Unit tests for PDF22MDAssetManager image extraction and management
//

#import <XCTest/XCTest.h>
#import "PDF22MDAssetManager.h"
#import "PDF22MDImageElement.h"
#import "PDF22MDError.h"

@interface PDF22MDAssetManagerTests : XCTestCase
@property (nonatomic, strong) PDF22MDAssetManager *assetManager;
@property (nonatomic, strong) NSString *tempAssetsPath;
@end

@implementation PDF22MDAssetManagerTests

- (void)setUp {
    [super setUp];
    
    // Create temporary assets directory
    self.tempAssetsPath = [NSTemporaryDirectory() stringByAppendingPathComponent:@"test-assets"];
    [[NSFileManager defaultManager] createDirectoryAtPath:self.tempAssetsPath 
                              withIntermediateDirectories:YES 
                                               attributes:nil 
                                                    error:nil];
    
    self.assetManager = [[PDF22MDAssetManager alloc] initWithAssetsPath:self.tempAssetsPath];
}

- (void)tearDown {
    // Clean up temporary directory
    [[NSFileManager defaultManager] removeItemAtPath:self.tempAssetsPath error:nil];
    self.assetManager = nil;
    [super tearDown];
}

#pragma mark - Initialization Tests

- (void)testAssetManagerInitialization {
    XCTAssertNotNil(self.assetManager, @"Asset manager should initialize successfully");
}

- (void)testInitializationWithNilPath {
    PDF22MDAssetManager *manager = [[PDF22MDAssetManager alloc] initWithAssetsPath:nil];
    XCTAssertNotNil(manager, @"Asset manager should handle nil assets path");
}

- (void)testAssetsDirectoryCreation {
    NSString *newPath = [NSTemporaryDirectory() stringByAppendingPathComponent:@"new-assets"];
    PDF22MDAssetManager *manager = [[PDF22MDAssetManager alloc] initWithAssetsPath:newPath];
    
    NSError *error = nil;
    BOOL success = [manager ensureAssetsDirectoryExists:&error];
    
    XCTAssertTrue(success, @"Should successfully create assets directory");
    XCTAssertNil(error, @"Should not return error when creating valid directory");
    
    BOOL isDirectory;
    BOOL exists = [[NSFileManager defaultManager] fileExistsAtPath:newPath isDirectory:&isDirectory];
    XCTAssertTrue(exists && isDirectory, @"Assets directory should exist and be a directory");
    
    // Clean up
    [[NSFileManager defaultManager] removeItemAtPath:newPath error:nil];
}

#pragma mark - Image Processing Tests

- (void)testImageElementCreation {
    // Create a simple test image (1x1 pixel)
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, 1, 1, 8, 4, colorSpace, kCGImageAlphaZero);
    CGImageRef cgImage = CGBitmapContextCreateImage(context);
    
    PDF22MDImageElement *element = [[PDF22MDImageElement alloc] initWithImage:cgImage 
                                                                        bounds:CGRectMake(0, 0, 100, 100) 
                                                                    pageNumber:1];
    
    XCTAssertNotNil(element, @"Should create image element successfully");
    XCTAssertEqual(element.pageNumber, 1, @"Page number should be set correctly");
    XCTAssertEqualWithAccuracy(element.bounds.size.width, 100.0, 0.1, @"Width should be set correctly");
    
    // Clean up
    CGImageRelease(cgImage);
    CGContextRelease(context);
    CGColorSpaceRelease(colorSpace);
}

- (void)testImageFormatSelection {
    // Test PNG selection for images with transparency
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, 10, 10, 8, 40, colorSpace, kCGImageAlphaFirst);
    CGImageRef transparentImage = CGBitmapContextCreateImage(context);
    
    NSString *format = [self.assetManager preferredFormatForImage:transparentImage];
    XCTAssertEqualObjects(format, @"png", @"Should prefer PNG for images with transparency");
    
    CGImageRelease(transparentImage);
    CGContextRelease(context);
    CGColorSpaceRelease(colorSpace);
}

- (void)testImageFilenameGeneration {
    NSString *filename1 = [self.assetManager generateFilenameForImageAtIndex:0 withFormat:@"png"];
    NSString *filename2 = [self.assetManager generateFilenameForImageAtIndex:1 withFormat:@"jpg"];
    NSString *filename3 = [self.assetManager generateFilenameForImageAtIndex:99 withFormat:@"png"];
    
    XCTAssertEqualObjects(filename1, @"image_001.png", @"Should generate correct filename for index 0");
    XCTAssertEqualObjects(filename2, @"image_002.jpg", @"Should generate correct filename for index 1");
    XCTAssertEqualObjects(filename3, @"image_100.png", @"Should generate correct filename for index 99");
}

#pragma mark - File Path Tests

- (void)testRelativePathGeneration {
    NSString *filename = @"image_001.png";
    NSString *relativePath = [self.assetManager relativePathForFilename:filename];
    
    NSString *expectedPath = [@"test-assets" stringByAppendingPathComponent:filename];
    XCTAssertEqualObjects(relativePath, expectedPath, @"Should generate correct relative path");
}

- (void)testAbsolutePathGeneration {
    NSString *filename = @"image_001.png";
    NSString *absolutePath = [self.assetManager absolutePathForFilename:filename];
    
    NSString *expectedPath = [self.tempAssetsPath stringByAppendingPathComponent:filename];
    XCTAssertEqualObjects(absolutePath, expectedPath, @"Should generate correct absolute path");
}

#pragma mark - Error Handling Tests

- (void)testInvalidAssetsPathHandling {
    // Try to create assets directory in a location that requires root access
    NSString *invalidPath = @"/usr/bin/invalid-assets";
    PDF22MDAssetManager *manager = [[PDF22MDAssetManager alloc] initWithAssetsPath:invalidPath];
    
    NSError *error = nil;
    BOOL success = [manager ensureAssetsDirectoryExists:&error];
    
    XCTAssertFalse(success, @"Should fail to create directory in invalid location");
    XCTAssertNotNil(error, @"Should return error for invalid directory creation");
    XCTAssertEqual(error.code, PDF22MDErrorAssetFolderCreation, @"Should return appropriate error code");
}

- (void)testNilImageHandling {
    NSString *result = [self.assetManager preferredFormatForImage:NULL];
    XCTAssertEqualObjects(result, @"png", @"Should default to PNG for nil image");
}

#pragma mark - Integration Tests

- (void)testCompleteImageSaveWorkflow {
    // Create a test image
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, 50, 50, 8, 200, colorSpace, kCGImageAlphaZero);
    
    // Draw something simple
    CGContextSetRGBFillColor(context, 1.0, 0.0, 0.0, 1.0);
    CGContextFillRect(context, CGRectMake(0, 0, 50, 50));
    
    CGImageRef testImage = CGBitmapContextCreateImage(context);
    
    // Test the save workflow
    NSError *error = nil;
    BOOL directoryCreated = [self.assetManager ensureAssetsDirectoryExists:&error];
    XCTAssertTrue(directoryCreated, @"Should create assets directory");
    
    NSString *filename = [self.assetManager generateFilenameForImageAtIndex:0 withFormat:@"png"];
    NSString *absolutePath = [self.assetManager absolutePathForFilename:filename];
    
    // Save image (this would normally be done by the asset manager)
    NSData *imageData = (__bridge_transfer NSData *)CGImagePNGRepresentation(testImage);
    BOOL saved = [imageData writeToFile:absolutePath atomically:YES];
    XCTAssertTrue(saved, @"Should save image successfully");
    
    // Verify file exists
    BOOL fileExists = [[NSFileManager defaultManager] fileExistsAtPath:absolutePath];
    XCTAssertTrue(fileExists, @"Saved image file should exist");
    
    // Clean up
    CGImageRelease(testImage);
    CGContextRelease(context);
    CGColorSpaceRelease(colorSpace);
}

#pragma mark - Performance Tests

- (void)testMultipleImageHandling {
    NSMutableArray *images = [NSMutableArray array];
    
    // Create multiple test images
    for (int i = 0; i < 10; i++) {
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        CGContextRef context = CGBitmapContextCreate(NULL, 10, 10, 8, 40, colorSpace, kCGImageAlphaZero);
        CGImageRef image = CGBitmapContextCreateImage(context);
        
        [images addObject:(__bridge id)image];
        
        CGContextRelease(context);
        CGColorSpaceRelease(colorSpace);
    }
    
    NSDate *startTime = [NSDate date];
    
    // Test filename generation for all images
    for (int i = 0; i < images.count; i++) {
        NSString *filename = [self.assetManager generateFilenameForImageAtIndex:i withFormat:@"png"];
        XCTAssertNotNil(filename, @"Should generate filename for image %d", i);
    }
    
    NSTimeInterval elapsed = [[NSDate date] timeIntervalSinceDate:startTime];
    XCTAssertLessThan(elapsed, 1.0, @"Should handle multiple images quickly");
    
    // Clean up images
    for (id image in images) {
        CGImageRelease((__bridge CGImageRef)image);
    }
}

// Helper function for PNG representation (normally would be in asset manager)
CFDataRef CGImagePNGRepresentation(CGImageRef image) {
    CFMutableDataRef data = CFDataCreateMutable(NULL, 0);
    CGImageDestinationRef destination = CGImageDestinationCreateWithData(data, kUTTypePNG, 1, NULL);
    
    if (destination) {
        CGImageDestinationAddImage(destination, image, NULL);
        CGImageDestinationFinalize(destination);
        CFRelease(destination);
    }
    
    return data;
}

@end
</file>

<file path="pdf22md-objc/Tests/Unit/PDF22MDConverterTests.m">
//
//  PDF22MDConverterTests.m
//  pdf22md-objc
//
//  Unit tests for PDF22MDConverter core functionality
//

#import <XCTest/XCTest.h>
#import "PDF22MDConverter.h"
#import "PDF22MDConversionOptions.h"
#import "PDF22MDError.h"

@interface PDF22MDConverterTests : XCTestCase
@property (nonatomic, strong) PDF22MDConverter *converter;
@property (nonatomic, strong) PDF22MDConversionOptions *defaultOptions;
@property (nonatomic, strong) NSString *testResourcesPath;
@end

@implementation PDF22MDConverterTests

- (void)setUp {
    [super setUp];
    self.converter = [[PDF22MDConverter alloc] init];
    self.defaultOptions = [[PDF22MDConversionOptions alloc] init];
    
    // Set up test resources path
    NSBundle *bundle = [NSBundle bundleForClass:[self class]];
    self.testResourcesPath = [bundle.resourcePath stringByAppendingPathComponent:@"Tests/Resources"];
}

- (void)tearDown {
    self.converter = nil;
    self.defaultOptions = nil;
    [super tearDown];
}

#pragma mark - Initialization Tests

- (void)testConverterInitialization {
    XCTAssertNotNil(self.converter, @"Converter should initialize successfully");
}

- (void)testDefaultOptionsInitialization {
    XCTAssertNotNil(self.defaultOptions, @"Default options should initialize successfully");
    XCTAssertEqual(self.defaultOptions.dpi, 144, @"Default DPI should be 144");
    XCTAssertNil(self.defaultOptions.assetsPath, @"Default assets path should be nil");
}

#pragma mark - Input Validation Tests

- (void)testNilInputPathHandling {
    NSError *error = nil;
    NSString *result = [self.converter convertPDFAtPath:nil 
                                            withOptions:self.defaultOptions 
                                                  error:&error];
    
    XCTAssertNil(result, @"Should return nil for nil input path");
    XCTAssertNotNil(error, @"Should provide error for nil input path");
    XCTAssertEqual(error.code, PDF22MDErrorInvalidInput, @"Should return invalid input error");
}

- (void)testNonExistentFileHandling {
    NSError *error = nil;
    NSString *nonExistentPath = @"/tmp/nonexistent_file.pdf";
    NSString *result = [self.converter convertPDFAtPath:nonExistentPath 
                                            withOptions:self.defaultOptions 
                                                  error:&error];
    
    XCTAssertNil(result, @"Should return nil for nonexistent file");
    XCTAssertNotNil(error, @"Should provide error for nonexistent file");
    XCTAssertEqual(error.code, PDF22MDErrorFileNotFound, @"Should return file not found error");
}

- (void)testNonPDFFileHandling {
    NSError *error = nil;
    
    // Create a temporary text file
    NSString *tempPath = [NSTemporaryDirectory() stringByAppendingPathComponent:@"test.txt"];
    [@"This is not a PDF" writeToFile:tempPath 
                           atomically:YES 
                             encoding:NSUTF8StringEncoding 
                                error:nil];
    
    NSString *result = [self.converter convertPDFAtPath:tempPath 
                                            withOptions:self.defaultOptions 
                                                  error:&error];
    
    XCTAssertNil(result, @"Should return nil for non-PDF file");
    XCTAssertNotNil(error, @"Should provide error for non-PDF file");
    XCTAssertEqual(error.code, PDF22MDErrorInvalidPDF, @"Should return invalid PDF error");
    
    // Clean up
    [[NSFileManager defaultManager] removeItemAtPath:tempPath error:nil];
}

#pragma mark - Basic Conversion Tests

- (void)testBasicTextConversion {
    // This test would require a simple test PDF file
    // For now, we'll create a placeholder that demonstrates the expected behavior
    
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"simple-text.pdf"];
    
    // Skip test if resource file doesn't exist (expected during initial setup)
    if (![[NSFileManager defaultManager] fileExistsAtPath:testPDFPath]) {
        NSLog(@"Test PDF not found at %@, skipping test", testPDFPath);
        return;
    }
    
    NSError *error = nil;
    NSString *result = [self.converter convertPDFAtPath:testPDFPath 
                                            withOptions:self.defaultOptions 
                                                  error:&error];
    
    XCTAssertNotNil(result, @"Should successfully convert simple text PDF");
    XCTAssertNil(error, @"Should not return error for valid PDF");
    XCTAssertTrue([result containsString:@"#"], @"Should contain markdown headers");
    XCTAssertTrue(result.length > 0, @"Should return non-empty markdown");
}

#pragma mark - Options Validation Tests

- (void)testCustomDPIOption {
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    options.dpi = 300;
    
    XCTAssertEqual(options.dpi, 300, @"Should accept custom DPI value");
}

- (void)testAssetsPathOption {
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    options.assetsPath = @"/tmp/assets";
    
    XCTAssertEqualObjects(options.assetsPath, @"/tmp/assets", @"Should accept custom assets path");
}

#pragma mark - Memory Management Tests

- (void)testMemoryManagement {
    // Test that repeated conversions don't cause memory leaks
    for (int i = 0; i < 10; i++) {
        @autoreleasepool {
            PDF22MDConverter *tempConverter = [[PDF22MDConverter alloc] init];
            PDF22MDConversionOptions *tempOptions = [[PDF22MDConversionOptions alloc] init];
            
            XCTAssertNotNil(tempConverter, @"Converter should initialize in loop iteration %d", i);
            XCTAssertNotNil(tempOptions, @"Options should initialize in loop iteration %d", i);
        }
    }
}

#pragma mark - Error Handling Tests

- (void)testErrorMessageQuality {
    NSError *error = nil;
    NSString *result = [self.converter convertPDFAtPath:@"/nonexistent/path.pdf" 
                                            withOptions:self.defaultOptions 
                                                  error:&error];
    
    XCTAssertNil(result, @"Should return nil for invalid path");
    XCTAssertNotNil(error, @"Should provide error");
    XCTAssertNotNil(error.localizedDescription, @"Error should have localized description");
    XCTAssertTrue(error.localizedDescription.length > 0, @"Error description should not be empty");
    XCTAssertFalse([error.localizedDescription containsString:@"nil"], @"Error description should not contain 'nil'");
}

@end
</file>

<file path="pdf22md-objc/Tests/Unit/PDF22MDFontAnalyzerTests.m">
//
//  PDF22MDFontAnalyzerTests.m
//  pdf22md-objc
//
//  Unit tests for PDF22MDFontAnalyzer heading detection logic
//

#import <XCTest/XCTest.h>
#import "PDF22MDFontAnalyzer.h"

@interface PDF22MDFontAnalyzerTests : XCTestCase
@property (nonatomic, strong) PDF22MDFontAnalyzer *analyzer;
@end

@implementation PDF22MDFontAnalyzerTests

- (void)setUp {
    [super setUp];
    self.analyzer = [[PDF22MDFontAnalyzer alloc] init];
}

- (void)tearDown {
    self.analyzer = nil;
    [super tearDown];
}

#pragma mark - Initialization Tests

- (void)testAnalyzerInitialization {
    XCTAssertNotNil(self.analyzer, @"Font analyzer should initialize successfully");
}

#pragma mark - Font Size Analysis Tests

- (void)testBasicFontSizeAnalysis {
    // Test the core font size analysis functionality
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    
    // Simulate typical document font usage
    fontSizes[@"12.0"] = @100;  // Body text - most frequent
    fontSizes[@"18.0"] = @5;    // Major heading
    fontSizes[@"16.0"] = @8;    // Minor heading
    fontSizes[@"14.0"] = @12;   // Subheading
    
    [self.analyzer analyzeFontSizes:fontSizes];
    
    // Test heading level assignment
    NSInteger h1Level = [self.analyzer headingLevelForFontSize:18.0];
    NSInteger h2Level = [self.analyzer headingLevelForFontSize:16.0];
    NSInteger h3Level = [self.analyzer headingLevelForFontSize:14.0];
    NSInteger bodyLevel = [self.analyzer headingLevelForFontSize:12.0];
    
    XCTAssertEqual(h1Level, 1, @"Largest non-body font should be H1");
    XCTAssertEqual(h2Level, 2, @"Second largest font should be H2");
    XCTAssertEqual(h3Level, 3, @"Third largest font should be H3");
    XCTAssertEqual(bodyLevel, 0, @"Most frequent font should be body text (level 0)");
}

- (void)testSingleFontSizeDocument {
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    fontSizes[@"12.0"] = @100;  // Only one font size
    
    [self.analyzer analyzeFontSizes:fontSizes];
    
    NSInteger level = [self.analyzer headingLevelForFontSize:12.0];
    XCTAssertEqual(level, 0, @"Single font size should be treated as body text");
}

- (void)testEmptyFontAnalysis {
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    
    [self.analyzer analyzeFontSizes:fontSizes];
    
    NSInteger level = [self.analyzer headingLevelForFontSize:12.0];
    XCTAssertEqual(level, 0, @"Unknown font size should default to body text");
}

#pragma mark - Edge Case Tests

- (void)testVerySmallFontSizes {
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    fontSizes[@"8.0"] = @50;    // Small body text
    fontSizes[@"10.0"] = @5;    // Slightly larger
    
    [self.analyzer analyzeFontSizes:fontSizes];
    
    NSInteger smallLevel = [self.analyzer headingLevelForFontSize:8.0];
    NSInteger largerLevel = [self.analyzer headingLevelForFontSize:10.0];
    
    XCTAssertEqual(smallLevel, 0, @"Most frequent small font should be body text");
    XCTAssertEqual(largerLevel, 1, @"Less frequent larger font should be heading");
}

- (void)testVeryLargeFontSizes {
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    fontSizes[@"12.0"] = @100;  // Body text
    fontSizes[@"72.0"] = @1;    // Very large title
    fontSizes[@"48.0"] = @2;    // Large heading
    fontSizes[@"36.0"] = @3;    // Medium heading
    
    [self.analyzer analyzeFontSizes:fontSizes];
    
    NSInteger titleLevel = [self.analyzer headingLevelForFontSize:72.0];
    NSInteger h1Level = [self.analyzer headingLevelForFontSize:48.0];
    NSInteger h2Level = [self.analyzer headingLevelForFontSize:36.0];
    
    XCTAssertEqual(titleLevel, 1, @"Largest font should be H1");
    XCTAssertEqual(h1Level, 2, @"Second largest should be H2");
    XCTAssertEqual(h2Level, 3, @"Third largest should be H3");
}

#pragma mark - Frequency Analysis Tests

- (void)testFrequencyBasedBodyTextDetection {
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    fontSizes[@"12.0"] = @200;  // Very frequent - clearly body text
    fontSizes[@"14.0"] = @150;  // Also frequent - might be body text too
    fontSizes[@"18.0"] = @5;    // Infrequent - heading
    
    [self.analyzer analyzeFontSizes:fontSizes];
    
    NSInteger mostFrequentLevel = [self.analyzer headingLevelForFontSize:12.0];
    NSInteger secondFrequentLevel = [self.analyzer headingLevelForFontSize:14.0];
    NSInteger infrequentLevel = [self.analyzer headingLevelForFontSize:18.0];
    
    XCTAssertEqual(mostFrequentLevel, 0, @"Most frequent font should be body text");
    // The second most frequent could be body or heading depending on algorithm
    XCTAssertTrue(infrequentLevel > 0, @"Infrequent large font should be a heading");
}

#pragma mark - Heading Level Limits Tests

- (void)testMaximumHeadingLevels {
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    fontSizes[@"12.0"] = @100;  // Body
    
    // Add many different heading sizes
    for (int i = 1; i <= 10; i++) {
        fontSizes[[NSString stringWithFormat:@"%.1f", 12.0 + i * 2]] = @(10 - i);
    }
    
    [self.analyzer analyzeFontSizes:fontSizes];
    
    // Check that we don't exceed H6 (level 6)
    NSInteger maxLevel = 0;
    for (NSString *sizeStr in fontSizes.allKeys) {
        CGFloat size = [sizeStr floatValue];
        NSInteger level = [self.analyzer headingLevelForFontSize:size];
        if (level > maxLevel) {
            maxLevel = level;
        }
    }
    
    XCTAssertLessThanOrEqual(maxLevel, 6, @"Should not exceed H6 (level 6)");
}

#pragma mark - Performance Tests

- (void)testLargeFontSetPerformance {
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    
    // Create a large set of font sizes to test performance
    for (int i = 8; i <= 72; i++) {
        fontSizes[[NSString stringWithFormat:@"%.1f", (CGFloat)i]] = @(arc4random() % 100 + 1);
    }
    
    NSDate *startTime = [NSDate date];
    [self.analyzer analyzeFontSizes:fontSizes];
    NSTimeInterval elapsed = [[NSDate date] timeIntervalSinceDate:startTime];
    
    XCTAssertLessThan(elapsed, 1.0, @"Font analysis should complete within 1 second for large font set");
}

#pragma mark - Algorithm Consistency Tests

- (void)testConsistentResults {
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    fontSizes[@"12.0"] = @100;
    fontSizes[@"16.0"] = @10;
    fontSizes[@"20.0"] = @5;
    
    // Run analysis multiple times
    [self.analyzer analyzeFontSizes:fontSizes];
    NSInteger firstRun16 = [self.analyzer headingLevelForFontSize:16.0];
    NSInteger firstRun20 = [self.analyzer headingLevelForFontSize:20.0];
    
    [self.analyzer analyzeFontSizes:fontSizes];
    NSInteger secondRun16 = [self.analyzer headingLevelForFontSize:16.0];
    NSInteger secondRun20 = [self.analyzer headingLevelForFontSize:20.0];
    
    XCTAssertEqual(firstRun16, secondRun16, @"Font analysis should be consistent across runs");
    XCTAssertEqual(firstRun20, secondRun20, @"Font analysis should be consistent across runs");
}

@end
</file>

<file path="pdf22md-objc/Tests/Unit/PDFMarkdownConverterTests.m">
//
//  PDFMarkdownConverterTests.m
//  pdf22md
//
//  Unit tests for core PDF to Markdown conversion functionality
//

#import <XCTest/XCTest.h>
#import "../../src/PDFMarkdownConverter.h"
#import "../../src/AssetExtractor.h"
#import "../../src/ContentElement.h"

@interface PDFMarkdownConverterTests : XCTestCase
@property (nonatomic, strong) PDFMarkdownConverter *converter;
@property (nonatomic, strong) NSString *testResourcesPath;
@end

@implementation PDFMarkdownConverterTests

- (void)setUp {
    [super setUp];
    self.converter = [[PDFMarkdownConverter alloc] init];
    
    // Set up test resources path
    NSBundle *testBundle = [NSBundle bundleForClass:[self class]];
    self.testResourcesPath = [testBundle.bundlePath stringByAppendingPathComponent:@"Resources"];
    
    // Ensure test resources directory exists
    NSFileManager *fileManager = [NSFileManager defaultManager];
    if (![fileManager fileExistsAtPath:self.testResourcesPath]) {
        [fileManager createDirectoryAtPath:self.testResourcesPath 
               withIntermediateDirectories:YES 
                                attributes:nil 
                                     error:nil];
    }
}

- (void)tearDown {
    self.converter = nil;
    self.testResourcesPath = nil;
    [super tearDown];
}

#pragma mark - Basic Functionality Tests

- (void)testConverterInitialization {
    XCTAssertNotNil(self.converter, @"PDFMarkdownConverter should initialize successfully");
}

- (void)testInvalidPDFHandling {
    // Test with nil input
    NSString *result = [self.converter convertPDFAtPath:nil 
                                          assetsFolderPath:nil 
                                                       dpi:144];
    XCTAssertNil(result, @"Converter should return nil for nil input path");
    
    // Test with non-existent file
    NSString *nonExistentPath = @"/path/that/does/not/exist.pdf";
    result = [self.converter convertPDFAtPath:nonExistentPath 
                               assetsFolderPath:nil 
                                            dpi:144];
    XCTAssertNil(result, @"Converter should return nil for non-existent file");
}

- (void)testEmptyStringHandling {
    // Test with empty string
    NSString *result = [self.converter convertPDFAtPath:@"" 
                                          assetsFolderPath:nil 
                                                       dpi:144];
    XCTAssertNil(result, @"Converter should return nil for empty string path");
}

- (void)testDPIParameterValidation {
    // Create a minimal test PDF path (we'll use an existing test file)
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"simple-test.pdf"];
    
    // Test with invalid DPI values
    NSString *result = [self.converter convertPDFAtPath:testPDFPath 
                                          assetsFolderPath:nil 
                                                       dpi:0];
    // Should still work with fallback DPI or return error gracefully
    // The exact behavior depends on implementation, but should not crash
    
    result = [self.converter convertPDFAtPath:testPDFPath 
                               assetsFolderPath:nil 
                                            dpi:-144];
    // Should handle negative DPI gracefully
}

#pragma mark - Asset Folder Tests

- (void)testAssetFolderCreation {
    NSString *tempDir = NSTemporaryDirectory();
    NSString *testAssetsFolder = [tempDir stringByAppendingPathComponent:@"test-assets"];
    
    // Clean up any existing test folder
    NSFileManager *fileManager = [NSFileManager defaultManager];
    [fileManager removeItemAtPath:testAssetsFolder error:nil];
    
    // Verify folder doesn't exist initially
    XCTAssertFalse([fileManager fileExistsAtPath:testAssetsFolder], 
                   @"Test assets folder should not exist initially");
    
    // Test folder creation during conversion (with a valid PDF)
    // For now, just test that the method accepts the parameter
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"simple-test.pdf"];
    [self.converter convertPDFAtPath:testPDFPath 
                      assetsFolderPath:testAssetsFolder 
                                   dpi:144];
    
    // Clean up
    [fileManager removeItemAtPath:testAssetsFolder error:nil];
}

#pragma mark - Memory Management Tests

- (void)testMemoryManagement {
    // Test that converter handles multiple conversions without memory issues
    for (int i = 0; i < 10; i++) {
        @autoreleasepool {
            PDFMarkdownConverter *tempConverter = [[PDFMarkdownConverter alloc] init];
            
            // Test with nil path to avoid actual file I/O
            NSString *result = [tempConverter convertPDFAtPath:nil 
                                               assetsFolderPath:nil 
                                                            dpi:144];
            XCTAssertNil(result, @"Should handle nil input gracefully");
            
            tempConverter = nil;
        }
    }
}

#pragma mark - Performance Tests

- (void)testPerformanceBaseline {
    // Simple performance test to establish baseline
    [self measureBlock:^{
        // Test basic object creation and method call
        PDFMarkdownConverter *converter = [[PDFMarkdownConverter alloc] init];
        [converter convertPDFAtPath:nil assetsFolderPath:nil dpi:144];
    }];
}

#pragma mark - Error Handling Tests

- (void)testErrorConditions {
    // Test various error conditions that should be handled gracefully
    NSArray *invalidPaths = @[
        @"",
        @"not-a-pdf.txt",
        @"/dev/null",
        @"~/nonexistent/path/file.pdf"
    ];
    
    for (NSString *invalidPath in invalidPaths) {
        NSString *result = [self.converter convertPDFAtPath:invalidPath 
                                            assetsFolderPath:nil 
                                                         dpi:144];
        XCTAssertNil(result, @"Should handle invalid path gracefully: %@", invalidPath);
    }
}

#pragma mark - Integration Points Tests

- (void)testAssetExtractorIntegration {
    // Test that converter properly integrates with AssetExtractor
    // This is a basic smoke test for the integration
    AssetExtractor *extractor = [[AssetExtractor alloc] init];
    XCTAssertNotNil(extractor, @"AssetExtractor should initialize for integration testing");
}

- (void)testContentElementIntegration {
    // Test that converter properly works with ContentElement classes
    // This verifies the model layer integration
    XCTAssertTrue([NSClassFromString(@"ContentElement") conformsToProtocol:@protocol(NSObject)], 
                  @"ContentElement should be available for integration");
}

@end
</file>

<file path="pdf22md-objc/Tests/Unit/SimpleConverterTest.m">
//
//  SimpleConverterTest.m
//  pdf22md-objc
//
//  Simple test without XCTest framework dependency
//

#import <Foundation/Foundation.h>
#import "Core/PDF22MDConverter.h"
#import "Core/PDF22MDConversionOptions.h"
#import "Core/PDF22MDError.h"

// Simple assertion macro for non-XCTest testing
#define ASSERT(condition, message) \
    if (!(condition)) { \
        printf("❌ ASSERT FAILED: %s - %s\n", #condition, message); \
        return 1; \
    } else { \
        printf("✅ ASSERT PASSED: %s\n", #condition); \
    }

int main(int argc, char *argv[]) {
    @autoreleasepool {
        printf("🧪 Running Simple Converter Tests\n");
        printf("==================================\n");
        
        // Test 1: Options initialization
        PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
        ASSERT(options != nil, "Options should initialize successfully");
        ASSERT(options.rasterizationDPI == 144.0, "Default DPI should be 144");
        
        // Test 2: Default options creation
        PDF22MDConversionOptions *defaultOptions = [PDF22MDConversionOptions defaultOptions];
        ASSERT(defaultOptions != nil, "Default options should initialize successfully");
        
        // Test 3: Error handling for nil URL
        PDF22MDConverter *converter = [[PDF22MDConverter alloc] initWithPDFURL:nil];
        ASSERT(converter == nil, "Should return nil for nil URL");
        
        // Test 4: Error handling for non-existent file  
        NSURL *nonExistentURL = [NSURL fileURLWithPath:@"/nonexistent/file.pdf"];
        converter = [[PDF22MDConverter alloc] initWithPDFURL:nonExistentURL];
        ASSERT(converter == nil, "Should return nil for non-existent file");
        
        // Test 5: Error helper methods
        NSError *testError = [PDF22MDErrorHelper invalidPDFError];
        ASSERT(testError != nil, "Error helper should create error");
        ASSERT(testError.localizedDescription != nil, "Error should have localized description");
        ASSERT(testError.localizedDescription.length > 0, "Error description should not be empty");
        
        // Test 6: File not found error
        NSError *fileError = [PDF22MDErrorHelper fileNotFoundErrorWithPath:@"/test/path"];
        ASSERT(fileError != nil, "Should create file not found error");
        ASSERT(fileError.code == PDF22MDErrorFileNotFound, "Should have correct error code");
        
        printf("\n🎉 All simple tests passed!\n");
        return 0;
    }
}
</file>

<file path="pdf22md-objc/build.sh">
#!/bin/bash

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Print functions
print_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
print_warning() { echo -e "${YELLOW}[WARN]${NC} $1"; }
print_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Check for required tools
check_requirements() {
    local missing_tools=()

    if ! command -v clang &>/dev/null; then
        missing_tools+=("clang")
    fi

    if ! command -v make &>/dev/null; then
        missing_tools+=("make")
    fi

    if [ ${#missing_tools[@]} -ne 0 ]; then
        print_error "Missing required tools: ${missing_tools[*]}"
        print_info "Please install Xcode Command Line Tools:"
        print_info "xcode-select --install"
        exit 1
    fi
}

# Build pdf22md-objc
build_objc() {
    print_info "Building pdf22md (Objective-C implementation)..."
    make clean
    if make; then
        print_info "✓ pdf22md-objc built successfully"
        return 0
    else
        print_error "Failed to build pdf22md-objc"
        return 1
    fi
}

# Install binary
install_binary() {
    local install_dir="/usr/local/bin"
    print_info "Installing binary to $install_dir..."

    # Create install directory if it doesn't exist
    sudo mkdir -p "$install_dir"

    # Install pdf22md
    if [ -f "pdf22md" ]; then
        sudo install -m 755 pdf22md "$install_dir/pdf22md"
        print_info "✓ Installed pdf22md"
    fi

    # Install man pages
    if [ -f "docs/pdf22md.1" ]; then
        sudo mkdir -p /usr/local/share/man/man1
        sudo install -m 644 docs/pdf22md.1 /usr/local/share/man/man1/
        print_info "✓ Installed man pages"
    fi
}

# Run tests
run_tests() {
    print_info "Running tests..."
    if [ -f "run-tests.sh" ]; then
        ./run-tests.sh
    else
        print_warning "No test script found"
    fi
}

# Main execution
main() {
    print_info "Starting pdf22md-objc build process..."

    # Check requirements
    check_requirements

    # Build component
    build_objc

    # Run tests if requested
    if [ "$1" = "--test" ]; then
        run_tests
    fi

    # Install if requested
    if [ "$1" = "--install" ] || [ "$2" = "--install" ]; then
        install_binary
    fi

    print_info "Build complete!"
    print_info "Run './pdf22md --help' for usage information"
}

main "$@"
</file>

<file path="pdf22md-objc/llms.txt">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
docs/
  PARALLEL_PROCESSING.md
  pdf22md.1
src/
  CLI/
    main.m
  Core/
    PDF22MDConversionOptions.h
    PDF22MDConversionOptions.m
    PDF22MDConverter.h
    PDF22MDConverter.m
    PDF22MDError.h
    PDF22MDError.m
    PDF22MDFontAnalyzer.h
    PDF22MDFontAnalyzer.m
    PDF22MDPageProcessor.h
    PDF22MDPageProcessor.m
  Models/
    PDF22MDContentElement.h
    PDF22MDImageElement.h
    PDF22MDImageElement.m
    PDF22MDTextElement.h
    PDF22MDTextElement.m
  Services/
    PDF22MDAssetManager.h
    PDF22MDAssetManager.m
    PDF22MDMarkdownGenerator.h
    PDF22MDMarkdownGenerator.m
  AssetExtractor.h
  AssetExtractor.m
  ContentElement.h
  ContentElement.m
  main.m
  PDF22MDErrorHelper.h
  PDF22MDErrorHelper.m
  PDFMarkdownConverter.h
  PDFMarkdownConverter.m
  PDFPageProcessor.h
  PDFPageProcessor.m
test/
  benchmark/
    output.md
  README.md
Tests/
  Integration/
    EndToEndConversionTests.m
  Unit/
    AssetExtractorTests.m
    ContentElementTests.m
    PDF22MDAssetManagerTests.m
    PDF22MDConverterTests.m
    PDF22MDFontAnalyzerTests.m
    PDFMarkdownConverterTests.m
    SimpleConverterTest.m
build.sh
Makefile
README.md
release.sh
run-tests.sh
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="docs/PARALLEL_PROCESSING.md">
# Parallel Processing in `pdf22md`

This document outlines the implementation of parallel processing in the `pdf22md` command-line tool for converting PDF documents to Markdown format.

## 1. Objective

The goal was to accelerate the conversion of multi-page PDF documents by processing multiple pages concurrently and saving extracted images in parallel.

## 2. Technology: Grand Central Dispatch (GCD)

Similar to `pdfupng`, we utilized Apple's **Grand Central Dispatch (GCD)** framework with the `dispatch_apply` function for parallel execution.

## 3. Implementation Details

### 3.1. Parallel Page Processing

The core changes were made within the `convertWithAssetsFolderPath:rasterizedDPI:completion:` method in `PDFMarkdownConverter.m`.

#### From Sequential to Concurrent

The original implementation used a sequential `for` loop:

```objc
for (NSInteger pageIndex = 0; pageIndex < pageCount; pageIndex++) {
    PDFPage *page = [self.pdfDocument pageAtIndex:pageIndex];
    // ... process page ...
}
```

This was replaced with:

```objc
dispatch_apply(pageCount, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t pageIndex) {
    @autoreleasepool {
        PDFPage *page = [self.pdfDocument pageAtIndex:pageIndex];
        // ... process page ...
    }
});
```

### 3.2. Thread Safety Measures

1. **Temporary Storage Arrays**: Instead of directly modifying shared arrays (`allElements`, `fontStats`), we create temporary per-page storage:

```objc
NSMutableArray<NSMutableArray<id<ContentElement>> *> *pageElementsArray = [NSMutableArray arrayWithCapacity:pageCount];
NSMutableArray<NSMutableDictionary *> *pageFontStatsArray = [NSMutableArray arrayWithCapacity:pageCount];
```

2. **Error Handling**: A shared boolean flag with synchronized access:

```objc
__block BOOL processingFailed = NO;
NSObject *lock = [[NSObject alloc] init];

// Inside parallel block
@synchronized(lock) {
    if (processingFailed) return;
}
```

3. **Result Merging**: After parallel processing completes, results are merged sequentially:

```objc
for (NSInteger i = 0; i < pageCount; i++) {
    [self.allElements addObjectsFromArray:pageElementsArray[i]];
    // Merge font statistics...
}
```

### 3.3. Parallel Image Saving

Image saving was also parallelized:

```objc
dispatch_apply(imageCount, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t index) {
    @autoreleasepool {
        ImageElement *imageElement = imageElements[index];
        NSString *savedPath = [assetExtractor saveImage:imageElement.image ...];
        if (savedPath) {
            @synchronized(imageElement) {
                imageElement.assetRelativePath = savedPath;
            }
        }
    }
});
```

### 3.4. Memory Management

Each parallel operation is wrapped in `@autoreleasepool` to ensure prompt deallocation of temporary objects and prevent memory spikes.

## 4. Performance Benefits

- **Multi-core Utilization**: Pages are processed on multiple CPU cores simultaneously
- **Reduced Total Time**: For PDFs with many pages, the speedup is nearly linear with the number of cores
- **Efficient Memory Usage**: Autoreleasepool prevents memory accumulation
- **Scalability**: The implementation automatically adapts to the available hardware

## 5. Considerations

- **Thread Safety**: All shared resources are protected with appropriate synchronization
- **Memory Overhead**: Each parallel task has its own memory footprint, but autoreleasepool keeps it manageable
- **I/O Bottlenecks**: Image saving may be limited by disk I/O speed rather than CPU
</file>

<file path="docs/pdf22md.1">
.TH PDF22MD 1 "June 2025" "pdf22md v1.0" "User Commands"
.SH NAME
pdf22md \- high-performance PDF to Markdown converter
.SH SYNOPSIS
.B pdf22md
[\fB\-i\fR \fIinput.pdf\fR]
[\fB\-o\fR \fIoutput.md\fR]
[\fB\-a\fR \fIassets_folder\fR]
[\fB\-d\fR \fIdpi\fR]
[\fB\-v\fR]
[\fB\-h\fR]
.SH DESCRIPTION
.B pdf22md
is a blazingly fast PDF to Markdown converter that extracts text and images from PDF documents and converts them into clean, structured Markdown format. It uses parallel processing to achieve high performance on multi-page documents.

The tool automatically detects heading hierarchy based on font size analysis, extracts images with intelligent format optimization (PNG/JPEG), and generates YAML frontmatter with document metadata.

.SH OPTIONS
.TP
\fB\-i\fR \fIinput.pdf\fR
Specify the input PDF file to convert. If not provided, pdf22md reads from standard input (stdin).
.TP
\fB\-o\fR \fIoutput.md\fR
Specify the output Markdown file. If not provided, pdf22md writes to standard output (stdout).
.TP
\fB\-a\fR \fIassets_folder\fR
Specify the folder where extracted images will be saved. The folder will be created if it doesn't exist. Images are automatically referenced in the generated Markdown with relative paths.
.TP
\fB\-d\fR \fIdpi\fR
Set the DPI (dots per inch) for rasterizing vector graphics. Default is 144. Higher values produce better quality but larger file sizes. Common values: 72 (screen), 144 (default), 300 (print quality).
.TP
\fB\-v\fR, \fB\-\-version\fR
Display version information and exit.
.TP
\fB\-h\fR, \fB\-\-help\fR
Display usage information and exit.

.SH EXAMPLES
.TP
Convert a PDF file to Markdown:
.B pdf22md \-i document.pdf \-o document.md

.TP
Extract images to an assets folder:
.B pdf22md \-i document.pdf \-o document.md \-a ./assets

.TP
Use higher DPI for better image quality:
.B pdf22md \-i document.pdf \-o document.md \-a ./assets \-d 300

.TP
Convert using pipes (stdin/stdout):
.B cat document.pdf | pdf22md > document.md

.TP
Process a document with custom settings:
.B pdf22md \-i report.pdf \-o report.md \-a ./images \-d 200

.SH INPUT/OUTPUT
.SS Input Sources
.B pdf22md
accepts PDF input from:
.IP • 2
File path specified with \fB\-i\fR flag
.IP • 2
Standard input (stdin) when no \fB\-i\fR flag is provided

.SS Output Destinations
Markdown output is written to:
.IP • 2
File path specified with \fB\-o\fR flag
.IP • 2
Standard output (stdout) when no \fB\-o\fR flag is provided

.SS Image Assets
When the \fB\-a\fR flag is used:
.IP • 2
Images are extracted and saved to the specified folder
.IP • 2
Filenames follow the pattern: image_001.png, image_002.jpg, etc.
.IP • 2
Format selection is automatic (PNG for graphics, JPEG for photos)
.IP • 2
Markdown contains relative references to the images

.SH FEATURES
.SS Intelligent Content Processing
.IP • 2
\fBHeading Detection\fR: Automatically identifies headings (H1-H6) based on font size analysis
.IP • 2
\fBText Extraction\fR: Preserves text formatting and structure
.IP • 2
\fBImage Processing\fR: Extracts both raster and vector graphics
.IP • 2
\fBSmart Formatting\fR: Maintains document hierarchy and readability

.SS Performance Optimizations
.IP • 2
\fBParallel Processing\fR: Uses all available CPU cores for maximum speed
.IP • 2
\fBMemory Efficiency\fR: Processes large documents without excessive memory usage
.IP • 2
\fBFormat Optimization\fR: Automatic PNG/JPEG selection based on image content

.SS Output Features
.IP • 2
\fBYAML Frontmatter\fR: Includes document metadata (title, author, creation date)
.IP • 2
\fBClean Markdown\fR: Well-structured output compatible with all Markdown processors
.IP • 2
\fBAsset Management\fR: Organized image extraction with proper linking

.SH FILE FORMATS
.SS Supported Input
.IP • 2
PDF files (version 1.4 and higher)
.IP • 2
Unencrypted PDFs (password-protected PDFs are not supported)
.IP • 2
PDFs with text, images, and vector graphics
.IP • 2
Multi-page documents of any size

.SS Generated Output
.IP • 2
\fBMarkdown (.md)\fR: GitHub Flavored Markdown compatible
.IP • 2
\fBImages (.png/.jpg)\fR: Extracted graphics in optimal formats
.IP • 2
\fBYAML Frontmatter\fR: Document metadata in standard format

.SH PERFORMANCE
Typical conversion speeds on modern hardware:
.IP • 2
Simple text documents: <1 second per page
.IP • 2
Complex documents with images: 2-5 seconds per page
.IP • 2
Large documents (100+ pages): Scales linearly with parallel processing

Memory usage is optimized for documents up to 1000 pages. Very large documents may require additional system memory.

.SH ERROR HANDLING
.B pdf22md
provides detailed error messages with suggestions for common issues:

.SS Common Errors and Solutions
.TP
\fBInvalid PDF file\fR
.IP • 2
Verify the file exists and is a valid PDF
.IP • 2
Check if the file is corrupted
.IP • 2
Ensure you have read permissions

.TP
\fBCannot create assets folder\fR
.IP • 2
Check if the parent directory exists
.IP • 2
Verify you have write permissions
.IP • 2
Ensure sufficient disk space

.TP
\fBPassword-protected PDF\fR
.IP • 2
Remove password protection using another tool first
.IP • 2
Use: qpdf \-\-decrypt input.pdf output.pdf

.TP
\fBMemory pressure\fR
.IP • 2
Close other applications to free memory
.IP • 2
Try using a lower DPI setting (\-d 72)
.IP • 2
Process smaller sections of large documents

.SH EXIT STATUS
.TP
.B 0
Successful conversion
.TP
.B 1
Error occurred (invalid input, processing failure, I/O error)

.SH ENVIRONMENT
No special environment variables are required. The tool uses standard macOS frameworks (PDFKit, CoreGraphics) and runs on macOS 10.15 and later.

.SH LIMITATIONS
.IP • 2
Password-protected PDFs are not supported
.IP • 2
Scanned PDFs without OCR text layer will only extract images
.IP • 2
Complex table layouts may not convert perfectly
.IP • 2
Some advanced PDF features (forms, annotations) are not preserved

.SH COMPATIBILITY
.SS Platform Support
.IP • 2
macOS 10.15 (Catalina) and later
.IP • 2
Intel and Apple Silicon processors
.IP • 2
Universal binary for optimal performance

.SS Markdown Compatibility
Output is compatible with:
.IP • 2
GitHub Flavored Markdown
.IP • 2
CommonMark specification
.IP • 2
Popular Markdown processors (pandoc, Jekyll, etc.)
.IP • 2
Static site generators (Hugo, Jekyll, Gatsby)

.SH FILES
.TP
.I ~/.pdf22md/
User configuration directory (future use)
.TP
.I /usr/local/bin/pdf22md
Default installation location
.TP
.I /usr/local/share/man/man1/pdf22md.1
This manual page

.SH EXAMPLES WORKFLOW
.SS Basic Document Conversion
.nf
# Convert a simple document
pdf22md \-i report.pdf \-o report.md

# Result: clean Markdown with YAML frontmatter
# Output includes: title, headings, body text, metadata
.fi

.SS Academic Paper with Images
.nf
# Convert research paper with figure extraction
pdf22md \-i paper.pdf \-o paper.md \-a figures \-d 300

# Result: 
# - paper.md with structured content
# - figures/ folder with high-quality images
# - Proper cross-references to figures
.fi

.SS Batch Processing
.nf
# Process multiple documents
for pdf in *.pdf; do
    pdf22md \-i "$pdf" \-o "${pdf%.pdf}.md" \-a "assets_${pdf%.pdf}"
done
.fi

.SS Integration with Other Tools
.nf
# Combine with pandoc for further processing
pdf22md \-i document.pdf | pandoc \-f markdown \-t html \-o document.html

# Use with static site generators
pdf22md \-i post.pdf \-o content/posts/post.md \-a static/images
.fi

.SH TROUBLESHOOTING
.SS Performance Issues
If conversion is slow:
.IP • 2
Check available memory and CPU usage
.IP • 2
Close unnecessary applications
.IP • 2
Try lower DPI setting for faster processing
.IP • 2
Process documents in smaller batches

.SS Quality Issues
If output quality is poor:
.IP • 2
Increase DPI setting (\-d 300) for better images
.IP • 2
Verify the source PDF has good quality text
.IP • 2
Check if the PDF has a proper text layer (not just scanned images)

.SS Memory Errors
For large documents:
.IP • 2
Ensure sufficient RAM (8GB+ recommended for large PDFs)
.IP • 2
Close other memory-intensive applications
.IP • 2
Split very large PDFs into smaller parts first

.SH REPORTING BUGS
Report bugs and feature requests at:
.UR https://github.com/twardoch/pdf22md/issues
.UE

Include in your report:
.IP • 2
pdf22md version (\fBpdf22md \-v\fR)
.IP • 2
macOS version
.IP • 2
Sample PDF file (if possible)
.IP • 2
Complete error message
.IP • 2
Steps to reproduce the issue

.SH AUTHORS
Written by Adam Twardoch and contributors.

.SH LICENSE
MIT License. See the LICENSE file for details.

.SH SEE ALSO
.BR pandoc (1),
.BR qpdf (1),
.BR pdftotext (1),
.BR markdown (7)

Project homepage: 
.UR https://github.com/twardoch/pdf22md
.UE
</file>

<file path="src/CLI/main.m">
#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>
#import "../Core/PDF22MDConverter.h"
#import "../Core/PDF22MDConversionOptions.h"

#ifndef VERSION
#define VERSION "1.0.0"
#endif

void printUsage(const char *programName) {
    fprintf(stderr, "Usage: %s [-i input.pdf] [-o output.md] [-a assets_folder] [-d dpi] [-v] [-h]\n", programName);
    fprintf(stderr, "  Converts PDF documents to Markdown format\n");
    fprintf(stderr, "  -i <path>: Input PDF file (default: stdin)\n");
    fprintf(stderr, "  -o <path>: Output Markdown file (default: stdout)\n");
    fprintf(stderr, "  -a <path>: Assets folder for extracted images\n");
    fprintf(stderr, "  -d <dpi>: DPI for rasterizing vector graphics (default: 144)\n");
    fprintf(stderr, "  -v: Display version information\n");
    fprintf(stderr, "  -h: Display this help message\n");
}

void printVersion() {
    printf("pdf22md version %s\n", VERSION);
}

int main(int argc, const char *argv[]) {
    @autoreleasepool {
        NSString *inputPath = nil;
        NSString *outputPath = nil;
        NSString *assetsPath = nil;
        CGFloat dpi = 144.0;
        
        // Parse command line arguments
        int opt;
        while ((opt = getopt(argc, (char * const *)argv, "i:o:a:d:hvV")) != -1) {
            switch (opt) {
                case 'i':
                    inputPath = [NSString stringWithUTF8String:optarg];
                    break;
                case 'o':
                    outputPath = [NSString stringWithUTF8String:optarg];
                    break;
                case 'a':
                    assetsPath = [NSString stringWithUTF8String:optarg];
                    break;
                case 'd':
                    dpi = atof(optarg);
                    if (dpi <= 0) {
                        fprintf(stderr, "Invalid DPI value: %s\n", optarg);
                        return 1;
                    }
                    break;
                case 'h':
                    printUsage(argv[0]);
                    return 0;
                case 'v':
                case 'V':
                    printVersion();
                    return 0;
                default:
                    printUsage(argv[0]);
                    return 1;
            }
        }
        
        // Initialize converter
        PDF22MDConverter *converter = nil;
        
        if (inputPath) {
            // Read from file
            NSURL *pdfURL = [NSURL fileURLWithPath:inputPath];
            converter = [[PDF22MDConverter alloc] initWithPDFURL:pdfURL];
            if (!converter) {
                fprintf(stderr, "Failed to load PDF from: %s\n", [inputPath UTF8String]);
                return 1;
            }
        } else {
            // Read from stdin
            NSFileHandle *stdinHandle = [NSFileHandle fileHandleWithStandardInput];
            NSData *pdfData = [stdinHandle readDataToEndOfFile];
            
            if (!pdfData || [pdfData length] == 0) {
                fprintf(stderr, "No PDF data received from stdin\n");
                return 1;
            }
            
            converter = [[PDF22MDConverter alloc] initWithPDFData:pdfData];
            if (!converter) {
                fprintf(stderr, "Failed to create PDF document from stdin data\n");
                return 1;
            }
        }
        
        // Create conversion options
        PDF22MDConversionOptionsBuilder *builder = [[PDF22MDConversionOptionsBuilder alloc] init];
        builder.assetsFolderPath = assetsPath;
        builder.rasterizationDPI = dpi;
        builder.extractImages = (assetsPath != nil);
        
        // Add progress handler for interactive terminals
        if (isatty(STDERR_FILENO)) {
            builder.progressHandler = ^(NSInteger currentPage, NSInteger totalPages) {
                fprintf(stderr, "\rProcessing page %ld of %ld...", (long)currentPage, (long)totalPages);
                fflush(stderr);
            };
        }
        
        PDF22MDConversionOptions *options = [builder build];
        
        // Perform conversion
        __block NSString *markdown = nil;
        __block NSError *conversionError = nil;
        
        dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
        
        [converter convertWithOptions:options
                           completion:^(NSString *result, NSError *error) {
            markdown = result;
            conversionError = error;
            dispatch_semaphore_signal(semaphore);
        }];
        
        // Wait for completion
        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
        
        if (isatty(STDERR_FILENO) && options.progressHandler) {
            fprintf(stderr, "\n"); // Clear progress line
        }
        
        if (conversionError) {
            fprintf(stderr, "Conversion failed: %s\n", 
                    [[conversionError localizedDescription] UTF8String]);
            return 1;
        }
        
        // Write output
        if (outputPath) {
            // Write to file
            NSError *writeError = nil;
            BOOL success = [markdown writeToFile:outputPath
                                      atomically:YES
                                        encoding:NSUTF8StringEncoding
                                           error:&writeError];
            if (!success) {
                fprintf(stderr, "Failed to write output file: %s\n",
                        [[writeError localizedDescription] UTF8String]);
                return 1;
            }
        } else {
            // Write to stdout
            NSFileHandle *stdoutHandle = [NSFileHandle fileHandleWithStandardOutput];
            NSData *markdownData = [markdown dataUsingEncoding:NSUTF8StringEncoding];
            [stdoutHandle writeData:markdownData];
            
            // Add newline if not present
            if (![markdown hasSuffix:@"\n"]) {
                [stdoutHandle writeData:[@"\n" dataUsingEncoding:NSUTF8StringEncoding]];
            }
        }
        
        return 0;
    }
}
</file>

<file path="src/Core/PDF22MDConversionOptions.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

/**
 * Configuration options for PDF to Markdown conversion.
 * This class uses the builder pattern for convenient configuration.
 */
@interface PDF22MDConversionOptions : NSObject <NSCopying>

/**
 * Path to the folder where extracted assets (images) should be saved.
 * If nil, images will not be extracted.
 */
@property (nonatomic, copy, nullable) NSString *assetsFolderPath;

/**
 * DPI for rasterizing vector graphics.
 * Default is 144.0
 */
@property (nonatomic, assign) CGFloat rasterizationDPI;

/**
 * Maximum number of concurrent page processing operations.
 * Default is NSProcessInfo.processInfo.processorCount
 */
@property (nonatomic, assign) NSInteger maxConcurrentPages;

/**
 * Whether to include YAML frontmatter with metadata.
 * Default is YES
 */
@property (nonatomic, assign) BOOL includeMetadata;

/**
 * Whether to extract images from the PDF.
 * Default is YES (if assetsFolderPath is set)
 */
@property (nonatomic, assign) BOOL extractImages;

/**
 * Whether to preserve the PDF outline/bookmarks structure.
 * Default is YES
 */
@property (nonatomic, assign) BOOL preserveOutline;

/**
 * Minimum font size difference to consider for heading detection.
 * Default is 2.0 points
 */
@property (nonatomic, assign) CGFloat headingFontSizeThreshold;

/**
 * Maximum heading level to detect (1-6).
 * Default is 6
 */
@property (nonatomic, assign) NSInteger maxHeadingLevel;

/**
 * Progress handler called during conversion.
 * The handler receives the current page index and total page count.
 */
@property (nonatomic, copy, nullable) void (^progressHandler)(NSInteger currentPage, NSInteger totalPages);

/**
 * Creates default conversion options.
 */
+ (instancetype)defaultOptions;

/**
 * Validates the current options configuration.
 * @param error Set if validation fails
 * @return YES if valid, NO otherwise
 */
- (BOOL)validateWithError:(NSError * _Nullable * _Nullable)error;

@end

/**
 * Builder class for creating PDF22MDConversionOptions instances.
 */
@interface PDF22MDConversionOptionsBuilder : NSObject

@property (nonatomic, copy, nullable) NSString *assetsFolderPath;
@property (nonatomic, assign) CGFloat rasterizationDPI;
@property (nonatomic, assign) NSInteger maxConcurrentPages;
@property (nonatomic, assign) BOOL includeMetadata;
@property (nonatomic, assign) BOOL extractImages;
@property (nonatomic, assign) BOOL preserveOutline;
@property (nonatomic, assign) CGFloat headingFontSizeThreshold;
@property (nonatomic, assign) NSInteger maxHeadingLevel;
@property (nonatomic, copy, nullable) void (^progressHandler)(NSInteger currentPage, NSInteger totalPages);

- (PDF22MDConversionOptions *)build;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="src/Core/PDF22MDConversionOptions.m">
#import "PDF22MDConversionOptions.h"
#import "PDF22MDError.h"

@implementation PDF22MDConversionOptions

#pragma mark - Initialization

- (instancetype)init {
    self = [super init];
    if (self) {
        // Set default values
        _rasterizationDPI = 144.0;
        _maxConcurrentPages = [[NSProcessInfo processInfo] processorCount];
        _includeMetadata = YES;
        _extractImages = YES;
        _preserveOutline = YES;
        _headingFontSizeThreshold = 2.0;
        _maxHeadingLevel = 6;
    }
    return self;
}

+ (instancetype)defaultOptions {
    return [[self alloc] init];
}

#pragma mark - NSCopying

- (id)copyWithZone:(nullable NSZone *)zone {
    PDF22MDConversionOptions *copy = [[PDF22MDConversionOptions allocWithZone:zone] init];
    
    copy.assetsFolderPath = self.assetsFolderPath;
    copy.rasterizationDPI = self.rasterizationDPI;
    copy.maxConcurrentPages = self.maxConcurrentPages;
    copy.includeMetadata = self.includeMetadata;
    copy.extractImages = self.extractImages;
    copy.preserveOutline = self.preserveOutline;
    copy.headingFontSizeThreshold = self.headingFontSizeThreshold;
    copy.maxHeadingLevel = self.maxHeadingLevel;
    copy.progressHandler = self.progressHandler;
    
    return copy;
}

#pragma mark - Validation

- (BOOL)validateWithError:(NSError * _Nullable * _Nullable)error {
    // Validate DPI
    if (self.rasterizationDPI <= 0 || self.rasterizationDPI > 600) {
        if (error) {
            *error = [NSError errorWithDomain:PDF22MDErrorDomain
                                         code:PDF22MDErrorInvalidConfiguration
                                     userInfo:@{
                NSLocalizedDescriptionKey: @"Invalid rasterization DPI",
                NSLocalizedFailureReasonErrorKey: @"DPI must be between 1 and 600"
            }];
        }
        return NO;
    }
    
    // Validate concurrent pages
    if (self.maxConcurrentPages < 1 || self.maxConcurrentPages > 64) {
        if (error) {
            *error = [NSError errorWithDomain:PDF22MDErrorDomain
                                         code:PDF22MDErrorInvalidConfiguration
                                     userInfo:@{
                NSLocalizedDescriptionKey: @"Invalid max concurrent pages",
                NSLocalizedFailureReasonErrorKey: @"Value must be between 1 and 64"
            }];
        }
        return NO;
    }
    
    // Validate heading level
    if (self.maxHeadingLevel < 1 || self.maxHeadingLevel > 6) {
        if (error) {
            *error = [NSError errorWithDomain:PDF22MDErrorDomain
                                         code:PDF22MDErrorInvalidConfiguration
                                     userInfo:@{
                NSLocalizedDescriptionKey: @"Invalid max heading level",
                NSLocalizedFailureReasonErrorKey: @"Heading level must be between 1 and 6"
            }];
        }
        return NO;
    }
    
    // Validate font size threshold
    if (self.headingFontSizeThreshold < 0.5 || self.headingFontSizeThreshold > 10.0) {
        if (error) {
            *error = [NSError errorWithDomain:PDF22MDErrorDomain
                                         code:PDF22MDErrorInvalidConfiguration
                                     userInfo:@{
                NSLocalizedDescriptionKey: @"Invalid heading font size threshold",
                NSLocalizedFailureReasonErrorKey: @"Threshold must be between 0.5 and 10.0 points"
            }];
        }
        return NO;
    }
    
    // Validate assets path if image extraction is enabled
    if (self.extractImages && self.assetsFolderPath) {
        NSFileManager *fileManager = [NSFileManager defaultManager];
        BOOL isDirectory = NO;
        BOOL exists = [fileManager fileExistsAtPath:self.assetsFolderPath isDirectory:&isDirectory];
        
        if (exists && !isDirectory) {
            if (error) {
                *error = [PDF22MDErrorHelper assetFolderCreationErrorWithPath:self.assetsFolderPath
                                                                         reason:@"Path exists but is not a directory"];
            }
            return NO;
        }
    }
    
    return YES;
}

#pragma mark - Description

- (NSString *)description {
    return [NSString stringWithFormat:@"<%@: %p, assets=%@, dpi=%.0f, concurrent=%ld>",
            NSStringFromClass([self class]),
            self,
            self.assetsFolderPath ?: @"<none>",
            self.rasterizationDPI,
            (long)self.maxConcurrentPages];
}

@end

#pragma mark - Builder Implementation

@implementation PDF22MDConversionOptionsBuilder

- (instancetype)init {
    self = [super init];
    if (self) {
        // Initialize with default values
        PDF22MDConversionOptions *defaults = [PDF22MDConversionOptions defaultOptions];
        _rasterizationDPI = defaults.rasterizationDPI;
        _maxConcurrentPages = defaults.maxConcurrentPages;
        _includeMetadata = defaults.includeMetadata;
        _extractImages = defaults.extractImages;
        _preserveOutline = defaults.preserveOutline;
        _headingFontSizeThreshold = defaults.headingFontSizeThreshold;
        _maxHeadingLevel = defaults.maxHeadingLevel;
    }
    return self;
}

- (PDF22MDConversionOptions *)build {
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    
    options.assetsFolderPath = self.assetsFolderPath;
    options.rasterizationDPI = self.rasterizationDPI;
    options.maxConcurrentPages = self.maxConcurrentPages;
    options.includeMetadata = self.includeMetadata;
    options.extractImages = self.extractImages;
    options.preserveOutline = self.preserveOutline;
    options.headingFontSizeThreshold = self.headingFontSizeThreshold;
    options.maxHeadingLevel = self.maxHeadingLevel;
    options.progressHandler = self.progressHandler;
    
    return options;
}

@end
</file>

<file path="src/Core/PDF22MDConverter.h">
#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>

NS_ASSUME_NONNULL_BEGIN

@class PDF22MDConversionOptions;

/**
 * Main converter class that coordinates the PDF to Markdown conversion process.
 * This class manages the entire conversion pipeline including parallel processing,
 * content extraction, and markdown generation.
 */
@interface PDF22MDConverter : NSObject

/**
 * The PDF document being converted.
 */
@property (nonatomic, strong, readonly) PDFDocument *document;

/**
 * Progress object for tracking conversion progress.
 */
@property (nonatomic, strong, readonly) NSProgress *progress;

/**
 * Initializes a converter with PDF data.
 *
 * @param pdfData The PDF data to convert
 * @return A new converter instance, or nil if the PDF is invalid
 */
- (nullable instancetype)initWithPDFData:(NSData *)pdfData;

/**
 * Initializes a converter with a PDF file URL.
 *
 * @param pdfURL The URL of the PDF file to convert
 * @return A new converter instance, or nil if the PDF is invalid
 */
- (nullable instancetype)initWithPDFURL:(NSURL *)pdfURL;

/**
 * Designated initializer that creates a converter with both URL and document.
 * This is the real designated initializer that other initializers should call.
 *
 * @param pdfURL The URL of the PDF file (may be nil for data-based PDFs)
 * @param document The PDF document instance
 * @return A new converter instance, or nil if invalid
 */
- (nullable instancetype)initWithPDFURL:(nullable NSURL *)pdfURL document:(PDFDocument *)document NS_DESIGNATED_INITIALIZER;

- (instancetype)init NS_UNAVAILABLE;

/**
 * Converts the PDF to Markdown with the given options.
 * This method performs the conversion asynchronously on a background queue.
 *
 * @param options Conversion options (uses defaults if nil)
 * @param completion Completion handler called with the result or error
 */
- (void)convertWithOptions:(nullable PDF22MDConversionOptions *)options
                completion:(void (^)(NSString * _Nullable markdown, NSError * _Nullable error))completion;

/**
 * Cancels an ongoing conversion.
 * The completion handler will be called with a cancellation error.
 */
- (void)cancelConversion;

/**
 * Validates that the PDF can be converted.
 *
 * @param error Set if validation fails
 * @return YES if the PDF is valid for conversion, NO otherwise
 */
- (BOOL)validateDocumentWithError:(NSError * _Nullable * _Nullable)error;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="src/Core/PDF22MDConverter.m">
#import "PDF22MDConverter.h"
#import "PDF22MDConversionOptions.h"
#import "PDF22MDPageProcessor.h"
#import "../Models/PDF22MDContentElement.h"
#import "../Models/PDF22MDImageElement.h"
#import "../Services/PDF22MDAssetManager.h"
#import "../Services/PDF22MDMarkdownGenerator.h"
#import "PDF22MDFontAnalyzer.h"
#import "PDF22MDError.h"

@interface PDF22MDConverter ()
@property (nonatomic, strong) dispatch_queue_t conversionQueue;
@property (nonatomic, strong) NSMutableArray<id<PDF22MDContentElement>> *allElements;
@property (nonatomic, strong) PDF22MDFontAnalyzer *fontAnalyzer;
@property (nonatomic, assign) BOOL isCancelled;
@end

@implementation PDF22MDConverter

#pragma mark - Initialization

- (nullable instancetype)initWithPDFData:(NSData *)pdfData {
    if (!pdfData || pdfData.length == 0) {
        return nil;
    }
    
    PDFDocument *document = [[PDFDocument alloc] initWithData:pdfData];
    if (!document) {
        return nil;
    }
    
    NSURL *tempURL = [NSURL URLWithString:@"data:application/pdf"];
    return [self initWithPDFURL:tempURL document:document];
}

- (nullable instancetype)initWithPDFURL:(NSURL *)pdfURL {
    if (!pdfURL) {
        return nil;
    }
    
    PDFDocument *document = [[PDFDocument alloc] initWithURL:pdfURL];
    if (!document) {
        return nil;
    }
    
    return [self initWithPDFURL:pdfURL document:document];
}

- (nullable instancetype)initWithPDFURL:(nullable NSURL *)pdfURL document:(PDFDocument *)document {
    if (!document) {
        return nil;
    }
    
    self = [super init];
    if (self) {
        _document = document;
        _conversionQueue = dispatch_queue_create("com.twardoch.pdf22md.converter", DISPATCH_QUEUE_SERIAL);
        _allElements = [NSMutableArray array];
        _fontAnalyzer = [[PDF22MDFontAnalyzer alloc] init];
        _progress = [NSProgress progressWithTotalUnitCount:[document pageCount]];
        _isCancelled = NO;
    }
    return self;
}

#pragma mark - Public Methods

- (void)convertWithOptions:(nullable PDF22MDConversionOptions *)options
                completion:(void (^)(NSString * _Nullable markdown, NSError * _Nullable error))completion {
    // Use default options if none provided
    if (!options) {
        options = [PDF22MDConversionOptions defaultOptions];
    }
    
    // Validate options
    NSError *validationError = nil;
    if (![options validateWithError:&validationError]) {
        completion(nil, validationError);
        return;
    }
    
    // Reset state
    self.isCancelled = NO;
    [self.allElements removeAllObjects];
    [self.fontAnalyzer reset];
    self.progress.completedUnitCount = 0;
    
    // Configure font analyzer
    self.fontAnalyzer.fontSizeThreshold = options.headingFontSizeThreshold;
    self.fontAnalyzer.maxHeadingLevel = options.maxHeadingLevel;
    
    // Perform conversion on background queue
    dispatch_async(self.conversionQueue, ^{
        @autoreleasepool {
            NSError *error = nil;
            NSString *markdown = [self performConversionWithOptions:options error:&error];
            
            // Call completion on main queue
            dispatch_async(dispatch_get_main_queue(), ^{
                completion(markdown, error);
            });
        }
    });
}

- (void)cancelConversion {
    self.isCancelled = YES;
    [self.progress cancel];
}

- (BOOL)validateDocumentWithError:(NSError * _Nullable * _Nullable)error {
    if (!self.document) {
        if (error) {
            *error = [PDF22MDErrorHelper invalidPDFErrorWithReason:@"Document is nil"];
        }
        return NO;
    }
    
    if ([self.document pageCount] == 0) {
        if (error) {
            *error = [PDF22MDErrorHelper invalidPDFErrorWithReason:@"Document has no pages"];
        }
        return NO;
    }
    
    if ([self.document isLocked]) {
        if (error) {
            *error = [PDF22MDErrorHelper invalidPDFErrorWithReason:@"Document is password protected"];
        }
        return NO;
    }
    
    return YES;
}

#pragma mark - Private Methods

- (nullable NSString *)performConversionWithOptions:(PDF22MDConversionOptions *)options
                                              error:(NSError * _Nullable * _Nullable)error {
    // Validate document
    if (![self validateDocumentWithError:error]) {
        return nil;
    }
    
    NSInteger pageCount = [self.document pageCount];
    
    // Create asset manager if needed
    PDF22MDAssetManager *assetManager = nil;
    if (options.extractImages && options.assetsFolderPath) {
        assetManager = [[PDF22MDAssetManager alloc] initWithAssetFolder:options.assetsFolderPath];
        if (!assetManager) {
            if (error) {
                *error = [PDF22MDErrorHelper assetFolderCreationErrorWithPath:options.assetsFolderPath
                                                                          reason:@"Failed to create asset manager"];
            }
            return nil;
        }
    }
    
    // Process pages in parallel
    NSMutableArray<NSMutableArray<id<PDF22MDContentElement>> *> *pageElementsArray = [NSMutableArray arrayWithCapacity:pageCount];
    NSMutableArray<PDF22MDFontAnalyzer *> *pageFontAnalyzers = [NSMutableArray arrayWithCapacity:pageCount];
    
    for (NSInteger i = 0; i < pageCount; i++) {
        [pageElementsArray addObject:[NSMutableArray array]];
        [pageFontAnalyzers addObject:[[PDF22MDFontAnalyzer alloc] init]];
    }
    
    // Create dispatch group for parallel processing
    dispatch_group_t processingGroup = dispatch_group_create();
    __block BOOL processingFailed = NO;
    __block NSError *processingError = nil;
    
    // Limit concurrency based on options
    dispatch_semaphore_t concurrencySemaphore = dispatch_semaphore_create(options.maxConcurrentPages);
    
    for (NSInteger pageIndex = 0; pageIndex < pageCount; pageIndex++) {
        if (self.isCancelled) {
            if (error) {
                *error = [NSError errorWithDomain:PDF22MDErrorDomain
                                             code:PDF22MDErrorCancelled
                                         userInfo:@{NSLocalizedDescriptionKey: @"Conversion was cancelled"}];
            }
            return nil;
        }
        
        dispatch_group_async(processingGroup, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            dispatch_semaphore_wait(concurrencySemaphore, DISPATCH_TIME_FOREVER);
            
            @autoreleasepool {
                if (!processingFailed && !self.isCancelled) {
                    PDFPage *page = [self.document pageAtIndex:pageIndex];
                    if (!page) {
                        processingFailed = YES;
                        processingError = [PDF22MDErrorHelper pageProcessingFailedErrorForPage:pageIndex
                                                                                        reason:@"Failed to get page"
                                                                               underlyingError:nil];
                    } else {
                        // Process page
                        PDF22MDPageProcessor *processor = [[PDF22MDPageProcessor alloc] initWithPDFPage:page
                                                                                             pageIndex:pageIndex
                                                                                                   dpi:options.rasterizationDPI];
                        processor.fontAnalyzer = pageFontAnalyzers[pageIndex];
                        
                        NSArray<id<PDF22MDContentElement>> *pageElements = [processor extractContentElements];
                        [pageElementsArray[pageIndex] addObjectsFromArray:pageElements];
                        
                        // Analyze fonts for this page
                        [pageFontAnalyzers[pageIndex] analyzeElements:pageElements];
                        
                        // Update progress
                        dispatch_async(dispatch_get_main_queue(), ^{
                            self.progress.completedUnitCount = pageIndex + 1;
                            if (options.progressHandler) {
                                options.progressHandler(pageIndex + 1, pageCount);
                            }
                        });
                    }
                }
            }
            
            dispatch_semaphore_signal(concurrencySemaphore);
        });
    }
    
    // Wait for all pages to complete
    dispatch_group_wait(processingGroup, DISPATCH_TIME_FOREVER);
    
    if (processingFailed) {
        if (error) {
            *error = processingError ?: [PDF22MDErrorHelper processingFailedErrorWithReason:@"Unknown processing error"
                                                                              underlyingError:nil];
        }
        return nil;
    }
    
    if (self.isCancelled) {
        if (error) {
            *error = [NSError errorWithDomain:PDF22MDErrorDomain
                                         code:PDF22MDErrorCancelled
                                     userInfo:@{NSLocalizedDescriptionKey: @"Conversion was cancelled"}];
        }
        return nil;
    }
    
    // Merge results from all pages
    for (NSInteger i = 0; i < pageCount; i++) {
        [self.allElements addObjectsFromArray:pageElementsArray[i]];
        [self.fontAnalyzer mergeFontStatisticsFromAnalyzer:pageFontAnalyzers[i]];
    }
    
    // Analyze font hierarchy and assign heading levels
    [self.fontAnalyzer analyzeElements:self.allElements];
    [self.fontAnalyzer assignHeadingLevels:self.allElements];
    
    // Sort elements by page and position
    [self sortElements];
    
    // Extract and save images if needed
    if (assetManager) {
        [self extractImagesWithAssetManager:assetManager];
    }
    
    // Generate markdown
    PDF22MDMarkdownGenerator *generator = [[PDF22MDMarkdownGenerator alloc] initWithOptions:options];
    PDF22MDDocumentMetadata *metadata = [PDF22MDMarkdownGenerator extractMetadataFromDocument:self.document];
    
    NSString *markdown = [generator generateMarkdownFromElements:self.allElements withMetadata:metadata];
    
    return markdown;
}

- (void)sortElements {
    [self.allElements sortUsingComparator:^NSComparisonResult(id<PDF22MDContentElement> obj1, id<PDF22MDContentElement> obj2) {
        // First sort by page
        if (obj1.pageIndex != obj2.pageIndex) {
            return obj1.pageIndex < obj2.pageIndex ? NSOrderedAscending : NSOrderedDescending;
        }
        
        // Then sort by vertical position (top to bottom)
        CGFloat y1 = CGRectGetMaxY(obj1.bounds);
        CGFloat y2 = CGRectGetMaxY(obj2.bounds);
        
        if (fabs(y1 - y2) > 5.0) { // Tolerance for same line
            return y1 > y2 ? NSOrderedAscending : NSOrderedDescending;
        }
        
        // Finally sort by horizontal position (left to right)
        CGFloat x1 = CGRectGetMinX(obj1.bounds);
        CGFloat x2 = CGRectGetMinX(obj2.bounds);
        
        return x1 < x2 ? NSOrderedAscending : NSOrderedDescending;
    }];
}

- (void)extractImagesWithAssetManager:(PDF22MDAssetManager *)assetManager {
    NSMutableArray<PDF22MDImageElement *> *imageElements = [NSMutableArray array];
    
    for (id<PDF22MDContentElement> element in self.allElements) {
        if ([element isKindOfClass:[PDF22MDImageElement class]]) {
            [imageElements addObject:(PDF22MDImageElement *)element];
        }
    }
    
    if (imageElements.count == 0) {
        return;
    }
    
    // Save images in parallel
    dispatch_group_t imageGroup = dispatch_group_create();
    dispatch_queue_t imageQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    
    [imageElements enumerateObjectsUsingBlock:^(PDF22MDImageElement *imageElement, NSUInteger idx, BOOL * __unused stop) {
        dispatch_group_async(imageGroup, imageQueue, ^{
            @autoreleasepool {
                NSString *baseName = [NSString stringWithFormat:@"image_%03lu", (unsigned long)idx];
                [assetManager saveImageElement:imageElement withBaseName:baseName];
            }
        });
    }];
    
    dispatch_group_wait(imageGroup, DISPATCH_TIME_FOREVER);
}

@end
</file>

<file path="src/Core/PDF22MDError.h">
#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

/**
 * Error domain for all PDF22MD errors.
 */
extern NSErrorDomain const PDF22MDErrorDomain;

/**
 * Error codes used throughout the PDF22MD framework.
 */
typedef NS_ERROR_ENUM(PDF22MDErrorDomain, PDF22MDError) {
    /**
     * The provided PDF file or data is invalid or corrupted.
     */
    PDF22MDErrorInvalidPDF = 1000,
    
    /**
     * Failed to create the assets folder or save extracted images.
     */
    PDF22MDErrorAssetFolderCreation = 1001,
    
    /**
     * General processing failure during conversion.
     */
    PDF22MDErrorProcessingFailed = 1002,
    
    /**
     * One or more pages failed to process.
     */
    PDF22MDErrorPageProcessingFailed = 1003,
    
    /**
     * Invalid or missing configuration options.
     */
    PDF22MDErrorInvalidConfiguration = 1004,
    
    /**
     * I/O error reading or writing files.
     */
    PDF22MDErrorIOFailure = 1005,
    
    /**
     * Memory allocation failure or insufficient memory to process PDF.
     */
    PDF22MDErrorMemoryPressure = 1006,
    
    /**
     * Operation was cancelled.
     */
    PDF22MDErrorCancelled = 1007,
    
    /**
     * PDF processing timed out (document too complex).
     */
    PDF22MDErrorProcessingTimeout = 1008,
    
    /**
     * Password-protected PDFs are not currently supported.
     */
    PDF22MDErrorEncryptedPDF = 1009,
    
    /**
     * The PDF contains no readable content.
     */
    PDF22MDErrorEmptyDocument = 1010,
    
    /**
     * Invalid input parameters provided.
     */
    PDF22MDErrorInvalidInput = 1011,
    
    /**
     * File not found at specified path.
     */
    PDF22MDErrorFileNotFound = 1012
};

/**
 * Keys for additional information in error's userInfo dictionary.
 */
extern NSString * const PDF22MDErrorPageIndexKey;      // NSNumber containing the failed page index
extern NSString * const PDF22MDErrorFilePathKey;       // NSString containing the problematic file path
extern NSString * const PDF22MDErrorUnderlyingErrorKey; // Original NSError that caused this error

/**
 * Helper class for creating consistent, user-friendly error objects.
 */
@interface PDF22MDErrorHelper : NSObject

/**
 * Creates a user-friendly error with code, description, and actionable suggestion.
 */
+ (NSError *)userFriendlyErrorWithCode:(PDF22MDError)code 
                           description:(NSString *)description
                            suggestion:(nullable NSString *)suggestion
                       underlyingError:(nullable NSError *)underlyingError;

/**
 * Creates an error for invalid PDF input.
 */
+ (NSError *)invalidPDFError;

/**
 * Creates an error for invalid PDF input with additional details.
 */
+ (NSError *)invalidPDFErrorWithReason:(nullable NSString *)reason;

/**
 * Creates an error for file not found.
 */
+ (NSError *)fileNotFoundErrorWithPath:(NSString *)path;

/**
 * Creates an error for invalid input parameters.
 */
+ (NSError *)invalidInputErrorWithReason:(NSString *)reason;

/**
 * Creates an error for asset folder creation failure.
 */
+ (NSError *)assetFolderCreationErrorWithPath:(NSString *)path 
                                       reason:(nullable NSString *)reason;

/**
 * Creates an error for memory pressure.
 */
+ (NSError *)memoryPressureError;

/**
 * Creates an error for processing timeout.
 */
+ (NSError *)processingTimeoutError;

/**
 * Creates an error for encrypted PDF.
 */
+ (NSError *)encryptedPDFError;

/**
 * Creates an error for empty document.
 */
+ (NSError *)emptyDocumentError;

/**
 * Creates an error for page processing failure.
 */
+ (NSError *)pageProcessingFailedErrorForPage:(NSInteger)pageIndex 
                                        reason:(nullable NSString *)reason
                               underlyingError:(nullable NSError *)underlyingError;

/**
 * Creates an error for general processing failure.
 */
+ (NSError *)processingFailedErrorWithReason:(NSString *)reason 
                              underlyingError:(nullable NSError *)underlyingError;

/**
 * Creates an error for I/O failure.
 */
+ (NSError *)ioFailureErrorWithPath:(nullable NSString *)path 
                              reason:(NSString *)reason
                     underlyingError:(nullable NSError *)underlyingError;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="src/Core/PDF22MDError.m">
#import "PDF22MDError.h"

NSErrorDomain const PDF22MDErrorDomain = @"com.twardoch.pdf22md.ErrorDomain";

NSString * const PDF22MDErrorPageIndexKey = @"PDF22MDErrorPageIndex";
NSString * const PDF22MDErrorFilePathKey = @"PDF22MDErrorFilePath";
NSString * const PDF22MDErrorUnderlyingErrorKey = @"PDF22MDErrorUnderlyingError";

@implementation PDF22MDErrorHelper

+ (NSError *)userFriendlyErrorWithCode:(PDF22MDError)code 
                           description:(NSString *)description
                            suggestion:(nullable NSString *)suggestion
                       underlyingError:(nullable NSError *)underlyingError {
    NSMutableDictionary *userInfo = [@{
        NSLocalizedDescriptionKey: description,
        NSLocalizedFailureReasonErrorKey: description
    } mutableCopy];
    
    if (suggestion) {
        userInfo[NSLocalizedRecoverySuggestionErrorKey] = suggestion;
    }
    
    if (underlyingError) {
        userInfo[NSUnderlyingErrorKey] = underlyingError;
        userInfo[PDF22MDErrorUnderlyingErrorKey] = underlyingError;
    }
    
    return [NSError errorWithDomain:PDF22MDErrorDomain
                               code:code
                           userInfo:userInfo];
}

+ (NSError *)invalidPDFError {
    return [self invalidPDFErrorWithReason:nil];
}

+ (NSError *)invalidPDFErrorWithReason:(nullable NSString *)reason {
    NSString *description = reason ?: @"The PDF file appears to be corrupted or invalid";
    NSString *suggestion = @"Ensure the file is a valid PDF document. Try opening it in another PDF viewer to verify it's not corrupted.";
    
    return [self userFriendlyErrorWithCode:PDF22MDErrorInvalidPDF
                               description:description
                                suggestion:suggestion
                           underlyingError:nil];
}

+ (NSError *)fileNotFoundErrorWithPath:(NSString *)path {
    NSString *description = [NSString stringWithFormat:@"File not found: %@", path];
    NSString *suggestion = @"Check that the file path is correct and the file exists.";
    
    NSError *error = [self userFriendlyErrorWithCode:PDF22MDErrorFileNotFound
                                         description:description
                                          suggestion:suggestion
                                     underlyingError:nil];
    
    NSMutableDictionary *userInfo = [error.userInfo mutableCopy];
    userInfo[PDF22MDErrorFilePathKey] = path;
    
    return [NSError errorWithDomain:PDF22MDErrorDomain
                               code:PDF22MDErrorFileNotFound
                           userInfo:userInfo];
}

+ (NSError *)invalidInputErrorWithReason:(NSString *)reason {
    NSString *description = [NSString stringWithFormat:@"Invalid input: %@", reason];
    NSString *suggestion = @"Check the command line arguments and ensure all required parameters are provided correctly.";
    
    return [self userFriendlyErrorWithCode:PDF22MDErrorInvalidInput
                               description:description
                                suggestion:suggestion
                           underlyingError:nil];
}

+ (NSError *)assetFolderCreationErrorWithPath:(NSString *)path 
                                       reason:(nullable NSString *)reason {
    NSString *description = reason ?: @"Could not create assets folder at specified path";
    NSString *suggestion = @"Ensure you have write permissions to the target directory and sufficient disk space.";
    
    NSError *error = [self userFriendlyErrorWithCode:PDF22MDErrorAssetFolderCreation
                                         description:description
                                          suggestion:suggestion
                                     underlyingError:nil];
    
    NSMutableDictionary *userInfo = [error.userInfo mutableCopy];
    userInfo[PDF22MDErrorFilePathKey] = path;
    
    return [NSError errorWithDomain:PDF22MDErrorDomain
                               code:PDF22MDErrorAssetFolderCreation
                           userInfo:userInfo];
}

+ (NSError *)memoryPressureError {
    NSString *description = @"Insufficient memory to process this PDF";
    NSString *suggestion = @"Try processing a smaller PDF or close other applications to free up memory. For very large documents, consider splitting them into smaller files.";
    
    return [self userFriendlyErrorWithCode:PDF22MDErrorMemoryPressure
                               description:description
                                suggestion:suggestion
                           underlyingError:nil];
}

+ (NSError *)processingTimeoutError {
    NSString *description = @"PDF processing timed out (document too complex)";
    NSString *suggestion = @"The PDF may be extremely large or complex. Try processing smaller sections or contact support if this persists.";
    
    return [self userFriendlyErrorWithCode:PDF22MDErrorProcessingTimeout
                               description:description
                                suggestion:suggestion
                           underlyingError:nil];
}

+ (NSError *)encryptedPDFError {
    NSString *description = @"Password-protected PDFs are not currently supported";
    NSString *suggestion = @"Please remove the password protection from the PDF using another tool before conversion.";
    
    return [self userFriendlyErrorWithCode:PDF22MDErrorEncryptedPDF
                               description:description
                                suggestion:suggestion
                           underlyingError:nil];
}

+ (NSError *)emptyDocumentError {
    NSString *description = @"The PDF contains no readable content";
    NSString *suggestion = @"The PDF may be empty, contain only images without text, or have text in an unsupported format.";
    
    return [self userFriendlyErrorWithCode:PDF22MDErrorEmptyDocument
                               description:description
                                suggestion:suggestion
                           underlyingError:nil];
}

+ (NSError *)assetCreationFailedErrorWithPath:(NSString *)path 
                                         reason:(nullable NSString *)reason {
    // This method is deprecated in favor of assetFolderCreationErrorWithPath:reason:
    return [self assetFolderCreationErrorWithPath:path reason:reason];
}

+ (NSError *)pageProcessingFailedErrorForPage:(NSInteger)pageIndex 
                                        reason:(nullable NSString *)reason
                               underlyingError:(nullable NSError *)underlyingError {
    NSString *description = [NSString stringWithFormat:@"Failed to process page %ld", (long)(pageIndex + 1)];
    NSString *failureReason = reason ?: @"An error occurred while extracting content from the page";
    
    NSMutableDictionary *userInfo = [@{
        NSLocalizedDescriptionKey: description,
        NSLocalizedFailureReasonErrorKey: failureReason,
        NSLocalizedRecoverySuggestionErrorKey: @"The page may contain unsupported content or be corrupted",
        PDF22MDErrorPageIndexKey: @(pageIndex)
    } mutableCopy];
    
    if (underlyingError) {
        userInfo[NSUnderlyingErrorKey] = underlyingError;
        userInfo[PDF22MDErrorUnderlyingErrorKey] = underlyingError;
    }
    
    return [NSError errorWithDomain:PDF22MDErrorDomain
                               code:PDF22MDErrorPageProcessingFailed
                           userInfo:userInfo];
}

+ (NSError *)processingFailedErrorWithReason:(NSString *)reason 
                              underlyingError:(nullable NSError *)underlyingError {
    NSString *description = @"PDF processing failed";
    
    NSMutableDictionary *userInfo = [@{
        NSLocalizedDescriptionKey: description,
        NSLocalizedFailureReasonErrorKey: reason,
        NSLocalizedRecoverySuggestionErrorKey: @"Check the input file and try again"
    } mutableCopy];
    
    if (underlyingError) {
        userInfo[NSUnderlyingErrorKey] = underlyingError;
        userInfo[PDF22MDErrorUnderlyingErrorKey] = underlyingError;
    }
    
    return [NSError errorWithDomain:PDF22MDErrorDomain
                               code:PDF22MDErrorProcessingFailed
                           userInfo:userInfo];
}

+ (NSError *)ioFailureErrorWithPath:(nullable NSString *)path 
                              reason:(NSString *)reason
                     underlyingError:(nullable NSError *)underlyingError {
    NSString *description = @"File I/O operation failed";
    
    NSMutableDictionary *userInfo = [@{
        NSLocalizedDescriptionKey: description,
        NSLocalizedFailureReasonErrorKey: reason,
        NSLocalizedRecoverySuggestionErrorKey: @"Check file permissions and available disk space"
    } mutableCopy];
    
    if (path) {
        userInfo[PDF22MDErrorFilePathKey] = path;
    }
    
    if (underlyingError) {
        userInfo[NSUnderlyingErrorKey] = underlyingError;
        userInfo[PDF22MDErrorUnderlyingErrorKey] = underlyingError;
    }
    
    return [NSError errorWithDomain:PDF22MDErrorDomain
                               code:PDF22MDErrorIOFailure
                           userInfo:userInfo];
}

@end
</file>

<file path="src/Core/PDF22MDFontAnalyzer.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

@protocol PDF22MDContentElement;
@class PDF22MDTextElement;

/**
 * Font statistics for a particular font and size combination.
 */
@interface PDF22MDFontStatistics : NSObject
@property (nonatomic, copy, readonly) NSString *fontKey;
@property (nonatomic, copy, readonly) NSString *fontName;
@property (nonatomic, assign, readonly) CGFloat fontSize;
@property (nonatomic, assign, readonly) NSUInteger occurrenceCount;
@property (nonatomic, assign) NSInteger assignedHeadingLevel; // 0 for body text, 1-6 for headings

- (instancetype)initWithFontKey:(NSString *)fontKey
                       fontName:(NSString *)fontName
                       fontSize:(CGFloat)fontSize;

- (void)incrementOccurrenceCount;
- (void)addOccurrenceCount:(NSUInteger)count;

@end

/**
 * Analyzes font usage in PDF documents to detect heading hierarchy.
 */
@interface PDF22MDFontAnalyzer : NSObject

/**
 * The font size threshold for detecting headings.
 * Text with font size differences greater than this value may be considered headings.
 */
@property (nonatomic, assign) CGFloat fontSizeThreshold;

/**
 * Maximum heading level to assign (1-6).
 */
@property (nonatomic, assign) NSInteger maxHeadingLevel;

/**
 * Dictionary of font statistics keyed by font identifier.
 */
@property (nonatomic, strong, readonly) NSDictionary<NSString *, PDF22MDFontStatistics *> *fontStatistics;

/**
 * Initializes the analyzer with default settings.
 */
- (instancetype)init;

/**
 * Analyzes an array of content elements to build font statistics.
 * This should be called before assignHeadingLevels.
 *
 * @param elements Array of content elements to analyze
 */
- (void)analyzeElements:(NSArray<id<PDF22MDContentElement>> *)elements;

/**
 * Assigns heading levels to text elements based on font analysis.
 * Call this after analyzeElements.
 *
 * @param elements Array of content elements to process
 */
- (void)assignHeadingLevels:(NSArray<id<PDF22MDContentElement>> *)elements;

/**
 * Merges font statistics from another analyzer.
 * Useful for combining statistics from multiple pages.
 *
 * @param otherAnalyzer The analyzer to merge from
 */
- (void)mergeFontStatisticsFromAnalyzer:(PDF22MDFontAnalyzer *)otherAnalyzer;

/**
 * Resets all collected statistics.
 */
- (void)reset;

/**
 * Gets a sorted array of font statistics by size (largest first).
 */
- (NSArray<PDF22MDFontStatistics *> *)sortedFontStatistics;

/**
 * Creates a font key identifier from font properties.
 */
+ (NSString *)fontKeyForFontName:(nullable NSString *)fontName fontSize:(CGFloat)fontSize;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="src/Core/PDF22MDFontAnalyzer.m">
#import "PDF22MDFontAnalyzer.h"
#import "../Models/PDF22MDContentElement.h"
#import "../Models/PDF22MDTextElement.h"

@implementation PDF22MDFontStatistics

- (instancetype)initWithFontKey:(NSString *)fontKey
                       fontName:(NSString *)fontName
                       fontSize:(CGFloat)fontSize {
    self = [super init];
    if (self) {
        _fontKey = [fontKey copy];
        _fontName = [fontName copy];
        _fontSize = fontSize;
        _occurrenceCount = 0;
        _assignedHeadingLevel = 0;
    }
    return self;
}

- (void)incrementOccurrenceCount {
    _occurrenceCount++;
}

- (void)addOccurrenceCount:(NSUInteger)count {
    _occurrenceCount += count;
}

- (NSString *)description {
    return [NSString stringWithFormat:@"<FontStats: %@ size=%.1f count=%lu level=%ld>",
            self.fontName, self.fontSize, (unsigned long)self.occurrenceCount, (long)self.assignedHeadingLevel];
}

@end

@interface PDF22MDFontAnalyzer ()
@property (nonatomic, strong) NSMutableDictionary<NSString *, PDF22MDFontStatistics *> *mutableFontStatistics;
@end

@implementation PDF22MDFontAnalyzer

#pragma mark - Initialization

- (instancetype)init {
    self = [super init];
    if (self) {
        _fontSizeThreshold = 2.0;
        _maxHeadingLevel = 6;
        _mutableFontStatistics = [NSMutableDictionary dictionary];
    }
    return self;
}

#pragma mark - Public Methods

- (void)analyzeElements:(NSArray<id<PDF22MDContentElement>> *)elements {
    for (id<PDF22MDContentElement> element in elements) {
        if ([element isKindOfClass:[PDF22MDTextElement class]]) {
            PDF22MDTextElement *textElement = (PDF22MDTextElement *)element;
            [self addTextElementToStatistics:textElement];
        }
    }
}

- (void)assignHeadingLevels:(NSArray<id<PDF22MDContentElement>> *)elements {
    // Get sorted font statistics
    NSArray<PDF22MDFontStatistics *> *sortedStats = [self sortedFontStatistics];
    
    if (sortedStats.count == 0) {
        return;
    }
    
    // Find the most common font size (likely body text)
    PDF22MDFontStatistics *mostCommonFont = nil;
    NSUInteger highestCount = 0;
    
    for (PDF22MDFontStatistics *stats in sortedStats) {
        if (stats.occurrenceCount > highestCount) {
            highestCount = stats.occurrenceCount;
            mostCommonFont = stats;
        }
    }
    
    CGFloat bodyFontSize = mostCommonFont ? mostCommonFont.fontSize : 12.0;
    
    // Assign heading levels based on size hierarchy
    NSInteger currentHeadingLevel = 1;
    CGFloat lastHeadingSize = CGFLOAT_MAX;
    
    for (PDF22MDFontStatistics *stats in sortedStats) {
        // Skip if this is likely body text
        if (stats == mostCommonFont) {
            stats.assignedHeadingLevel = 0;
            continue;
        }
        
        // Check if this font is significantly larger than body text
        CGFloat sizeDifference = stats.fontSize - bodyFontSize;
        
        if (sizeDifference >= self.fontSizeThreshold) {
            // This is a potential heading
            // Check if it's significantly different from the last heading size
            if (lastHeadingSize - stats.fontSize >= self.fontSizeThreshold) {
                currentHeadingLevel++;
            }
            
            if (currentHeadingLevel <= self.maxHeadingLevel) {
                stats.assignedHeadingLevel = currentHeadingLevel;
                lastHeadingSize = stats.fontSize;
            } else {
                // Too many heading levels, treat as body text
                stats.assignedHeadingLevel = 0;
            }
        } else {
            // Not large enough to be a heading
            stats.assignedHeadingLevel = 0;
        }
        
        // Additional heuristic: if occurrence count is very high, it's probably not a heading
        if (stats.occurrenceCount > highestCount * 0.5) {
            stats.assignedHeadingLevel = 0;
        }
    }
    
    // Apply heading levels to text elements
    for (id<PDF22MDContentElement> element in elements) {
        if ([element isKindOfClass:[PDF22MDTextElement class]]) {
            PDF22MDTextElement *textElement = (PDF22MDTextElement *)element;
            NSString *fontKey = [[self class] fontKeyForFontName:textElement.fontName 
                                                        fontSize:textElement.fontSize];
            PDF22MDFontStatistics *stats = self.mutableFontStatistics[fontKey];
            if (stats) {
                textElement.headingLevel = stats.assignedHeadingLevel;
            }
        }
    }
}

- (void)mergeFontStatisticsFromAnalyzer:(PDF22MDFontAnalyzer *)otherAnalyzer {
    [otherAnalyzer.fontStatistics enumerateKeysAndObjectsUsingBlock:^(NSString *key, PDF22MDFontStatistics *otherStats, BOOL * __unused stop) {
        PDF22MDFontStatistics *existingStats = self.mutableFontStatistics[key];
        
        if (existingStats) {
            // Merge occurrence counts
            [existingStats addOccurrenceCount:otherStats.occurrenceCount];
        } else {
            // Add new statistics
            PDF22MDFontStatistics *newStats = [[PDF22MDFontStatistics alloc] initWithFontKey:otherStats.fontKey
                                                                                    fontName:otherStats.fontName
                                                                                    fontSize:otherStats.fontSize];
            [newStats addOccurrenceCount:otherStats.occurrenceCount];
            self.mutableFontStatistics[key] = newStats;
        }
    }];
}

- (void)reset {
    [self.mutableFontStatistics removeAllObjects];
}

- (NSArray<PDF22MDFontStatistics *> *)sortedFontStatistics {
    NSArray<PDF22MDFontStatistics *> *allStats = [self.mutableFontStatistics allValues];
    
    // Sort by font size in descending order
    return [allStats sortedArrayUsingComparator:^NSComparisonResult(PDF22MDFontStatistics *obj1, PDF22MDFontStatistics *obj2) {
        if (obj1.fontSize > obj2.fontSize) {
            return NSOrderedAscending;
        } else if (obj1.fontSize < obj2.fontSize) {
            return NSOrderedDescending;
        } else {
            // Same size, sort by occurrence count
            if (obj1.occurrenceCount > obj2.occurrenceCount) {
                return NSOrderedAscending;
            } else if (obj1.occurrenceCount < obj2.occurrenceCount) {
                return NSOrderedDescending;
            }
            return NSOrderedSame;
        }
    }];
}

+ (NSString *)fontKeyForFontName:(nullable NSString *)fontName fontSize:(CGFloat)fontSize {
    NSString *name = fontName ?: @"Unknown";
    return [NSString stringWithFormat:@"%.1f-%@", fontSize, name];
}

#pragma mark - Properties

- (NSDictionary<NSString *, PDF22MDFontStatistics *> *)fontStatistics {
    return [self.mutableFontStatistics copy];
}

#pragma mark - Private Methods

- (void)addTextElementToStatistics:(PDF22MDTextElement *)textElement {
    // Skip empty text
    NSString *trimmedText = [textElement.text stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    if (trimmedText.length == 0) {
        return;
    }
    
    NSString *fontKey = [[self class] fontKeyForFontName:textElement.fontName fontSize:textElement.fontSize];
    
    PDF22MDFontStatistics *stats = self.mutableFontStatistics[fontKey];
    if (!stats) {
        stats = [[PDF22MDFontStatistics alloc] initWithFontKey:fontKey
                                                      fontName:textElement.fontName ?: @"Unknown"
                                                      fontSize:textElement.fontSize];
        self.mutableFontStatistics[fontKey] = stats;
    }
    
    [stats incrementOccurrenceCount];
}

@end
</file>

<file path="src/Core/PDF22MDPageProcessor.h">
#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

@protocol PDF22MDContentElement;
@class PDF22MDFontAnalyzer;

/**
 * Processes individual PDF pages to extract content elements.
 * Uses PDFKit's high-level API for safe and reliable content extraction.
 */
@interface PDF22MDPageProcessor : NSObject

/**
 * The PDF page being processed.
 */
@property (nonatomic, strong, readonly) PDFPage *pdfPage;

/**
 * The zero-based index of the page.
 */
@property (nonatomic, assign, readonly) NSInteger pageIndex;

/**
 * DPI for rasterizing vector graphics.
 */
@property (nonatomic, assign, readonly) CGFloat dpi;

/**
 * Font analyzer for this page (optional).
 */
@property (nonatomic, strong, nullable) PDF22MDFontAnalyzer *fontAnalyzer;

/**
 * Initializes a page processor for the given PDF page.
 *
 * @param pdfPage The PDF page to process
 * @param pageIndex The zero-based page index
 * @param dpi DPI for rasterization (default: 144)
 * @return A new page processor instance
 */
- (instancetype)initWithPDFPage:(PDFPage *)pdfPage
                      pageIndex:(NSInteger)pageIndex
                            dpi:(CGFloat)dpi NS_DESIGNATED_INITIALIZER;

- (instancetype)init NS_UNAVAILABLE;

/**
 * Extracts all content elements from the page.
 * This includes text and images.
 *
 * @return Array of content elements in reading order
 */
- (NSArray<id<PDF22MDContentElement>> *)extractContentElements;

/**
 * Extracts only text elements from the page.
 *
 * @return Array of text elements
 */
- (NSArray<id<PDF22MDContentElement>> *)extractTextElements;

/**
 * Extracts only image elements from the page.
 *
 * @return Array of image elements
 */
- (NSArray<id<PDF22MDContentElement>> *)extractImageElements;

/**
 * Captures vector graphics in the specified bounds as a rasterized image.
 *
 * @param bounds The area to capture
 * @param elements Array to add the captured image element to
 */
- (void)captureVectorGraphicsInBounds:(CGRect)bounds
                         withElements:(NSMutableArray<id<PDF22MDContentElement>> *)elements;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="src/Core/PDF22MDPageProcessor.m">
#import "PDF22MDPageProcessor.h"
#import "../Models/PDF22MDTextElement.h"
#import "../Models/PDF22MDImageElement.h"
#import "PDF22MDFontAnalyzer.h"
#import <CoreGraphics/CoreGraphics.h>

#if TARGET_OS_MAC && !TARGET_OS_IPHONE
#import <AppKit/AppKit.h>
#else
#import <UIKit/UIKit.h>
#endif

@interface PDF22MDPageProcessor ()
@property (nonatomic, assign) CGPDFPageRef cgPdfPage;
@end

@implementation PDF22MDPageProcessor

#pragma mark - Initialization

- (instancetype)initWithPDFPage:(PDFPage *)pdfPage
                      pageIndex:(NSInteger)pageIndex
                            dpi:(CGFloat)dpi {
    self = [super init];
    if (self) {
        _pdfPage = pdfPage;
        _pageIndex = pageIndex;
        _dpi = dpi;
        _cgPdfPage = [pdfPage pageRef];
    }
    return self;
}

#pragma mark - Public Methods

- (NSArray<id<PDF22MDContentElement>> *)extractContentElements {
    NSMutableArray<id<PDF22MDContentElement>> *elements = [NSMutableArray array];
    
    // Extract text elements
    NSArray *textElements = [self extractTextElements];
    [elements addObjectsFromArray:textElements];
    
    // Extract image elements
    NSArray *imageElements = [self extractImageElements];
    [elements addObjectsFromArray:imageElements];
    
    // Sort elements by position
    [self sortElementsByPosition:elements];
    
    return elements;
}

- (NSArray<id<PDF22MDContentElement>> *)extractTextElements {
    NSMutableArray<id<PDF22MDContentElement>> *elements = [NSMutableArray array];
    
    // Extract text using PDFKit's high-level API
    NSString *pageText = [self.pdfPage string];
    if (!pageText || pageText.length == 0) {
        return elements;
    }
    
    // Get page bounds for positioning
    CGRect pageRect = [self.pdfPage boundsForBox:kPDFDisplayBoxMediaBox];
    CGFloat pageHeight = CGRectGetHeight(pageRect);
    
    // Split into paragraphs while preserving structure
    NSArray<NSString *> *paragraphs = [self extractParagraphsFromPageText:pageText];
    
    // Create text elements with approximate positioning
    CGFloat cursorY = pageHeight - 20; // Start near top with margin
    CGFloat lineHeight = 14.0; // Default line height
    CGFloat paragraphSpacing = lineHeight * 0.5;
    
    for (NSString *paragraph in paragraphs) {
        NSString *trimmed = [paragraph stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
        if (trimmed.length == 0) {
            cursorY -= paragraphSpacing;
            continue;
        }
        
        // Try to extract font information from PDF selections
        PDFSelection *selection = [self.pdfPage selectionForRange:NSMakeRange(0, trimmed.length)];
        NSDictionary *fontInfo = [self extractFontInfoFromSelection:selection];
        
        PDF22MDTextElement *element = [[PDF22MDTextElement alloc] initWithText:trimmed
                                                                        bounds:CGRectMake(20, cursorY - lineHeight, pageRect.size.width - 40, lineHeight)
                                                                     pageIndex:self.pageIndex
                                                                      fontName:fontInfo[@"fontName"]
                                                                      fontSize:[fontInfo[@"fontSize"] doubleValue]
                                                                        isBold:[fontInfo[@"isBold"] boolValue]
                                                                      isItalic:[fontInfo[@"isItalic"] boolValue]];
        
        [elements addObject:element];
        
        // Update cursor position
        NSInteger lineCount = [self estimateLineCountForText:trimmed inWidth:pageRect.size.width - 40];
        cursorY -= (lineHeight * lineCount + paragraphSpacing);
    }
    
    return elements;
}

- (NSArray<id<PDF22MDContentElement>> *)extractImageElements {
    NSMutableArray<id<PDF22MDContentElement>> *elements = [NSMutableArray array];
    
    // Method 1: Extract images from annotations
    NSArray<PDFAnnotation *> *annotations = [self.pdfPage annotations];
    
    for (PDFAnnotation *annotation in annotations) {
        // Check if annotation might contain an image
        if ([self annotationMayContainImage:annotation]) {
            CGImageRef image = [self imageFromAnnotation:annotation];
            if (image) {
                PDF22MDImageElement *element = [[PDF22MDImageElement alloc] initWithImage:image
                                                                                   bounds:[annotation bounds]
                                                                                pageIndex:self.pageIndex
                                                                           isVectorSource:NO];
                [elements addObject:element];
                CGImageRelease(image);
            }
        }
    }
    
    // Method 2: Detect image regions by analyzing page content
    NSArray *imageRegions = [self detectImageRegionsInPage];
    for (NSData *regionData in imageRegions) {
        CGRect region;
        [regionData getBytes:&region length:sizeof(CGRect)];
        [self captureVectorGraphicsInBounds:region withElements:elements];
    }
    
    return elements;
}

- (void)captureVectorGraphicsInBounds:(CGRect)bounds
                         withElements:(NSMutableArray<id<PDF22MDContentElement>> *)elements {
    // Expand bounds slightly to ensure we capture everything
    bounds = CGRectInset(bounds, -5, -5);
    
    // Calculate size at specified DPI
    CGFloat scale = self.dpi / 72.0;
    size_t width = (size_t)(CGRectGetWidth(bounds) * scale);
    size_t height = (size_t)(CGRectGetHeight(bounds) * scale);
    
    if (width == 0 || height == 0 || width > 4096 || height > 4096) {
        return;
    }
    
    // Create bitmap context
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, colorSpace,
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        return;
    }
    
    // Set white background
    CGContextSetRGBFillColor(context, 1.0, 1.0, 1.0, 1.0);
    CGContextFillRect(context, CGRectMake(0, 0, width, height));
    
    // Set up transformation to render just the bounds area
    CGContextSaveGState(context);
    CGContextScaleCTM(context, scale, scale);
    CGContextTranslateCTM(context, -bounds.origin.x, -bounds.origin.y);
    
    // Draw the PDF page
    CGContextDrawPDFPage(context, self.cgPdfPage);
    
    CGContextRestoreGState(context);
    
    // Create image
    CGImageRef image = CGBitmapContextCreateImage(context);
    CGContextRelease(context);
    
    if (image) {
        PDF22MDImageElement *element = [[PDF22MDImageElement alloc] initWithImage:image
                                                                           bounds:bounds
                                                                        pageIndex:self.pageIndex
                                                                   isVectorSource:YES];
        [elements addObject:element];
        CGImageRelease(image);
    }
}

#pragma mark - Private Methods

- (NSArray<NSString *> *)extractParagraphsFromPageText:(NSString *)pageText {
    // Split by multiple newlines to get paragraphs
    NSArray *components = [pageText componentsSeparatedByString:@"\n\n"];
    NSMutableArray *paragraphs = [NSMutableArray array];
    
    for (NSString *component in components) {
        // Further split by single newlines but join short lines
        NSArray *lines = [component componentsSeparatedByString:@"\n"];
        NSMutableString *paragraph = [NSMutableString string];
        
        for (NSString *line in lines) {
            NSString *trimmedLine = [line stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
            if (trimmedLine.length > 0) {
                if (paragraph.length > 0) {
                    // Add space between lines
                    [paragraph appendString:@" "];
                }
                [paragraph appendString:trimmedLine];
            }
        }
        
        if (paragraph.length > 0) {
            [paragraphs addObject:[paragraph copy]];
        }
    }
    
    return paragraphs;
}

- (NSDictionary *)extractFontInfoFromSelection:(PDFSelection *)selection {
    // Default font info
    NSMutableDictionary *fontInfo = [@{
        @"fontName": @"Helvetica",
        @"fontSize": @(12.0),
        @"isBold": @(NO),
        @"isItalic": @(NO)
    } mutableCopy];
    
    // PDFKit doesn't provide direct access to font information
    // This would require lower-level Core Graphics analysis
    // For now, we'll use heuristics based on the text content
    
    NSString *text = [selection string];
    if (text) {
        // Simple heuristic: all caps might indicate a heading
        if ([text isEqualToString:[text uppercaseString]] && text.length > 3) {
            fontInfo[@"fontSize"] = @(14.0);
            fontInfo[@"isBold"] = @(YES);
        }
    }
    
    return fontInfo;
}

- (BOOL)annotationMayContainImage:(PDFAnnotation *)annotation {
    // Check annotation type and bounds
    CGRect bounds = [annotation bounds];
    
    // Images typically have reasonable dimensions
    if (CGRectIsEmpty(bounds) || bounds.size.width < 10 || bounds.size.height < 10) {
        return NO;
    }
    
    // Check if it's not a text annotation
    NSString *contents = [annotation contents];
    if (contents && contents.length > 0) {
        return NO;
    }
    
    return YES;
}

- (CGImageRef)imageFromAnnotation:(PDFAnnotation *)annotation {
    CGRect bounds = [annotation bounds];
    
    // Create a bitmap context to render the annotation
    CGFloat scale = self.dpi / 72.0;
    size_t width = (size_t)(bounds.size.width * scale);
    size_t height = (size_t)(bounds.size.height * scale);
    
    if (width == 0 || height == 0 || width > 4096 || height > 4096) {
        return NULL;
    }
    
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, colorSpace,
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        return NULL;
    }
    
    // Set white background
    CGContextSetRGBFillColor(context, 1.0, 1.0, 1.0, 1.0);
    CGContextFillRect(context, CGRectMake(0, 0, width, height));
    
    // Transform context to match annotation bounds
    CGContextSaveGState(context);
    CGContextScaleCTM(context, scale, scale);
    
    // Draw just the annotation area from the page
    CGContextClipToRect(context, CGRectMake(0, 0, bounds.size.width, bounds.size.height));
    CGContextTranslateCTM(context, -bounds.origin.x, -bounds.origin.y);
    CGContextDrawPDFPage(context, self.cgPdfPage);
    
    CGContextRestoreGState(context);
    
    // Create image
    CGImageRef image = CGBitmapContextCreateImage(context);
    CGContextRelease(context);
    
    return image;
}

- (NSArray *)detectImageRegionsInPage {
    NSMutableArray *regions = [NSMutableArray array];
    
    // Simple heuristic: divide page into grid and check for non-text regions
    CGRect pageRect = [self.pdfPage boundsForBox:kPDFDisplayBoxMediaBox];
    CGFloat gridSize = 100.0;
    
    NSInteger gridX = (NSInteger)ceil(pageRect.size.width / gridSize);
    NSInteger gridY = (NSInteger)ceil(pageRect.size.height / gridSize);
    
    for (NSInteger x = 0; x < gridX; x++) {
        for (NSInteger y = 0; y < gridY; y++) {
            CGRect gridRect = CGRectMake(x * gridSize, y * gridSize, gridSize, gridSize);
            gridRect = CGRectIntersection(gridRect, pageRect);
            
            if (CGRectIsEmpty(gridRect) || gridRect.size.width < 20 || gridRect.size.height < 20) {
                continue;
            }
            
            // Check if this region contains primarily non-text content
            PDFSelection *selection = [self.pdfPage selectionForRect:gridRect];
            NSString *regionText = [[selection string] stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
            
            // If very little text, might be an image region
            if (regionText.length < 10) {
                NSData *rectData = [NSData dataWithBytes:&gridRect length:sizeof(CGRect)];
                [regions addObject:rectData];
            }
        }
    }
    
    // Merge adjacent regions
    return [self mergeAdjacentRegions:regions];
}

- (NSArray *)mergeAdjacentRegions:(NSArray *)regions {
    if (regions.count <= 1) {
        return regions;
    }
    
    NSMutableArray *mergedRegions = [NSMutableArray array];
    NSMutableSet *processedIndices = [NSMutableSet set];
    
    for (NSUInteger i = 0; i < regions.count; i++) {
        if ([processedIndices containsObject:@(i)]) {
            continue;
        }
        
        CGRect currentRect;
        [regions[i] getBytes:&currentRect length:sizeof(CGRect)];
        [processedIndices addObject:@(i)];
        
        // Try to merge with adjacent regions
        BOOL merged = YES;
        while (merged) {
            merged = NO;
            
            for (NSUInteger j = 0; j < regions.count; j++) {
                if ([processedIndices containsObject:@(j)]) {
                    continue;
                }
                
                CGRect otherRect;
                [regions[j] getBytes:&otherRect length:sizeof(CGRect)];
                
                // Check if rectangles are adjacent
                if (CGRectIntersectsRect(CGRectInset(currentRect, -10, -10), otherRect)) {
                    currentRect = CGRectUnion(currentRect, otherRect);
                    [processedIndices addObject:@(j)];
                    merged = YES;
                }
            }
        }
        
        NSData *rectData = [NSData dataWithBytes:&currentRect length:sizeof(CGRect)];
        [mergedRegions addObject:rectData];
    }
    
    return mergedRegions;
}

- (NSInteger)estimateLineCountForText:(NSString *)text inWidth:(CGFloat)width {
    // Simple estimation based on average character width
    CGFloat avgCharWidth = 7.0; // Approximate for 12pt font
    NSInteger charsPerLine = (NSInteger)(width / avgCharWidth);
    
    if (charsPerLine <= 0) {
        return 1;
    }
    
    return MAX(1, (text.length + charsPerLine - 1) / charsPerLine);
}

- (void)sortElementsByPosition:(NSMutableArray<id<PDF22MDContentElement>> *)elements {
    [elements sortUsingComparator:^NSComparisonResult(id<PDF22MDContentElement> obj1, id<PDF22MDContentElement> obj2) {
        // Sort by vertical position (top to bottom)
        CGFloat y1 = CGRectGetMaxY(obj1.bounds);
        CGFloat y2 = CGRectGetMaxY(obj2.bounds);
        
        if (fabs(y1 - y2) > 5.0) { // Tolerance for same line
            return y1 > y2 ? NSOrderedAscending : NSOrderedDescending;
        }
        
        // Same line, sort by horizontal position (left to right)
        CGFloat x1 = CGRectGetMinX(obj1.bounds);
        CGFloat x2 = CGRectGetMinX(obj2.bounds);
        
        return x1 < x2 ? NSOrderedAscending : NSOrderedDescending;
    }];
}

@end
</file>

<file path="src/Models/PDF22MDContentElement.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

/**
 * Protocol defining the interface for all content elements extracted from a PDF.
 * This includes text elements, image elements, and potentially other content types.
 */
@protocol PDF22MDContentElement <NSObject>

@required
/**
 * The bounding rectangle of this element in PDF coordinate space.
 */
@property (nonatomic, readonly) CGRect bounds;

/**
 * The zero-based index of the page this element was extracted from.
 */
@property (nonatomic, readonly) NSInteger pageIndex;

/**
 * Generates the Markdown representation of this element.
 * @return A string containing the Markdown formatted content, or nil if the element has no valid representation.
 */
- (nullable NSString *)markdownRepresentation;

@optional
/**
 * Additional metadata associated with this element.
 * The dictionary keys and values are element-type specific.
 */
- (NSDictionary<NSString *, id> *)metadata;

/**
 * The original extraction context for debugging purposes.
 */
- (NSString *)debugDescription;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="src/Models/PDF22MDImageElement.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>
#import "PDF22MDContentElement.h"

NS_ASSUME_NONNULL_BEGIN

/**
 * Represents an image element extracted from a PDF page.
 * Handles both raster and vector graphics.
 */
@interface PDF22MDImageElement : NSObject <PDF22MDContentElement>

/**
 * The extracted image. Ownership is transferred to this object.
 */
@property (nonatomic, readonly) CGImageRef image;

/**
 * The bounding rectangle of this image in the PDF.
 */
@property (nonatomic, assign, readonly) CGRect bounds;

/**
 * The page index where this image was found.
 */
@property (nonatomic, assign, readonly) NSInteger pageIndex;

/**
 * Indicates whether this image was originally vector graphics.
 */
@property (nonatomic, assign, readonly) BOOL isVectorSource;

/**
 * The relative path to the saved asset file, if any.
 * This is set after the image has been extracted and saved.
 */
@property (nonatomic, copy, nullable) NSString *assetRelativePath;

/**
 * Designated initializer for creating an image element.
 *
 * @param image The CGImage (ownership is transferred)
 * @param bounds The bounding rectangle
 * @param pageIndex The page index
 * @param isVectorSource Whether this was originally vector graphics
 * @return A new image element instance
 */
- (instancetype)initWithImage:(CGImageRef)image
                       bounds:(CGRect)bounds
                    pageIndex:(NSInteger)pageIndex
               isVectorSource:(BOOL)isVectorSource NS_DESIGNATED_INITIALIZER;

- (instancetype)init NS_UNAVAILABLE;

/**
 * Analyzes the image to determine if JPEG compression would be suitable.
 * @return YES if JPEG is recommended, NO for PNG
 */
- (BOOL)shouldUseJPEGCompression;

/**
 * Gets the dimensions of the image.
 * @return The size in pixels
 */
- (CGSize)imageDimensions;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="src/Models/PDF22MDImageElement.m">
#import "PDF22MDImageElement.h"

@implementation PDF22MDImageElement

#pragma mark - Initialization

- (instancetype)initWithImage:(CGImageRef)image
                       bounds:(CGRect)bounds
                    pageIndex:(NSInteger)pageIndex
               isVectorSource:(BOOL)isVectorSource {
    self = [super init];
    if (self) {
        _image = CGImageRetain(image);
        _bounds = bounds;
        _pageIndex = pageIndex;
        _isVectorSource = isVectorSource;
    }
    return self;
}

- (void)dealloc {
    if (_image) {
        CGImageRelease(_image);
    }
}

#pragma mark - PDF22MDContentElement Protocol

- (nullable NSString *)markdownRepresentation {
    if (!self.assetRelativePath) {
        return @"![Image](image-not-saved)";
    }
    
    return [NSString stringWithFormat:@"![Image](%@)", self.assetRelativePath];
}

- (NSDictionary<NSString *, id> *)metadata {
    CGSize dimensions = [self imageDimensions];
    
    return @{
        @"width": @(dimensions.width),
        @"height": @(dimensions.height),
        @"isVectorSource": @(self.isVectorSource),
        @"hasAlpha": @([self imageHasAlpha]),
        @"shouldUseJPEG": @([self shouldUseJPEGCompression])
    };
}

#pragma mark - Public Methods

- (CGSize)imageDimensions {
    if (!self.image) {
        return CGSizeZero;
    }
    
    return CGSizeMake(CGImageGetWidth(self.image), CGImageGetHeight(self.image));
}

- (BOOL)shouldUseJPEGCompression {
    if (!self.image) {
        return NO;
    }
    
    // If image has alpha channel, use PNG
    if ([self imageHasAlpha]) {
        return NO;
    }
    
    // For small images, use PNG
    CGSize dimensions = [self imageDimensions];
    if (dimensions.width * dimensions.height < 10000) { // Less than 100x100
        return NO;
    }
    
    // For vector sources, prefer PNG to maintain quality
    if (self.isVectorSource) {
        return NO;
    }
    
    // Analyze color complexity
    NSUInteger uniqueColors = [self estimateUniqueColorCount];
    
    // If we have many unique colors, it's likely a photograph - use JPEG
    return uniqueColors > 256;
}

#pragma mark - Private Methods

- (BOOL)imageHasAlpha {
    if (!self.image) {
        return NO;
    }
    
    CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(self.image);
    
    return alphaInfo != kCGImageAlphaNone &&
           alphaInfo != kCGImageAlphaNoneSkipFirst &&
           alphaInfo != kCGImageAlphaNoneSkipLast;
}

- (NSUInteger)estimateUniqueColorCount {
    if (!self.image) {
        return 0;
    }
    
    size_t width = CGImageGetWidth(self.image);
    size_t height = CGImageGetHeight(self.image);
    
    // Sample a subset of pixels for performance
    size_t sampleWidth = MIN(width, 100);
    size_t sampleHeight = MIN(height, 100);
    size_t __unused stepX = MAX(1, width / sampleWidth);
    size_t __unused stepY = MAX(1, height / sampleHeight);
    
    // Create a small bitmap context for sampling
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    size_t bytesPerRow = sampleWidth * 4;
    unsigned char *pixelData = calloc(sampleHeight * bytesPerRow, sizeof(unsigned char));
    
    if (!pixelData) {
        CGColorSpaceRelease(colorSpace);
        return 256; // Default to medium complexity
    }
    
    CGContextRef context = CGBitmapContextCreate(pixelData, sampleWidth, sampleHeight, 8, bytesPerRow, colorSpace,
                                                kCGImageAlphaNoneSkipLast | kCGBitmapByteOrder32Big);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        free(pixelData);
        return 256;
    }
    
    // Draw scaled image
    CGContextDrawImage(context, CGRectMake(0, 0, sampleWidth, sampleHeight), self.image);
    CGContextRelease(context);
    
    // Count unique colors
    NSMutableSet *uniqueColors = [NSMutableSet set];
    
    for (size_t y = 0; y < sampleHeight; y++) {
        for (size_t x = 0; x < sampleWidth; x++) {
            size_t offset = (y * bytesPerRow) + (x * 4);
            uint32_t color = (pixelData[offset] << 24) | 
                           (pixelData[offset + 1] << 16) | 
                           (pixelData[offset + 2] << 8) | 
                           pixelData[offset + 3];
            [uniqueColors addObject:@(color)];
            
            // Early exit if we already have many colors
            if (uniqueColors.count > 1000) {
                free(pixelData);
                return uniqueColors.count;
            }
        }
    }
    
    free(pixelData);
    return uniqueColors.count;
}

#pragma mark - NSObject

- (NSString *)description {
    CGSize dimensions = [self imageDimensions];
    return [NSString stringWithFormat:@"<%@: %p, size=%.0fx%.0f, bounds=%@, page=%ld>",
            NSStringFromClass([self class]),
            self,
            dimensions.width,
            dimensions.height,
            [NSString stringWithFormat:@"{{%.1f,%.1f},{%.1f,%.1f}}", self.bounds.origin.x, self.bounds.origin.y, self.bounds.size.width, self.bounds.size.height],
            (long)self.pageIndex];
}

- (NSString *)debugDescription {
    CGSize dimensions = [self imageDimensions];
    return [NSString stringWithFormat:@"<%@: %p> {\n  dimensions: %.0fx%.0f\n  bounds: %@\n  page: %ld\n  vector: %@\n  alpha: %@\n  path: %@\n}",
            NSStringFromClass([self class]),
            self,
            dimensions.width,
            dimensions.height,
            [NSString stringWithFormat:@"{{%.1f,%.1f},{%.1f,%.1f}}", self.bounds.origin.x, self.bounds.origin.y, self.bounds.size.width, self.bounds.size.height],
            (long)self.pageIndex,
            self.isVectorSource ? @"YES" : @"NO",
            [self imageHasAlpha] ? @"YES" : @"NO",
            self.assetRelativePath ?: @"<not saved>"];
}

- (BOOL)isEqual:(id)object {
    if (self == object) {
        return YES;
    }
    
    if (![object isKindOfClass:[PDF22MDImageElement class]]) {
        return NO;
    }
    
    PDF22MDImageElement *other = (PDF22MDImageElement *)object;
    
    return CGRectEqualToRect(self.bounds, other.bounds) &&
           self.pageIndex == other.pageIndex &&
           self.isVectorSource == other.isVectorSource &&
           (self.assetRelativePath == other.assetRelativePath || 
            [self.assetRelativePath isEqualToString:other.assetRelativePath]);
}

- (NSUInteger)hash {
    NSUInteger prime = 31;
    NSUInteger result = 1;
    
    result = prime * result + (NSUInteger)(self.bounds.origin.x + self.bounds.origin.y + self.bounds.size.width + self.bounds.size.height);
    result = prime * result + self.pageIndex;
    result = prime * result + (self.isVectorSource ? 1 : 0);
    result = prime * result + [self.assetRelativePath hash];
    
    return result;
}

@end
</file>

<file path="src/Models/PDF22MDTextElement.h">
#import <Foundation/Foundation.h>
#import "PDF22MDContentElement.h"

NS_ASSUME_NONNULL_BEGIN

/**
 * Represents a text element extracted from a PDF page.
 * Includes text content and associated styling information.
 */
@interface PDF22MDTextElement : NSObject <PDF22MDContentElement>

/**
 * The extracted text content. Never nil, but may be empty.
 */
@property (nonatomic, copy, readonly) NSString *text;

/**
 * The bounding rectangle of this text element.
 */
@property (nonatomic, assign, readonly) CGRect bounds;

/**
 * The page index where this text was found.
 */
@property (nonatomic, assign, readonly) NSInteger pageIndex;

/**
 * The font name used for this text, if available.
 */
@property (nonatomic, copy, nullable, readonly) NSString *fontName;

/**
 * The font size in points.
 */
@property (nonatomic, assign, readonly) CGFloat fontSize;

/**
 * Indicates if the text appears to be bold.
 */
@property (nonatomic, assign, readonly) BOOL isBold;

/**
 * Indicates if the text appears to be italic.
 */
@property (nonatomic, assign, readonly) BOOL isItalic;

/**
 * The detected heading level (0 for body text, 1-6 for headings).
 */
@property (nonatomic, assign) NSInteger headingLevel;

/**
 * Designated initializer for creating a text element.
 *
 * @param text The text content (required)
 * @param bounds The bounding rectangle
 * @param pageIndex The page index
 * @return A new text element instance
 */
- (instancetype)initWithText:(NSString *)text
                      bounds:(CGRect)bounds
                   pageIndex:(NSInteger)pageIndex;

/**
 * Convenience initializer with full styling information.
 *
 * @param text The text content
 * @param bounds The bounding rectangle
 * @param pageIndex The page index
 * @param fontName The font name (optional)
 * @param fontSize The font size
 * @param isBold Bold style flag
 * @param isItalic Italic style flag
 * @return A new text element instance
 */
- (instancetype)initWithText:(NSString *)text
                      bounds:(CGRect)bounds
                   pageIndex:(NSInteger)pageIndex
                    fontName:(nullable NSString *)fontName
                    fontSize:(CGFloat)fontSize
                      isBold:(BOOL)isBold
                    isItalic:(BOOL)isItalic NS_DESIGNATED_INITIALIZER;

- (instancetype)init NS_UNAVAILABLE;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="src/Models/PDF22MDTextElement.m">
#import "PDF22MDTextElement.h"

@implementation PDF22MDTextElement

#pragma mark - Initialization

- (instancetype)initWithText:(NSString *)text
                      bounds:(CGRect)bounds
                   pageIndex:(NSInteger)pageIndex {
    return [self initWithText:text
                       bounds:bounds
                    pageIndex:pageIndex
                     fontName:nil
                     fontSize:12.0
                       isBold:NO
                     isItalic:NO];
}

- (instancetype)initWithText:(NSString *)text
                      bounds:(CGRect)bounds
                   pageIndex:(NSInteger)pageIndex
                    fontName:(nullable NSString *)fontName
                    fontSize:(CGFloat)fontSize
                      isBold:(BOOL)isBold
                    isItalic:(BOOL)isItalic {
    self = [super init];
    if (self) {
        _text = [text copy];
        _bounds = bounds;
        _pageIndex = pageIndex;
        _fontName = [fontName copy];
        _fontSize = fontSize;
        _isBold = isBold;
        _isItalic = isItalic;
        _headingLevel = 0; // Default to body text
    }
    return self;
}

#pragma mark - PDF22MDContentElement Protocol

- (nullable NSString *)markdownRepresentation {
    if (!self.text || self.text.length == 0) {
        return nil;
    }
    
    NSString *trimmedText = [self.text stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    if (trimmedText.length == 0) {
        return nil;
    }
    
    // Apply heading formatting
    if (self.headingLevel > 0 && self.headingLevel <= 6) {
        NSMutableString *heading = [NSMutableString string];
        for (NSInteger i = 0; i < self.headingLevel; i++) {
            [heading appendString:@"#"];
        }
        [heading appendString:@" "];
        [heading appendString:trimmedText];
        return heading;
    }
    
    // Apply bold/italic formatting
    NSString *formattedText = trimmedText;
    
    if (self.isBold && self.isItalic) {
        formattedText = [NSString stringWithFormat:@"***%@***", formattedText];
    } else if (self.isBold) {
        formattedText = [NSString stringWithFormat:@"**%@**", formattedText];
    } else if (self.isItalic) {
        formattedText = [NSString stringWithFormat:@"*%@*", formattedText];
    }
    
    return formattedText;
}

- (NSDictionary<NSString *, id> *)metadata {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    if (self.fontName) {
        metadata[@"fontName"] = self.fontName;
    }
    metadata[@"fontSize"] = @(self.fontSize);
    metadata[@"isBold"] = @(self.isBold);
    metadata[@"isItalic"] = @(self.isItalic);
    metadata[@"headingLevel"] = @(self.headingLevel);
    
    return [metadata copy];
}

#pragma mark - NSObject

- (NSString *)description {
    return [NSString stringWithFormat:@"<%@: %p, text='%@', bounds=%@, page=%ld>",
            NSStringFromClass([self class]),
            self,
            [self.text length] > 50 ? [[self.text substringToIndex:50] stringByAppendingString:@"..."] : self.text,
            [NSString stringWithFormat:@"{{%.1f,%.1f},{%.1f,%.1f}}", self.bounds.origin.x, self.bounds.origin.y, self.bounds.size.width, self.bounds.size.height],
            (long)self.pageIndex];
}

- (NSString *)debugDescription {
    return [NSString stringWithFormat:@"<%@: %p> {\n  text: '%@'\n  bounds: %@\n  page: %ld\n  font: %@\n  size: %.1f\n  bold: %@\n  italic: %@\n  heading: %ld\n}",
            NSStringFromClass([self class]),
            self,
            self.text,
            [NSString stringWithFormat:@"{{%.1f,%.1f},{%.1f,%.1f}}", self.bounds.origin.x, self.bounds.origin.y, self.bounds.size.width, self.bounds.size.height],
            (long)self.pageIndex,
            self.fontName ?: @"<unknown>",
            self.fontSize,
            self.isBold ? @"YES" : @"NO",
            self.isItalic ? @"YES" : @"NO",
            (long)self.headingLevel];
}

- (BOOL)isEqual:(id)object {
    if (self == object) {
        return YES;
    }
    
    if (![object isKindOfClass:[PDF22MDTextElement class]]) {
        return NO;
    }
    
    PDF22MDTextElement *other = (PDF22MDTextElement *)object;
    
    return [self.text isEqualToString:other.text] &&
           CGRectEqualToRect(self.bounds, other.bounds) &&
           self.pageIndex == other.pageIndex &&
           (self.fontName == other.fontName || [self.fontName isEqualToString:other.fontName]) &&
           self.fontSize == other.fontSize &&
           self.isBold == other.isBold &&
           self.isItalic == other.isItalic &&
           self.headingLevel == other.headingLevel;
}

- (NSUInteger)hash {
    NSUInteger prime = 31;
    NSUInteger result = 1;
    
    result = prime * result + [self.text hash];
    result = prime * result + (NSUInteger)(self.bounds.origin.x + self.bounds.origin.y + self.bounds.size.width + self.bounds.size.height);
    result = prime * result + self.pageIndex;
    result = prime * result + [self.fontName hash];
    result = prime * result + (NSUInteger)self.fontSize;
    result = prime * result + (self.isBold ? 1 : 0);
    result = prime * result + (self.isItalic ? 1 : 0);
    result = prime * result + self.headingLevel;
    
    return result;
}

@end
</file>

<file path="src/Services/PDF22MDAssetManager.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

@class PDF22MDImageElement;

/**
 * Manages the extraction and saving of assets (images) from PDF documents.
 * Thread-safe for concurrent image saving operations.
 */
@interface PDF22MDAssetManager : NSObject

/**
 * The base folder path where assets will be saved.
 */
@property (nonatomic, copy, readonly) NSString *assetsFolderPath;

/**
 * Initializes the asset manager with a folder path.
 * Creates the folder if it doesn't exist.
 *
 * @param folderPath The path where assets will be saved
 * @return A new instance, or nil if folder creation fails
 */
- (nullable instancetype)initWithAssetFolder:(NSString *)folderPath NS_DESIGNATED_INITIALIZER;

- (instancetype)init NS_UNAVAILABLE;

/**
 * Saves an image to the assets folder with automatic format selection.
 *
 * @param image The CGImage to save
 * @param isVectorSource Whether this image originated from vector graphics
 * @param baseName The base filename (without extension)
 * @return The relative path to the saved file, or nil on failure
 */
- (nullable NSString *)saveImage:(CGImageRef)image
                  isVectorSource:(BOOL)isVectorSource
                    withBaseName:(NSString *)baseName;

/**
 * Saves an image element to the assets folder.
 * Updates the element's assetRelativePath property on success.
 *
 * @param imageElement The image element to save
 * @param baseName The base filename (without extension)
 * @return The relative path to the saved file, or nil on failure
 */
- (nullable NSString *)saveImageElement:(PDF22MDImageElement *)imageElement
                           withBaseName:(NSString *)baseName;

/**
 * Determines the optimal image format for the given image.
 *
 * @param image The image to analyze
 * @param isVectorSource Whether this originated from vector graphics
 * @return YES for JPEG, NO for PNG
 */
- (BOOL)shouldUseJPEGForImage:(CGImageRef)image
                isVectorSource:(BOOL)isVectorSource;

/**
 * Gets the next available filename for the given base name.
 * Handles conflicts by appending numbers.
 *
 * @param baseName The desired base filename
 * @param extension The file extension (without dot)
 * @return A unique filename
 */
- (NSString *)uniqueFilenameForBaseName:(NSString *)baseName
                          withExtension:(NSString *)extension;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="src/Services/PDF22MDAssetManager.m">
#import "PDF22MDAssetManager.h"
#import "../Models/PDF22MDImageElement.h"
#import <ImageIO/ImageIO.h>

@interface PDF22MDAssetManager ()
@property (nonatomic, strong) NSFileManager *fileManager;
@property (nonatomic, strong) dispatch_queue_t fileAccessQueue;
@property (nonatomic, strong) NSMutableSet<NSString *> *usedFilenames;
@end

@implementation PDF22MDAssetManager

#pragma mark - Initialization

- (nullable instancetype)initWithAssetFolder:(NSString *)folderPath {
    self = [super init];
    if (self) {
        _assetsFolderPath = [folderPath copy];
        _fileManager = [[NSFileManager alloc] init];
        _fileAccessQueue = dispatch_queue_create("com.twardoch.pdf22md.assetmanager", DISPATCH_QUEUE_SERIAL);
        _usedFilenames = [NSMutableSet set];
        
        // Create assets folder if it doesn't exist
        NSError *error = nil;
        BOOL isDirectory = NO;
        BOOL exists = [_fileManager fileExistsAtPath:folderPath isDirectory:&isDirectory];
        
        if (exists && !isDirectory) {
            NSLog(@"Asset path exists but is not a directory: %@", folderPath);
            return nil;
        }
        
        if (!exists) {
            if (![_fileManager createDirectoryAtPath:folderPath
                         withIntermediateDirectories:YES
                                          attributes:nil
                                               error:&error]) {
                NSLog(@"Failed to create assets folder: %@", error);
                return nil;
            }
        }
    }
    return self;
}

#pragma mark - Public Methods

- (nullable NSString *)saveImage:(CGImageRef)image
                  isVectorSource:(BOOL)isVectorSource
                    withBaseName:(NSString *)baseName {
    if (!image) {
        return nil;
    }
    
    // Determine optimal format
    BOOL shouldUseJPEG = [self shouldUseJPEGForImage:image isVectorSource:isVectorSource];
    
    NSString *extension = shouldUseJPEG ? @"jpg" : @"png";
    NSString *fileName = [self uniqueFilenameForBaseName:baseName withExtension:extension];
    NSString *fullPath = [self.assetsFolderPath stringByAppendingPathComponent:fileName];
    
    // Create destination
    NSURL *fileURL = [NSURL fileURLWithPath:fullPath];
    CGImageDestinationRef destination = CGImageDestinationCreateWithURL(
        (__bridge CFURLRef)fileURL,
        shouldUseJPEG ? (__bridge CFStringRef)@"public.jpeg" : (__bridge CFStringRef)@"public.png",
        1,
        NULL
    );
    
    if (!destination) {
        NSLog(@"Failed to create image destination for %@", fullPath);
        return nil;
    }
    
    // Set compression options
    NSDictionary *properties = nil;
    if (shouldUseJPEG) {
        properties = @{(__bridge NSString *)kCGImageDestinationLossyCompressionQuality: @(0.85)};
    } else {
        // For PNG, we can set compression level
        properties = @{(__bridge NSString *)kCGImagePropertyPNGCompressionFilter: @(1)}; // Best compression
    }
    
    // Add image to destination
    CGImageDestinationAddImage(destination, image, (__bridge CFDictionaryRef)properties);
    
    // Finalize
    BOOL success = CGImageDestinationFinalize(destination);
    CFRelease(destination);
    
    if (!success) {
        NSLog(@"Failed to save image to %@", fullPath);
        return nil;
    }
    
    // Return relative path (just the filename since it's in the assets folder)
    return fileName;
}

- (nullable NSString *)saveImageElement:(PDF22MDImageElement *)imageElement
                           withBaseName:(NSString *)baseName {
    NSString *savedPath = [self saveImage:imageElement.image
                           isVectorSource:imageElement.isVectorSource
                             withBaseName:baseName];
    
    if (savedPath) {
        imageElement.assetRelativePath = savedPath;
    }
    
    return savedPath;
}

- (BOOL)shouldUseJPEGForImage:(CGImageRef)image
                isVectorSource:(BOOL)isVectorSource {
    if (!image) {
        return NO;
    }
    
    // Get image properties
    size_t width = CGImageGetWidth(image);
    size_t height = CGImageGetHeight(image);
    CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(image);
    
    // If image has alpha channel, use PNG
    if (alphaInfo != kCGImageAlphaNone &&
        alphaInfo != kCGImageAlphaNoneSkipFirst &&
        alphaInfo != kCGImageAlphaNoneSkipLast) {
        return NO;
    }
    
    // For small images, use PNG
    if (width * height < 10000) { // Less than 100x100
        return NO;
    }
    
    // For vector sources, prefer PNG to maintain quality
    if (isVectorSource) {
        return NO;
    }
    
    // Analyze color complexity
    NSUInteger uniqueColors = [self estimateUniqueColorCountForImage:image];
    
    // If we have many unique colors, it's likely a photograph - use JPEG
    return uniqueColors > 256;
}

- (NSString *)uniqueFilenameForBaseName:(NSString *)baseName
                          withExtension:(NSString *)extension {
    __block NSString *filename = nil;
    
    dispatch_sync(self.fileAccessQueue, ^{
        NSString *candidate = [NSString stringWithFormat:@"%@.%@", baseName, extension];
        NSInteger counter = 1;
        
        // Check if filename is already used
        while ([self.usedFilenames containsObject:candidate] ||
               [self.fileManager fileExistsAtPath:[self.assetsFolderPath stringByAppendingPathComponent:candidate]]) {
            candidate = [NSString stringWithFormat:@"%@_%03ld.%@", baseName, (long)counter, extension];
            counter++;
        }
        
        [self.usedFilenames addObject:candidate];
        filename = candidate;
    });
    
    return filename;
}

#pragma mark - Private Methods

- (NSUInteger)estimateUniqueColorCountForImage:(CGImageRef)image {
    size_t width = CGImageGetWidth(image);
    size_t height = CGImageGetHeight(image);
    
    // Sample a subset of pixels for performance
    size_t __unused sampleSize = MIN(width * height, 10000);
    size_t stepX = MAX(1, width / 100);
    size_t stepY = MAX(1, height / 100);
    
    // Create a small bitmap context for sampling
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    size_t bytesPerRow = 4; // Single pixel
    unsigned char *pixelData = calloc(4, sizeof(unsigned char));
    
    if (!pixelData) {
        CGColorSpaceRelease(colorSpace);
        return 256; // Default to medium complexity
    }
    
    CGContextRef context = CGBitmapContextCreate(pixelData, 1, 1, 8, bytesPerRow, colorSpace,
                                                kCGImageAlphaNoneSkipLast | kCGBitmapByteOrder32Big);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        free(pixelData);
        return 256;
    }
    
    // Count unique colors by sampling
    NSMutableSet *uniqueColors = [NSMutableSet set];
    
    for (size_t y = 0; y < height; y += stepY) {
        for (size_t x = 0; x < width; x += stepX) {
            // Draw a single pixel
            CGRect __unused sourceRect = CGRectMake(x, y, 1, 1);
            CGContextClearRect(context, CGRectMake(0, 0, 1, 1));
            CGContextDrawImage(context, CGRectMake(-x, -y, width, height), image);
            
            uint32_t color = (pixelData[0] << 24) | (pixelData[1] << 16) | 
                           (pixelData[2] << 8) | pixelData[3];
            [uniqueColors addObject:@(color)];
            
            // Early exit if we already have many colors
            if (uniqueColors.count > 1000) {
                break;
            }
        }
        
        if (uniqueColors.count > 1000) {
            break;
        }
    }
    
    CGContextRelease(context);
    free(pixelData);
    
    return uniqueColors.count;
}

@end
</file>

<file path="src/Services/PDF22MDMarkdownGenerator.h">
#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>

NS_ASSUME_NONNULL_BEGIN

@protocol PDF22MDContentElement;
@class PDF22MDConversionOptions;

/**
 * Metadata structure for YAML frontmatter generation.
 */
@interface PDF22MDDocumentMetadata : NSObject
@property (nonatomic, copy, nullable) NSString *title;
@property (nonatomic, copy, nullable) NSString *author;
@property (nonatomic, copy, nullable) NSString *subject;
@property (nonatomic, copy, nullable) NSArray<NSString *> *keywords;
@property (nonatomic, copy, nullable) NSString *creator;
@property (nonatomic, copy, nullable) NSString *producer;
@property (nonatomic, strong, nullable) NSDate *creationDate;
@property (nonatomic, strong, nullable) NSDate *modificationDate;
@property (nonatomic, assign) NSInteger pageCount;
@property (nonatomic, copy, nullable) NSString *pdfVersion;
@property (nonatomic, strong, nullable) PDFOutline *outline;
@end

/**
 * Generates Markdown output from PDF content elements.
 */
@interface PDF22MDMarkdownGenerator : NSObject

/**
 * Conversion options affecting markdown generation.
 */
@property (nonatomic, strong, readonly) PDF22MDConversionOptions *options;

/**
 * Initializes the generator with conversion options.
 *
 * @param options The conversion options to use
 * @return A new generator instance
 */
- (instancetype)initWithOptions:(PDF22MDConversionOptions *)options NS_DESIGNATED_INITIALIZER;

- (instancetype)init NS_UNAVAILABLE;

/**
 * Generates a complete markdown document from content elements.
 *
 * @param elements Array of content elements in reading order
 * @param metadata Document metadata for frontmatter
 * @return The generated markdown string
 */
- (NSString *)generateMarkdownFromElements:(NSArray<id<PDF22MDContentElement>> *)elements
                              withMetadata:(nullable PDF22MDDocumentMetadata *)metadata;

/**
 * Generates YAML frontmatter from document metadata.
 *
 * @param metadata The document metadata
 * @return YAML frontmatter string, or nil if includeMetadata is NO
 */
- (nullable NSString *)generateYAMLFrontmatter:(PDF22MDDocumentMetadata *)metadata;

/**
 * Generates markdown content from elements without frontmatter.
 *
 * @param elements Array of content elements
 * @return The markdown content
 */
- (NSString *)generateMarkdownContent:(NSArray<id<PDF22MDContentElement>> *)elements;

/**
 * Extracts metadata from a PDF document.
 *
 * @param document The PDF document
 * @return Populated metadata object
 */
+ (PDF22MDDocumentMetadata *)extractMetadataFromDocument:(PDFDocument *)document;

/**
 * Escapes a string for safe inclusion in YAML.
 *
 * @param string The string to escape
 * @return The escaped string
 */
+ (NSString *)escapeYAMLString:(NSString *)string;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="src/Services/PDF22MDMarkdownGenerator.m">
#import "PDF22MDMarkdownGenerator.h"
#import "../Core/PDF22MDConversionOptions.h"
#import "../Models/PDF22MDContentElement.h"
#import "../Models/PDF22MDTextElement.h"

// Version string - should match the compiled version
#ifndef PDF22MD_VERSION
#define PDF22MD_VERSION "1.0.0"
#endif

@implementation PDF22MDDocumentMetadata
@end

@implementation PDF22MDMarkdownGenerator

#pragma mark - Initialization

- (instancetype)initWithOptions:(PDF22MDConversionOptions *)options {
    self = [super init];
    if (self) {
        _options = options;
    }
    return self;
}

#pragma mark - Public Methods

- (NSString *)generateMarkdownFromElements:(NSArray<id<PDF22MDContentElement>> *)elements
                              withMetadata:(nullable PDF22MDDocumentMetadata *)metadata {
    NSMutableString *markdown = [NSMutableString string];
    
    // Add YAML frontmatter if enabled
    if (self.options.includeMetadata && metadata) {
        NSString *frontmatter = [self generateYAMLFrontmatter:metadata];
        if (frontmatter) {
            [markdown appendString:frontmatter];
            [markdown appendString:@"\n"];
        }
    }
    
    // Generate content
    NSString *content = [self generateMarkdownContent:elements];
    [markdown appendString:content];
    
    // Clean up extra newlines
    NSString *finalMarkdown = [markdown stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    
    return finalMarkdown;
}

- (nullable NSString *)generateYAMLFrontmatter:(PDF22MDDocumentMetadata *)metadata {
    if (!self.options.includeMetadata) {
        return nil;
    }
    
    NSMutableString *yaml = [NSMutableString string];
    [yaml appendString:@"---\n"];
    
    // Basic metadata
    if (metadata.title && metadata.title.length > 0) {
        [yaml appendFormat:@"title: \"%@\"\n", [[self class] escapeYAMLString:metadata.title]];
    }
    
    if (metadata.author && metadata.author.length > 0) {
        [yaml appendFormat:@"author: \"%@\"\n", [[self class] escapeYAMLString:metadata.author]];
    }
    
    if (metadata.subject && metadata.subject.length > 0) {
        [yaml appendFormat:@"subject: \"%@\"\n", [[self class] escapeYAMLString:metadata.subject]];
    }
    
    // Keywords
    if (metadata.keywords && metadata.keywords.count > 0) {
        [yaml appendString:@"keywords:\n"];
        for (NSString *keyword in metadata.keywords) {
            [yaml appendFormat:@"  - \"%@\"\n", [[self class] escapeYAMLString:keyword]];
        }
    }
    
    // Creator and producer
    if (metadata.creator && metadata.creator.length > 0) {
        [yaml appendFormat:@"creator: \"%@\"\n", [[self class] escapeYAMLString:metadata.creator]];
    }
    
    if (metadata.producer && metadata.producer.length > 0) {
        [yaml appendFormat:@"producer: \"%@\"\n", [[self class] escapeYAMLString:metadata.producer]];
    }
    
    // Dates
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateFormat:@"yyyy-MM-dd'T'HH:mm:ssZZZZZ"];
    [formatter setLocale:[NSLocale localeWithLocaleIdentifier:@"en_US_POSIX"]];
    
    if (metadata.creationDate) {
        [yaml appendFormat:@"created: %@\n", [formatter stringFromDate:metadata.creationDate]];
    }
    
    if (metadata.modificationDate) {
        [yaml appendFormat:@"modified: %@\n", [formatter stringFromDate:metadata.modificationDate]];
    }
    
    // PDF specific metadata
    [yaml appendString:@"pdf_metadata:\n"];
    [yaml appendFormat:@"  page_count: %ld\n", (long)metadata.pageCount];
    
    if (metadata.pdfVersion && metadata.pdfVersion.length > 0) {
        [yaml appendFormat:@"  version: \"%@\"\n", metadata.pdfVersion];
    }
    
    // Outline/bookmarks
    if (self.options.preserveOutline && metadata.outline && [metadata.outline numberOfChildren] > 0) {
        [yaml appendString:@"  outline:\n"];
        [self appendOutlineToYAML:yaml outline:metadata.outline indent:@"    "];
    }
    
    // Conversion metadata
    [yaml appendString:@"conversion:\n"];
    [yaml appendString:@"  tool: \"pdf22md\"\n"];
    [yaml appendFormat:@"  version: \"%s\"\n", PDF22MD_VERSION];
    [yaml appendFormat:@"  date: %@\n", [formatter stringFromDate:[NSDate date]]];
    
    [yaml appendString:@"---\n"];
    
    return yaml;
}

- (NSString *)generateMarkdownContent:(NSArray<id<PDF22MDContentElement>> *)elements {
    NSMutableString *content = [NSMutableString string];
    
    id<PDF22MDContentElement> previousElement = nil;
    
    for (id<PDF22MDContentElement> element in elements) {
        NSString *elementMarkdown = [element markdownRepresentation];
        
        if (elementMarkdown && elementMarkdown.length > 0) {
            // Add appropriate spacing between elements
            if (previousElement) {
                // Check if we need extra spacing (e.g., between paragraphs)
                if ([self shouldAddExtraSpacingBetween:previousElement and:element]) {
                    [content appendString:@"\n\n"];
                } else {
                    [content appendString:@"\n"];
                }
            }
            
            [content appendString:elementMarkdown];
            previousElement = element;
        }
    }
    
    return content;
}

+ (PDF22MDDocumentMetadata *)extractMetadataFromDocument:(PDFDocument *)document {
    PDF22MDDocumentMetadata *metadata = [[PDF22MDDocumentMetadata alloc] init];
    
    // Get document attributes
    NSDictionary *attributes = [document documentAttributes];
    
    metadata.title = attributes[PDFDocumentTitleAttribute];
    metadata.author = attributes[PDFDocumentAuthorAttribute];
    metadata.subject = attributes[PDFDocumentSubjectAttribute];
    metadata.keywords = attributes[PDFDocumentKeywordsAttribute];
    metadata.creator = attributes[PDFDocumentCreatorAttribute];
    metadata.producer = attributes[PDFDocumentProducerAttribute];
    metadata.creationDate = attributes[PDFDocumentCreationDateAttribute];
    metadata.modificationDate = attributes[PDFDocumentModificationDateAttribute];
    
    metadata.pageCount = [document pageCount];
    metadata.outline = [document outlineRoot];
    
    // Try to extract PDF version
    metadata.pdfVersion = [self extractPDFVersionFromAttributes:attributes];
    
    return metadata;
}

+ (NSString *)escapeYAMLString:(NSString *)string {
    // Escape quotes and backslashes for YAML
    NSString *escaped = [string stringByReplacingOccurrencesOfString:@"\\" withString:@"\\\\"];
    escaped = [escaped stringByReplacingOccurrencesOfString:@"\"" withString:@"\\\""];
    escaped = [escaped stringByReplacingOccurrencesOfString:@"\n" withString:@"\\n"];
    escaped = [escaped stringByReplacingOccurrencesOfString:@"\r" withString:@"\\r"];
    escaped = [escaped stringByReplacingOccurrencesOfString:@"\t" withString:@"\\t"];
    return escaped;
}

#pragma mark - Private Methods

- (void)appendOutlineToYAML:(NSMutableString *)yaml outline:(PDFOutline *)outline indent:(NSString *)indent {
    for (NSUInteger i = 0; i < [outline numberOfChildren]; i++) {
        PDFOutline *child = [outline childAtIndex:i];
        NSString *label = [child label];
        
        if (label && label.length > 0) {
            [yaml appendFormat:@"%@- title: \"%@\"\n", indent, [[self class] escapeYAMLString:label]];
            
            PDFDestination *destination = [child destination];
            if (destination) {
                PDFPage *page = [destination page];
                if (page) {
                    // Note: We need the document to get page index, so this is an approximation
                    [yaml appendFormat:@"%@  page: %ld\n", indent, (long)1];
                }
            }
            
            if ([child numberOfChildren] > 0) {
                [yaml appendFormat:@"%@  children:\n", indent];
                NSString *newIndent = [indent stringByAppendingString:@"    "];
                [self appendOutlineToYAML:yaml outline:child indent:newIndent];
            }
        }
    }
}

+ (NSString *)extractPDFVersionFromAttributes:(NSDictionary *)attributes {
    // Look for PDF version in various attribute keys
    for (NSString *key in attributes) {
        id value = attributes[key];
        if ([value isKindOfClass:[NSString class]]) {
            NSString *stringValue = (NSString *)value;
            
            // Look for PDF version patterns
            NSRange pdfRange = [stringValue rangeOfString:@"PDF-" options:NSCaseInsensitiveSearch];
            if (pdfRange.location != NSNotFound) {
                // Extract version number after "PDF-"
                NSString *versionPart = [stringValue substringFromIndex:pdfRange.location];
                NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"PDF-?(\\d+\\.\\d+)"
                                                                                       options:NSRegularExpressionCaseInsensitive
                                                                                         error:nil];
                NSTextCheckingResult *match = [regex firstMatchInString:versionPart
                                                               options:0
                                                                 range:NSMakeRange(0, versionPart.length)];
                if (match && match.numberOfRanges > 1) {
                    return [versionPart substringWithRange:[match rangeAtIndex:1]];
                }
            }
        }
    }
    
    return nil;
}

- (BOOL)shouldAddExtraSpacingBetween:(id<PDF22MDContentElement>)element1 
                                 and:(id<PDF22MDContentElement>)element2 {
    // Add extra spacing between different element types
    if ([element1 class] != [element2 class]) {
        return YES;
    }
    
    // Add extra spacing after headings
    if ([element1 isKindOfClass:[PDF22MDTextElement class]]) {
        PDF22MDTextElement *textElement = (PDF22MDTextElement *)element1;
        if (textElement.headingLevel > 0) {
            return YES;
        }
    }
    
    // Add extra spacing between elements on different pages
    if (element1.pageIndex != element2.pageIndex) {
        return YES;
    }
    
    // Check vertical distance between elements
    CGFloat verticalDistance = fabs(CGRectGetMinY(element1.bounds) - CGRectGetMaxY(element2.bounds));
    if (verticalDistance > 20.0) { // Significant gap
        return YES;
    }
    
    return NO;
}

@end
</file>

<file path="src/AssetExtractor.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

@interface AssetExtractor : NSObject

- (nullable instancetype)initWithAssetFolder:(NSString *)folderPath;

- (nullable NSString *)saveImage:(CGImageRef)image
                  isVectorSource:(BOOL)isVector
                      withBaseName:(NSString *)baseName;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="src/AssetExtractor.m">
#import "AssetExtractor.h"
#import <ImageIO/ImageIO.h>

@interface AssetExtractor ()
@property (nonatomic, strong) NSString *assetFolderPath;
@property (nonatomic, strong) NSFileManager *fileManager;
@end

@implementation AssetExtractor

- (nullable instancetype)initWithAssetFolder:(NSString *)folderPath {
    self = [super init];
    if (self) {
        _assetFolderPath = folderPath;
        _fileManager = [NSFileManager defaultManager];
        
        // Create assets folder if it doesn't exist
        NSError *error = nil;
        BOOL isDirectory = NO;
        BOOL exists = [_fileManager fileExistsAtPath:folderPath isDirectory:&isDirectory];
        
        if (exists && !isDirectory) {
            NSLog(@"Asset path exists but is not a directory: %@", folderPath);
            return nil;
        }
        
        if (!exists) {
            if (![_fileManager createDirectoryAtPath:folderPath
                         withIntermediateDirectories:YES
                                          attributes:nil
                                               error:&error]) {
                NSLog(@"Failed to create assets folder: %@", error);
                return nil;
            }
        }
    }
    return self;
}

- (nullable NSString *)saveImage:(CGImageRef)image
                  isVectorSource:(BOOL)isVector
                      withBaseName:(NSString *)baseName {
    if (!image) {
        return nil;
    }
    
    // Analyze image to determine optimal format
    BOOL shouldUseJPEG = [self shouldUseJPEGForImage:image];
    
    NSString *extension = shouldUseJPEG ? @"jpg" : @"png";
    NSString *fileName = [NSString stringWithFormat:@"%@.%@", baseName, extension];
    NSString *fullPath = [self.assetFolderPath stringByAppendingPathComponent:fileName];
    
    // Create destination
    NSURL *fileURL = [NSURL fileURLWithPath:fullPath];
    CGImageDestinationRef destination = CGImageDestinationCreateWithURL((__bridge CFURLRef)fileURL,
                                                                       shouldUseJPEG ? (__bridge CFStringRef)@"public.jpeg" : (__bridge CFStringRef)@"public.png",
                                                                       1, NULL);
    if (!destination) {
        NSLog(@"Failed to create image destination");
        return nil;
    }
    
    // Set compression options
    NSDictionary *properties = nil;
    if (shouldUseJPEG) {
        properties = @{(__bridge NSString *)kCGImageDestinationLossyCompressionQuality: @0.85};
    }
    
    // Add image to destination
    CGImageDestinationAddImage(destination, image, (__bridge CFDictionaryRef)properties);
    
    // Finalize
    BOOL success = CGImageDestinationFinalize(destination);
    CFRelease(destination);
    
    if (!success) {
        NSLog(@"Failed to save image to %@", fullPath);
        return nil;
    }
    
    // Return relative path (just the filename since it's in the assets folder)
    return fileName;
}

- (BOOL)shouldUseJPEGForImage:(CGImageRef)image {
    // Get image properties
    size_t width = CGImageGetWidth(image);
    size_t height = CGImageGetHeight(image);
    CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(image);
    
    // If image has alpha channel, use PNG
    if (alphaInfo != kCGImageAlphaNone &&
        alphaInfo != kCGImageAlphaNoneSkipFirst &&
        alphaInfo != kCGImageAlphaNoneSkipLast) {
        return NO;
    }
    
    // For small images, use PNG
    if (width * height < 10000) { // Less than 100x100
        return NO;
    }
    
    // Analyze color complexity by sampling pixels
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    size_t bytesPerRow = width * 4;
    size_t sampleSize = MIN(width * height, 10000); // Sample up to 10k pixels
    
    unsigned char *pixelData = calloc(sampleSize * 4, sizeof(unsigned char));
    if (!pixelData) {
        CGColorSpaceRelease(colorSpace);
        return YES; // Default to JPEG if we can't analyze
    }
    
    CGContextRef context = CGBitmapContextCreate(pixelData, width, 1, 8, bytesPerRow, colorSpace,
                                                kCGImageAlphaNoneSkipLast | kCGBitmapByteOrder32Big);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        free(pixelData);
        return YES;
    }
    
    // Sample middle row
    CGContextDrawImage(context, CGRectMake(0, 0, width, 1), image);
    CGContextRelease(context);
    
    // Count unique colors in sample
    NSMutableSet *uniqueColors = [NSMutableSet set];
    for (size_t i = 0; i < width * 4; i += 4) {
        uint32_t color = (pixelData[i] << 24) | (pixelData[i+1] << 16) | 
                        (pixelData[i+2] << 8) | pixelData[i+3];
        [uniqueColors addObject:@(color)];
    }
    
    free(pixelData);
    
    // If we have many unique colors, it's likely a photograph - use JPEG
    return [uniqueColors count] > 256;
}

@end
</file>

<file path="src/ContentElement.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

@protocol ContentElement <NSObject>
@property (nonatomic, readonly) CGRect bounds;
@property (nonatomic, readonly) NSInteger pageIndex;
- (NSString *)markdownRepresentation;
@end

@interface TextElement : NSObject <ContentElement>
@property (nonatomic, strong) NSString *text;
@property (nonatomic, assign) CGRect bounds;
@property (nonatomic, assign) NSInteger pageIndex;
@property (nonatomic, strong, nullable) NSString *fontName;
@property (nonatomic, assign) CGFloat fontSize;
@property (nonatomic, assign) BOOL isBold;
@property (nonatomic, assign) BOOL isItalic;
@property (nonatomic, assign) NSInteger headingLevel;
@end

@interface ImageElement : NSObject <ContentElement>
@property (nonatomic, assign) CGImageRef image;
@property (nonatomic, assign) CGRect bounds;
@property (nonatomic, assign) NSInteger pageIndex;
@property (nonatomic, assign) BOOL isVectorSource;
@property (nonatomic, strong, nullable) NSString *assetRelativePath;
@end

NS_ASSUME_NONNULL_END
</file>

<file path="src/ContentElement.m">
#import "ContentElement.h"

@implementation TextElement

- (NSString *)markdownRepresentation {
    if (!self.text || [self.text length] == 0) {
        return nil;
    }
    
    NSString *trimmedText = [self.text stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    if ([trimmedText length] == 0) {
        return nil;
    }
    
    // Apply heading formatting
    if (self.headingLevel > 0 && self.headingLevel <= 6) {
        NSMutableString *heading = [NSMutableString string];
        for (NSInteger i = 0; i < self.headingLevel; i++) {
            [heading appendString:@"#"];
        }
        [heading appendString:@" "];
        [heading appendString:trimmedText];
        return heading;
    }
    
    // Apply bold/italic formatting
    NSString *formattedText = trimmedText;
    
    if (self.isBold && self.isItalic) {
        formattedText = [NSString stringWithFormat:@"***%@***", formattedText];
    } else if (self.isBold) {
        formattedText = [NSString stringWithFormat:@"**%@**", formattedText];
    } else if (self.isItalic) {
        formattedText = [NSString stringWithFormat:@"*%@*", formattedText];
    }
    
    return formattedText;
}

- (void)dealloc {
    // No need to release CGImageRef here as ARC doesn't manage it
}

@end

@implementation ImageElement

- (NSString *)markdownRepresentation {
    if (!self.assetRelativePath) {
        return @"![Image](image-not-saved)";
    }
    
    return [NSString stringWithFormat:@"![Image](%@)", self.assetRelativePath];
}

- (void)dealloc {
    if (self.image) {
        CGImageRelease(self.image);
    }
}

@end
</file>

<file path="src/main.m">
#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>
#import "PDFMarkdownConverter.h"
#import "PDF22MDErrorHelper.h"

#ifndef VERSION
#define VERSION "dev"
#endif

void printUsage(const char *programName) {
    fprintf(stderr, "Usage: %s [-i input.pdf] [-o output.md] [-a assets_folder] [-d dpi] [-v] [-h]\n", programName);
    fprintf(stderr, "  Converts PDF documents to Markdown format\n");
    fprintf(stderr, "  -i <path>: Input PDF file (default: stdin)\n");
    fprintf(stderr, "  -o <path>: Output Markdown file (default: stdout)\n");
    fprintf(stderr, "  -a <path>: Assets folder for extracted images\n");
    fprintf(stderr, "  -d <dpi>: DPI for rasterizing vector graphics (default: 144)\n");
    fprintf(stderr, "  -v: Display version information\n");
    fprintf(stderr, "  -h: Display this help message\n");
}

void printVersion() {
    printf("pdf22md version %s\n", VERSION);
}

int main(int argc, const char *argv[]) {
    @autoreleasepool {
        NSString *inputPath = nil;
        NSString *outputPath = nil;
        NSString *assetsPath = nil;
        CGFloat dpi = 144.0;
        
        // Parse command line arguments
        int opt;
        while ((opt = getopt(argc, (char * const *)argv, "i:o:a:d:hvV")) != -1) {
            switch (opt) {
                case 'i':
                    inputPath = [NSString stringWithUTF8String:optarg];
                    break;
                case 'o':
                    outputPath = [NSString stringWithUTF8String:optarg];
                    break;
                case 'a':
                    assetsPath = [NSString stringWithUTF8String:optarg];
                    break;
                case 'd':
                    dpi = atof(optarg);
                    if (dpi <= 0) {
                        fprintf(stderr, "Invalid DPI value: %s\n", optarg);
                        return 1;
                    }
                    break;
                case 'h':
                    printUsage(argv[0]);
                    return 0;
                case 'v':
                case 'V':
                    printVersion();
                    return 0;
                default:
                    printUsage(argv[0]);
                    return 1;
            }
        }
        
        // Initialize converter
        PDFMarkdownConverter *converter = nil;
        
        if (inputPath) {
            // Read from file
            NSURL *pdfURL = [NSURL fileURLWithPath:inputPath];
            converter = [[PDFMarkdownConverter alloc] initWithPDFAtURL:pdfURL];
            if (!converter) {
                NSError *error = [PDF22MDErrorHelper invalidPDFErrorWithPath:inputPath];
                NSString *userMessage = [PDF22MDErrorHelper userFriendlyMessageForError:error];
                fprintf(stderr, "%s\n", [userMessage UTF8String]);
                return 1;
            }
        } else {
            // Read from stdin
            NSFileHandle *stdinHandle = [NSFileHandle fileHandleWithStandardInput];
            NSData *pdfData = [stdinHandle readDataToEndOfFile];
            
            if (!pdfData || [pdfData length] == 0) {
                NSError *error = [PDF22MDErrorHelper errorWithCode:PDF22MDErrorIOError
                                                        description:@"No PDF data received from stdin"
                                                         suggestion:@"• Pipe a valid PDF file to stdin\n"
                                                                   @"• Example: cat document.pdf | pdf22md > output.md\n"
                                                                   @"• Check that the input source contains PDF data"];
                NSString *userMessage = [PDF22MDErrorHelper userFriendlyMessageForError:error];
                fprintf(stderr, "%s\n", [userMessage UTF8String]);
                return 1;
            }
            
            converter = [[PDFMarkdownConverter alloc] initWithPDFData:pdfData];
            if (!converter) {
                NSError *error = [PDF22MDErrorHelper errorWithCode:PDF22MDErrorInvalidPDF
                                                        description:@"Failed to create PDF document from stdin data"
                                                         suggestion:@"• Ensure the piped data is a valid PDF file\n"
                                                                   @"• Verify the PDF is not corrupted\n"
                                                                   @"• Check if the PDF is password-protected"];
                NSString *userMessage = [PDF22MDErrorHelper userFriendlyMessageForError:error];
                fprintf(stderr, "%s\n", [userMessage UTF8String]);
                return 1;
            }
        }
        
        // Perform conversion
        __block NSString *markdown = nil;
        __block NSError *conversionError = nil;
        
        dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
        
        [converter convertWithAssetsFolderPath:assetsPath
                                rasterizedDPI:dpi
                                   completion:^(NSString *result, NSError *error) {
            markdown = result;
            conversionError = error;
            dispatch_semaphore_signal(semaphore);
        }];
        
        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
        
        if (conversionError) {
            NSString *userMessage = [PDF22MDErrorHelper userFriendlyMessageForError:conversionError];
            fprintf(stderr, "%s\n", [userMessage UTF8String]);
            return 1;
        }
        
        // Write output
        if (outputPath) {
            // Write to file
            NSError *writeError = nil;
            BOOL success = [markdown writeToFile:outputPath
                                      atomically:YES
                                        encoding:NSUTF8StringEncoding
                                           error:&writeError];
            if (!success) {
                NSError *enhancedError = [PDF22MDErrorHelper ioErrorWithPath:outputPath operation:@"write"];
                if (writeError) {
                    enhancedError = [PDF22MDErrorHelper errorWithCode:PDF22MDErrorIOError
                                                           description:[NSString stringWithFormat:@"Failed to write output file: %@", outputPath]
                                                            suggestion:@"• Check if you have write permissions for the directory\n"
                                                                      @"• Ensure sufficient disk space\n"
                                                                      @"• Verify the path is correct and accessible\n"
                                                                      @"• Check if the file is locked by another application"
                                                       underlyingError:writeError];
                }
                NSString *userMessage = [PDF22MDErrorHelper userFriendlyMessageForError:enhancedError];
                fprintf(stderr, "%s\n", [userMessage UTF8String]);
                return 1;
            }
        } else {
            // Write to stdout
            NSFileHandle *stdoutHandle = [NSFileHandle fileHandleWithStandardOutput];
            NSData *markdownData = [markdown dataUsingEncoding:NSUTF8StringEncoding];
            [stdoutHandle writeData:markdownData];
        }
        
        return 0;
    }
}
</file>

<file path="src/PDF22MDErrorHelper.h">
//
//  PDF22MDErrorHelper.h
//  pdf22md
//
//  Enhanced error handling with user-friendly messages and suggestions
//

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

// Error domain for pdf22md errors
extern NSErrorDomain const PDF22MDErrorDomain;

// Specific error codes with clear meanings
typedef NS_ENUM(NSInteger, PDF22MDError) {
    PDF22MDErrorInvalidPDF = 1000,          // PDF file is corrupted or invalid
    PDF22MDErrorAssetFolderCreation,        // Cannot create assets folder
    PDF22MDErrorMemoryPressure,            // Insufficient memory
    PDF22MDErrorProcessingTimeout,         // Processing took too long
    PDF22MDErrorEncryptedPDF,              // Password-protected PDF
    PDF22MDErrorEmptyDocument,             // PDF has no readable content
    PDF22MDErrorIOError,                   // File I/O error
    PDF22MDErrorPermissionDenied,          // Insufficient permissions
    PDF22MDErrorUnsupportedFormat          // PDF format not supported
};

/**
 * Helper class for creating user-friendly error messages with actionable suggestions
 */
@interface PDF22MDErrorHelper : NSObject

/**
 * Creates a user-friendly error with description and suggestion
 */
+ (NSError *)errorWithCode:(PDF22MDError)code
               description:(NSString *)description
                suggestion:(NSString *)suggestion;

/**
 * Creates a user-friendly error with underlying error context
 */
+ (NSError *)errorWithCode:(PDF22MDError)code
               description:(NSString *)description
                suggestion:(NSString *)suggestion
           underlyingError:(nullable NSError *)underlyingError;

/**
 * Common error factory methods
 */
+ (NSError *)invalidPDFErrorWithPath:(NSString *)path;
+ (NSError *)assetFolderErrorWithPath:(NSString *)path reason:(NSString *)reason;
+ (NSError *)memoryPressureError;
+ (NSError *)encryptedPDFError;
+ (NSError *)emptyDocumentError;
+ (NSError *)ioErrorWithPath:(NSString *)path operation:(NSString *)operation;
+ (NSError *)permissionErrorWithPath:(NSString *)path;

/**
 * Formats error for command-line display
 */
+ (NSString *)userFriendlyMessageForError:(NSError *)error;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="src/PDF22MDErrorHelper.m">
//
//  PDF22MDErrorHelper.m
//  pdf22md
//
//  Enhanced error handling with user-friendly messages and suggestions
//

#import "PDF22MDErrorHelper.h"

NSErrorDomain const PDF22MDErrorDomain = @"com.twardoch.pdf22md.error";

@implementation PDF22MDErrorHelper

+ (NSError *)errorWithCode:(PDF22MDError)code
               description:(NSString *)description
                suggestion:(NSString *)suggestion {
    return [self errorWithCode:code
                   description:description
                    suggestion:suggestion
               underlyingError:nil];
}

+ (NSError *)errorWithCode:(PDF22MDError)code
               description:(NSString *)description
                suggestion:(NSString *)suggestion
           underlyingError:(nullable NSError *)underlyingError {
    
    NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];
    
    userInfo[NSLocalizedDescriptionKey] = description;
    userInfo[NSLocalizedRecoverySuggestionErrorKey] = suggestion;
    
    if (underlyingError) {
        userInfo[NSUnderlyingErrorKey] = underlyingError;
    }
    
    // Add additional context based on error code
    switch (code) {
        case PDF22MDErrorInvalidPDF:
            userInfo[NSLocalizedFailureReasonErrorKey] = @"The PDF file appears to be corrupted or in an unsupported format";
            break;
        case PDF22MDErrorAssetFolderCreation:
            userInfo[NSLocalizedFailureReasonErrorKey] = @"Unable to create the specified assets folder";
            break;
        case PDF22MDErrorMemoryPressure:
            userInfo[NSLocalizedFailureReasonErrorKey] = @"Insufficient memory to process this PDF";
            break;
        case PDF22MDErrorProcessingTimeout:
            userInfo[NSLocalizedFailureReasonErrorKey] = @"PDF processing timed out";
            break;
        case PDF22MDErrorEncryptedPDF:
            userInfo[NSLocalizedFailureReasonErrorKey] = @"The PDF is password-protected";
            break;
        case PDF22MDErrorEmptyDocument:
            userInfo[NSLocalizedFailureReasonErrorKey] = @"The PDF contains no readable content";
            break;
        case PDF22MDErrorIOError:
            userInfo[NSLocalizedFailureReasonErrorKey] = @"File input/output error occurred";
            break;
        case PDF22MDErrorPermissionDenied:
            userInfo[NSLocalizedFailureReasonErrorKey] = @"Insufficient permissions to access the file or folder";
            break;
        case PDF22MDErrorUnsupportedFormat:
            userInfo[NSLocalizedFailureReasonErrorKey] = @"The PDF format or version is not supported";
            break;
    }
    
    return [NSError errorWithDomain:PDF22MDErrorDomain code:code userInfo:userInfo];
}

#pragma mark - Factory Methods

+ (NSError *)invalidPDFErrorWithPath:(NSString *)path {
    NSString *description = [NSString stringWithFormat:@"Cannot open PDF file: %@", path];
    NSString *suggestion = @"• Verify the file exists and is a valid PDF\n"
                          @"• Check if the file is corrupted\n"
                          @"• Ensure you have read permissions for the file";
    
    return [self errorWithCode:PDF22MDErrorInvalidPDF
                   description:description
                    suggestion:suggestion];
}

+ (NSError *)assetFolderErrorWithPath:(NSString *)path reason:(NSString *)reason {
    NSString *description = [NSString stringWithFormat:@"Cannot create assets folder: %@", path];
    NSString *suggestion = [NSString stringWithFormat:@"• Check if the parent directory exists\n"
                                                      @"• Verify you have write permissions\n"
                                                      @"• Ensure sufficient disk space\n"
                                                      @"• Error details: %@", reason];
    
    return [self errorWithCode:PDF22MDErrorAssetFolderCreation
                   description:description
                    suggestion:suggestion];
}

+ (NSError *)memoryPressureError {
    NSString *description = @"Insufficient memory to process this PDF";
    NSString *suggestion = @"• Close other applications to free memory\n"
                          @"• Try processing a smaller PDF file\n"
                          @"• Consider using a lower DPI setting (-d 72)\n"
                          @"• If the PDF is very large, split it into smaller parts";
    
    return [self errorWithCode:PDF22MDErrorMemoryPressure
                   description:description
                    suggestion:suggestion];
}

+ (NSError *)encryptedPDFError {
    NSString *description = @"Cannot process password-protected PDF";
    NSString *suggestion = @"• Remove password protection using another tool first\n"
                          @"• Use Adobe Acrobat or similar to unlock the PDF\n"
                          @"• Try: qpdf --decrypt input.pdf output.pdf";
    
    return [self errorWithCode:PDF22MDErrorEncryptedPDF
                   description:description
                    suggestion:suggestion];
}

+ (NSError *)emptyDocumentError {
    NSString *description = @"PDF contains no readable text or content";
    NSString *suggestion = @"• Check if the PDF has text (not just scanned images)\n"
                          @"• For scanned documents, use OCR software first\n"
                          @"• Verify the PDF is not corrupted";
    
    return [self errorWithCode:PDF22MDErrorEmptyDocument
                   description:description
                    suggestion:suggestion];
}

+ (NSError *)ioErrorWithPath:(NSString *)path operation:(NSString *)operation {
    NSString *description = [NSString stringWithFormat:@"Failed to %@ file: %@", operation, path];
    NSString *suggestion = @"• Check if the file path is correct\n"
                          @"• Verify you have appropriate permissions\n"
                          @"• Ensure sufficient disk space\n"
                          @"• Check if the file is in use by another application";
    
    return [self errorWithCode:PDF22MDErrorIOError
                   description:description
                    suggestion:suggestion];
}

+ (NSError *)permissionErrorWithPath:(NSString *)path {
    NSString *description = [NSString stringWithFormat:@"Permission denied accessing: %@", path];
    NSString *suggestion = @"• Check file permissions with: ls -la\n"
                          @"• Use: chmod 644 for files, chmod 755 for directories\n"
                          @"• Ensure you own the file or have appropriate access\n"
                          @"• Try running with sudo if appropriate";
    
    return [self errorWithCode:PDF22MDErrorPermissionDenied
                   description:description
                    suggestion:suggestion];
}

#pragma mark - User-Friendly Formatting

+ (NSString *)userFriendlyMessageForError:(NSError *)error {
    if (![error.domain isEqualToString:PDF22MDErrorDomain]) {
        // For non-PDF22MD errors, provide basic formatting
        return [NSString stringWithFormat:@"Error: %@", error.localizedDescription];
    }
    
    NSMutableString *message = [NSMutableString string];
    
    // Add main description
    [message appendFormat:@"❌ %@\n", error.localizedDescription];
    
    // Add failure reason if available
    NSString *failureReason = error.userInfo[NSLocalizedFailureReasonErrorKey];
    if (failureReason) {
        [message appendFormat:@"\n💡 %@\n", failureReason];
    }
    
    // Add suggestions if available
    NSString *suggestion = error.userInfo[NSLocalizedRecoverySuggestionErrorKey];
    if (suggestion) {
        [message appendFormat:@"\n🔧 Try these solutions:\n%@\n", suggestion];
    }
    
    // Add underlying error details if available
    NSError *underlyingError = error.userInfo[NSUnderlyingErrorKey];
    if (underlyingError) {
        [message appendFormat:@"\n📋 Technical details: %@", underlyingError.localizedDescription];
    }
    
    return message;
}

@end
</file>

<file path="src/PDFMarkdownConverter.h">
#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>

NS_ASSUME_NONNULL_BEGIN

@interface PDFMarkdownConverter : NSObject

- (nullable instancetype)initWithPDFData:(NSData *)pdfData;
- (nullable instancetype)initWithPDFAtURL:(NSURL *)pdfURL;

- (void)convertWithAssetsFolderPath:(nullable NSString *)assetsPath
                     rasterizedDPI:(CGFloat)dpi
                        completion:(void (^)(NSString * _Nullable markdown, NSError * _Nullable error))completion;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="src/PDFMarkdownConverter.m">
#import "PDFMarkdownConverter.h"
#import "PDFPageProcessor.h"
#import "ContentElement.h"
#import "AssetExtractor.h"

@interface PDFMarkdownConverter ()
@property (nonatomic, strong) PDFDocument *pdfDocument;
@property (nonatomic, strong) NSMutableArray<id<ContentElement>> *allElements;
@property (nonatomic, strong) NSMutableDictionary<NSString *, NSNumber *> *fontStats;
@end

@implementation PDFMarkdownConverter

- (nullable instancetype)initWithPDFData:(NSData *)pdfData {
    self = [super init];
    if (self) {
        _pdfDocument = [[PDFDocument alloc] initWithData:pdfData];
        if (!_pdfDocument) {
            return nil;
        }
        _allElements = [NSMutableArray array];
        _fontStats = [NSMutableDictionary dictionary];
    }
    return self;
}

- (nullable instancetype)initWithPDFAtURL:(NSURL *)pdfURL {
    self = [super init];
    if (self) {
        _pdfDocument = [[PDFDocument alloc] initWithURL:pdfURL];
        if (!_pdfDocument) {
            return nil;
        }
        _allElements = [NSMutableArray array];
        _fontStats = [NSMutableDictionary dictionary];
    }
    return self;
}

- (void)convertWithAssetsFolderPath:(nullable NSString *)assetsPath
                     rasterizedDPI:(CGFloat)dpi
                        completion:(void (^)(NSString * _Nullable markdown, NSError * _Nullable error))completion {
    
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSError *error = nil;
        
        // Process all pages in parallel
        NSInteger pageCount = [self.pdfDocument pageCount];
        // DEBUG log suppressed: Starting conversion of pages
        
        // Create thread-safe temporary storage
        NSMutableArray<NSMutableArray<id<ContentElement>> *> *pageElementsArray = [NSMutableArray arrayWithCapacity:pageCount];
        NSMutableArray<NSMutableDictionary *> *pageFontStatsArray = [NSMutableArray arrayWithCapacity:pageCount];
        
        // Initialize arrays
        for (NSInteger i = 0; i < pageCount; i++) {
            [pageElementsArray addObject:[NSMutableArray array]];
            [pageFontStatsArray addObject:[NSMutableDictionary dictionary]];
        }
        
        // Lock for thread safety
        NSObject *lock = [[NSObject alloc] init];
        __block BOOL processingFailed = NO;
        
        // Process pages in parallel using dispatch_apply
        // DEBUG log suppressed: Starting dispatch_apply for pages
        dispatch_apply(pageCount, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t pageIndex) {
            @autoreleasepool {
                // DEBUG log suppressed: Processing page
                // Check if processing has already failed
                @synchronized(lock) {
                    if (processingFailed) return;
                }
                
                PDFPage *page = [self.pdfDocument pageAtIndex:pageIndex];
                if (!page) {
                    @synchronized(lock) {
                        processingFailed = YES;
                    }
                    return;
                }
                
                PDFPageProcessor *processor = [[PDFPageProcessor alloc] initWithPDFPage:page
                                                                               pageIndex:pageIndex
                                                                                     dpi:dpi];
                
                NSArray<id<ContentElement>> *pageElements = [processor extractContentElements];
                // DEBUG log suppressed: Page extracted elements
                
                // Store results in thread-safe arrays
                pageElementsArray[pageIndex] = [pageElements mutableCopy];
                
                // Collect font statistics for this page
                NSMutableDictionary *pageFontStats = pageFontStatsArray[pageIndex];
                for (id<ContentElement> element in pageElements) {
                    if ([element isKindOfClass:[TextElement class]]) {
                        TextElement *textElement = (TextElement *)element;
                        NSString *fontKey = [NSString stringWithFormat:@"%.1f-%@", 
                                           textElement.fontSize, 
                                           textElement.fontName ?: @"Unknown"];
                        
                        NSNumber *count = pageFontStats[fontKey];
                        pageFontStats[fontKey] = @([count integerValue] + 1);
                    }
                }
            }
        });
        
        // DEBUG log suppressed: dispatch_apply completed
        
        // Check if processing failed
        if (processingFailed) {
            error = [NSError errorWithDomain:@"PDFMarkdownConverter"
                                       code:2
                                   userInfo:@{NSLocalizedDescriptionKey: @"Failed to process one or more PDF pages"}];
            completion(nil, error);
            return;
        }
        
        // DEBUG log suppressed: Merging results from all pages
        
        // Merge results from all pages
        for (NSInteger i = 0; i < pageCount; i++) {
            [self.allElements addObjectsFromArray:pageElementsArray[i]];
            
            // Merge font statistics
            NSDictionary *pageFontStats = pageFontStatsArray[i];
            for (NSString *fontKey in pageFontStats) {
                NSNumber *pageCount = pageFontStats[fontKey];
                NSNumber *totalCount = self.fontStats[fontKey];
                self.fontStats[fontKey] = @([totalCount integerValue] + [pageCount integerValue]);
            }
        }
        
        // DEBUG log suppressed: Analyzing font hierarchy
        
        // Analyze font hierarchy
        [self analyzeFontHierarchy];
        
        // DEBUG log suppressed: Sorting elements
        
        // Sort elements by page and position
        [self sortElements];
        
        // DEBUG log suppressed: Sort completed
        
        // Handle assets if needed
        AssetExtractor *assetExtractor = nil;
        if (assetsPath) {
            // DEBUG log suppressed: Starting asset extraction with path:
            assetExtractor = [[AssetExtractor alloc] initWithAssetFolder:assetsPath];
            if (!assetExtractor) {
                error = [NSError errorWithDomain:@"PDFMarkdownConverter"
                                           code:1
                                       userInfo:@{NSLocalizedDescriptionKey: @"Failed to create assets folder"}];
                completion(nil, error);
                return;
            }
            
            // Save images in parallel
            NSMutableArray<ImageElement *> *imageElements = [NSMutableArray array];
            for (id<ContentElement> element in self.allElements) {
                if ([element isKindOfClass:[ImageElement class]]) {
                    [imageElements addObject:(ImageElement *)element];
                }
            }
            
            NSInteger imageCount = [imageElements count];
            // DEBUG log suppressed: Found images to extract
            if (imageCount > 0) {
                // DEBUG log suppressed: Starting parallel image extraction
                dispatch_apply(imageCount, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t index) {
                    @autoreleasepool {
                        ImageElement *imageElement = imageElements[index];
                        NSString *baseName = [NSString stringWithFormat:@"image_%03zu", index];
                        NSString *savedPath = [assetExtractor saveImage:imageElement.image
                                                          isVectorSource:imageElement.isVectorSource
                                                              withBaseName:baseName];
                        if (savedPath) {
                            @synchronized(imageElement) {
                                imageElement.assetRelativePath = savedPath;
                            }
                        }
                    }
                });
                // DEBUG log suppressed: Completed parallel image extraction
            }
        } else {
            // DEBUG log suppressed: No assets path provided, skipping image extraction
        }
        
        // DEBUG log suppressed: Starting markdown generation
        
        // Generate markdown with YAML frontmatter
        NSMutableString *markdown = [NSMutableString string];
        
        // Add YAML frontmatter with metadata
        // DEBUG log suppressed: Generating YAML frontmatter
        NSString *yamlFrontmatter = [self generateYAMLFrontmatter];
        if (yamlFrontmatter) {
            [markdown appendString:yamlFrontmatter];
            [markdown appendString:@"\n"];
        }
        
        // DEBUG log suppressed: Converting elements to markdown
        for (id<ContentElement> element in self.allElements) {
            NSString *elementMarkdown = [element markdownRepresentation];
            if (elementMarkdown) {
                [markdown appendString:elementMarkdown];
                [markdown appendString:@"\n\n"];
            }
        }
        // DEBUG log suppressed: Markdown generation completed
        
        // Clean up extra newlines
        NSString *finalMarkdown = [markdown stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
        
        completion(finalMarkdown, nil);
    });
}

- (void)collectFontStatisticsFromElements:(NSArray<id<ContentElement>> *)elements {
    for (id<ContentElement> element in elements) {
        if ([element isKindOfClass:[TextElement class]]) {
            TextElement *textElement = (TextElement *)element;
            NSString *fontKey = [NSString stringWithFormat:@"%.1f-%@", 
                               textElement.fontSize, 
                               textElement.fontName ?: @"Unknown"];
            
            NSNumber *count = self.fontStats[fontKey];
            self.fontStats[fontKey] = @([count integerValue] + 1);
        }
    }
}

- (void)analyzeFontHierarchy {
    // Sort font sizes to determine heading levels
    NSMutableArray<NSNumber *> *uniqueSizes = [NSMutableArray array];
    NSMutableDictionary<NSNumber *, NSNumber *> *sizeFrequency = [NSMutableDictionary dictionary];
    
    for (NSString *fontKey in self.fontStats) {
        NSArray *components = [fontKey componentsSeparatedByString:@"-"];
        if (components.count > 0) {
            CGFloat fontSize = [components[0] floatValue];
            NSNumber *sizeNum = @(fontSize);
            
            if (![uniqueSizes containsObject:sizeNum]) {
                [uniqueSizes addObject:sizeNum];
            }
            
            NSInteger freq = [sizeFrequency[sizeNum] integerValue] + [self.fontStats[fontKey] integerValue];
            sizeFrequency[sizeNum] = @(freq);
        }
    }
    
    // Sort sizes in descending order
    [uniqueSizes sortUsingComparator:^NSComparisonResult(NSNumber *obj1, NSNumber *obj2) {
        return [obj2 compare:obj1];
    }];
    
    // Assign heading levels based on size hierarchy
    // Assume largest font is H1, second largest is H2, etc.
    NSMutableDictionary<NSNumber *, NSNumber *> *sizeToHeadingLevel = [NSMutableDictionary dictionary];
    NSInteger headingLevel = 1;
    
    for (NSNumber *size in uniqueSizes) {
        // Only assign heading levels to fonts that are significantly larger than average
        // and appear less frequently (typical of headings)
        NSInteger frequency = [sizeFrequency[size] integerValue];
        
        if (headingLevel <= 6 && frequency < 100) { // Adjust threshold as needed
            sizeToHeadingLevel[size] = @(headingLevel);
            headingLevel++;
        } else {
            sizeToHeadingLevel[size] = @(0); // Body text
        }
    }
    
    // Apply heading levels to text elements
    for (id<ContentElement> element in self.allElements) {
        if ([element isKindOfClass:[TextElement class]]) {
            TextElement *textElement = (TextElement *)element;
            NSNumber *sizeNum = @(textElement.fontSize);
            NSNumber *level = sizeToHeadingLevel[sizeNum];
            textElement.headingLevel = level ? [level integerValue] : 0;
        }
    }
}

- (void)sortElements {
    [self.allElements sortUsingComparator:^NSComparisonResult(id<ContentElement> obj1, id<ContentElement> obj2) {
        // First sort by page
        if ([obj1 respondsToSelector:@selector(pageIndex)] && [obj2 respondsToSelector:@selector(pageIndex)]) {
            NSInteger page1 = [(id)obj1 pageIndex];
            NSInteger page2 = [(id)obj2 pageIndex];
            
            if (page1 != page2) {
                return page1 < page2 ? NSOrderedAscending : NSOrderedDescending;
            }
        }
        
        // Then sort by vertical position (top to bottom)
        CGFloat y1 = CGRectGetMaxY(obj1.bounds);
        CGFloat y2 = CGRectGetMaxY(obj2.bounds);
        
        if (fabs(y1 - y2) > 5.0) { // Tolerance for same line
            return y1 > y2 ? NSOrderedAscending : NSOrderedDescending;
        }
        
        // Finally sort by horizontal position (left to right)
        CGFloat x1 = CGRectGetMinX(obj1.bounds);
        CGFloat x2 = CGRectGetMinX(obj2.bounds);
        
        return x1 < x2 ? NSOrderedAscending : NSOrderedDescending;
    }];
}

- (NSString *)generateYAMLFrontmatter {
    NSMutableString *yaml = [NSMutableString string];
    
    // Get PDF metadata
    NSDictionary *docAttributes = [self.pdfDocument documentAttributes];
    
    [yaml appendString:@"---\n"];
    
    // Title
    NSString *title = docAttributes[PDFDocumentTitleAttribute];
    if (title && title.length > 0) {
        [yaml appendFormat:@"title: \"%@\"\n", [self escapeYAMLString:title]];
    }
    
    // Author
    NSString *author = docAttributes[PDFDocumentAuthorAttribute];
    if (author && author.length > 0) {
        [yaml appendFormat:@"author: \"%@\"\n", [self escapeYAMLString:author]];
    }
    
    // Subject
    NSString *subject = docAttributes[PDFDocumentSubjectAttribute];
    if (subject && subject.length > 0) {
        [yaml appendFormat:@"subject: \"%@\"\n", [self escapeYAMLString:subject]];
    }
    
    // Keywords
    NSArray *keywords = docAttributes[PDFDocumentKeywordsAttribute];
    if (keywords && [keywords isKindOfClass:[NSArray class]] && keywords.count > 0) {
        [yaml appendString:@"keywords:\n"];
        for (NSString *keyword in keywords) {
            if ([keyword isKindOfClass:[NSString class]]) {
                [yaml appendFormat:@"  - \"%@\"\n", [self escapeYAMLString:keyword]];
            }
        }
    }
    
    // Creator (PDF producer software)
    NSString *creator = docAttributes[PDFDocumentCreatorAttribute];
    if (creator && creator.length > 0) {
        [yaml appendFormat:@"creator: \"%@\"\n", [self escapeYAMLString:creator]];
    }
    
    // Producer
    NSString *producer = docAttributes[PDFDocumentProducerAttribute];
    if (producer && producer.length > 0) {
        [yaml appendFormat:@"producer: \"%@\"\n", [self escapeYAMLString:producer]];
    }
    
    // Creation date
    NSDate *creationDate = docAttributes[PDFDocumentCreationDateAttribute];
    if (creationDate) {
        NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
        [formatter setDateFormat:@"yyyy-MM-dd'T'HH:mm:ssZZZZZ"];
        [yaml appendFormat:@"created: %@\n", [formatter stringFromDate:creationDate]];
    }
    
    // Modification date
    NSDate *modDate = docAttributes[PDFDocumentModificationDateAttribute];
    if (modDate) {
        NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
        [formatter setDateFormat:@"yyyy-MM-dd'T'HH:mm:ssZZZZZ"];
        [yaml appendFormat:@"modified: %@\n", [formatter stringFromDate:modDate]];
    }
    
    // PDF specific metadata
    [yaml appendString:@"pdf_metadata:\n"];
    [yaml appendFormat:@"  page_count: %ld\n", (long)[self.pdfDocument pageCount]];
    
    // PDF version
    NSString *pdfVersion = [self extractPDFVersion];
    if (pdfVersion) {
        [yaml appendFormat:@"  version: \"%@\"\n", pdfVersion];
    }
    
    // PDF outline (bookmarks/TOC)
    PDFOutline *outline = [self.pdfDocument outlineRoot];
    if (outline && [outline numberOfChildren] > 0) {
        [yaml appendString:@"  outline:\n"];
        [self appendOutlineToYAML:yaml outline:outline indent:@"    "];
    }
    
    // Conversion metadata
    [yaml appendString:@"conversion:\n"];
    [yaml appendString:@"  tool: \"pdf22md\"\n"];
    [yaml appendFormat:@"  version: \"%s\"\n", VERSION];
    
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateFormat:@"yyyy-MM-dd'T'HH:mm:ssZZZZZ"];
    [yaml appendFormat:@"  date: %@\n", [formatter stringFromDate:[NSDate date]]];
    
    [yaml appendString:@"---\n"];
    
    return yaml;
}

- (NSString *)escapeYAMLString:(NSString *)string {
    // Escape quotes and backslashes for YAML
    NSString *escaped = [string stringByReplacingOccurrencesOfString:@"\\" withString:@"\\\\"];
    escaped = [escaped stringByReplacingOccurrencesOfString:@"\"" withString:@"\\\""];
    escaped = [escaped stringByReplacingOccurrencesOfString:@"\n" withString:@"\\n"];
    escaped = [escaped stringByReplacingOccurrencesOfString:@"\r" withString:@"\\r"];
    return escaped;
}

- (NSString *)extractPDFVersion {
    // Try to extract PDF version from document attributes or metadata
    // This is a simplified approach - actual PDF version extraction might require
    // reading the PDF header directly
    NSDictionary *attributes = [self.pdfDocument documentAttributes];
    for (NSString *key in attributes) {
        id value = attributes[key];
        if ([value isKindOfClass:[NSString class]] && 
            [value rangeOfString:@"PDF-" options:NSCaseInsensitiveSearch].location != NSNotFound) {
            return value;
        }
    }
    return nil;
}

- (void)appendOutlineToYAML:(NSMutableString *)yaml outline:(PDFOutline *)outline indent:(NSString *)indent {
    for (NSUInteger i = 0; i < [outline numberOfChildren]; i++) {
        PDFOutline *child = [outline childAtIndex:i];
        NSString *label = [child label];
        if (label && label.length > 0) {
            [yaml appendFormat:@"%@- title: \"%@\"\n", indent, [self escapeYAMLString:label]];
            
            PDFDestination *destination = [child destination];
            if (destination) {
                PDFPage *page = [destination page];
                NSInteger pageIndex = [self.pdfDocument indexForPage:page];
                [yaml appendFormat:@"%@  page: %ld\n", indent, (long)(pageIndex + 1)];
            }
            
            if ([child numberOfChildren] > 0) {
                [yaml appendFormat:@"%@  children:\n", indent];
                NSString *newIndent = [indent stringByAppendingString:@"    "];
                [self appendOutlineToYAML:yaml outline:child indent:newIndent];
            }
        }
    }
}

@end
</file>

<file path="src/PDFPageProcessor.h">
#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

@protocol ContentElement;

@interface PDFPageProcessor : NSObject {
    @public
    NSInteger _pageIndex;
}

- (instancetype)initWithPDFPage:(PDFPage *)pdfPage
                      pageIndex:(NSInteger)pageIndex
                            dpi:(CGFloat)dpi;

- (NSArray<id<ContentElement>> *)extractContentElements;

- (void)captureVectorGraphicsInBounds:(CGRect)bounds
                         withElements:(NSMutableArray *)elements;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="src/PDFPageProcessor.m">
#import "PDFPageProcessor.h"
#import "ContentElement.h"

@interface PDFPageProcessor ()
@property (nonatomic, strong) PDFPage *pdfPage;
@property (nonatomic, assign) NSInteger pageIndex;
@property (nonatomic, assign) CGFloat dpi;
@property (nonatomic, assign) CGPDFPageRef cgPdfPage;
@end

@implementation PDFPageProcessor

- (instancetype)initWithPDFPage:(PDFPage *)pdfPage
                      pageIndex:(NSInteger)pageIndex
                            dpi:(CGFloat)dpi {
    self = [super init];
    if (self) {
        _pdfPage = pdfPage;
        _pageIndex = pageIndex;
        _dpi = dpi;
        _cgPdfPage = [pdfPage pageRef];
    }
    return self;
}

- (NSArray<id<ContentElement>> *)extractContentElements {
    // -------------------------------------------------------------------------
    // NEW IMPLEMENTATION (2025-06-22)
    // -------------------------------------------------------------------------
    // The previous version relied on low-level CGPDFScanner APIs which could
    // enter an infinite loop on some malformed PDFs, causing the whole tool to
    // hang. We now use PDFKit's high-level API which is both safer and faster
    // for common text extraction tasks. Vector graphics and images will be
    // handled separately in future improvements.
    // -------------------------------------------------------------------------
    
    NSMutableArray<id<ContentElement>> *elements = [NSMutableArray array];
    
    // 1. Extract plain text for the entire page.
    NSString *pageText = [self.pdfPage string]; // PDFKit handles parsing
    if (!pageText || pageText.length == 0) {
        return elements; // Nothing to do
    }
    
    // 2. Split into paragraphs so we keep some structure.
    NSArray<NSString *> *paragraphs = [pageText componentsSeparatedByCharactersInSet:[NSCharacterSet newlineCharacterSet]];
    
    // 3. Prepare some default typography metadata. We no longer have direct
    //    font info – set conservative defaults so later heading detection logic
    //    can still run (all body text will share the same size, which is fine
    //    for now; future work can re-introduce advanced heuristics).
    NSString *defaultFontName = @"Helvetica";
    CGFloat   defaultFontSize = 12.0;
    
    // 4. Create a rough vertical cursor so elements have distinct Y positions.
    //    This keeps the existing (page, y, x) sort logic intact.
    CGFloat pageHeight = CGRectGetHeight([self.pdfPage boundsForBox:kPDFDisplayBoxMediaBox]);
    CGFloat cursorY    = pageHeight; // start at the top
    CGFloat lineHeight = defaultFontSize * 1.4; // simple approximation
    
    for (NSString *rawParagraph in paragraphs) {
        NSString *trimmed = [rawParagraph stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
        if (trimmed.length == 0) { continue; }
        
        TextElement *element = [[TextElement alloc] init];
        element.text      = trimmed;
        element.fontName  = defaultFontName;
        element.fontSize  = defaultFontSize;
        element.isBold    = NO;
        element.isItalic  = NO;
        element.pageIndex = self.pageIndex;
        
        CGRect bounds = CGRectMake(0, cursorY - lineHeight, 400, lineHeight);
        element.bounds = bounds;
        
        cursorY -= (lineHeight + 2.0); // simple spacing
        
        [elements addObject:element];
    }
    
    // 5. Extract images using PDFKit annotations
    [self extractImagesFromPageWithElements:elements];
    
    return elements;
}

- (void)captureVectorGraphicsInBounds:(CGRect)bounds
                         withElements:(NSMutableArray *)elements {
    // Expand bounds slightly to ensure we capture everything
    bounds = CGRectInset(bounds, -5, -5);
    
    // Calculate size at specified DPI
    CGFloat scale = self.dpi / 72.0;
    size_t width = (size_t)(CGRectGetWidth(bounds) * scale);
    size_t height = (size_t)(CGRectGetHeight(bounds) * scale);
    
    if (width == 0 || height == 0) {
        return;
    }
    
    // Create bitmap context
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, colorSpace,
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        return;
    }
    
    // Set white background
    CGContextSetRGBFillColor(context, 1.0, 1.0, 1.0, 1.0);
    CGContextFillRect(context, CGRectMake(0, 0, width, height));
    
    // Set up transformation to render just the bounds area
    CGContextSaveGState(context);
    CGContextScaleCTM(context, scale, scale);
    CGContextTranslateCTM(context, -bounds.origin.x, -bounds.origin.y);
    
    // Draw the PDF page
    CGContextDrawPDFPage(context, self.cgPdfPage);
    
    CGContextRestoreGState(context);
    
    // Create image
    CGImageRef image = CGBitmapContextCreateImage(context);
    CGContextRelease(context);
    
    if (image) {
        ImageElement *element = [[ImageElement alloc] init];
        element.image = image;
        element.bounds = bounds;
        element.pageIndex = self.pageIndex;
        element.isVectorSource = YES;
        [elements addObject:element];
    }
}

- (void)extractImagesFromPageWithElements:(NSMutableArray *)elements {
    // Method 1: Extract images from annotations (for embedded images)
    NSArray<PDFAnnotation *> *annotations = [self.pdfPage annotations];
    NSInteger imageIndex = 0;
    
    for (PDFAnnotation *annotation in annotations) {
        // Skip text annotations and other non-image types
        if (![annotation isKindOfClass:[PDFAnnotation class]]) {
            continue;
        }
        
        // Try to get image from annotation appearance
        CGImageRef image = [self imageFromAnnotation:annotation];
        if (image) {
            ImageElement *element = [[ImageElement alloc] init];
            element.image = image;
            element.bounds = [annotation bounds];
            element.pageIndex = self.pageIndex;
            element.isVectorSource = NO;
            [elements addObject:element];
            imageIndex++;
        }
    }
    
    // Method 2: Render page areas that likely contain images
    // This is a fallback approach - render page in sections and detect image-like content
    [self extractImagesByRenderingPageSections:elements startingIndex:imageIndex];
}

- (CGImageRef)imageFromAnnotation:(PDFAnnotation *)annotation {
    // Try to extract image from annotation's appearance stream
    CGRect bounds = [annotation bounds];
    if (CGRectIsEmpty(bounds) || bounds.size.width < 10 || bounds.size.height < 10) {
        return NULL;
    }
    
    // Create a bitmap context to render the annotation
    CGFloat scale = self.dpi / 72.0;
    size_t width = (size_t)(bounds.size.width * scale);
    size_t height = (size_t)(bounds.size.height * scale);
    
    if (width == 0 || height == 0) {
        return NULL;
    }
    
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, colorSpace,
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        return NULL;
    }
    
    // Set white background
    CGContextSetRGBFillColor(context, 1.0, 1.0, 1.0, 1.0);
    CGContextFillRect(context, CGRectMake(0, 0, width, height));
    
    // Transform context to match annotation bounds
    CGContextSaveGState(context);
    CGContextScaleCTM(context, scale, scale);
    
    // Draw just the annotation area from the page
    CGContextClipToRect(context, CGRectMake(0, 0, bounds.size.width, bounds.size.height));
    CGContextTranslateCTM(context, -bounds.origin.x, -bounds.origin.y);
    CGContextDrawPDFPage(context, self.cgPdfPage);
    
    CGContextRestoreGState(context);
    
    // Create image
    CGImageRef image = CGBitmapContextCreateImage(context);
    CGContextRelease(context);
    
    return image;
}

- (void)extractImagesByRenderingPageSections:(NSMutableArray *)elements startingIndex:(NSInteger)startIndex {
    // This method divides the page into a grid and analyzes each section
    // to detect areas that contain primarily image content vs text content
    
    CGRect pageRect = [self.pdfPage boundsForBox:kPDFDisplayBoxMediaBox];
    CGFloat sectionSize = 100.0; // 100 point sections
    
    NSInteger gridX = (NSInteger)ceil(pageRect.size.width / sectionSize);
    NSInteger gridY = (NSInteger)ceil(pageRect.size.height / sectionSize);
    
    NSInteger imageIndex = startIndex;
    
    for (NSInteger x = 0; x < gridX; x++) {
        for (NSInteger y = 0; y < gridY; y++) {
            CGRect sectionRect = CGRectMake(x * sectionSize, y * sectionSize, 
                                          sectionSize, sectionSize);
            
            // Intersect with page bounds
            sectionRect = CGRectIntersection(sectionRect, pageRect);
            if (CGRectIsEmpty(sectionRect) || sectionRect.size.width < 20 || sectionRect.size.height < 20) {
                continue;
            }
            
            // Check if this section contains primarily image content
            if ([self sectionContainsImageContent:sectionRect]) {
                CGImageRef sectionImage = [self renderPageSection:sectionRect];
                if (sectionImage) {
                    ImageElement *element = [[ImageElement alloc] init];
                    element.image = sectionImage;
                    element.bounds = sectionRect;
                    element.pageIndex = self.pageIndex;
                    element.isVectorSource = YES; // Since we're rendering from vector
                    [elements addObject:element];
                    imageIndex++;
                }
            }
        }
    }
}

- (BOOL)sectionContainsImageContent:(CGRect)sectionRect {
    // Simple heuristic: if a section doesn't contain much text, it might be an image
    // This is a simplified approach - we could improve this with more sophisticated analysis
    
    // Get text in this section
    PDFSelection *selection = [self.pdfPage selectionForRect:sectionRect];
    NSString *sectionText = [selection string];
    
    // If there's very little text, it might be an image area
    NSString *trimmedText = [sectionText stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    
    // Threshold: if less than 10 characters, consider it potentially an image area
    return [trimmedText length] < 10;
}

- (CGImageRef)renderPageSection:(CGRect)sectionRect {
    // Render just the specified section of the page
    CGFloat scale = self.dpi / 72.0;
    size_t width = (size_t)(sectionRect.size.width * scale);
    size_t height = (size_t)(sectionRect.size.height * scale);
    
    if (width == 0 || height == 0) {
        return NULL;
    }
    
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, colorSpace,
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        return NULL;
    }
    
    // Set white background
    CGContextSetRGBFillColor(context, 1.0, 1.0, 1.0, 1.0);
    CGContextFillRect(context, CGRectMake(0, 0, width, height));
    
    // Transform context to render just the section
    CGContextSaveGState(context);
    CGContextScaleCTM(context, scale, scale);
    CGContextTranslateCTM(context, -sectionRect.origin.x, -sectionRect.origin.y);
    
    // Draw the PDF page
    CGContextDrawPDFPage(context, self.cgPdfPage);
    
    CGContextRestoreGState(context);
    
    // Create image
    CGImageRef image = CGBitmapContextCreateImage(context);
    CGContextRelease(context);
    
    return image;
}

@end
</file>

<file path="test/benchmark/output.md">
---
title: "README.md"
creator: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36 Edg/137.0.0.0"
producer: "Skia/PDF m137"
created: 2025-06-23T01:33:53+02:00
modified: 2025-06-23T01:33:53+02:00
pdf_metadata:
  page_count: 2
conversion:
  tool: "pdf22md"
  version: "v1.2.0-dirty"
  date: 2025-06-25T16:02:06+02:00
---

23/06/2025, 01:33 README.md

![Image](image_000.png)

![Image](image_001.png)

pdf22md

MIT

License MIT

License

10.15+

![Image](image_002.png)

![Image](image_003.png)

macOS 10.15+

macOS

Build and Release Build and Release passing passing

A blazingly fast PDF to Markdown converter for macOS.

pdf22md is a command-line tool that extracts all text and image content from a PDF file and converts it into a

![Image](image_004.png)

![Image](image_005.png)

![Image](image_006.png)

clean Markdown document. It uses Grand Central Dispatch (GCD) to process pages and save images in

parallel, making it exceptionally fast for multi-page documents.

Key Features

High-Speed Conversion: Uses all available CPU cores to process PDF pages concurrently

Intelligent Heading Detection: Analyzes font sizes and usage frequency to automatically format titles

![Image](image_007.png)

![Image](image_008.png)

![Image](image_009.png)

and headings ( # , ## , etc.)

Asset Extraction: Saves raster and vector images into a specified assets folder and links them correctly

in the Markdown file

Smart Image Formatting: Automatically chooses between JPEG (for photos) and PNG (for graphics with

transparency) to optimize file size and quality

Flexible I/O: Reads from a PDF file or stdin and writes to a Markdown file or stdout

![Image](image_010.png)

![Image](image_011.png)

![Image](image_012.png)

Customizable Rasterization: Allows setting a custom DPI for converting vector graphics to bitmaps

Installation

Using Homebrew (Coming Soon)

brew tap twardoch/pdf22md

brew install pdf22md

![Image](image_013.png)

![Image](image_014.png)

Building from Source

To build the project manually, you need Xcode Command Line Tools installed.

# Clone the repository

git clone https://github.com/twardoch/pdf22md.git

cd pdf22md

# Compile the tool

make

# Install it to /usr/local/bin (optional)

sudo make install

Download Pre-built Binary

Pre-built binaries are available from the Releases page.

Usage

Usage: pdf22md [-i input.pdf] [-o output.md] [-a assets

_

folder] [-d dpi]

Converts PDF documents to Markdown format

-i <path>: Input PDF file (default: stdin)

-o <path>: Output Markdown file (default: stdout)

-a <path>: Assets folder for extracted images

-d <dpi>: DPI for rasterizing vector graphics (default: 144)

Examples

# Convert a PDF file to Markdown

pdf22md -i document.pdf -o document.md

# Convert with images saved to an 'assets' folder

pdf22md -i report.pdf -o report.md -a ./assets

# Convert with custom DPI for vector graphics

pdf22md -i presentation.pdf -o presentation.md -a ./images -d 300

# Use with pipes

cat document.pdf | pdf22md > document.md

# Convert and view in less

pdf22md -i manual.pdf | less

Requirements

macOS 10.15 (Catalina) or later

Xcode Command Line Tools (for building from source)

Project Structure

pdf22md/

├── src/ # Source code

│ ├── main.m # Entry point

│ ├── PDFMarkdownConverter.* # Main conversion logic

│ ├── PDFPageProcessor.* # PDF page processing

│ ├── ContentElement.* # Content element definitions

│ └── AssetExtractor.* # Image extraction logic

├── docs/ # Additional documentation

├── test/ # Test files

file:///Users/adam/Developer/vcs/github.twardoch/pub/pdf22md/README.md 1/2

23/06/2025, 01:33 README.md

![Image](image_015.png)

![Image](image_016.png)

├── LICENSE # MIT License

├── Makefile # Build configuration

└── README.md # This file

Contributing

Contributions are welcome! Please feel free to submit a Pull Request. For major changes, please open an

![Image](image_017.png)

![Image](image_018.png)

![Image](image_019.png)

issue first to discuss what you

would like to change.

1. Fork the repository

2. Create your feature branch ( git checkout -b feature/AmazingFeature )

3. Commit your changes ( git commit -m 'Add some AmazingFeature' )

![Image](image_020.png)

![Image](image_021.png)

![Image](image_022.png)

4. Push to the branch ( git push origin feature/AmazingFeature )

5. Open a Pull Request

License

This project is licensed under the MIT License - see the LICENSE file for details.

Acknowledgments

![Image](image_023.png)

![Image](image_024.png)

![Image](image_025.png)

![Image](image_026.png)

![Image](image_027.png)

Built with Apple’s PDFKit and Core Graphics frameworks

Parallel processing powered by Grand Central Dispatch (GCD)

Inspired by the need for fast, accurate PDF to Markdown conversion

Related Projects

pdfplumber - Python library for PDF processing

![Image](image_028.png)

pdf2md - Another PDF to Markdown converter

![Image](image_029.png)

![Image](image_030.png)

![Image](image_031.png)

![Image](image_032.png)

pandoc - Universal document converter

Changelog

See CHANGELOG.md for a list of changes in each version.

Support

If you encounter any issues or have questions, please open an issue on GitHub.

![Image](image_033.png)

![Image](image_034.png)

file:///Users/adam/Developer/vcs/github.twardoch/pub/pdf22md/README.md 2/2
</file>

<file path="test/README.md">
---
title: "README.md"
creator: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36 Edg/137.0.0.0"
producer: "Skia/PDF m137"
created: 2025-06-23T01:33:53+02:00
modified: 2025-06-23T01:33:53+02:00
pdf_metadata:
  page_count: 2
conversion:
  tool: "pdf22md"
  version: "v1.1.0-dirty"
  date: 2025-06-23T02:28:31+02:00
---

23/06/2025, 01:33 README.md

![Image](image_000.png)

![Image](image_001.png)

pdf22md

MIT

License MIT

License

10.15+

![Image](image_002.png)

![Image](image_003.png)

macOS 10.15+

macOS

Build and Release Build and Release passing passing

A blazingly fast PDF to Markdown converter for macOS.

pdf22md is a command-line tool that extracts all text and image content from a PDF file and converts it into a

![Image](image_004.png)

![Image](image_005.png)

![Image](image_006.png)

clean Markdown document. It uses Grand Central Dispatch (GCD) to process pages and save images in

parallel, making it exceptionally fast for multi-page documents.

Key Features

High-Speed Conversion: Uses all available CPU cores to process PDF pages concurrently

Intelligent Heading Detection: Analyzes font sizes and usage frequency to automatically format titles

![Image](image_007.png)

![Image](image_008.png)

![Image](image_009.png)

and headings ( # , ## , etc.)

Asset Extraction: Saves raster and vector images into a specified assets folder and links them correctly

in the Markdown file

Smart Image Formatting: Automatically chooses between JPEG (for photos) and PNG (for graphics with

transparency) to optimize file size and quality

Flexible I/O: Reads from a PDF file or stdin and writes to a Markdown file or stdout

![Image](image_010.png)

![Image](image_011.png)

![Image](image_012.png)

Customizable Rasterization: Allows setting a custom DPI for converting vector graphics to bitmaps

Installation

Using Homebrew (Coming Soon)

brew tap twardoch/pdf22md

brew install pdf22md

![Image](image_013.png)

![Image](image_014.png)

Building from Source

To build the project manually, you need Xcode Command Line Tools installed.

# Clone the repository

git clone https://github.com/twardoch/pdf22md.git

cd pdf22md

# Compile the tool

make

# Install it to /usr/local/bin (optional)

sudo make install

Download Pre-built Binary

Pre-built binaries are available from the Releases page.

Usage

Usage: pdf22md [-i input.pdf] [-o output.md] [-a assets

_

folder] [-d dpi]

Converts PDF documents to Markdown format

-i <path>: Input PDF file (default: stdin)

-o <path>: Output Markdown file (default: stdout)

-a <path>: Assets folder for extracted images

-d <dpi>: DPI for rasterizing vector graphics (default: 144)

Examples

# Convert a PDF file to Markdown

pdf22md -i document.pdf -o document.md

# Convert with images saved to an 'assets' folder

pdf22md -i report.pdf -o report.md -a ./assets

# Convert with custom DPI for vector graphics

pdf22md -i presentation.pdf -o presentation.md -a ./images -d 300

# Use with pipes

cat document.pdf | pdf22md > document.md

# Convert and view in less

pdf22md -i manual.pdf | less

Requirements

macOS 10.15 (Catalina) or later

Xcode Command Line Tools (for building from source)

Project Structure

pdf22md/

├── src/ # Source code

│ ├── main.m # Entry point

│ ├── PDFMarkdownConverter.* # Main conversion logic

│ ├── PDFPageProcessor.* # PDF page processing

│ ├── ContentElement.* # Content element definitions

│ └── AssetExtractor.* # Image extraction logic

├── docs/ # Additional documentation

├── test/ # Test files

file:///Users/adam/Developer/vcs/github.twardoch/pub/pdf22md/README.md 1/2

23/06/2025, 01:33 README.md

![Image](image_015.png)

![Image](image_016.png)

├── LICENSE # MIT License

├── Makefile # Build configuration

└── README.md # This file

Contributing

Contributions are welcome! Please feel free to submit a Pull Request. For major changes, please open an

![Image](image_017.png)

![Image](image_018.png)

![Image](image_019.png)

issue first to discuss what you

would like to change.

1. Fork the repository

2. Create your feature branch ( git checkout -b feature/AmazingFeature )

3. Commit your changes ( git commit -m 'Add some AmazingFeature' )

![Image](image_020.png)

![Image](image_021.png)

![Image](image_022.png)

4. Push to the branch ( git push origin feature/AmazingFeature )

5. Open a Pull Request

License

This project is licensed under the MIT License - see the LICENSE file for details.

Acknowledgments

![Image](image_023.png)

![Image](image_024.png)

![Image](image_025.png)

![Image](image_026.png)

![Image](image_027.png)

Built with Apple’s PDFKit and Core Graphics frameworks

Parallel processing powered by Grand Central Dispatch (GCD)

Inspired by the need for fast, accurate PDF to Markdown conversion

Related Projects

pdfplumber - Python library for PDF processing

![Image](image_028.png)

pdf2md - Another PDF to Markdown converter

![Image](image_029.png)

![Image](image_030.png)

![Image](image_031.png)

![Image](image_032.png)

pandoc - Universal document converter

Changelog

See CHANGELOG.md for a list of changes in each version.

Support

If you encounter any issues or have questions, please open an issue on GitHub.

![Image](image_033.png)

![Image](image_034.png)

file:///Users/adam/Developer/vcs/github.twardoch/pub/pdf22md/README.md 2/2
</file>

<file path="Tests/Integration/EndToEndConversionTests.m">
//
//  EndToEndConversionTests.m
//  pdf22md-objc
//
//  Integration tests for complete PDF to Markdown conversion pipeline
//

#import <XCTest/XCTest.h>
#import "PDF22MDConverter.h"
#import "PDF22MDConversionOptions.h"
#import "PDF22MDError.h"

@interface EndToEndConversionTests : XCTestCase
@property (nonatomic, strong) PDF22MDConverter *converter;
@property (nonatomic, strong) NSString *testResourcesPath;
@property (nonatomic, strong) NSString *tempOutputPath;
@end

@implementation EndToEndConversionTests

- (void)setUp {
    [super setUp];
    self.converter = [[PDF22MDConverter alloc] init];
    
    // Set up test resources path
    NSBundle *bundle = [NSBundle bundleForClass:[self class]];
    self.testResourcesPath = [bundle.resourcePath stringByAppendingPathComponent:@"Tests/Resources"];
    
    // Create temporary output directory
    self.tempOutputPath = [NSTemporaryDirectory() stringByAppendingPathComponent:@"pdf22md-test-output"];
    [[NSFileManager defaultManager] createDirectoryAtPath:self.tempOutputPath 
                              withIntermediateDirectories:YES 
                                               attributes:nil 
                                                    error:nil];
}

- (void)tearDown {
    // Clean up temporary directory
    [[NSFileManager defaultManager] removeItemAtPath:self.tempOutputPath error:nil];
    self.converter = nil;
    [super tearDown];
}

#pragma mark - Complete Workflow Tests

- (void)testSimpleTextDocumentConversion {
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"simple-text.pdf"];
    
    // Skip test if resource file doesn't exist
    if (![self fileExistsAtPath:testPDFPath]) {
        NSLog(@"Test PDF 'simple-text.pdf' not found, skipping test");
        return;
    }
    
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    options.assetsPath = [self.tempOutputPath stringByAppendingPathComponent:@"assets"];
    
    NSError *error = nil;
    NSString *markdown = [self.converter convertPDFAtPath:testPDFPath 
                                              withOptions:options 
                                                    error:&error];
    
    XCTAssertNotNil(markdown, @"Should successfully convert simple text PDF");
    XCTAssertNil(error, @"Should not return error for valid PDF conversion");
    
    // Validate markdown structure
    [self validateBasicMarkdownStructure:markdown];
    
    // Check that assets directory was created (even if empty)
    BOOL isDirectory;
    BOOL assetsExist = [[NSFileManager defaultManager] fileExistsAtPath:options.assetsPath 
                                                            isDirectory:&isDirectory];
    XCTAssertTrue(assetsExist && isDirectory, @"Assets directory should be created");
}

- (void)testComplexDocumentWithImages {
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"complex-with-images.pdf"];
    
    if (![self fileExistsAtPath:testPDFPath]) {
        NSLog(@"Test PDF 'complex-with-images.pdf' not found, skipping test");
        return;
    }
    
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    options.assetsPath = [self.tempOutputPath stringByAppendingPathComponent:@"assets"];
    options.dpi = 200; // Higher DPI for quality
    
    NSError *error = nil;
    NSString *markdown = [self.converter convertPDFAtPath:testPDFPath 
                                              withOptions:options 
                                                    error:&error];
    
    XCTAssertNotNil(markdown, @"Should successfully convert complex PDF with images");
    XCTAssertNil(error, @"Should not return error for valid PDF conversion");
    
    // Validate markdown structure
    [self validateBasicMarkdownStructure:markdown];
    
    // Check for image references in markdown
    XCTAssertTrue([markdown containsString:@"!["], @"Should contain image references");
    XCTAssertTrue([markdown containsString:@"assets/"], @"Should reference assets directory");
    
    // Verify that image files were actually created
    NSArray *assetFiles = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:options.assetsPath error:nil];
    XCTAssertTrue(assetFiles.count > 0, @"Should extract at least one asset file");
    
    // Verify image file formats
    for (NSString *filename in assetFiles) {
        XCTAssertTrue([filename hasSuffix:@".png"] || [filename hasSuffix:@".jpg"], 
                      @"Asset files should be PNG or JPG format");
    }
}

- (void)testLargeDocumentPerformance {
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"large-document.pdf"];
    
    if (![self fileExistsAtPath:testPDFPath]) {
        NSLog(@"Test PDF 'large-document.pdf' not found, skipping test");
        return;
    }
    
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    options.assetsPath = [self.tempOutputPath stringByAppendingPathComponent:@"assets"];
    
    NSDate *startTime = [NSDate date];
    
    NSError *error = nil;
    NSString *markdown = [self.converter convertPDFAtPath:testPDFPath 
                                              withOptions:options 
                                                    error:&error];
    
    NSTimeInterval elapsed = [[NSDate date] timeIntervalSinceDate:startTime];
    
    XCTAssertNotNil(markdown, @"Should successfully convert large PDF");
    XCTAssertNil(error, @"Should not return error for valid large PDF");
    XCTAssertLessThan(elapsed, 30.0, @"Large document conversion should complete within 30 seconds");
    
    NSLog(@"Large document conversion time: %.2f seconds", elapsed);
}

#pragma mark - Error Handling Integration Tests

- (void)testMalformedPDFHandling {
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"malformed.pdf"];
    
    if (![self fileExistsAtPath:testPDFPath]) {
        NSLog(@"Test PDF 'malformed.pdf' not found, skipping test");
        return;
    }
    
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    
    NSError *error = nil;
    NSString *markdown = [self.converter convertPDFAtPath:testPDFPath 
                                              withOptions:options 
                                                    error:&error];
    
    // Should either succeed with partial content or fail gracefully
    if (markdown) {
        XCTAssertNil(error, @"If conversion succeeds, should not return error");
        XCTAssertTrue(markdown.length > 0, @"If conversion succeeds, should return content");
    } else {
        XCTAssertNotNil(error, @"If conversion fails, should return meaningful error");
        XCTAssertNotEqual(error.code, 0, @"Error should have meaningful error code");
        XCTAssertTrue(error.localizedDescription.length > 0, @"Error should have description");
    }
}

- (void)testEncryptedPDFHandling {
    // This test would require an encrypted PDF sample
    // For now, we'll test the expected behavior
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"encrypted.pdf"];
    
    if (![self fileExistsAtPath:testPDFPath]) {
        NSLog(@"Test PDF 'encrypted.pdf' not found, skipping test");
        return;
    }
    
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    
    NSError *error = nil;
    NSString *markdown = [self.converter convertPDFAtPath:testPDFPath 
                                              withOptions:options 
                                                    error:&error];
    
    XCTAssertNil(markdown, @"Should not convert encrypted PDF without password");
    XCTAssertNotNil(error, @"Should return error for encrypted PDF");
    XCTAssertEqual(error.code, PDF22MDErrorEncryptedPDF, @"Should return encrypted PDF error code");
}

#pragma mark - Memory Stress Tests

- (void)testMemoryStabilityUnderLoad {
    // Test multiple conversions to ensure memory stability
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    options.assetsPath = [self.tempOutputPath stringByAppendingPathComponent:@"stress-assets"];
    
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"simple-text.pdf"];
    
    if (![self fileExistsAtPath:testPDFPath]) {
        NSLog(@"Test PDF not found, creating minimal test for memory stability");
        return;
    }
    
    // Run multiple conversions
    for (int i = 0; i < 5; i++) {
        @autoreleasepool {
            NSError *error = nil;
            NSString *markdown = [self.converter convertPDFAtPath:testPDFPath 
                                                      withOptions:options 
                                                            error:&error];
            
            XCTAssertNotNil(markdown, @"Conversion %d should succeed", i + 1);
            XCTAssertNil(error, @"Conversion %d should not return error", i + 1);
        }
    }
}

#pragma mark - Output Validation Tests

- (void)testMarkdownOutputQuality {
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"simple-text.pdf"];
    
    if (![self fileExistsAtPath:testPDFPath]) {
        NSLog(@"Test PDF not found, skipping output quality test");
        return;
    }
    
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    
    NSError *error = nil;
    NSString *markdown = [self.converter convertPDFAtPath:testPDFPath 
                                              withOptions:options 
                                                    error:&error];
    
    XCTAssertNotNil(markdown, @"Should produce markdown output");
    
    if (markdown) {
        [self validateAdvancedMarkdownStructure:markdown];
    }
}

- (void)testExpectedOutputComparison {
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"simple-text.pdf"];
    NSString *expectedPath = [self.testResourcesPath stringByAppendingPathComponent:@"expected-outputs/simple-text.md"];
    
    if (![self fileExistsAtPath:testPDFPath] || ![self fileExistsAtPath:expectedPath]) {
        NSLog(@"Test files not found, skipping expected output comparison");
        return;
    }
    
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    
    NSError *error = nil;
    NSString *actualMarkdown = [self.converter convertPDFAtPath:testPDFPath 
                                                    withOptions:options 
                                                          error:&error];
    
    NSString *expectedMarkdown = [NSString stringWithContentsOfFile:expectedPath 
                                                           encoding:NSUTF8StringEncoding 
                                                              error:nil];
    
    XCTAssertNotNil(actualMarkdown, @"Should produce actual markdown");
    XCTAssertNotNil(expectedMarkdown, @"Should load expected markdown");
    
    if (actualMarkdown && expectedMarkdown) {
        // Normalize whitespace for comparison
        NSString *normalizedActual = [self normalizeWhitespace:actualMarkdown];
        NSString *normalizedExpected = [self normalizeWhitespace:expectedMarkdown];
        
        XCTAssertEqualObjects(normalizedActual, normalizedExpected, 
                              @"Actual output should match expected output");
    }
}

#pragma mark - Helper Methods

- (BOOL)fileExistsAtPath:(NSString *)path {
    return [[NSFileManager defaultManager] fileExistsAtPath:path];
}

- (void)validateBasicMarkdownStructure:(NSString *)markdown {
    XCTAssertTrue(markdown.length > 0, @"Markdown should not be empty");
    
    // Should not contain raw PDF artifacts
    XCTAssertFalse([markdown containsString:@"%%PDF"], @"Should not contain PDF header");
    XCTAssertFalse([markdown containsString:@"endobj"], @"Should not contain PDF objects");
    
    // Should be valid UTF-8
    NSData *data = [markdown dataUsingEncoding:NSUTF8StringEncoding];
    XCTAssertNotNil(data, @"Markdown should be valid UTF-8");
}

- (void)validateAdvancedMarkdownStructure:(NSString *)markdown {
    [self validateBasicMarkdownStructure:markdown];
    
    // Check for proper markdown formatting
    NSArray *lines = [markdown componentsSeparatedByString:@"\n"];
    
    BOOL hasHeadings = NO;
    BOOL hasContent = NO;
    
    for (NSString *line in lines) {
        NSString *trimmed = [line stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
        
        if ([trimmed hasPrefix:@"#"]) {
            hasHeadings = YES;
            // Validate heading format
            XCTAssertTrue([trimmed rangeOfString:@"# "].location != NSNotFound ||
                         [trimmed rangeOfString:@"## "].location != NSNotFound ||
                         [trimmed rangeOfString:@"### "].location != NSNotFound,
                         @"Headings should have proper spacing");
        }
        
        if (trimmed.length > 0 && ![trimmed hasPrefix:@"#"] && ![trimmed hasPrefix:@"!"]) {
            hasContent = YES;
        }
    }
    
    // Don't require headings for all documents, but if present, they should be formatted correctly
    if (hasHeadings) {
        XCTAssertTrue(hasContent, @"Document with headings should also have content");
    }
}

- (NSString *)normalizeWhitespace:(NSString *)text {
    // Normalize line endings and excessive whitespace for comparison
    NSString *normalized = [text stringByReplacingOccurrencesOfString:@"\r\n" withString:@"\n"];
    normalized = [normalized stringByReplacingOccurrencesOfString:@"\r" withString:@"\n"];
    
    // Remove trailing whitespace from lines
    NSMutableArray *lines = [[normalized componentsSeparatedByString:@"\n"] mutableCopy];
    for (NSInteger i = 0; i < lines.count; i++) {
        lines[i] = [lines[i] stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
    }
    
    return [lines componentsJoinedByString:@"\n"];
}

@end
</file>

<file path="Tests/Unit/AssetExtractorTests.m">
//
//  AssetExtractorTests.m
//  pdf22md
//
//  Unit tests for asset extraction and image processing functionality
//

#import <XCTest/XCTest.h>
#import <CoreGraphics/CoreGraphics.h>
#import <ImageIO/ImageIO.h>
#import "../../src/AssetExtractor.h"

@interface AssetExtractorTests : XCTestCase
@property (nonatomic, strong) AssetExtractor *extractor;
@property (nonatomic, strong) NSString *testAssetsPath;
@end

@implementation AssetExtractorTests

- (void)setUp {
    [super setUp];
    self.extractor = [[AssetExtractor alloc] init];
    
    // Create temporary test assets directory
    NSString *tempDir = NSTemporaryDirectory();
    self.testAssetsPath = [tempDir stringByAppendingPathComponent:@"pdf22md-test-assets"];
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    [fileManager createDirectoryAtPath:self.testAssetsPath 
           withIntermediateDirectories:YES 
                            attributes:nil 
                                 error:nil];
}

- (void)tearDown {
    // Clean up test assets directory
    NSFileManager *fileManager = [NSFileManager defaultManager];
    [fileManager removeItemAtPath:self.testAssetsPath error:nil];
    
    self.extractor = nil;
    self.testAssetsPath = nil;
    [super tearDown];
}

#pragma mark - Basic Functionality Tests

- (void)testExtractorInitialization {
    XCTAssertNotNil(self.extractor, @"AssetExtractor should initialize successfully");
}

- (void)testSetAssetsFolderPath {
    NSString *testPath = @"/tmp/test-assets";
    [self.extractor setAssetsFolderPath:testPath];
    
    // Note: We can't directly test the private property, but we can test that the method doesn't crash
    // and that subsequent operations work as expected
    XCTAssertTrue(YES, @"setAssetsFolderPath should complete without crashing");
}

#pragma mark - Image Format Detection Tests

- (void)testFormatOptimizationLogic {
    // Test the format optimization logic with synthetic images
    
    // Create a simple test image
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, 100, 100, 8, 0, colorSpace, 
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (context) {
        // Fill with a simple color
        CGContextSetRGBFillColor(context, 1.0, 0.0, 0.0, 1.0);
        CGContextFillRect(context, CGRectMake(0, 0, 100, 100));
        
        CGImageRef testImage = CGBitmapContextCreateImage(context);
        CGContextRelease(context);
        
        if (testImage) {
            // Test format decision logic
            BOOL shouldUseJPEG = [self.extractor shouldUseJPEGForImage:testImage];
            
            // For a simple solid color image, PNG should be preferred
            // (though the exact logic depends on implementation)
            XCTAssertTrue(shouldUseJPEG == YES || shouldUseJPEG == NO, 
                         @"shouldUseJPEGForImage should return a boolean value");
            
            CGImageRelease(testImage);
        }
    }
}

- (void)testImageSaving {
    // Test image saving functionality
    
    // Create a minimal test image
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, 50, 50, 8, 0, colorSpace, 
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (context) {
        // Create a gradient pattern for testing
        CGContextSetRGBFillColor(context, 0.5, 0.5, 1.0, 1.0);
        CGContextFillRect(context, CGRectMake(0, 0, 50, 50));
        
        CGImageRef testImage = CGBitmapContextCreateImage(context);
        CGContextRelease(context);
        
        if (testImage) {
            [self.extractor setAssetsFolderPath:self.testAssetsPath];
            
            NSString *savedPath = [self.extractor saveImage:testImage withBaseName:@"test_image"];
            
            if (savedPath) {
                // Verify the file was created
                NSString *fullPath = [self.testAssetsPath stringByAppendingPathComponent:savedPath];
                NSFileManager *fileManager = [NSFileManager defaultManager];
                XCTAssertTrue([fileManager fileExistsAtPath:fullPath], 
                             @"Saved image file should exist at path: %@", fullPath);
                
                // Verify it's a valid image file
                NSData *imageData = [NSData dataWithContentsOfFile:fullPath];
                XCTAssertNotNil(imageData, @"Should be able to read saved image data");
                XCTAssertTrue(imageData.length > 0, @"Saved image should have non-zero size");
            } else {
                XCTFail(@"saveImage should return a non-nil path");
            }
            
            CGImageRelease(testImage);
        }
    }
}

#pragma mark - File Naming Tests

- (void)testUniqueFileNaming {
    // Test that the extractor generates unique filenames
    [self.extractor setAssetsFolderPath:self.testAssetsPath];
    
    // Create multiple test images and verify unique naming
    for (int i = 0; i < 3; i++) {
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        CGContextRef context = CGBitmapContextCreate(NULL, 20, 20, 8, 0, colorSpace, 
                                                    kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
        CGColorSpaceRelease(colorSpace);
        
        if (context) {
            // Use different colors for each image
            CGFloat red = (i == 0) ? 1.0 : 0.0;
            CGFloat green = (i == 1) ? 1.0 : 0.0;
            CGFloat blue = (i == 2) ? 1.0 : 0.0;
            
            CGContextSetRGBFillColor(context, red, green, blue, 1.0);
            CGContextFillRect(context, CGRectMake(0, 0, 20, 20));
            
            CGImageRef testImage = CGBitmapContextCreateImage(context);
            CGContextRelease(context);
            
            if (testImage) {
                NSString *savedPath = [self.extractor saveImage:testImage withBaseName:@"test"];
                XCTAssertNotNil(savedPath, @"Should get a valid filename for image %d", i);
                
                CGImageRelease(testImage);
            }
        }
    }
    
    // Verify multiple files were created
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSArray *contents = [fileManager contentsOfDirectoryAtPath:self.testAssetsPath error:nil];
    XCTAssertTrue(contents.count >= 1, @"Should have created at least one image file");
}

#pragma mark - Error Handling Tests

- (void)testNilImageHandling {
    [self.extractor setAssetsFolderPath:self.testAssetsPath];
    
    NSString *result = [self.extractor saveImage:NULL withBaseName:@"test"];
    XCTAssertNil(result, @"Should return nil for NULL image");
}

- (void)testInvalidAssetsFolderHandling {
    // Test with invalid assets folder path
    NSString *invalidPath = @"/invalid/path/that/cannot/be/created";
    [self.extractor setAssetsFolderPath:invalidPath];
    
    // Create a test image
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, 10, 10, 8, 0, colorSpace, 
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (context) {
        CGContextSetRGBFillColor(context, 1.0, 1.0, 1.0, 1.0);
        CGContextFillRect(context, CGRectMake(0, 0, 10, 10));
        
        CGImageRef testImage = CGBitmapContextCreateImage(context);
        CGContextRelease(context);
        
        if (testImage) {
            NSString *result = [self.extractor saveImage:testImage withBaseName:@"test"];
            // Should handle the error gracefully (exact behavior depends on implementation)
            // At minimum, should not crash
            
            CGImageRelease(testImage);
        }
    }
}

#pragma mark - Performance Tests

- (void)testImageSavingPerformance {
    [self.extractor setAssetsFolderPath:self.testAssetsPath];
    
    [self measureBlock:^{
        // Create and save a test image
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        CGContextRef context = CGBitmapContextCreate(NULL, 100, 100, 8, 0, colorSpace, 
                                                    kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
        CGColorSpaceRelease(colorSpace);
        
        if (context) {
            CGContextSetRGBFillColor(context, 0.5, 0.5, 0.5, 1.0);
            CGContextFillRect(context, CGRectMake(0, 0, 100, 100));
            
            CGImageRef testImage = CGBitmapContextCreateImage(context);
            CGContextRelease(context);
            
            if (testImage) {
                [self.extractor saveImage:testImage withBaseName:@"perf_test"];
                CGImageRelease(testImage);
            }
        }
    }];
}

#pragma mark - Memory Management Tests

- (void)testMemoryManagement {
    // Test that multiple image operations don't cause memory issues
    [self.extractor setAssetsFolderPath:self.testAssetsPath];
    
    for (int i = 0; i < 10; i++) {
        @autoreleasepool {
            CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
            CGContextRef context = CGBitmapContextCreate(NULL, 50, 50, 8, 0, colorSpace, 
                                                        kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
            CGColorSpaceRelease(colorSpace);
            
            if (context) {
                CGContextSetRGBFillColor(context, (i % 3) / 3.0, ((i + 1) % 3) / 3.0, ((i + 2) % 3) / 3.0, 1.0);
                CGContextFillRect(context, CGRectMake(0, 0, 50, 50));
                
                CGImageRef testImage = CGBitmapContextCreateImage(context);
                CGContextRelease(context);
                
                if (testImage) {
                    NSString *baseName = [NSString stringWithFormat:@"memory_test_%d", i];
                    [self.extractor saveImage:testImage withBaseName:baseName];
                    CGImageRelease(testImage);
                }
            }
        }
    }
    
    // Verify files were created
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSArray *contents = [fileManager contentsOfDirectoryAtPath:self.testAssetsPath error:nil];
    XCTAssertTrue(contents.count > 0, @"Should have created image files during memory test");
}

@end
</file>

<file path="Tests/Unit/ContentElementTests.m">
//
//  ContentElementTests.m
//  pdf22md
//
//  Unit tests for ContentElement model and text/image element functionality
//

#import <XCTest/XCTest.h>
#import <CoreGraphics/CoreGraphics.h>
#import "../../src/ContentElement.h"

@interface ContentElementTests : XCTestCase
@end

@implementation ContentElementTests

- (void)setUp {
    [super setUp];
}

- (void)tearDown {
    [super tearDown];
}

#pragma mark - ContentElement Protocol Tests

- (void)testContentElementProtocolExists {
    // Verify that the ContentElement protocol exists and can be referenced
    Protocol *contentElementProtocol = @protocol(ContentElement);
    XCTAssertNotNil(contentElementProtocol, @"ContentElement protocol should exist");
}

#pragma mark - Text Element Tests

- (void)testTextElementCreation {
    // Test creation of text elements
    NSString *testText = @"Sample text content";
    CGRect testBounds = CGRectMake(10, 20, 200, 30);
    NSInteger testPage = 1;
    
    // Check if TextElement class exists and can be instantiated
    Class textElementClass = NSClassFromString(@"TextElement");
    if (textElementClass) {
        // Test basic instantiation
        id textElement = [[textElementClass alloc] init];
        XCTAssertNotNil(textElement, @"TextElement should be instantiable");
        
        // Test that it conforms to ContentElement protocol
        XCTAssertTrue([textElement conformsToProtocol:@protocol(ContentElement)], 
                     @"TextElement should conform to ContentElement protocol");
    } else {
        XCTFail(@"TextElement class should be available");
    }
}

- (void)testTextElementProperties {
    Class textElementClass = NSClassFromString(@"TextElement");
    if (textElementClass) {
        id textElement = [[textElementClass alloc] init];
        
        // Test basic property access (using KVC since we don't have direct access to the interface)
        NSString *testText = @"Test content";
        
        // Check if text property exists and can be set/get
        if ([textElement respondsToSelector:@selector(setText:)]) {
            [textElement performSelector:@selector(setText:) withObject:testText];
            
            if ([textElement respondsToSelector:@selector(text)]) {
                NSString *retrievedText = [textElement performSelector:@selector(text)];
                XCTAssertEqualObjects(retrievedText, testText, @"Text property should store and retrieve correctly");
            }
        }
        
        // Test bounds property if available
        if ([textElement respondsToSelector:@selector(setBounds:)]) {
            CGRect testBounds = CGRectMake(5, 10, 100, 20);
            NSValue *boundsValue = [NSValue valueWithCGRect:testBounds];
            [textElement performSelector:@selector(setBounds:) withObject:boundsValue];
            
            if ([textElement respondsToSelector:@selector(bounds)]) {
                NSValue *retrievedBounds = [textElement performSelector:@selector(bounds)];
                CGRect retrievedRect = [retrievedBounds CGRectValue];
                XCTAssertTrue(CGRectEqualToRect(retrievedRect, testBounds), 
                             @"Bounds property should store and retrieve correctly");
            }
        }
    }
}

#pragma mark - Image Element Tests

- (void)testImageElementCreation {
    Class imageElementClass = NSClassFromString(@"ImageElement");
    if (imageElementClass) {
        // Test basic instantiation
        id imageElement = [[imageElementClass alloc] init];
        XCTAssertNotNil(imageElement, @"ImageElement should be instantiable");
        
        // Test that it conforms to ContentElement protocol
        XCTAssertTrue([imageElement conformsToProtocol:@protocol(ContentElement)], 
                     @"ImageElement should conform to ContentElement protocol");
    } else {
        XCTFail(@"ImageElement class should be available");
    }
}

- (void)testImageElementWithCGImage {
    Class imageElementClass = NSClassFromString(@"ImageElement");
    if (imageElementClass) {
        // Create a test CGImage
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        CGContextRef context = CGBitmapContextCreate(NULL, 50, 50, 8, 0, colorSpace, 
                                                    kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
        CGColorSpaceRelease(colorSpace);
        
        if (context) {
            CGContextSetRGBFillColor(context, 1.0, 0.0, 0.0, 1.0);
            CGContextFillRect(context, CGRectMake(0, 0, 50, 50));
            
            CGImageRef testImage = CGBitmapContextCreateImage(context);
            CGContextRelease(context);
            
            if (testImage) {
                id imageElement = [[imageElementClass alloc] init];
                
                // Test image property if available
                if ([imageElement respondsToSelector:@selector(setImage:)]) {
                    // Note: CGImageRef is not an object, so we need to handle it appropriately
                    // This test may need adjustment based on the actual implementation
                    XCTAssertTrue(YES, @"Image element should be able to handle CGImageRef");
                }
                
                CGImageRelease(testImage);
            }
        }
    }
}

#pragma mark - Markdown Generation Tests

- (void)testMarkdownGeneration {
    // Test that elements can generate markdown representation
    Class textElementClass = NSClassFromString(@"TextElement");
    if (textElementClass) {
        id textElement = [[textElementClass alloc] init];
        
        if ([textElement respondsToSelector:@selector(markdownRepresentation)]) {
            NSString *markdown = [textElement performSelector:@selector(markdownRepresentation)];
            XCTAssertTrue([markdown isKindOfClass:[NSString class]], 
                         @"markdownRepresentation should return an NSString");
        } else {
            XCTFail(@"TextElement should implement markdownRepresentation method");
        }
    }
}

#pragma mark - Bounds and Positioning Tests

- (void)testBoundsHandling {
    // Test bounds property across different element types
    NSArray *elementClassNames = @[@"TextElement", @"ImageElement"];
    
    for (NSString *className in elementClassNames) {
        Class elementClass = NSClassFromString(className);
        if (elementClass) {
            id element = [[elementClass alloc] init];
            
            // Test bounds property
            if ([element respondsToSelector:@selector(bounds)]) {
                // Default bounds should be valid
                CGRect bounds = CGRectZero;
                if ([element respondsToSelector:@selector(bounds)]) {
                    NSValue *boundsValue = [element performSelector:@selector(bounds)];
                    if (boundsValue) {
                        bounds = [boundsValue CGRectValue];
                    }
                }
                
                // Bounds should be a valid rectangle (finite values)
                XCTAssertTrue(isfinite(bounds.origin.x) && isfinite(bounds.origin.y) && 
                             isfinite(bounds.size.width) && isfinite(bounds.size.height),
                             @"%@ bounds should have finite values", className);
            }
        }
    }
}

#pragma mark - Page Index Tests

- (void)testPageIndexProperty {
    // Test page index property across element types
    NSArray *elementClassNames = @[@"TextElement", @"ImageElement"];
    
    for (NSString *className in elementClassNames) {
        Class elementClass = NSClassFromString(className);
        if (elementClass) {
            id element = [[elementClass alloc] init];
            
            if ([element respondsToSelector:@selector(pageIndex)]) {
                NSInteger pageIndex = [[element performSelector:@selector(pageIndex)] integerValue];
                XCTAssertTrue(pageIndex >= 0, @"%@ pageIndex should be non-negative", className);
            }
            
            // Test setting page index if setter exists
            if ([element respondsToSelector:@selector(setPageIndex:)]) {
                NSInteger testPageIndex = 5;
                [element performSelector:@selector(setPageIndex:) withObject:@(testPageIndex)];
                
                if ([element respondsToSelector:@selector(pageIndex)]) {
                    NSInteger retrievedIndex = [[element performSelector:@selector(pageIndex)] integerValue];
                    XCTAssertEqual(retrievedIndex, testPageIndex, 
                                  @"%@ should store and retrieve pageIndex correctly", className);
                }
            }
        }
    }
}

#pragma mark - Memory Management Tests

- (void)testElementMemoryManagement {
    // Test that elements can be created and destroyed without memory issues
    for (int i = 0; i < 100; i++) {
        @autoreleasepool {
            Class textElementClass = NSClassFromString(@"TextElement");
            if (textElementClass) {
                id textElement = [[textElementClass alloc] init];
                
                // Set some properties to test memory handling
                if ([textElement respondsToSelector:@selector(setText:)]) {
                    NSString *testText = [NSString stringWithFormat:@"Test text %d", i];
                    [textElement performSelector:@selector(setText:) withObject:testText];
                }
                
                textElement = nil;
            }
            
            Class imageElementClass = NSClassFromString(@"ImageElement");
            if (imageElementClass) {
                id imageElement = [[imageElementClass alloc] init];
                imageElement = nil;
            }
        }
    }
    
    XCTAssertTrue(YES, @"Memory management test completed without crashes");
}

#pragma mark - Performance Tests

- (void)testElementCreationPerformance {
    [self measureBlock:^{
        for (int i = 0; i < 1000; i++) {
            @autoreleasepool {
                Class textElementClass = NSClassFromString(@"TextElement");
                if (textElementClass) {
                    id textElement = [[textElementClass alloc] init];
                    textElement = nil;
                }
            }
        }
    }];
}

- (void)testMarkdownGenerationPerformance {
    Class textElementClass = NSClassFromString(@"TextElement");
    if (textElementClass) {
        id textElement = [[textElementClass alloc] init];
        
        if ([textElement respondsToSelector:@selector(setText:)]) {
            [textElement performSelector:@selector(setText:) withObject:@"Sample text for performance testing"];
        }
        
        [self measureBlock:^{
            for (int i = 0; i < 1000; i++) {
                if ([textElement respondsToSelector:@selector(markdownRepresentation)]) {
                    [textElement performSelector:@selector(markdownRepresentation)];
                }
            }
        }];
    }
}

@end
</file>

<file path="Tests/Unit/PDF22MDAssetManagerTests.m">
//
//  PDF22MDAssetManagerTests.m
//  pdf22md-objc
//
//  Unit tests for PDF22MDAssetManager image extraction and management
//

#import <XCTest/XCTest.h>
#import "PDF22MDAssetManager.h"
#import "PDF22MDImageElement.h"
#import "PDF22MDError.h"

@interface PDF22MDAssetManagerTests : XCTestCase
@property (nonatomic, strong) PDF22MDAssetManager *assetManager;
@property (nonatomic, strong) NSString *tempAssetsPath;
@end

@implementation PDF22MDAssetManagerTests

- (void)setUp {
    [super setUp];
    
    // Create temporary assets directory
    self.tempAssetsPath = [NSTemporaryDirectory() stringByAppendingPathComponent:@"test-assets"];
    [[NSFileManager defaultManager] createDirectoryAtPath:self.tempAssetsPath 
                              withIntermediateDirectories:YES 
                                               attributes:nil 
                                                    error:nil];
    
    self.assetManager = [[PDF22MDAssetManager alloc] initWithAssetsPath:self.tempAssetsPath];
}

- (void)tearDown {
    // Clean up temporary directory
    [[NSFileManager defaultManager] removeItemAtPath:self.tempAssetsPath error:nil];
    self.assetManager = nil;
    [super tearDown];
}

#pragma mark - Initialization Tests

- (void)testAssetManagerInitialization {
    XCTAssertNotNil(self.assetManager, @"Asset manager should initialize successfully");
}

- (void)testInitializationWithNilPath {
    PDF22MDAssetManager *manager = [[PDF22MDAssetManager alloc] initWithAssetsPath:nil];
    XCTAssertNotNil(manager, @"Asset manager should handle nil assets path");
}

- (void)testAssetsDirectoryCreation {
    NSString *newPath = [NSTemporaryDirectory() stringByAppendingPathComponent:@"new-assets"];
    PDF22MDAssetManager *manager = [[PDF22MDAssetManager alloc] initWithAssetsPath:newPath];
    
    NSError *error = nil;
    BOOL success = [manager ensureAssetsDirectoryExists:&error];
    
    XCTAssertTrue(success, @"Should successfully create assets directory");
    XCTAssertNil(error, @"Should not return error when creating valid directory");
    
    BOOL isDirectory;
    BOOL exists = [[NSFileManager defaultManager] fileExistsAtPath:newPath isDirectory:&isDirectory];
    XCTAssertTrue(exists && isDirectory, @"Assets directory should exist and be a directory");
    
    // Clean up
    [[NSFileManager defaultManager] removeItemAtPath:newPath error:nil];
}

#pragma mark - Image Processing Tests

- (void)testImageElementCreation {
    // Create a simple test image (1x1 pixel)
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, 1, 1, 8, 4, colorSpace, kCGImageAlphaZero);
    CGImageRef cgImage = CGBitmapContextCreateImage(context);
    
    PDF22MDImageElement *element = [[PDF22MDImageElement alloc] initWithImage:cgImage 
                                                                        bounds:CGRectMake(0, 0, 100, 100) 
                                                                    pageNumber:1];
    
    XCTAssertNotNil(element, @"Should create image element successfully");
    XCTAssertEqual(element.pageNumber, 1, @"Page number should be set correctly");
    XCTAssertEqualWithAccuracy(element.bounds.size.width, 100.0, 0.1, @"Width should be set correctly");
    
    // Clean up
    CGImageRelease(cgImage);
    CGContextRelease(context);
    CGColorSpaceRelease(colorSpace);
}

- (void)testImageFormatSelection {
    // Test PNG selection for images with transparency
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, 10, 10, 8, 40, colorSpace, kCGImageAlphaFirst);
    CGImageRef transparentImage = CGBitmapContextCreateImage(context);
    
    NSString *format = [self.assetManager preferredFormatForImage:transparentImage];
    XCTAssertEqualObjects(format, @"png", @"Should prefer PNG for images with transparency");
    
    CGImageRelease(transparentImage);
    CGContextRelease(context);
    CGColorSpaceRelease(colorSpace);
}

- (void)testImageFilenameGeneration {
    NSString *filename1 = [self.assetManager generateFilenameForImageAtIndex:0 withFormat:@"png"];
    NSString *filename2 = [self.assetManager generateFilenameForImageAtIndex:1 withFormat:@"jpg"];
    NSString *filename3 = [self.assetManager generateFilenameForImageAtIndex:99 withFormat:@"png"];
    
    XCTAssertEqualObjects(filename1, @"image_001.png", @"Should generate correct filename for index 0");
    XCTAssertEqualObjects(filename2, @"image_002.jpg", @"Should generate correct filename for index 1");
    XCTAssertEqualObjects(filename3, @"image_100.png", @"Should generate correct filename for index 99");
}

#pragma mark - File Path Tests

- (void)testRelativePathGeneration {
    NSString *filename = @"image_001.png";
    NSString *relativePath = [self.assetManager relativePathForFilename:filename];
    
    NSString *expectedPath = [@"test-assets" stringByAppendingPathComponent:filename];
    XCTAssertEqualObjects(relativePath, expectedPath, @"Should generate correct relative path");
}

- (void)testAbsolutePathGeneration {
    NSString *filename = @"image_001.png";
    NSString *absolutePath = [self.assetManager absolutePathForFilename:filename];
    
    NSString *expectedPath = [self.tempAssetsPath stringByAppendingPathComponent:filename];
    XCTAssertEqualObjects(absolutePath, expectedPath, @"Should generate correct absolute path");
}

#pragma mark - Error Handling Tests

- (void)testInvalidAssetsPathHandling {
    // Try to create assets directory in a location that requires root access
    NSString *invalidPath = @"/usr/bin/invalid-assets";
    PDF22MDAssetManager *manager = [[PDF22MDAssetManager alloc] initWithAssetsPath:invalidPath];
    
    NSError *error = nil;
    BOOL success = [manager ensureAssetsDirectoryExists:&error];
    
    XCTAssertFalse(success, @"Should fail to create directory in invalid location");
    XCTAssertNotNil(error, @"Should return error for invalid directory creation");
    XCTAssertEqual(error.code, PDF22MDErrorAssetFolderCreation, @"Should return appropriate error code");
}

- (void)testNilImageHandling {
    NSString *result = [self.assetManager preferredFormatForImage:NULL];
    XCTAssertEqualObjects(result, @"png", @"Should default to PNG for nil image");
}

#pragma mark - Integration Tests

- (void)testCompleteImageSaveWorkflow {
    // Create a test image
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, 50, 50, 8, 200, colorSpace, kCGImageAlphaZero);
    
    // Draw something simple
    CGContextSetRGBFillColor(context, 1.0, 0.0, 0.0, 1.0);
    CGContextFillRect(context, CGRectMake(0, 0, 50, 50));
    
    CGImageRef testImage = CGBitmapContextCreateImage(context);
    
    // Test the save workflow
    NSError *error = nil;
    BOOL directoryCreated = [self.assetManager ensureAssetsDirectoryExists:&error];
    XCTAssertTrue(directoryCreated, @"Should create assets directory");
    
    NSString *filename = [self.assetManager generateFilenameForImageAtIndex:0 withFormat:@"png"];
    NSString *absolutePath = [self.assetManager absolutePathForFilename:filename];
    
    // Save image (this would normally be done by the asset manager)
    NSData *imageData = (__bridge_transfer NSData *)CGImagePNGRepresentation(testImage);
    BOOL saved = [imageData writeToFile:absolutePath atomically:YES];
    XCTAssertTrue(saved, @"Should save image successfully");
    
    // Verify file exists
    BOOL fileExists = [[NSFileManager defaultManager] fileExistsAtPath:absolutePath];
    XCTAssertTrue(fileExists, @"Saved image file should exist");
    
    // Clean up
    CGImageRelease(testImage);
    CGContextRelease(context);
    CGColorSpaceRelease(colorSpace);
}

#pragma mark - Performance Tests

- (void)testMultipleImageHandling {
    NSMutableArray *images = [NSMutableArray array];
    
    // Create multiple test images
    for (int i = 0; i < 10; i++) {
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        CGContextRef context = CGBitmapContextCreate(NULL, 10, 10, 8, 40, colorSpace, kCGImageAlphaZero);
        CGImageRef image = CGBitmapContextCreateImage(context);
        
        [images addObject:(__bridge id)image];
        
        CGContextRelease(context);
        CGColorSpaceRelease(colorSpace);
    }
    
    NSDate *startTime = [NSDate date];
    
    // Test filename generation for all images
    for (int i = 0; i < images.count; i++) {
        NSString *filename = [self.assetManager generateFilenameForImageAtIndex:i withFormat:@"png"];
        XCTAssertNotNil(filename, @"Should generate filename for image %d", i);
    }
    
    NSTimeInterval elapsed = [[NSDate date] timeIntervalSinceDate:startTime];
    XCTAssertLessThan(elapsed, 1.0, @"Should handle multiple images quickly");
    
    // Clean up images
    for (id image in images) {
        CGImageRelease((__bridge CGImageRef)image);
    }
}

// Helper function for PNG representation (normally would be in asset manager)
CFDataRef CGImagePNGRepresentation(CGImageRef image) {
    CFMutableDataRef data = CFDataCreateMutable(NULL, 0);
    CGImageDestinationRef destination = CGImageDestinationCreateWithData(data, kUTTypePNG, 1, NULL);
    
    if (destination) {
        CGImageDestinationAddImage(destination, image, NULL);
        CGImageDestinationFinalize(destination);
        CFRelease(destination);
    }
    
    return data;
}

@end
</file>

<file path="Tests/Unit/PDF22MDConverterTests.m">
//
//  PDF22MDConverterTests.m
//  pdf22md-objc
//
//  Unit tests for PDF22MDConverter core functionality
//

#import <XCTest/XCTest.h>
#import "PDF22MDConverter.h"
#import "PDF22MDConversionOptions.h"
#import "PDF22MDError.h"

@interface PDF22MDConverterTests : XCTestCase
@property (nonatomic, strong) PDF22MDConverter *converter;
@property (nonatomic, strong) PDF22MDConversionOptions *defaultOptions;
@property (nonatomic, strong) NSString *testResourcesPath;
@end

@implementation PDF22MDConverterTests

- (void)setUp {
    [super setUp];
    self.converter = [[PDF22MDConverter alloc] init];
    self.defaultOptions = [[PDF22MDConversionOptions alloc] init];
    
    // Set up test resources path
    NSBundle *bundle = [NSBundle bundleForClass:[self class]];
    self.testResourcesPath = [bundle.resourcePath stringByAppendingPathComponent:@"Tests/Resources"];
}

- (void)tearDown {
    self.converter = nil;
    self.defaultOptions = nil;
    [super tearDown];
}

#pragma mark - Initialization Tests

- (void)testConverterInitialization {
    XCTAssertNotNil(self.converter, @"Converter should initialize successfully");
}

- (void)testDefaultOptionsInitialization {
    XCTAssertNotNil(self.defaultOptions, @"Default options should initialize successfully");
    XCTAssertEqual(self.defaultOptions.dpi, 144, @"Default DPI should be 144");
    XCTAssertNil(self.defaultOptions.assetsPath, @"Default assets path should be nil");
}

#pragma mark - Input Validation Tests

- (void)testNilInputPathHandling {
    NSError *error = nil;
    NSString *result = [self.converter convertPDFAtPath:nil 
                                            withOptions:self.defaultOptions 
                                                  error:&error];
    
    XCTAssertNil(result, @"Should return nil for nil input path");
    XCTAssertNotNil(error, @"Should provide error for nil input path");
    XCTAssertEqual(error.code, PDF22MDErrorInvalidInput, @"Should return invalid input error");
}

- (void)testNonExistentFileHandling {
    NSError *error = nil;
    NSString *nonExistentPath = @"/tmp/nonexistent_file.pdf";
    NSString *result = [self.converter convertPDFAtPath:nonExistentPath 
                                            withOptions:self.defaultOptions 
                                                  error:&error];
    
    XCTAssertNil(result, @"Should return nil for nonexistent file");
    XCTAssertNotNil(error, @"Should provide error for nonexistent file");
    XCTAssertEqual(error.code, PDF22MDErrorFileNotFound, @"Should return file not found error");
}

- (void)testNonPDFFileHandling {
    NSError *error = nil;
    
    // Create a temporary text file
    NSString *tempPath = [NSTemporaryDirectory() stringByAppendingPathComponent:@"test.txt"];
    [@"This is not a PDF" writeToFile:tempPath 
                           atomically:YES 
                             encoding:NSUTF8StringEncoding 
                                error:nil];
    
    NSString *result = [self.converter convertPDFAtPath:tempPath 
                                            withOptions:self.defaultOptions 
                                                  error:&error];
    
    XCTAssertNil(result, @"Should return nil for non-PDF file");
    XCTAssertNotNil(error, @"Should provide error for non-PDF file");
    XCTAssertEqual(error.code, PDF22MDErrorInvalidPDF, @"Should return invalid PDF error");
    
    // Clean up
    [[NSFileManager defaultManager] removeItemAtPath:tempPath error:nil];
}

#pragma mark - Basic Conversion Tests

- (void)testBasicTextConversion {
    // This test would require a simple test PDF file
    // For now, we'll create a placeholder that demonstrates the expected behavior
    
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"simple-text.pdf"];
    
    // Skip test if resource file doesn't exist (expected during initial setup)
    if (![[NSFileManager defaultManager] fileExistsAtPath:testPDFPath]) {
        NSLog(@"Test PDF not found at %@, skipping test", testPDFPath);
        return;
    }
    
    NSError *error = nil;
    NSString *result = [self.converter convertPDFAtPath:testPDFPath 
                                            withOptions:self.defaultOptions 
                                                  error:&error];
    
    XCTAssertNotNil(result, @"Should successfully convert simple text PDF");
    XCTAssertNil(error, @"Should not return error for valid PDF");
    XCTAssertTrue([result containsString:@"#"], @"Should contain markdown headers");
    XCTAssertTrue(result.length > 0, @"Should return non-empty markdown");
}

#pragma mark - Options Validation Tests

- (void)testCustomDPIOption {
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    options.dpi = 300;
    
    XCTAssertEqual(options.dpi, 300, @"Should accept custom DPI value");
}

- (void)testAssetsPathOption {
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    options.assetsPath = @"/tmp/assets";
    
    XCTAssertEqualObjects(options.assetsPath, @"/tmp/assets", @"Should accept custom assets path");
}

#pragma mark - Memory Management Tests

- (void)testMemoryManagement {
    // Test that repeated conversions don't cause memory leaks
    for (int i = 0; i < 10; i++) {
        @autoreleasepool {
            PDF22MDConverter *tempConverter = [[PDF22MDConverter alloc] init];
            PDF22MDConversionOptions *tempOptions = [[PDF22MDConversionOptions alloc] init];
            
            XCTAssertNotNil(tempConverter, @"Converter should initialize in loop iteration %d", i);
            XCTAssertNotNil(tempOptions, @"Options should initialize in loop iteration %d", i);
        }
    }
}

#pragma mark - Error Handling Tests

- (void)testErrorMessageQuality {
    NSError *error = nil;
    NSString *result = [self.converter convertPDFAtPath:@"/nonexistent/path.pdf" 
                                            withOptions:self.defaultOptions 
                                                  error:&error];
    
    XCTAssertNil(result, @"Should return nil for invalid path");
    XCTAssertNotNil(error, @"Should provide error");
    XCTAssertNotNil(error.localizedDescription, @"Error should have localized description");
    XCTAssertTrue(error.localizedDescription.length > 0, @"Error description should not be empty");
    XCTAssertFalse([error.localizedDescription containsString:@"nil"], @"Error description should not contain 'nil'");
}

@end
</file>

<file path="Tests/Unit/PDF22MDFontAnalyzerTests.m">
//
//  PDF22MDFontAnalyzerTests.m
//  pdf22md-objc
//
//  Unit tests for PDF22MDFontAnalyzer heading detection logic
//

#import <XCTest/XCTest.h>
#import "PDF22MDFontAnalyzer.h"

@interface PDF22MDFontAnalyzerTests : XCTestCase
@property (nonatomic, strong) PDF22MDFontAnalyzer *analyzer;
@end

@implementation PDF22MDFontAnalyzerTests

- (void)setUp {
    [super setUp];
    self.analyzer = [[PDF22MDFontAnalyzer alloc] init];
}

- (void)tearDown {
    self.analyzer = nil;
    [super tearDown];
}

#pragma mark - Initialization Tests

- (void)testAnalyzerInitialization {
    XCTAssertNotNil(self.analyzer, @"Font analyzer should initialize successfully");
}

#pragma mark - Font Size Analysis Tests

- (void)testBasicFontSizeAnalysis {
    // Test the core font size analysis functionality
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    
    // Simulate typical document font usage
    fontSizes[@"12.0"] = @100;  // Body text - most frequent
    fontSizes[@"18.0"] = @5;    // Major heading
    fontSizes[@"16.0"] = @8;    // Minor heading
    fontSizes[@"14.0"] = @12;   // Subheading
    
    [self.analyzer analyzeFontSizes:fontSizes];
    
    // Test heading level assignment
    NSInteger h1Level = [self.analyzer headingLevelForFontSize:18.0];
    NSInteger h2Level = [self.analyzer headingLevelForFontSize:16.0];
    NSInteger h3Level = [self.analyzer headingLevelForFontSize:14.0];
    NSInteger bodyLevel = [self.analyzer headingLevelForFontSize:12.0];
    
    XCTAssertEqual(h1Level, 1, @"Largest non-body font should be H1");
    XCTAssertEqual(h2Level, 2, @"Second largest font should be H2");
    XCTAssertEqual(h3Level, 3, @"Third largest font should be H3");
    XCTAssertEqual(bodyLevel, 0, @"Most frequent font should be body text (level 0)");
}

- (void)testSingleFontSizeDocument {
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    fontSizes[@"12.0"] = @100;  // Only one font size
    
    [self.analyzer analyzeFontSizes:fontSizes];
    
    NSInteger level = [self.analyzer headingLevelForFontSize:12.0];
    XCTAssertEqual(level, 0, @"Single font size should be treated as body text");
}

- (void)testEmptyFontAnalysis {
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    
    [self.analyzer analyzeFontSizes:fontSizes];
    
    NSInteger level = [self.analyzer headingLevelForFontSize:12.0];
    XCTAssertEqual(level, 0, @"Unknown font size should default to body text");
}

#pragma mark - Edge Case Tests

- (void)testVerySmallFontSizes {
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    fontSizes[@"8.0"] = @50;    // Small body text
    fontSizes[@"10.0"] = @5;    // Slightly larger
    
    [self.analyzer analyzeFontSizes:fontSizes];
    
    NSInteger smallLevel = [self.analyzer headingLevelForFontSize:8.0];
    NSInteger largerLevel = [self.analyzer headingLevelForFontSize:10.0];
    
    XCTAssertEqual(smallLevel, 0, @"Most frequent small font should be body text");
    XCTAssertEqual(largerLevel, 1, @"Less frequent larger font should be heading");
}

- (void)testVeryLargeFontSizes {
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    fontSizes[@"12.0"] = @100;  // Body text
    fontSizes[@"72.0"] = @1;    // Very large title
    fontSizes[@"48.0"] = @2;    // Large heading
    fontSizes[@"36.0"] = @3;    // Medium heading
    
    [self.analyzer analyzeFontSizes:fontSizes];
    
    NSInteger titleLevel = [self.analyzer headingLevelForFontSize:72.0];
    NSInteger h1Level = [self.analyzer headingLevelForFontSize:48.0];
    NSInteger h2Level = [self.analyzer headingLevelForFontSize:36.0];
    
    XCTAssertEqual(titleLevel, 1, @"Largest font should be H1");
    XCTAssertEqual(h1Level, 2, @"Second largest should be H2");
    XCTAssertEqual(h2Level, 3, @"Third largest should be H3");
}

#pragma mark - Frequency Analysis Tests

- (void)testFrequencyBasedBodyTextDetection {
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    fontSizes[@"12.0"] = @200;  // Very frequent - clearly body text
    fontSizes[@"14.0"] = @150;  // Also frequent - might be body text too
    fontSizes[@"18.0"] = @5;    // Infrequent - heading
    
    [self.analyzer analyzeFontSizes:fontSizes];
    
    NSInteger mostFrequentLevel = [self.analyzer headingLevelForFontSize:12.0];
    NSInteger secondFrequentLevel = [self.analyzer headingLevelForFontSize:14.0];
    NSInteger infrequentLevel = [self.analyzer headingLevelForFontSize:18.0];
    
    XCTAssertEqual(mostFrequentLevel, 0, @"Most frequent font should be body text");
    // The second most frequent could be body or heading depending on algorithm
    XCTAssertTrue(infrequentLevel > 0, @"Infrequent large font should be a heading");
}

#pragma mark - Heading Level Limits Tests

- (void)testMaximumHeadingLevels {
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    fontSizes[@"12.0"] = @100;  // Body
    
    // Add many different heading sizes
    for (int i = 1; i <= 10; i++) {
        fontSizes[[NSString stringWithFormat:@"%.1f", 12.0 + i * 2]] = @(10 - i);
    }
    
    [self.analyzer analyzeFontSizes:fontSizes];
    
    // Check that we don't exceed H6 (level 6)
    NSInteger maxLevel = 0;
    for (NSString *sizeStr in fontSizes.allKeys) {
        CGFloat size = [sizeStr floatValue];
        NSInteger level = [self.analyzer headingLevelForFontSize:size];
        if (level > maxLevel) {
            maxLevel = level;
        }
    }
    
    XCTAssertLessThanOrEqual(maxLevel, 6, @"Should not exceed H6 (level 6)");
}

#pragma mark - Performance Tests

- (void)testLargeFontSetPerformance {
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    
    // Create a large set of font sizes to test performance
    for (int i = 8; i <= 72; i++) {
        fontSizes[[NSString stringWithFormat:@"%.1f", (CGFloat)i]] = @(arc4random() % 100 + 1);
    }
    
    NSDate *startTime = [NSDate date];
    [self.analyzer analyzeFontSizes:fontSizes];
    NSTimeInterval elapsed = [[NSDate date] timeIntervalSinceDate:startTime];
    
    XCTAssertLessThan(elapsed, 1.0, @"Font analysis should complete within 1 second for large font set");
}

#pragma mark - Algorithm Consistency Tests

- (void)testConsistentResults {
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    fontSizes[@"12.0"] = @100;
    fontSizes[@"16.0"] = @10;
    fontSizes[@"20.0"] = @5;
    
    // Run analysis multiple times
    [self.analyzer analyzeFontSizes:fontSizes];
    NSInteger firstRun16 = [self.analyzer headingLevelForFontSize:16.0];
    NSInteger firstRun20 = [self.analyzer headingLevelForFontSize:20.0];
    
    [self.analyzer analyzeFontSizes:fontSizes];
    NSInteger secondRun16 = [self.analyzer headingLevelForFontSize:16.0];
    NSInteger secondRun20 = [self.analyzer headingLevelForFontSize:20.0];
    
    XCTAssertEqual(firstRun16, secondRun16, @"Font analysis should be consistent across runs");
    XCTAssertEqual(firstRun20, secondRun20, @"Font analysis should be consistent across runs");
}

@end
</file>

<file path="Tests/Unit/PDFMarkdownConverterTests.m">
//
//  PDFMarkdownConverterTests.m
//  pdf22md
//
//  Unit tests for core PDF to Markdown conversion functionality
//

#import <XCTest/XCTest.h>
#import "../../src/PDFMarkdownConverter.h"
#import "../../src/AssetExtractor.h"
#import "../../src/ContentElement.h"

@interface PDFMarkdownConverterTests : XCTestCase
@property (nonatomic, strong) PDFMarkdownConverter *converter;
@property (nonatomic, strong) NSString *testResourcesPath;
@end

@implementation PDFMarkdownConverterTests

- (void)setUp {
    [super setUp];
    self.converter = [[PDFMarkdownConverter alloc] init];
    
    // Set up test resources path
    NSBundle *testBundle = [NSBundle bundleForClass:[self class]];
    self.testResourcesPath = [testBundle.bundlePath stringByAppendingPathComponent:@"Resources"];
    
    // Ensure test resources directory exists
    NSFileManager *fileManager = [NSFileManager defaultManager];
    if (![fileManager fileExistsAtPath:self.testResourcesPath]) {
        [fileManager createDirectoryAtPath:self.testResourcesPath 
               withIntermediateDirectories:YES 
                                attributes:nil 
                                     error:nil];
    }
}

- (void)tearDown {
    self.converter = nil;
    self.testResourcesPath = nil;
    [super tearDown];
}

#pragma mark - Basic Functionality Tests

- (void)testConverterInitialization {
    XCTAssertNotNil(self.converter, @"PDFMarkdownConverter should initialize successfully");
}

- (void)testInvalidPDFHandling {
    // Test with nil input
    NSString *result = [self.converter convertPDFAtPath:nil 
                                          assetsFolderPath:nil 
                                                       dpi:144];
    XCTAssertNil(result, @"Converter should return nil for nil input path");
    
    // Test with non-existent file
    NSString *nonExistentPath = @"/path/that/does/not/exist.pdf";
    result = [self.converter convertPDFAtPath:nonExistentPath 
                               assetsFolderPath:nil 
                                            dpi:144];
    XCTAssertNil(result, @"Converter should return nil for non-existent file");
}

- (void)testEmptyStringHandling {
    // Test with empty string
    NSString *result = [self.converter convertPDFAtPath:@"" 
                                          assetsFolderPath:nil 
                                                       dpi:144];
    XCTAssertNil(result, @"Converter should return nil for empty string path");
}

- (void)testDPIParameterValidation {
    // Create a minimal test PDF path (we'll use an existing test file)
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"simple-test.pdf"];
    
    // Test with invalid DPI values
    NSString *result = [self.converter convertPDFAtPath:testPDFPath 
                                          assetsFolderPath:nil 
                                                       dpi:0];
    // Should still work with fallback DPI or return error gracefully
    // The exact behavior depends on implementation, but should not crash
    
    result = [self.converter convertPDFAtPath:testPDFPath 
                               assetsFolderPath:nil 
                                            dpi:-144];
    // Should handle negative DPI gracefully
}

#pragma mark - Asset Folder Tests

- (void)testAssetFolderCreation {
    NSString *tempDir = NSTemporaryDirectory();
    NSString *testAssetsFolder = [tempDir stringByAppendingPathComponent:@"test-assets"];
    
    // Clean up any existing test folder
    NSFileManager *fileManager = [NSFileManager defaultManager];
    [fileManager removeItemAtPath:testAssetsFolder error:nil];
    
    // Verify folder doesn't exist initially
    XCTAssertFalse([fileManager fileExistsAtPath:testAssetsFolder], 
                   @"Test assets folder should not exist initially");
    
    // Test folder creation during conversion (with a valid PDF)
    // For now, just test that the method accepts the parameter
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"simple-test.pdf"];
    [self.converter convertPDFAtPath:testPDFPath 
                      assetsFolderPath:testAssetsFolder 
                                   dpi:144];
    
    // Clean up
    [fileManager removeItemAtPath:testAssetsFolder error:nil];
}

#pragma mark - Memory Management Tests

- (void)testMemoryManagement {
    // Test that converter handles multiple conversions without memory issues
    for (int i = 0; i < 10; i++) {
        @autoreleasepool {
            PDFMarkdownConverter *tempConverter = [[PDFMarkdownConverter alloc] init];
            
            // Test with nil path to avoid actual file I/O
            NSString *result = [tempConverter convertPDFAtPath:nil 
                                               assetsFolderPath:nil 
                                                            dpi:144];
            XCTAssertNil(result, @"Should handle nil input gracefully");
            
            tempConverter = nil;
        }
    }
}

#pragma mark - Performance Tests

- (void)testPerformanceBaseline {
    // Simple performance test to establish baseline
    [self measureBlock:^{
        // Test basic object creation and method call
        PDFMarkdownConverter *converter = [[PDFMarkdownConverter alloc] init];
        [converter convertPDFAtPath:nil assetsFolderPath:nil dpi:144];
    }];
}

#pragma mark - Error Handling Tests

- (void)testErrorConditions {
    // Test various error conditions that should be handled gracefully
    NSArray *invalidPaths = @[
        @"",
        @"not-a-pdf.txt",
        @"/dev/null",
        @"~/nonexistent/path/file.pdf"
    ];
    
    for (NSString *invalidPath in invalidPaths) {
        NSString *result = [self.converter convertPDFAtPath:invalidPath 
                                            assetsFolderPath:nil 
                                                         dpi:144];
        XCTAssertNil(result, @"Should handle invalid path gracefully: %@", invalidPath);
    }
}

#pragma mark - Integration Points Tests

- (void)testAssetExtractorIntegration {
    // Test that converter properly integrates with AssetExtractor
    // This is a basic smoke test for the integration
    AssetExtractor *extractor = [[AssetExtractor alloc] init];
    XCTAssertNotNil(extractor, @"AssetExtractor should initialize for integration testing");
}

- (void)testContentElementIntegration {
    // Test that converter properly works with ContentElement classes
    // This verifies the model layer integration
    XCTAssertTrue([NSClassFromString(@"ContentElement") conformsToProtocol:@protocol(NSObject)], 
                  @"ContentElement should be available for integration");
}

@end
</file>

<file path="Tests/Unit/SimpleConverterTest.m">
//
//  SimpleConverterTest.m
//  pdf22md-objc
//
//  Simple test without XCTest framework dependency
//

#import <Foundation/Foundation.h>
#import "Core/PDF22MDConverter.h"
#import "Core/PDF22MDConversionOptions.h"
#import "Core/PDF22MDError.h"

// Simple assertion macro for non-XCTest testing
#define ASSERT(condition, message) \
    if (!(condition)) { \
        printf("❌ ASSERT FAILED: %s - %s\n", #condition, message); \
        return 1; \
    } else { \
        printf("✅ ASSERT PASSED: %s\n", #condition); \
    }

int main(int argc, char *argv[]) {
    @autoreleasepool {
        printf("🧪 Running Simple Converter Tests\n");
        printf("==================================\n");
        
        // Test 1: Options initialization
        PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
        ASSERT(options != nil, "Options should initialize successfully");
        ASSERT(options.rasterizationDPI == 144.0, "Default DPI should be 144");
        
        // Test 2: Default options creation
        PDF22MDConversionOptions *defaultOptions = [PDF22MDConversionOptions defaultOptions];
        ASSERT(defaultOptions != nil, "Default options should initialize successfully");
        
        // Test 3: Error handling for nil URL
        PDF22MDConverter *converter = [[PDF22MDConverter alloc] initWithPDFURL:nil];
        ASSERT(converter == nil, "Should return nil for nil URL");
        
        // Test 4: Error handling for non-existent file  
        NSURL *nonExistentURL = [NSURL fileURLWithPath:@"/nonexistent/file.pdf"];
        converter = [[PDF22MDConverter alloc] initWithPDFURL:nonExistentURL];
        ASSERT(converter == nil, "Should return nil for non-existent file");
        
        // Test 5: Error helper methods
        NSError *testError = [PDF22MDErrorHelper invalidPDFError];
        ASSERT(testError != nil, "Error helper should create error");
        ASSERT(testError.localizedDescription != nil, "Error should have localized description");
        ASSERT(testError.localizedDescription.length > 0, "Error description should not be empty");
        
        // Test 6: File not found error
        NSError *fileError = [PDF22MDErrorHelper fileNotFoundErrorWithPath:@"/test/path"];
        ASSERT(fileError != nil, "Should create file not found error");
        ASSERT(fileError.code == PDF22MDErrorFileNotFound, "Should have correct error code");
        
        printf("\n🎉 All simple tests passed!\n");
        return 0;
    }
}
</file>

<file path="build.sh">
#!/bin/bash

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Print functions
print_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
print_warning() { echo -e "${YELLOW}[WARN]${NC} $1"; }
print_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Check for required tools
check_requirements() {
    local missing_tools=()

    if ! command -v clang &>/dev/null; then
        missing_tools+=("clang")
    fi

    if ! command -v make &>/dev/null; then
        missing_tools+=("make")
    fi

    if [ ${#missing_tools[@]} -ne 0 ]; then
        print_error "Missing required tools: ${missing_tools[*]}"
        print_info "Please install Xcode Command Line Tools:"
        print_info "xcode-select --install"
        exit 1
    fi
}

# Build pdf22md-objc
build_objc() {
    print_info "Building pdf22md (Objective-C implementation)..."
    make clean
    if make; then
        print_info "✓ pdf22md-objc built successfully"
        return 0
    else
        print_error "Failed to build pdf22md-objc"
        return 1
    fi
}

# Install binary
install_binary() {
    local install_dir="/usr/local/bin"
    print_info "Installing binary to $install_dir..."

    # Create install directory if it doesn't exist
    sudo mkdir -p "$install_dir"

    # Install pdf22md
    if [ -f "pdf22md" ]; then
        sudo install -m 755 pdf22md "$install_dir/pdf22md"
        print_info "✓ Installed pdf22md"
    fi

    # Install man pages
    if [ -f "docs/pdf22md.1" ]; then
        sudo mkdir -p /usr/local/share/man/man1
        sudo install -m 644 docs/pdf22md.1 /usr/local/share/man/man1/
        print_info "✓ Installed man pages"
    fi
}

# Run tests
run_tests() {
    print_info "Running tests..."
    if [ -f "run-tests.sh" ]; then
        ./run-tests.sh
    else
        print_warning "No test script found"
    fi
}

# Main execution
main() {
    print_info "Starting pdf22md-objc build process..."

    # Check requirements
    check_requirements

    # Build component
    build_objc

    # Run tests if requested
    if [ "$1" = "--test" ]; then
        run_tests
    fi

    # Install if requested
    if [ "$1" = "--install" ] || [ "$2" = "--install" ]; then
        install_binary
    fi

    print_info "Build complete!"
    print_info "Run './pdf22md --help' for usage information"
}

main "$@"
</file>

<file path="Makefile">
CC = clang
CFLAGS = -Wall -Wextra -O2 -fobjc-arc
FRAMEWORKS = -framework Foundation -framework PDFKit -framework CoreGraphics -framework ImageIO -framework CoreServices
TARGET = pdf22md

# Version from git tag or fallback
VERSION ?= $(shell git describe --tags --always --dirty 2>/dev/null || echo "dev")

# Define directories
SRC_DIR = src
BUILD_DIR = build

# Source and object files - look in all subdirectories
SOURCES = $(wildcard $(SRC_DIR)/*/*.m $(SRC_DIR)/*/*/*.m)
OBJECTS = $(patsubst $(SRC_DIR)/%.m,$(BUILD_DIR)/%.o,$(SOURCES))

# Default prefix for installation
PREFIX ?= /usr/local

all: $(BUILD_DIR) $(TARGET)

$(BUILD_DIR):
	mkdir -p $(BUILD_DIR)

$(TARGET): $(OBJECTS)
	$(CC) $(CFLAGS) $(FRAMEWORKS) -o $(TARGET) $(OBJECTS)

$(BUILD_DIR)/%.o: $(SRC_DIR)/%.m | $(BUILD_DIR)
	@mkdir -p $(dir $@)
	$(CC) $(CFLAGS) -DVERSION=\"$(VERSION)\" -Isrc -c $< -o $@

clean:
	rm -rf $(BUILD_DIR) $(TARGET)

install: $(TARGET)
	install -d $(DESTDIR)$(PREFIX)/bin
	install -m 755 $(TARGET) $(DESTDIR)$(PREFIX)/bin/
	install -d $(DESTDIR)$(PREFIX)/share/man/man1
	install -m 644 docs/pdf22md.1 $(DESTDIR)$(PREFIX)/share/man/man1/

uninstall:
	rm -f $(DESTDIR)$(PREFIX)/bin/$(TARGET)
	rm -f $(DESTDIR)$(PREFIX)/share/man/man1/pdf22md.1

# Testing
test: $(BUILD_DIR)
	@echo "🧪 Running pdf22md test suite..."
	@./run-tests.sh

test-unit: $(BUILD_DIR)
	@echo "🔬 Running unit tests..."
	@mkdir -p build/tests
	@for test in Tests/Unit/*.m; do \
		if [ -f "$$test" ]; then \
			echo "  Building $$test..."; \
			test_name=$$(basename "$$test" .m); \
			$(CC) $(CFLAGS) $(FRAMEWORKS) -Isrc \
				"$$test" src/Core/*.m src/Models/*.m src/Services/*.m \
				-o "build/tests/$$test_name" && \
			echo "  ✓ Compiled $$test_name" || echo "  ✗ Failed to compile $$test_name"; \
		fi; \
	done

test-integration: $(BUILD_DIR)
	@echo "🔬 Running integration tests..."
	@mkdir -p build/tests
	@for test in Tests/Integration/*.m; do \
		if [ -f "$$test" ]; then \
			echo "  Building $$test..."; \
			test_name=$$(basename "$$test" .m); \
			$(CC) $(CFLAGS) $(FRAMEWORKS) -Isrc \
				"$$test" src/Core/*.m src/Models/*.m src/Services/*.m \
				-o "build/tests/$$test_name" && \
			echo "  ✓ Compiled $$test_name" || echo "  ✗ Failed to compile $$test_name"; \
		fi; \
	done

test-clean:
	@echo "🧹 Cleaning test artifacts..."
	@rm -rf build/tests Tests/Resources/*.pdf

# Benchmark and profiling
benchmark: $(TARGET)
	@echo "📊 Running performance benchmarks..."
	@echo "Creating benchmark test PDF..."
	@mkdir -p test/benchmark
	@echo "Benchmarking conversion speed..."
	@time ./$(TARGET) -i test/README.pdf -o test/benchmark/output.md -a test/benchmark/assets
	@echo "Benchmark complete. Check test/benchmark/ for results."

memory-check: $(TARGET)
	@echo "🔍 Running memory leak detection..."
	@echo "Note: Install Xcode and run 'leaks' command manually for detailed analysis"
	@echo "Basic memory test with multiple conversions..."
	@for i in 1 2 3 4 5; do \
		echo "  Conversion $$i..."; \
		./$(TARGET) -i test/README.pdf -o /tmp/test_$$i.md; \
	done
	@echo "Memory test complete. Monitor Activity Monitor for memory usage."

.PHONY: all clean install uninstall test test-unit test-integration test-clean benchmark memory-check
</file>

<file path="README.md">
# pdf22md - Modern Objective-C Implementation

A high-performance PDF to Markdown converter built with modern Objective-C patterns and best practices.

## Features

- **Modern Objective-C**: Uses nullability annotations, lightweight generics, and designated initializers
- **Thread-Safe**: Concurrent page processing with GCD and proper synchronization
- **Memory Efficient**: Automatic reference counting with strategic use of autorelease pools
- **Error Handling**: Comprehensive error reporting with custom error domain
- **Progress Tracking**: NSProgress integration for monitoring conversion status
- **Modular Architecture**: Clean separation of concerns with protocols and services

## Architecture

```
pdf22md-objc/
├── src/
│   ├── Core/                    # Core conversion logic
│   │   ├── PDF22MDConverter     # Main coordinator
│   │   ├── PDF22MDPageProcessor # Page content extraction
│   │   ├── PDF22MDFontAnalyzer  # Heading detection
│   │   └── PDF22MDError         # Error handling
│   ├── Models/                  # Data models
│   │   ├── PDF22MDContentElement # Protocol definition
│   │   ├── PDF22MDTextElement   # Text content
│   │   └── PDF22MDImageElement  # Image content
│   ├── Services/                # Business logic services
│   │   ├── PDF22MDAssetManager  # Image extraction/saving
│   │   └── PDF22MDMarkdownGenerator # Markdown generation
│   └── CLI/                     # Command-line interface
│       └── main.m
```

## Building

### Using the Build Script (Recommended)
```bash
# Build the project
./build.sh

# Build and run tests
./build.sh --test

# Build and install to /usr/local/bin
./build.sh --install

# Build, test, and install
./build.sh --test --install
```

### Using Make Directly
```bash
# Build with make
make

# Build with custom version
make VERSION=1.2.3

# Clean build artifacts
make clean

# Install to /usr/local/bin
sudo make install
```

## Usage

```bash
# Convert a PDF file
./pdf22md -i document.pdf -o document.md

# Extract images to assets folder
./pdf22md -i report.pdf -o report.md -a ./assets

# Customize DPI for vector graphics
./pdf22md -i presentation.pdf -o presentation.md -a ./images -d 300

# Use with pipes
cat document.pdf | ./pdf22md > document.md
```

## Key Implementation Details

### Thread Safety
- Uses dispatch queues for concurrent page processing
- Thread-safe collections with `@synchronized` blocks
- Atomic property access for shared state

### Memory Management
- ARC-enabled with proper ownership semantics
- Strategic `@autoreleasepool` blocks in loops
- Manual Core Graphics memory management where needed

### Error Handling
```objc
typedef NS_ERROR_ENUM(PDF22MDErrorDomain, PDF22MDError) {
    PDF22MDErrorInvalidPDF = 1000,
    PDF22MDErrorAssetCreationFailed,
    PDF22MDErrorProcessingFailed,
    // ...
};
```

### Progress Reporting
```objc
builder.progressHandler = ^(NSInteger currentPage, NSInteger totalPages) {
    NSLog(@"Processing page %ld of %ld", currentPage, totalPages);
};
```

## Modern Objective-C Features Used

1. **Nullability Annotations**
   - `NS_ASSUME_NONNULL_BEGIN/END`
   - `nullable` and `nonnull` qualifiers

2. **Lightweight Generics**
   - `NSArray<id<PDF22MDContentElement>> *`
   - `NSDictionary<NSString *, NSNumber *> *`

3. **Designated Initializers**
   - `NS_DESIGNATED_INITIALIZER`
   - `NS_UNAVAILABLE` for unsupported initializers

4. **Property Attributes**
   - Proper use of `copy`, `strong`, `weak`, `readonly`

5. **Modern Enumerations**
   - `NS_ENUM` and `NS_ERROR_ENUM` macros

## Testing

```bash
# Run basic tests
make test

# Test with sample PDFs
./pdf22md -i ../test/sample.pdf -o output.md -a ./test-assets
```

## Performance

- Utilizes all available CPU cores via GCD
- Concurrent image extraction and saving
- Memory-efficient streaming for large PDFs
- Optimized font analysis with caching

## Requirements

- macOS 10.15 or later
- Xcode Command Line Tools
- ARC enabled

## License

MIT License - see LICENSE file in the root directory
</file>

<file path="release.sh">
#!/bin/bash

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to print colored output
print_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

# Function to get the latest semver tag
get_latest_tag() {
    git tag -l 'v*' | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -n1
}

# Function to increment version
increment_version() {
    local version=$1
    local major=$(echo $version | cut -d. -f1)
    local minor=$(echo $version | cut -d. -f2)
    local patch=$(echo $version | cut -d. -f3)
    
    # Increment minor version
    minor=$((minor + 1))
    patch=0
    
    echo "${major}.${minor}.${patch}"
}

# Parse command line arguments
VERSION=""
while [[ $# -gt 0 ]]; do
    case $1 in
        --v)
            VERSION="$2"
            shift 2
            ;;
        -h|--help)
            echo "Usage: $0 [--v VERSION]"
            echo "  --v VERSION   Specify version (e.g., 1.2.3)"
            echo "  -h, --help    Show this help message"
            echo ""
            echo "If no version is specified, the script will increment the minor version"
            echo "of the latest git tag, or use 1.0.0 if no tags exist."
            exit 0
            ;;
        *)
            print_error "Unknown option: $1"
            exit 1
            ;;
    esac
done

# Determine version
if [ -z "$VERSION" ]; then
    LATEST_TAG=$(get_latest_tag)
    if [ -z "$LATEST_TAG" ]; then
        VERSION="1.0.0"
        print_info "No previous tags found. Using version $VERSION"
    else
        # Remove 'v' prefix
        CURRENT_VERSION=${LATEST_TAG#v}
        VERSION=$(increment_version $CURRENT_VERSION)
        print_info "Latest tag: $LATEST_TAG"
        print_info "New version: $VERSION"
    fi
else
    # Validate version format
    if ! echo "$VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
        print_error "Invalid version format. Please use semantic versioning (e.g., 1.2.3)"
        exit 1
    fi
fi

TAG="v$VERSION"

# Check if we're on macOS
if [[ "$OSTYPE" != "darwin"* ]]; then
    print_error "This script must be run on macOS"
    exit 1
fi

# Check if git is clean
if ! git diff-index --quiet HEAD --; then
    print_warning "You have uncommitted changes. Committing them now..."
    git add -A
    git commit -m "Release version $VERSION"
fi

# Check if tag already exists
if git rev-parse "$TAG" >/dev/null 2>&1; then
    print_error "Tag $TAG already exists"
    exit 1
fi

print_info "Building pdf22md version $VERSION..."

# Clean and build with version
make clean
make VERSION="$VERSION"

# Test the binary
if ! ./pdf22md -v | grep -q "$VERSION"; then
    print_error "Version check failed"
    exit 1
fi

print_info "Build successful!"

# Create git tag
print_info "Creating git tag $TAG..."
git tag -a "$TAG" -m "Release version $VERSION"

# Push commits and tags
print_info "Pushing to remote..."
git push origin main
git push origin "$TAG"

print_info "✅ Release $VERSION completed successfully!"
print_info ""
print_info "The GitHub Actions workflow will now:"
print_info "  1. Build the universal binary for Intel and Apple Silicon"
print_info "  2. Create a .pkg installer"
print_info "  3. Create a GitHub release with the artifacts"
print_info ""
print_info "Check the Actions tab on GitHub to monitor the release process."
</file>

<file path="run-tests.sh">
#!/bin/bash

# pdf22md Test Runner
# Compiles and runs unit tests for the pdf22md project

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo -e "${YELLOW}🧪 pdf22md Test Suite${NC}"
echo "=================================="

# Create build directory for tests
TEST_BUILD_DIR="build/tests"
mkdir -p "$TEST_BUILD_DIR"

# Compile flags
CFLAGS="-Wall -Wextra -O2 -fobjc-arc"
FRAMEWORKS="-framework Foundation -framework PDFKit -framework CoreGraphics -framework ImageIO -framework XCTest"
INCLUDES="-I./src"

echo -e "${YELLOW}📦 Compiling test framework...${NC}"

# Function to compile and run a test
run_test() {
    local test_file="$1"
    local test_name=$(basename "$test_file" .m)
    local executable="$TEST_BUILD_DIR/$test_name"
    
    echo -e "  ${YELLOW}Building${NC} $test_name..."
    
    # Compile the test
    if clang $CFLAGS $FRAMEWORKS $INCLUDES \
        "$test_file" \
        src/Core/*.m \
        src/Models/*.m \
        src/Services/*.m \
        -o "$executable" 2>/dev/null; then
        
        echo -e "  ${GREEN}✓${NC} Compiled $test_name"
        
        # Run the test
        echo -e "  ${YELLOW}Running${NC} $test_name..."
        if "$executable" 2>/dev/null; then
            echo -e "  ${GREEN}✓ PASSED${NC} $test_name"
            return 0
        else
            echo -e "  ${RED}✗ FAILED${NC} $test_name"
            return 1
        fi
    else
        echo -e "  ${RED}✗ COMPILE FAILED${NC} $test_name"
        return 1
    fi
}

# Track test results
TOTAL_TESTS=0
PASSED_TESTS=0
FAILED_TESTS=0

echo -e "\n${YELLOW}🔬 Running Unit Tests...${NC}"

# Run unit tests
for test_file in Tests/Unit/*.m; do
    if [ -f "$test_file" ]; then
        TOTAL_TESTS=$((TOTAL_TESTS + 1))
        if run_test "$test_file"; then
            PASSED_TESTS=$((PASSED_TESTS + 1))
        else
            FAILED_TESTS=$((FAILED_TESTS + 1))
        fi
        echo
    fi
done

echo -e "${YELLOW}🔬 Running Integration Tests...${NC}"

# Run integration tests
for test_file in Tests/Integration/*.m; do
    if [ -f "$test_file" ]; then
        TOTAL_TESTS=$((TOTAL_TESTS + 1))
        if run_test "$test_file"; then
            PASSED_TESTS=$((PASSED_TESTS + 1))
        else
            FAILED_TESTS=$((FAILED_TESTS + 1))
        fi
        echo
    fi
done

# Summary
echo "=================================="
echo -e "${YELLOW}📊 Test Summary${NC}"
echo "Total Tests:  $TOTAL_TESTS"
echo -e "Passed:       ${GREEN}$PASSED_TESTS${NC}"

if [ $FAILED_TESTS -gt 0 ]; then
    echo -e "Failed:       ${RED}$FAILED_TESTS${NC}"
    echo -e "\n${RED}❌ Some tests failed${NC}"
    exit 1
else
    echo -e "Failed:       ${GREEN}0${NC}"
    echo -e "\n${GREEN}✅ All tests passed!${NC}"
    exit 0
fi
</file>

</files>
</file>

<file path="pdf22md-objc/release.sh">
#!/bin/bash

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to print colored output
print_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

# Function to get the latest semver tag
get_latest_tag() {
    git tag -l 'v*' | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -n1
}

# Function to increment version
increment_version() {
    local version=$1
    local major=$(echo $version | cut -d. -f1)
    local minor=$(echo $version | cut -d. -f2)
    local patch=$(echo $version | cut -d. -f3)
    
    # Increment minor version
    minor=$((minor + 1))
    patch=0
    
    echo "${major}.${minor}.${patch}"
}

# Parse command line arguments
VERSION=""
while [[ $# -gt 0 ]]; do
    case $1 in
        --v)
            VERSION="$2"
            shift 2
            ;;
        -h|--help)
            echo "Usage: $0 [--v VERSION]"
            echo "  --v VERSION   Specify version (e.g., 1.2.3)"
            echo "  -h, --help    Show this help message"
            echo ""
            echo "If no version is specified, the script will increment the minor version"
            echo "of the latest git tag, or use 1.0.0 if no tags exist."
            exit 0
            ;;
        *)
            print_error "Unknown option: $1"
            exit 1
            ;;
    esac
done

# Determine version
if [ -z "$VERSION" ]; then
    LATEST_TAG=$(get_latest_tag)
    if [ -z "$LATEST_TAG" ]; then
        VERSION="1.0.0"
        print_info "No previous tags found. Using version $VERSION"
    else
        # Remove 'v' prefix
        CURRENT_VERSION=${LATEST_TAG#v}
        VERSION=$(increment_version $CURRENT_VERSION)
        print_info "Latest tag: $LATEST_TAG"
        print_info "New version: $VERSION"
    fi
else
    # Validate version format
    if ! echo "$VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
        print_error "Invalid version format. Please use semantic versioning (e.g., 1.2.3)"
        exit 1
    fi
fi

TAG="v$VERSION"

# Check if we're on macOS
if [[ "$OSTYPE" != "darwin"* ]]; then
    print_error "This script must be run on macOS"
    exit 1
fi

# Check if git is clean
if ! git diff-index --quiet HEAD --; then
    print_warning "You have uncommitted changes. Committing them now..."
    git add -A
    git commit -m "Release version $VERSION"
fi

# Check if tag already exists
if git rev-parse "$TAG" >/dev/null 2>&1; then
    print_error "Tag $TAG already exists"
    exit 1
fi

print_info "Building pdf22md version $VERSION..."

# Clean and build with version
make clean
make VERSION="$VERSION"

# Test the binary
if ! ./pdf22md -v | grep -q "$VERSION"; then
    print_error "Version check failed"
    exit 1
fi

print_info "Build successful!"

# Create git tag
print_info "Creating git tag $TAG..."
git tag -a "$TAG" -m "Release version $VERSION"

# Push commits and tags
print_info "Pushing to remote..."
git push origin main
git push origin "$TAG"

print_info "✅ Release $VERSION completed successfully!"
print_info ""
print_info "The GitHub Actions workflow will now:"
print_info "  1. Build the universal binary for Intel and Apple Silicon"
print_info "  2. Create a .pkg installer"
print_info "  3. Create a GitHub release with the artifacts"
print_info ""
print_info "Check the Actions tab on GitHub to monitor the release process."
</file>

<file path="pdf22md-objc/run-tests.sh">
#!/bin/bash

# pdf22md Test Runner
# Compiles and runs unit tests for the pdf22md project

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo -e "${YELLOW}🧪 pdf22md Test Suite${NC}"
echo "=================================="

# Create build directory for tests
TEST_BUILD_DIR="build/tests"
mkdir -p "$TEST_BUILD_DIR"

# Compile flags
CFLAGS="-Wall -Wextra -O2 -fobjc-arc"
FRAMEWORKS="-framework Foundation -framework PDFKit -framework CoreGraphics -framework ImageIO -framework XCTest"
INCLUDES="-I./src"

echo -e "${YELLOW}📦 Compiling test framework...${NC}"

# Function to compile and run a test
run_test() {
    local test_file="$1"
    local test_name=$(basename "$test_file" .m)
    local executable="$TEST_BUILD_DIR/$test_name"
    
    echo -e "  ${YELLOW}Building${NC} $test_name..."
    
    # Compile the test
    if clang $CFLAGS $FRAMEWORKS $INCLUDES \
        "$test_file" \
        src/Core/*.m \
        src/Models/*.m \
        src/Services/*.m \
        -o "$executable" 2>/dev/null; then
        
        echo -e "  ${GREEN}✓${NC} Compiled $test_name"
        
        # Run the test
        echo -e "  ${YELLOW}Running${NC} $test_name..."
        if "$executable" 2>/dev/null; then
            echo -e "  ${GREEN}✓ PASSED${NC} $test_name"
            return 0
        else
            echo -e "  ${RED}✗ FAILED${NC} $test_name"
            return 1
        fi
    else
        echo -e "  ${RED}✗ COMPILE FAILED${NC} $test_name"
        return 1
    fi
}

# Track test results
TOTAL_TESTS=0
PASSED_TESTS=0
FAILED_TESTS=0

echo -e "\n${YELLOW}🔬 Running Unit Tests...${NC}"

# Run unit tests
for test_file in Tests/Unit/*.m; do
    if [ -f "$test_file" ]; then
        TOTAL_TESTS=$((TOTAL_TESTS + 1))
        if run_test "$test_file"; then
            PASSED_TESTS=$((PASSED_TESTS + 1))
        else
            FAILED_TESTS=$((FAILED_TESTS + 1))
        fi
        echo
    fi
done

echo -e "${YELLOW}🔬 Running Integration Tests...${NC}"

# Run integration tests
for test_file in Tests/Integration/*.m; do
    if [ -f "$test_file" ]; then
        TOTAL_TESTS=$((TOTAL_TESTS + 1))
        if run_test "$test_file"; then
            PASSED_TESTS=$((PASSED_TESTS + 1))
        else
            FAILED_TESTS=$((FAILED_TESTS + 1))
        fi
        echo
    fi
done

# Summary
echo "=================================="
echo -e "${YELLOW}📊 Test Summary${NC}"
echo "Total Tests:  $TOTAL_TESTS"
echo -e "Passed:       ${GREEN}$PASSED_TESTS${NC}"

if [ $FAILED_TESTS -gt 0 ]; then
    echo -e "Failed:       ${RED}$FAILED_TESTS${NC}"
    echo -e "\n${RED}❌ Some tests failed${NC}"
    exit 1
else
    echo -e "Failed:       ${GREEN}0${NC}"
    echo -e "\n${GREEN}✅ All tests passed!${NC}"
    exit 0
fi
</file>

<file path="pdf22md-swift/docs/pdf22md.1">
.TH PDF22MD 1 "June 2025" "pdf22md v1.0" "User Commands"
.SH NAME
pdf22md \- high-performance PDF to Markdown converter
.SH SYNOPSIS
.B pdf22md
[\fB\-i\fR \fIinput.pdf\fR]
[\fB\-o\fR \fIoutput.md\fR]
[\fB\-a\fR \fIassets_folder\fR]
[\fB\-d\fR \fIdpi\fR]
[\fB\-v\fR]
[\fB\-h\fR]
.SH DESCRIPTION
.B pdf22md
is a blazingly fast PDF to Markdown converter that extracts text and images from PDF documents and converts them into clean, structured Markdown format. It uses parallel processing to achieve high performance on multi-page documents.

The tool automatically detects heading hierarchy based on font size analysis, extracts images with intelligent format optimization (PNG/JPEG), and generates YAML frontmatter with document metadata.

.SH OPTIONS
.TP
\fB\-i\fR \fIinput.pdf\fR
Specify the input PDF file to convert. If not provided, pdf22md reads from standard input (stdin).
.TP
\fB\-o\fR \fIoutput.md\fR
Specify the output Markdown file. If not provided, pdf22md writes to standard output (stdout).
.TP
\fB\-a\fR \fIassets_folder\fR
Specify the folder where extracted images will be saved. The folder will be created if it doesn't exist. Images are automatically referenced in the generated Markdown with relative paths.
.TP
\fB\-d\fR \fIdpi\fR
Set the DPI (dots per inch) for rasterizing vector graphics. Default is 144. Higher values produce better quality but larger file sizes. Common values: 72 (screen), 144 (default), 300 (print quality).
.TP
\fB\-v\fR, \fB\-\-version\fR
Display version information and exit.
.TP
\fB\-h\fR, \fB\-\-help\fR
Display usage information and exit.

.SH EXAMPLES
.TP
Convert a PDF file to Markdown:
.B pdf22md \-i document.pdf \-o document.md

.TP
Extract images to an assets folder:
.B pdf22md \-i document.pdf \-o document.md \-a ./assets

.TP
Use higher DPI for better image quality:
.B pdf22md \-i document.pdf \-o document.md \-a ./assets \-d 300

.TP
Convert using pipes (stdin/stdout):
.B cat document.pdf | pdf22md > document.md

.TP
Process a document with custom settings:
.B pdf22md \-i report.pdf \-o report.md \-a ./images \-d 200

.SH INPUT/OUTPUT
.SS Input Sources
.B pdf22md
accepts PDF input from:
.IP • 2
File path specified with \fB\-i\fR flag
.IP • 2
Standard input (stdin) when no \fB\-i\fR flag is provided

.SS Output Destinations
Markdown output is written to:
.IP • 2
File path specified with \fB\-o\fR flag
.IP • 2
Standard output (stdout) when no \fB\-o\fR flag is provided

.SS Image Assets
When the \fB\-a\fR flag is used:
.IP • 2
Images are extracted and saved to the specified folder
.IP • 2
Filenames follow the pattern: image_001.png, image_002.jpg, etc.
.IP • 2
Format selection is automatic (PNG for graphics, JPEG for photos)
.IP • 2
Markdown contains relative references to the images

.SH FEATURES
.SS Intelligent Content Processing
.IP • 2
\fBHeading Detection\fR: Automatically identifies headings (H1-H6) based on font size analysis
.IP • 2
\fBText Extraction\fR: Preserves text formatting and structure
.IP • 2
\fBImage Processing\fR: Extracts both raster and vector graphics
.IP • 2
\fBSmart Formatting\fR: Maintains document hierarchy and readability

.SS Performance Optimizations
.IP • 2
\fBParallel Processing\fR: Uses all available CPU cores for maximum speed
.IP • 2
\fBMemory Efficiency\fR: Processes large documents without excessive memory usage
.IP • 2
\fBFormat Optimization\fR: Automatic PNG/JPEG selection based on image content

.SS Output Features
.IP • 2
\fBYAML Frontmatter\fR: Includes document metadata (title, author, creation date)
.IP • 2
\fBClean Markdown\fR: Well-structured output compatible with all Markdown processors
.IP • 2
\fBAsset Management\fR: Organized image extraction with proper linking

.SH FILE FORMATS
.SS Supported Input
.IP • 2
PDF files (version 1.4 and higher)
.IP • 2
Unencrypted PDFs (password-protected PDFs are not supported)
.IP • 2
PDFs with text, images, and vector graphics
.IP • 2
Multi-page documents of any size

.SS Generated Output
.IP • 2
\fBMarkdown (.md)\fR: GitHub Flavored Markdown compatible
.IP • 2
\fBImages (.png/.jpg)\fR: Extracted graphics in optimal formats
.IP • 2
\fBYAML Frontmatter\fR: Document metadata in standard format

.SH PERFORMANCE
Typical conversion speeds on modern hardware:
.IP • 2
Simple text documents: <1 second per page
.IP • 2
Complex documents with images: 2-5 seconds per page
.IP • 2
Large documents (100+ pages): Scales linearly with parallel processing

Memory usage is optimized for documents up to 1000 pages. Very large documents may require additional system memory.

.SH ERROR HANDLING
.B pdf22md
provides detailed error messages with suggestions for common issues:

.SS Common Errors and Solutions
.TP
\fBInvalid PDF file\fR
.IP • 2
Verify the file exists and is a valid PDF
.IP • 2
Check if the file is corrupted
.IP • 2
Ensure you have read permissions

.TP
\fBCannot create assets folder\fR
.IP • 2
Check if the parent directory exists
.IP • 2
Verify you have write permissions
.IP • 2
Ensure sufficient disk space

.TP
\fBPassword-protected PDF\fR
.IP • 2
Remove password protection using another tool first
.IP • 2
Use: qpdf \-\-decrypt input.pdf output.pdf

.TP
\fBMemory pressure\fR
.IP • 2
Close other applications to free memory
.IP • 2
Try using a lower DPI setting (\-d 72)
.IP • 2
Process smaller sections of large documents

.SH EXIT STATUS
.TP
.B 0
Successful conversion
.TP
.B 1
Error occurred (invalid input, processing failure, I/O error)

.SH ENVIRONMENT
No special environment variables are required. The tool uses standard macOS frameworks (PDFKit, CoreGraphics) and runs on macOS 10.15 and later.

.SH LIMITATIONS
.IP • 2
Password-protected PDFs are not supported
.IP • 2
Scanned PDFs without OCR text layer will only extract images
.IP • 2
Complex table layouts may not convert perfectly
.IP • 2
Some advanced PDF features (forms, annotations) are not preserved

.SH COMPATIBILITY
.SS Platform Support
.IP • 2
macOS 10.15 (Catalina) and later
.IP • 2
Intel and Apple Silicon processors
.IP • 2
Universal binary for optimal performance

.SS Markdown Compatibility
Output is compatible with:
.IP • 2
GitHub Flavored Markdown
.IP • 2
CommonMark specification
.IP • 2
Popular Markdown processors (pandoc, Jekyll, etc.)
.IP • 2
Static site generators (Hugo, Jekyll, Gatsby)

.SH FILES
.TP
.I ~/.pdf22md/
User configuration directory (future use)
.TP
.I /usr/local/bin/pdf22md
Default installation location
.TP
.I /usr/local/share/man/man1/pdf22md.1
This manual page

.SH EXAMPLES WORKFLOW
.SS Basic Document Conversion
.nf
# Convert a simple document
pdf22md \-i report.pdf \-o report.md

# Result: clean Markdown with YAML frontmatter
# Output includes: title, headings, body text, metadata
.fi

.SS Academic Paper with Images
.nf
# Convert research paper with figure extraction
pdf22md \-i paper.pdf \-o paper.md \-a figures \-d 300

# Result: 
# - paper.md with structured content
# - figures/ folder with high-quality images
# - Proper cross-references to figures
.fi

.SS Batch Processing
.nf
# Process multiple documents
for pdf in *.pdf; do
    pdf22md \-i "$pdf" \-o "${pdf%.pdf}.md" \-a "assets_${pdf%.pdf}"
done
.fi

.SS Integration with Other Tools
.nf
# Combine with pandoc for further processing
pdf22md \-i document.pdf | pandoc \-f markdown \-t html \-o document.html

# Use with static site generators
pdf22md \-i post.pdf \-o content/posts/post.md \-a static/images
.fi

.SH TROUBLESHOOTING
.SS Performance Issues
If conversion is slow:
.IP • 2
Check available memory and CPU usage
.IP • 2
Close unnecessary applications
.IP • 2
Try lower DPI setting for faster processing
.IP • 2
Process documents in smaller batches

.SS Quality Issues
If output quality is poor:
.IP • 2
Increase DPI setting (\-d 300) for better images
.IP • 2
Verify the source PDF has good quality text
.IP • 2
Check if the PDF has a proper text layer (not just scanned images)

.SS Memory Errors
For large documents:
.IP • 2
Ensure sufficient RAM (8GB+ recommended for large PDFs)
.IP • 2
Close other memory-intensive applications
.IP • 2
Split very large PDFs into smaller parts first

.SH REPORTING BUGS
Report bugs and feature requests at:
.UR https://github.com/twardoch/pdf22md/issues
.UE

Include in your report:
.IP • 2
pdf22md version (\fBpdf22md \-v\fR)
.IP • 2
macOS version
.IP • 2
Sample PDF file (if possible)
.IP • 2
Complete error message
.IP • 2
Steps to reproduce the issue

.SH AUTHORS
Written by Adam Twardoch and contributors.

.SH LICENSE
MIT License. See the LICENSE file for details.

.SH SEE ALSO
.BR pandoc (1),
.BR qpdf (1),
.BR pdftotext (1),
.BR markdown (7)

Project homepage: 
.UR https://github.com/twardoch/pdf22md
.UE
</file>

<file path="pdf22md-swift/test/README.md">
---
title: "README.md"
creator: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36 Edg/137.0.0.0"
producer: "Skia/PDF m137"
created: 2025-06-23T01:33:53+02:00
modified: 2025-06-23T01:33:53+02:00
pdf_metadata:
  page_count: 2
conversion:
  tool: "pdf22md"
  version: "v1.1.0-dirty"
  date: 2025-06-23T02:28:31+02:00
---

23/06/2025, 01:33 README.md

![Image](image_000.png)

![Image](image_001.png)

pdf22md

MIT

License MIT

License

10.15+

![Image](image_002.png)

![Image](image_003.png)

macOS 10.15+

macOS

Build and Release Build and Release passing passing

A blazingly fast PDF to Markdown converter for macOS.

pdf22md is a command-line tool that extracts all text and image content from a PDF file and converts it into a

![Image](image_004.png)

![Image](image_005.png)

![Image](image_006.png)

clean Markdown document. It uses Grand Central Dispatch (GCD) to process pages and save images in

parallel, making it exceptionally fast for multi-page documents.

Key Features

High-Speed Conversion: Uses all available CPU cores to process PDF pages concurrently

Intelligent Heading Detection: Analyzes font sizes and usage frequency to automatically format titles

![Image](image_007.png)

![Image](image_008.png)

![Image](image_009.png)

and headings ( # , ## , etc.)

Asset Extraction: Saves raster and vector images into a specified assets folder and links them correctly

in the Markdown file

Smart Image Formatting: Automatically chooses between JPEG (for photos) and PNG (for graphics with

transparency) to optimize file size and quality

Flexible I/O: Reads from a PDF file or stdin and writes to a Markdown file or stdout

![Image](image_010.png)

![Image](image_011.png)

![Image](image_012.png)

Customizable Rasterization: Allows setting a custom DPI for converting vector graphics to bitmaps

Installation

Using Homebrew (Coming Soon)

brew tap twardoch/pdf22md

brew install pdf22md

![Image](image_013.png)

![Image](image_014.png)

Building from Source

To build the project manually, you need Xcode Command Line Tools installed.

# Clone the repository

git clone https://github.com/twardoch/pdf22md.git

cd pdf22md

# Compile the tool

make

# Install it to /usr/local/bin (optional)

sudo make install

Download Pre-built Binary

Pre-built binaries are available from the Releases page.

Usage

Usage: pdf22md [-i input.pdf] [-o output.md] [-a assets

_

folder] [-d dpi]

Converts PDF documents to Markdown format

-i <path>: Input PDF file (default: stdin)

-o <path>: Output Markdown file (default: stdout)

-a <path>: Assets folder for extracted images

-d <dpi>: DPI for rasterizing vector graphics (default: 144)

Examples

# Convert a PDF file to Markdown

pdf22md -i document.pdf -o document.md

# Convert with images saved to an 'assets' folder

pdf22md -i report.pdf -o report.md -a ./assets

# Convert with custom DPI for vector graphics

pdf22md -i presentation.pdf -o presentation.md -a ./images -d 300

# Use with pipes

cat document.pdf | pdf22md > document.md

# Convert and view in less

pdf22md -i manual.pdf | less

Requirements

macOS 10.15 (Catalina) or later

Xcode Command Line Tools (for building from source)

Project Structure

pdf22md/

├── src/ # Source code

│ ├── main.m # Entry point

│ ├── PDFMarkdownConverter.* # Main conversion logic

│ ├── PDFPageProcessor.* # PDF page processing

│ ├── ContentElement.* # Content element definitions

│ └── AssetExtractor.* # Image extraction logic

├── docs/ # Additional documentation

├── test/ # Test files

file:///Users/adam/Developer/vcs/github.twardoch/pub/pdf22md/README.md 1/2

23/06/2025, 01:33 README.md

![Image](image_015.png)

![Image](image_016.png)

├── LICENSE # MIT License

├── Makefile # Build configuration

└── README.md # This file

Contributing

Contributions are welcome! Please feel free to submit a Pull Request. For major changes, please open an

![Image](image_017.png)

![Image](image_018.png)

![Image](image_019.png)

issue first to discuss what you

would like to change.

1. Fork the repository

2. Create your feature branch ( git checkout -b feature/AmazingFeature )

3. Commit your changes ( git commit -m 'Add some AmazingFeature' )

![Image](image_020.png)

![Image](image_021.png)

![Image](image_022.png)

4. Push to the branch ( git push origin feature/AmazingFeature )

5. Open a Pull Request

License

This project is licensed under the MIT License - see the LICENSE file for details.

Acknowledgments

![Image](image_023.png)

![Image](image_024.png)

![Image](image_025.png)

![Image](image_026.png)

![Image](image_027.png)

Built with Apple’s PDFKit and Core Graphics frameworks

Parallel processing powered by Grand Central Dispatch (GCD)

Inspired by the need for fast, accurate PDF to Markdown conversion

Related Projects

pdfplumber - Python library for PDF processing

![Image](image_028.png)

pdf2md - Another PDF to Markdown converter

![Image](image_029.png)

![Image](image_030.png)

![Image](image_031.png)

![Image](image_032.png)

pandoc - Universal document converter

Changelog

See CHANGELOG.md for a list of changes in each version.

Support

If you encounter any issues or have questions, please open an issue on GitHub.

![Image](image_033.png)

![Image](image_034.png)

file:///Users/adam/Developer/vcs/github.twardoch/pub/pdf22md/README.md 2/2
</file>

<file path="pdf22md-swift/Tests/PDF22MDTests/PDF22MDTests.swift">
import XCTest
@testable import PDF22MD

final class PDF22MDTests: XCTestCase {
    
    // MARK: - TextElement Tests
    
    func testTextElementCreation() {
        let element = TextElement(
            text: "Hello, World!",
            bounds: CGRect(x: 0, y: 0, width: 100, height: 20),
            pageIndex: 0
        )
        
        XCTAssertEqual(element.text, "Hello, World!")
        XCTAssertEqual(element.pageIndex, 0)
        XCTAssertEqual(element.headingLevel, 0)
        XCTAssertFalse(element.isBold)
        XCTAssertFalse(element.isItalic)
    }
    
    func testTextElementMarkdownGeneration() {
        // Test regular text
        let regularText = TextElement(
            text: "Regular paragraph text",
            bounds: CGRect.zero,
            pageIndex: 0
        )
        XCTAssertEqual(regularText.markdownRepresentation(), "Regular paragraph text")
        
        // Test heading
        var heading = TextElement(
            text: "Chapter Title",
            bounds: CGRect.zero,
            pageIndex: 0
        )
        heading.headingLevel = 1
        XCTAssertEqual(heading.markdownRepresentation(), "# Chapter Title")
        
        // Test bold text
        let boldText = TextElement(
            text: "Bold text",
            bounds: CGRect.zero,
            pageIndex: 0,
            fontName: "Arial-Bold",
            fontSize: 12.0,
            isBold: true,
            isItalic: false
        )
        XCTAssertEqual(boldText.markdownRepresentation(), "**Bold text**")
        
        // Test italic text
        let italicText = TextElement(
            text: "Italic text",
            bounds: CGRect.zero,
            pageIndex: 0,
            fontName: "Arial-Italic",
            fontSize: 12.0,
            isBold: false,
            isItalic: true
        )
        XCTAssertEqual(italicText.markdownRepresentation(), "*Italic text*")
        
        // Test bold italic text
        let boldItalicText = TextElement(
            text: "Bold italic text",
            bounds: CGRect.zero,
            pageIndex: 0,
            fontName: "Arial-BoldItalic",
            fontSize: 12.0,
            isBold: true,
            isItalic: true
        )
        XCTAssertEqual(boldItalicText.markdownRepresentation(), "***Bold italic text***")
    }
    
    func testTextElementEquality() {
        let element1 = TextElement(
            text: "Test text",
            bounds: CGRect(x: 0, y: 0, width: 100, height: 20),
            pageIndex: 0
        )
        
        let element2 = TextElement(
            text: "Test text",
            bounds: CGRect(x: 0, y: 0, width: 100, height: 20),
            pageIndex: 0
        )
        
        XCTAssertEqual(element1, element2)
    }
    
    // MARK: - ConversionOptions Tests
    
    func testConversionOptionsDefaults() {
        let options = ConversionOptions()
        
        XCTAssertNil(options.assetsFolderPath)
        XCTAssertEqual(options.rasterizationDPI, 144.0)
        XCTAssertTrue(options.includeMetadata)
        XCTAssertTrue(options.extractImages)
        XCTAssertTrue(options.preserveOutline)
        XCTAssertEqual(options.headingFontSizeThreshold, 2.0)
        XCTAssertEqual(options.maxHeadingLevel, 6)
    }
    
    func testConversionOptionsValidation() {
        var options = ConversionOptions()
        
        // Valid options should not throw
        XCTAssertNoThrow(try options.validate())
        
        // Invalid DPI should throw
        options.rasterizationDPI = -1
        XCTAssertThrowsError(try options.validate()) { error in
            XCTAssertTrue(error is PDFError)
            if case .invalidConfiguration = error as! PDFError {
                // Expected error type
            } else {
                XCTFail("Expected invalidConfiguration error")
            }
        }
        
        // Reset to valid value
        options.rasterizationDPI = 144.0
        
        // Invalid max heading level should throw
        options.maxHeadingLevel = 0
        XCTAssertThrowsError(try options.validate())
        
        options.maxHeadingLevel = 7
        XCTAssertThrowsError(try options.validate())
    }
    
    func testConversionOptionsBuilder() {
        let options = ConversionOptionsBuilder()
            .assetsFolderPath("/tmp/assets")
            .rasterizationDPI(300.0)
            .includeMetadata(false)
            .extractImages(true)
            .maxHeadingLevel(3)
            .build()
        
        XCTAssertEqual(options.assetsFolderPath, "/tmp/assets")
        XCTAssertEqual(options.rasterizationDPI, 300.0)
        XCTAssertFalse(options.includeMetadata)
        XCTAssertTrue(options.extractImages)
        XCTAssertEqual(options.maxHeadingLevel, 3)
    }
    
    // MARK: - FontAnalyzer Tests
    
    func testFontKeyGeneration() {
        let key1 = FontAnalyzer.fontKey(forFontName: "Arial", fontSize: 12.0)
        let key2 = FontAnalyzer.fontKey(forFontName: "Arial", fontSize: 12.0)
        let key3 = FontAnalyzer.fontKey(forFontName: "Arial", fontSize: 14.0)
        let key4 = FontAnalyzer.fontKey(forFontName: nil, fontSize: 12.0)
        
        XCTAssertEqual(key1, key2)
        XCTAssertNotEqual(key1, key3)
        XCTAssertEqual(key4, "12.0-Unknown")
    }
    
    func testFontAnalyzerBasicFunctionality() {
        let analyzer = FontAnalyzer()
        
        let elements: [ContentElement] = [
            TextElement(
                text: "Body text",
                bounds: CGRect.zero,
                pageIndex: 0,
                fontName: "Arial",
                fontSize: 12.0,
                isBold: false,
                isItalic: false
            ),
            TextElement(
                text: "Heading",
                bounds: CGRect.zero,
                pageIndex: 0,
                fontName: "Arial-Bold",
                fontSize: 18.0,
                isBold: true,
                isItalic: false
            )
        ]
        
        analyzer.analyzeElements(elements)
        let stats = analyzer.getSortedFontStatistics()
        
        XCTAssertEqual(stats.count, 2)
        // Should be sorted by font size (largest first)
        XCTAssertEqual(stats[0].fontSize, 18.0)
        XCTAssertEqual(stats[1].fontSize, 12.0)
    }
    
    // MARK: - PDFError Tests
    
    func testPDFErrorMessages() {
        let invalidPDFError = PDFError.invalidPDF(reason: "Corrupted file")
        XCTAssertEqual(invalidPDFError.errorDescription, "Invalid or corrupted PDF file: Corrupted file")
        
        let assetError = PDFError.assetCreationFailed(path: "/tmp/test", reason: "No permission")
        XCTAssertEqual(assetError.errorDescription, "Failed to create or save asset at /tmp/test: No permission")
        
        let pageError = PDFError.pageProcessingFailed(page: 5, reason: "Malformed content")
        XCTAssertEqual(pageError.errorDescription, "Failed to process page 6: Malformed content")
        
        let cancelledError = PDFError.cancelled
        XCTAssertEqual(cancelledError.errorDescription, "Operation was cancelled")
    }
    
    // MARK: - MarkdownGenerator Tests
    
    func testMarkdownGeneratorBasic() {
        let options = ConversionOptions()
        let generator = MarkdownGenerator(options: options)
        
        let elements: [ContentElement] = [
            TextElement(text: "First paragraph", bounds: CGRect.zero, pageIndex: 0),
            TextElement(text: "Second paragraph", bounds: CGRect.zero, pageIndex: 0)
        ]
        
        let markdown = generator.generateMarkdownContent(from: elements)
        XCTAssertTrue(markdown.contains("First paragraph"))
        XCTAssertTrue(markdown.contains("Second paragraph"))
    }
    
    func testYAMLEscaping() {
        let options = ConversionOptions()
        let generator = MarkdownGenerator(options: options)
        
        // Test string escaping
        let testString = "Test \"quotes\" and\nnewlines"
        let escaped = generator.generateYAMLFrontmatter(DocumentMetadata(pageCount: 1))
        
        // Basic YAML structure should be present
        XCTAssertTrue(escaped?.contains("---") == true)
        XCTAssertTrue(escaped?.contains("pdf_metadata:") == true)
        XCTAssertTrue(escaped?.contains("page_count: 1") == true)
    }
    
    // MARK: - Performance Tests
    
    func testTextElementPerformance() {
        measure {
            for i in 0..<1000 {
                let element = TextElement(
                    text: "Performance test text \(i)",
                    bounds: CGRect(x: 0, y: CGFloat(i), width: 100, height: 20),
                    pageIndex: i % 10
                )
                _ = element.markdownRepresentation()
            }
        }
    }
    
    func testFontAnalyzerPerformance() {
        let analyzer = FontAnalyzer()
        let elements = (0..<1000).map { i in
            TextElement(
                text: "Text \(i)",
                bounds: CGRect.zero,
                pageIndex: 0,
                fontName: "Arial",
                fontSize: CGFloat(12 + (i % 6)),
                isBold: i % 2 == 0,
                isItalic: i % 3 == 0
            )
        }
        
        measure {
            analyzer.analyzeElements(elements)
            _ = analyzer.getSortedFontStatistics()
        }
    }
}
</file>

<file path="pdf22md-swift/Package.swift">
// swift-tools-version: 5.7
// The swift-tools-version declares the minimum version of Swift required to build this package.

import PackageDescription

let package = Package(
    name: "pdf22md",
    platforms: [
        .macOS(.v12) // Required for async/await
    ],
    products: [
        // Library product for programmatic usage
        .library(
            name: "PDF22MD",
            targets: ["PDF22MD"]
        ),
        // Executable product for CLI
        .executable(
            name: "pdf22md",
            targets: ["pdf22md"]
        )
    ],
    dependencies: [
        // Swift Argument Parser for CLI
        .package(url: "https://github.com/apple/swift-argument-parser", from: "1.2.0")
    ],
    targets: [
        // Main library target
        .target(
            name: "PDF22MD",
            dependencies: [],
            swiftSettings: [
                .define("VERSION", to: "\"1.0.0\"")
            ]
        ),
        // CLI executable target
        .executableTarget(
            name: "pdf22md",
            dependencies: [
                "PDF22MD",
                .product(name: "ArgumentParser", package: "swift-argument-parser")
            ]
        ),
        // Test target
        .testTarget(
            name: "PDF22MDTests",
            dependencies: ["PDF22MD"],
            resources: [
                .process("Resources")
            ]
        )
    ]
)
</file>

<file path="pdf22md-swift/release.sh">
#!/bin/bash

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Print functions
print_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
print_warning() { echo -e "${YELLOW}[WARN]${NC} $1"; }
print_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Configuration
APP_NAME="pdf22md-swift"
BUILD_DIR=".build/release"
ARCHIVE_DIR="archive"

# Get version from git or default
get_version() {
    local version=$(git describe --tags --always --dirty 2>/dev/null || echo "dev")
    echo "$version"
}

# Build release version
build_release() {
    print_info "Building release version..."
    
    # Clean and build
    swift build -c release
    
    if [ $? -eq 0 ]; then
        print_info "✓ Release build completed successfully"
        return 0
    else
        print_error "Release build failed"
        return 1
    fi
}

# Run tests before release
run_tests() {
    print_info "Running test suite..."
    
    if swift test; then
        print_info "✓ All tests passed"
        return 0
    else
        print_error "Tests failed"
        return 1
    fi
}

# Create archive
create_archive() {
    local version=$(get_version)
    local archive_name="${APP_NAME}-${version}-macos"
    
    print_info "Creating archive: ${archive_name}"
    
    # Create archive directory
    mkdir -p "$ARCHIVE_DIR"
    
    # Create temporary directory for archive contents
    local temp_dir=$(mktemp -d)
    local archive_path="$temp_dir/$archive_name"
    
    mkdir -p "$archive_path"
    
    # Copy binary
    if [ -f "$BUILD_DIR/pdf22md" ]; then
        cp "$BUILD_DIR/pdf22md" "$archive_path/"
        print_info "✓ Copied binary"
    else
        print_error "Binary not found at $BUILD_DIR/pdf22md"
        return 1
    fi
    
    # Copy documentation
    if [ -f "README.md" ]; then
        cp "README.md" "$archive_path/"
    fi
    
    if [ -f "docs/pdf22md.1" ]; then
        mkdir -p "$archive_path/man"
        cp "docs/pdf22md.1" "$archive_path/man/"
        print_info "✓ Copied documentation"
    fi
    
    # Create tarball
    cd "$temp_dir"
    tar -czf "${archive_name}.tar.gz" "$archive_name"
    
    # Move to archive directory
    mv "${archive_name}.tar.gz" "$OLDPWD/$ARCHIVE_DIR/"
    
    # Cleanup
    rm -rf "$temp_dir"
    
    print_info "✓ Archive created: $ARCHIVE_DIR/${archive_name}.tar.gz"
    
    # Show archive contents
    print_info "Archive contents:"
    tar -tzf "$ARCHIVE_DIR/${archive_name}.tar.gz" | sed 's/^/  /'
}

# Main execution
main() {
    local version=$(get_version)
    
    print_info "Starting release process for $APP_NAME version $version"
    
    # Build release
    if ! build_release; then
        exit 1
    fi
    
    # Run tests
    if ! run_tests; then
        print_error "Tests failed, aborting release"
        exit 1
    fi
    
    # Create archive
    if ! create_archive; then
        print_error "Archive creation failed"
        exit 1
    fi
    
    print_info "🎉 Release complete!"
    print_info "Version: $version"
    print_info "Archive: $ARCHIVE_DIR/${APP_NAME}-${version}-macos.tar.gz"
    print_info ""
    print_info "To install locally:"
    print_info "  tar -xzf $ARCHIVE_DIR/${APP_NAME}-${version}-macos.tar.gz"
    print_info "  sudo cp ${APP_NAME}-${version}-macos/pdf22md /usr/local/bin/pdf22md-swift"
}

main "$@"
</file>

<file path="test/README.md">
---
title: "README.md"
creator: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36 Edg/137.0.0.0"
producer: "Skia/PDF m137"
created: 2025-06-23T01:33:53+02:00
modified: 2025-06-23T01:33:53+02:00
pdf_metadata:
  page_count: 2
conversion:
  tool: "pdf22md"
  version: "v1.1.0-dirty"
  date: 2025-06-23T02:28:31+02:00
---

23/06/2025, 01:33 README.md

![Image](image_000.png)

![Image](image_001.png)

pdf22md

MIT

License MIT

License

10.15+

![Image](image_002.png)

![Image](image_003.png)

macOS 10.15+

macOS

Build and Release Build and Release passing passing

A blazingly fast PDF to Markdown converter for macOS.

pdf22md is a command-line tool that extracts all text and image content from a PDF file and converts it into a

![Image](image_004.png)

![Image](image_005.png)

![Image](image_006.png)

clean Markdown document. It uses Grand Central Dispatch (GCD) to process pages and save images in

parallel, making it exceptionally fast for multi-page documents.

Key Features

High-Speed Conversion: Uses all available CPU cores to process PDF pages concurrently

Intelligent Heading Detection: Analyzes font sizes and usage frequency to automatically format titles

![Image](image_007.png)

![Image](image_008.png)

![Image](image_009.png)

and headings ( # , ## , etc.)

Asset Extraction: Saves raster and vector images into a specified assets folder and links them correctly

in the Markdown file

Smart Image Formatting: Automatically chooses between JPEG (for photos) and PNG (for graphics with

transparency) to optimize file size and quality

Flexible I/O: Reads from a PDF file or stdin and writes to a Markdown file or stdout

![Image](image_010.png)

![Image](image_011.png)

![Image](image_012.png)

Customizable Rasterization: Allows setting a custom DPI for converting vector graphics to bitmaps

Installation

Using Homebrew (Coming Soon)

brew tap twardoch/pdf22md

brew install pdf22md

![Image](image_013.png)

![Image](image_014.png)

Building from Source

To build the project manually, you need Xcode Command Line Tools installed.

# Clone the repository

git clone https://github.com/twardoch/pdf22md.git

cd pdf22md

# Compile the tool

make

# Install it to /usr/local/bin (optional)

sudo make install

Download Pre-built Binary

Pre-built binaries are available from the Releases page.

Usage

Usage: pdf22md [-i input.pdf] [-o output.md] [-a assets

_

folder] [-d dpi]

Converts PDF documents to Markdown format

-i <path>: Input PDF file (default: stdin)

-o <path>: Output Markdown file (default: stdout)

-a <path>: Assets folder for extracted images

-d <dpi>: DPI for rasterizing vector graphics (default: 144)

Examples

# Convert a PDF file to Markdown

pdf22md -i document.pdf -o document.md

# Convert with images saved to an 'assets' folder

pdf22md -i report.pdf -o report.md -a ./assets

# Convert with custom DPI for vector graphics

pdf22md -i presentation.pdf -o presentation.md -a ./images -d 300

# Use with pipes

cat document.pdf | pdf22md > document.md

# Convert and view in less

pdf22md -i manual.pdf | less

Requirements

macOS 10.15 (Catalina) or later

Xcode Command Line Tools (for building from source)

Project Structure

pdf22md/

├── src/ # Source code

│ ├── main.m # Entry point

│ ├── PDFMarkdownConverter.* # Main conversion logic

│ ├── PDFPageProcessor.* # PDF page processing

│ ├── ContentElement.* # Content element definitions

│ └── AssetExtractor.* # Image extraction logic

├── docs/ # Additional documentation

├── test/ # Test files

file:///Users/adam/Developer/vcs/github.twardoch/pub/pdf22md/README.md 1/2

23/06/2025, 01:33 README.md

![Image](image_015.png)

![Image](image_016.png)

├── LICENSE # MIT License

├── Makefile # Build configuration

└── README.md # This file

Contributing

Contributions are welcome! Please feel free to submit a Pull Request. For major changes, please open an

![Image](image_017.png)

![Image](image_018.png)

![Image](image_019.png)

issue first to discuss what you

would like to change.

1. Fork the repository

2. Create your feature branch ( git checkout -b feature/AmazingFeature )

3. Commit your changes ( git commit -m 'Add some AmazingFeature' )

![Image](image_020.png)

![Image](image_021.png)

![Image](image_022.png)

4. Push to the branch ( git push origin feature/AmazingFeature )

5. Open a Pull Request

License

This project is licensed under the MIT License - see the LICENSE file for details.

Acknowledgments

![Image](image_023.png)

![Image](image_024.png)

![Image](image_025.png)

![Image](image_026.png)

![Image](image_027.png)

Built with Apple’s PDFKit and Core Graphics frameworks

Parallel processing powered by Grand Central Dispatch (GCD)

Inspired by the need for fast, accurate PDF to Markdown conversion

Related Projects

pdfplumber - Python library for PDF processing

![Image](image_028.png)

pdf2md - Another PDF to Markdown converter

![Image](image_029.png)

![Image](image_030.png)

![Image](image_031.png)

![Image](image_032.png)

pandoc - Universal document converter

Changelog

See CHANGELOG.md for a list of changes in each version.

Support

If you encounter any issues or have questions, please open an issue on GitHub.

![Image](image_033.png)

![Image](image_034.png)

file:///Users/adam/Developer/vcs/github.twardoch/pub/pdf22md/README.md 2/2
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2024 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path=".github/workflows/build-release.yml">
name: Build and Release

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  release:
    types: [ created ]

jobs:
  build:
    runs-on: macos-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Build the tool
      run: make

    - name: Run a basic check
      run: ./pdf22md -h

  create-release:
    if: github.event_name == 'release'
    runs-on: macos-latest
    needs: build

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Build the binary
      run: make

    - name: Create Tarball Archive
      run: |
        tar -czvf pdf22md-macos-x86_64.tar.gz pdf22md

    - name: Upload Release Asset
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ github.event.release.upload_url }}
        asset_path: ./pdf22md-macos-x86_64.tar.gz
        asset_name: pdf22md-macos-x86_64.tar.gz
        asset_content_type: application/gzip
</file>

<file path="issues/issue201.txt">
./build.sh
[BUILD] pdf22md - Multi-Implementation Build System
[INFO] Building Objective-C Swift implementations
[BUILD] Building pdf22md-objc...
[INFO] Starting pdf22md-objc build process...
[INFO] Building pdf22md (Objective-C implementation)...
rm -rf build pdf22md pdf22md-benchmark
mkdir -p build
clang -Wall -Wextra -O2 -fobjc-arc -DVERSION=\"v1.2.0-4-gf1d7a94-dirty\" -Isrc -c src/CLI/main.m -o build/CLI/main.o
clang -Wall -Wextra -O2 -fobjc-arc -DVERSION=\"v1.2.0-4-gf1d7a94-dirty\" -Isrc -c src/Core/PDF22MDConversionOptions.m -o build/Core/PDF22MDConversionOptions.o
clang -Wall -Wextra -O2 -fobjc-arc -DVERSION=\"v1.2.0-4-gf1d7a94-dirty\" -Isrc -c src/Core/PDF22MDConverter.m -o build/Core/PDF22MDConverter.o
clang -Wall -Wextra -O2 -fobjc-arc -DVERSION=\"v1.2.0-4-gf1d7a94-dirty\" -Isrc -c src/Core/PDF22MDError.m -o build/Core/PDF22MDError.o
clang -Wall -Wextra -O2 -fobjc-arc -DVERSION=\"v1.2.0-4-gf1d7a94-dirty\" -Isrc -c src/Core/PDF22MDFontAnalyzer.m -o build/Core/PDF22MDFontAnalyzer.o
clang -Wall -Wextra -O2 -fobjc-arc -DVERSION=\"v1.2.0-4-gf1d7a94-dirty\" -Isrc -c src/Core/PDF22MDPageProcessor.m -o build/Core/PDF22MDPageProcessor.o
clang -Wall -Wextra -O2 -fobjc-arc -DVERSION=\"v1.2.0-4-gf1d7a94-dirty\" -Isrc -c src/Models/PDF22MDImageElement.m -o build/Models/PDF22MDImageElement.o
clang -Wall -Wextra -O2 -fobjc-arc -DVERSION=\"v1.2.0-4-gf1d7a94-dirty\" -Isrc -c src/Models/PDF22MDTextElement.m -o build/Models/PDF22MDTextElement.o
clang -Wall -Wextra -O2 -fobjc-arc -DVERSION=\"v1.2.0-4-gf1d7a94-dirty\" -Isrc -c src/Services/PDF22MDAssetManager.m -o build/Services/PDF22MDAssetManager.o
clang -Wall -Wextra -O2 -fobjc-arc -DVERSION=\"v1.2.0-4-gf1d7a94-dirty\" -Isrc -c src/Services/PDF22MDMarkdownGenerator.m -o build/Services/PDF22MDMarkdownGenerator.o
clang -Wall -Wextra -O2 -fobjc-arc -framework Foundation -framework PDFKit -framework CoreGraphics -framework ImageIO -framework CoreServices -o pdf22md build/CLI/main.o build/Core/PDF22MDConversionOptions.o build/Core/PDF22MDConverter.o build/Core/PDF22MDError.o build/Core/PDF22MDFontAnalyzer.o build/Core/PDF22MDPageProcessor.o build/Models/PDF22MDImageElement.o build/Models/PDF22MDTextElement.o build/Services/PDF22MDAssetManager.o build/Services/PDF22MDMarkdownGenerator.o
[INFO] ✓ pdf22md-objc built successfully
[INFO] Build complete!
[INFO] Run './pdf22md --help' for usage information
[INFO] ✓ pdf22md-objc built successfully
[BUILD] Building pdf22md-swift...
[INFO] Starting pdf22md-swift build process...
[INFO] Building pdf22md (Swift implementation)...
[INFO] Checking Swift toolchain...
./build.sh: line 31: 12212 Abort trap: 6           xcrun swift build -c release 2> /dev/null
[WARN] xcrun failed, trying direct swift build...
./build.sh: line 31: 12213 Abort trap: 6           swift build -c release 2> /dev/null
[WARN] Standard build failed, attempting package reset...
./build.sh: line 31: 12214 Abort trap: 6           swift package reset 2> /dev/null
dyld[12215]: Library not loaded: @rpath/SWBBuildService.framework/Versions/A/SWBBuildService
  Referenced from: <DAAB41B3-19E5-3A14-8AFB-1A3635185E81> /Library/Developer/CommandLineTools/usr/bin/swift-package
  Reason: tried: '/Library/../SharedFrameworks/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/../SharedFrameworks/SwiftBuild.framework/Versions/A/PlugIns/SWBBuildService.bundle/Contents/Frameworks/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/../SharedFrameworks/SwiftBuild.framework/Versions/A/PlugIns/SWBBuildSystem.bundle/Contents/Frameworks/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/../Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/../Developer/Toolchains/XcodeDefault.xctoolchain/usr/local/include/SwiftToolsSupport/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/Developer/CommandLineTools/usr/lib/swift/pm/llbuild/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/Developer/CommandLineTools/usr/lib/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/Developer/CommandLineTools/usr/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/../SharedFrameworks/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/../SharedFrameworks/SwiftBuild.framework/Versions/A/PlugIns/SWBBuildService.bundle/Contents/Frameworks/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/../SharedFrameworks/SwiftBuild.framework/Versions/A/PlugIns/SWBBuildSystem.bundle/Contents/Frameworks/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/../Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/../Developer/Toolchains/XcodeDefault.xctoolchain/usr/local/include/SwiftToolsSupport/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/Developer/CommandLineTools/usr/lib/swift/pm/llbuild/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/Developer/CommandLineTools/usr/lib/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/Developer/CommandLineTools/usr/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file)
./build.sh: line 31: 12215 Abort trap: 6           swift build -c release
[ERROR] Failed to build pdf22md-swift
[ERROR] This may indicate a corrupted Swift toolchain.
[INFO] Try running: xcode-select --install
[INFO] Or reinstall Xcode Command Line Tools
[ERROR] ✗ pdf22md-swift build failed
[WARN] Swift toolchain may be corrupted. Try:
[INFO]   xcode-select --install
[WARN] Swift build failed but Objective-C build succeeded
[INFO] The Objective-C implementation is fully functional
[BUILD] Build Summary
[INFO] ✓ pdf22md-objc: SUCCESS
[ERROR] ✗ pdf22md-swift: FAILED

[ERROR] Some builds failed (1/2 successful)
</file>

<file path="pdf22md-objc/src/Core/PDF22MDConversionOptions.m">
#import "PDF22MDConversionOptions.h"
#import "PDF22MDError.h"

@implementation PDF22MDConversionOptions

#pragma mark - Initialization

- (instancetype)init {
    self = [super init];
    if (self) {
        // Set default values
        _rasterizationDPI = 144.0;
        _maxConcurrentPages = [[NSProcessInfo processInfo] processorCount];
        _includeMetadata = YES;
        _extractImages = YES;
        _preserveOutline = YES;
        _headingFontSizeThreshold = 2.0;
        _maxHeadingLevel = 6;
    }
    return self;
}

+ (instancetype)defaultOptions {
    return [[self alloc] init];
}

#pragma mark - NSCopying

- (id)copyWithZone:(nullable NSZone *)zone {
    PDF22MDConversionOptions *copy = [[PDF22MDConversionOptions allocWithZone:zone] init];
    
    copy.assetsFolderPath = self.assetsFolderPath;
    copy.rasterizationDPI = self.rasterizationDPI;
    copy.maxConcurrentPages = self.maxConcurrentPages;
    copy.includeMetadata = self.includeMetadata;
    copy.extractImages = self.extractImages;
    copy.preserveOutline = self.preserveOutline;
    copy.headingFontSizeThreshold = self.headingFontSizeThreshold;
    copy.maxHeadingLevel = self.maxHeadingLevel;
    copy.progressHandler = self.progressHandler;
    
    return copy;
}

#pragma mark - Validation

- (BOOL)validateWithError:(NSError * _Nullable * _Nullable)error {
    // Validate DPI
    if (self.rasterizationDPI <= 0 || self.rasterizationDPI > 600) {
        if (error) {
            *error = [NSError errorWithDomain:PDF22MDErrorDomain
                                         code:PDF22MDErrorInvalidConfiguration
                                     userInfo:@{
                NSLocalizedDescriptionKey: @"Invalid rasterization DPI",
                NSLocalizedFailureReasonErrorKey: @"DPI must be between 1 and 600"
            }];
        }
        return NO;
    }
    
    // Validate concurrent pages
    if (self.maxConcurrentPages < 1 || self.maxConcurrentPages > 64) {
        if (error) {
            *error = [NSError errorWithDomain:PDF22MDErrorDomain
                                         code:PDF22MDErrorInvalidConfiguration
                                     userInfo:@{
                NSLocalizedDescriptionKey: @"Invalid max concurrent pages",
                NSLocalizedFailureReasonErrorKey: @"Value must be between 1 and 64"
            }];
        }
        return NO;
    }
    
    // Validate heading level
    if (self.maxHeadingLevel < 1 || self.maxHeadingLevel > 6) {
        if (error) {
            *error = [NSError errorWithDomain:PDF22MDErrorDomain
                                         code:PDF22MDErrorInvalidConfiguration
                                     userInfo:@{
                NSLocalizedDescriptionKey: @"Invalid max heading level",
                NSLocalizedFailureReasonErrorKey: @"Heading level must be between 1 and 6"
            }];
        }
        return NO;
    }
    
    // Validate font size threshold
    if (self.headingFontSizeThreshold < 0.5 || self.headingFontSizeThreshold > 10.0) {
        if (error) {
            *error = [NSError errorWithDomain:PDF22MDErrorDomain
                                         code:PDF22MDErrorInvalidConfiguration
                                     userInfo:@{
                NSLocalizedDescriptionKey: @"Invalid heading font size threshold",
                NSLocalizedFailureReasonErrorKey: @"Threshold must be between 0.5 and 10.0 points"
            }];
        }
        return NO;
    }
    
    // Validate assets path if image extraction is enabled
    if (self.extractImages && self.assetsFolderPath) {
        NSFileManager *fileManager = [NSFileManager defaultManager];
        BOOL isDirectory = NO;
        BOOL exists = [fileManager fileExistsAtPath:self.assetsFolderPath isDirectory:&isDirectory];
        
        if (exists && !isDirectory) {
            if (error) {
                *error = [PDF22MDErrorHelper assetFolderCreationErrorWithPath:self.assetsFolderPath
                                                                         reason:@"Path exists but is not a directory"];
            }
            return NO;
        }
    }
    
    return YES;
}

#pragma mark - Description

- (NSString *)description {
    return [NSString stringWithFormat:@"<%@: %p, assets=%@, dpi=%.0f, concurrent=%ld>",
            NSStringFromClass([self class]),
            self,
            self.assetsFolderPath ?: @"<none>",
            self.rasterizationDPI,
            (long)self.maxConcurrentPages];
}

@end

#pragma mark - Builder Implementation

@implementation PDF22MDConversionOptionsBuilder

- (instancetype)init {
    self = [super init];
    if (self) {
        // Initialize with default values
        PDF22MDConversionOptions *defaults = [PDF22MDConversionOptions defaultOptions];
        _rasterizationDPI = defaults.rasterizationDPI;
        _maxConcurrentPages = defaults.maxConcurrentPages;
        _includeMetadata = defaults.includeMetadata;
        _extractImages = defaults.extractImages;
        _preserveOutline = defaults.preserveOutline;
        _headingFontSizeThreshold = defaults.headingFontSizeThreshold;
        _maxHeadingLevel = defaults.maxHeadingLevel;
    }
    return self;
}

- (PDF22MDConversionOptions *)build {
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    
    options.assetsFolderPath = self.assetsFolderPath;
    options.rasterizationDPI = self.rasterizationDPI;
    options.maxConcurrentPages = self.maxConcurrentPages;
    options.includeMetadata = self.includeMetadata;
    options.extractImages = self.extractImages;
    options.preserveOutline = self.preserveOutline;
    options.headingFontSizeThreshold = self.headingFontSizeThreshold;
    options.maxHeadingLevel = self.maxHeadingLevel;
    options.progressHandler = self.progressHandler;
    
    return options;
}

@end
</file>

<file path="pdf22md-objc/src/Core/PDF22MDConverter.m">
#import "PDF22MDConverter.h"
#import "PDF22MDConversionOptions.h"
#import "PDF22MDPageProcessor.h"
#import "../Models/PDF22MDContentElement.h"
#import "../Models/PDF22MDImageElement.h"
#import "../Services/PDF22MDAssetManager.h"
#import "../Services/PDF22MDMarkdownGenerator.h"
#import "PDF22MDFontAnalyzer.h"
#import "PDF22MDError.h"

@interface PDF22MDConverter ()
@property (nonatomic, strong) dispatch_queue_t conversionQueue;
@property (nonatomic, strong) NSMutableArray<id<PDF22MDContentElement>> *allElements;
@property (nonatomic, strong) PDF22MDFontAnalyzer *fontAnalyzer;
@property (nonatomic, assign) BOOL isCancelled;
@end

@implementation PDF22MDConverter

#pragma mark - Initialization

- (nullable instancetype)initWithPDFData:(NSData *)pdfData {
    if (!pdfData || pdfData.length == 0) {
        return nil;
    }
    
    PDFDocument *document = [[PDFDocument alloc] initWithData:pdfData];
    if (!document) {
        return nil;
    }
    
    NSURL *tempURL = [NSURL URLWithString:@"data:application/pdf"];
    return [self initWithPDFURL:tempURL document:document];
}

- (nullable instancetype)initWithPDFURL:(NSURL *)pdfURL {
    if (!pdfURL) {
        return nil;
    }
    
    PDFDocument *document = [[PDFDocument alloc] initWithURL:pdfURL];
    if (!document) {
        return nil;
    }
    
    return [self initWithPDFURL:pdfURL document:document];
}

- (nullable instancetype)initWithPDFURL:(nullable NSURL *)pdfURL document:(PDFDocument *)document {
    if (!document) {
        return nil;
    }
    
    self = [super init];
    if (self) {
        _document = document;
        _conversionQueue = dispatch_queue_create("com.twardoch.pdf22md.converter", DISPATCH_QUEUE_SERIAL);
        _allElements = [NSMutableArray array];
        _fontAnalyzer = [[PDF22MDFontAnalyzer alloc] init];
        _progress = [NSProgress progressWithTotalUnitCount:[document pageCount]];
        _isCancelled = NO;
    }
    return self;
}

#pragma mark - Public Methods

- (void)convertWithOptions:(nullable PDF22MDConversionOptions *)options
                completion:(void (^)(NSString * _Nullable markdown, NSError * _Nullable error))completion {
    // Use default options if none provided
    if (!options) {
        options = [PDF22MDConversionOptions defaultOptions];
    }
    
    // Validate options
    NSError *validationError = nil;
    if (![options validateWithError:&validationError]) {
        completion(nil, validationError);
        return;
    }
    
    // Reset state
    self.isCancelled = NO;
    [self.allElements removeAllObjects];
    [self.fontAnalyzer reset];
    self.progress.completedUnitCount = 0;
    
    // Configure font analyzer
    self.fontAnalyzer.fontSizeThreshold = options.headingFontSizeThreshold;
    self.fontAnalyzer.maxHeadingLevel = options.maxHeadingLevel;
    
    // Perform conversion on background queue
    dispatch_async(self.conversionQueue, ^{
        @autoreleasepool {
            NSError *error = nil;
            NSString *markdown = [self performConversionWithOptions:options error:&error];
            
            // Call completion on main queue
            dispatch_async(dispatch_get_main_queue(), ^{
                completion(markdown, error);
            });
        }
    });
}

- (void)cancelConversion {
    self.isCancelled = YES;
    [self.progress cancel];
}

- (BOOL)validateDocumentWithError:(NSError * _Nullable * _Nullable)error {
    if (!self.document) {
        if (error) {
            *error = [PDF22MDErrorHelper invalidPDFErrorWithReason:@"Document is nil"];
        }
        return NO;
    }
    
    if ([self.document pageCount] == 0) {
        if (error) {
            *error = [PDF22MDErrorHelper invalidPDFErrorWithReason:@"Document has no pages"];
        }
        return NO;
    }
    
    if ([self.document isLocked]) {
        if (error) {
            *error = [PDF22MDErrorHelper invalidPDFErrorWithReason:@"Document is password protected"];
        }
        return NO;
    }
    
    return YES;
}

#pragma mark - Private Methods

- (nullable NSString *)performConversionWithOptions:(PDF22MDConversionOptions *)options
                                              error:(NSError * _Nullable * _Nullable)error {
    // Validate document
    if (![self validateDocumentWithError:error]) {
        return nil;
    }
    
    NSInteger pageCount = [self.document pageCount];
    
    // Create asset manager if needed
    PDF22MDAssetManager *assetManager = nil;
    if (options.extractImages && options.assetsFolderPath) {
        assetManager = [[PDF22MDAssetManager alloc] initWithAssetFolder:options.assetsFolderPath];
        if (!assetManager) {
            if (error) {
                *error = [PDF22MDErrorHelper assetFolderCreationErrorWithPath:options.assetsFolderPath
                                                                          reason:@"Failed to create asset manager"];
            }
            return nil;
        }
    }
    
    // Process pages in parallel
    NSMutableArray<NSMutableArray<id<PDF22MDContentElement>> *> *pageElementsArray = [NSMutableArray arrayWithCapacity:pageCount];
    NSMutableArray<PDF22MDFontAnalyzer *> *pageFontAnalyzers = [NSMutableArray arrayWithCapacity:pageCount];
    
    for (NSInteger i = 0; i < pageCount; i++) {
        [pageElementsArray addObject:[NSMutableArray array]];
        [pageFontAnalyzers addObject:[[PDF22MDFontAnalyzer alloc] init]];
    }
    
    // Create dispatch group for parallel processing
    dispatch_group_t processingGroup = dispatch_group_create();
    __block BOOL processingFailed = NO;
    __block NSError *processingError = nil;
    
    // Limit concurrency based on options
    dispatch_semaphore_t concurrencySemaphore = dispatch_semaphore_create(options.maxConcurrentPages);
    
    for (NSInteger pageIndex = 0; pageIndex < pageCount; pageIndex++) {
        if (self.isCancelled) {
            if (error) {
                *error = [NSError errorWithDomain:PDF22MDErrorDomain
                                             code:PDF22MDErrorCancelled
                                         userInfo:@{NSLocalizedDescriptionKey: @"Conversion was cancelled"}];
            }
            return nil;
        }
        
        dispatch_group_async(processingGroup, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            dispatch_semaphore_wait(concurrencySemaphore, DISPATCH_TIME_FOREVER);
            
            @autoreleasepool {
                if (!processingFailed && !self.isCancelled) {
                    PDFPage *page = [self.document pageAtIndex:pageIndex];
                    if (!page) {
                        processingFailed = YES;
                        processingError = [PDF22MDErrorHelper pageProcessingFailedErrorForPage:pageIndex
                                                                                        reason:@"Failed to get page"
                                                                               underlyingError:nil];
                    } else {
                        // Process page
                        PDF22MDPageProcessor *processor = [[PDF22MDPageProcessor alloc] initWithPDFPage:page
                                                                                             pageIndex:pageIndex
                                                                                                   dpi:options.rasterizationDPI];
                        processor.fontAnalyzer = pageFontAnalyzers[pageIndex];
                        
                        NSArray<id<PDF22MDContentElement>> *pageElements = [processor extractContentElements];
                        [pageElementsArray[pageIndex] addObjectsFromArray:pageElements];
                        
                        // Analyze fonts for this page
                        [pageFontAnalyzers[pageIndex] analyzeElements:pageElements];
                        
                        // Update progress
                        dispatch_async(dispatch_get_main_queue(), ^{
                            self.progress.completedUnitCount = pageIndex + 1;
                            if (options.progressHandler) {
                                options.progressHandler(pageIndex + 1, pageCount);
                            }
                        });
                    }
                }
            }
            
            dispatch_semaphore_signal(concurrencySemaphore);
        });
    }
    
    // Wait for all pages to complete
    dispatch_group_wait(processingGroup, DISPATCH_TIME_FOREVER);
    
    if (processingFailed) {
        if (error) {
            *error = processingError ?: [PDF22MDErrorHelper processingFailedErrorWithReason:@"Unknown processing error"
                                                                              underlyingError:nil];
        }
        return nil;
    }
    
    if (self.isCancelled) {
        if (error) {
            *error = [NSError errorWithDomain:PDF22MDErrorDomain
                                         code:PDF22MDErrorCancelled
                                     userInfo:@{NSLocalizedDescriptionKey: @"Conversion was cancelled"}];
        }
        return nil;
    }
    
    // Merge results from all pages
    for (NSInteger i = 0; i < pageCount; i++) {
        [self.allElements addObjectsFromArray:pageElementsArray[i]];
        [self.fontAnalyzer mergeFontStatisticsFromAnalyzer:pageFontAnalyzers[i]];
    }
    
    // Analyze font hierarchy and assign heading levels
    [self.fontAnalyzer analyzeElements:self.allElements];
    [self.fontAnalyzer assignHeadingLevels:self.allElements];
    
    // Sort elements by page and position
    [self sortElements];
    
    // Extract and save images if needed
    if (assetManager) {
        [self extractImagesWithAssetManager:assetManager];
    }
    
    // Generate markdown
    PDF22MDMarkdownGenerator *generator = [[PDF22MDMarkdownGenerator alloc] initWithOptions:options];
    PDF22MDDocumentMetadata *metadata = [PDF22MDMarkdownGenerator extractMetadataFromDocument:self.document];
    
    NSString *markdown = [generator generateMarkdownFromElements:self.allElements withMetadata:metadata];
    
    return markdown;
}

- (void)sortElements {
    [self.allElements sortUsingComparator:^NSComparisonResult(id<PDF22MDContentElement> obj1, id<PDF22MDContentElement> obj2) {
        // First sort by page
        if (obj1.pageIndex != obj2.pageIndex) {
            return obj1.pageIndex < obj2.pageIndex ? NSOrderedAscending : NSOrderedDescending;
        }
        
        // Then sort by vertical position (top to bottom)
        CGFloat y1 = CGRectGetMaxY(obj1.bounds);
        CGFloat y2 = CGRectGetMaxY(obj2.bounds);
        
        if (fabs(y1 - y2) > 5.0) { // Tolerance for same line
            return y1 > y2 ? NSOrderedAscending : NSOrderedDescending;
        }
        
        // Finally sort by horizontal position (left to right)
        CGFloat x1 = CGRectGetMinX(obj1.bounds);
        CGFloat x2 = CGRectGetMinX(obj2.bounds);
        
        return x1 < x2 ? NSOrderedAscending : NSOrderedDescending;
    }];
}

- (void)extractImagesWithAssetManager:(PDF22MDAssetManager *)assetManager {
    NSMutableArray<PDF22MDImageElement *> *imageElements = [NSMutableArray array];
    
    for (id<PDF22MDContentElement> element in self.allElements) {
        if ([element isKindOfClass:[PDF22MDImageElement class]]) {
            [imageElements addObject:(PDF22MDImageElement *)element];
        }
    }
    
    if (imageElements.count == 0) {
        return;
    }
    
    // Save images in parallel
    dispatch_group_t imageGroup = dispatch_group_create();
    dispatch_queue_t imageQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    
    [imageElements enumerateObjectsUsingBlock:^(PDF22MDImageElement *imageElement, NSUInteger idx, BOOL * __unused stop) {
        dispatch_group_async(imageGroup, imageQueue, ^{
            @autoreleasepool {
                NSString *baseName = [NSString stringWithFormat:@"image_%03lu", (unsigned long)idx];
                [assetManager saveImageElement:imageElement withBaseName:baseName];
            }
        });
    }];
    
    dispatch_group_wait(imageGroup, DISPATCH_TIME_FOREVER);
}

@end
</file>

<file path="pdf22md-objc/src/Core/PDF22MDError.h">
#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

/**
 * Error domain for all PDF22MD errors.
 */
extern NSErrorDomain const PDF22MDErrorDomain;

/**
 * Error codes used throughout the PDF22MD framework.
 */
typedef NS_ERROR_ENUM(PDF22MDErrorDomain, PDF22MDError) {
    /**
     * The provided PDF file or data is invalid or corrupted.
     */
    PDF22MDErrorInvalidPDF = 1000,
    
    /**
     * Failed to create the assets folder or save extracted images.
     */
    PDF22MDErrorAssetFolderCreation = 1001,
    
    /**
     * General processing failure during conversion.
     */
    PDF22MDErrorProcessingFailed = 1002,
    
    /**
     * One or more pages failed to process.
     */
    PDF22MDErrorPageProcessingFailed = 1003,
    
    /**
     * Invalid or missing configuration options.
     */
    PDF22MDErrorInvalidConfiguration = 1004,
    
    /**
     * I/O error reading or writing files.
     */
    PDF22MDErrorIOFailure = 1005,
    
    /**
     * Memory allocation failure or insufficient memory to process PDF.
     */
    PDF22MDErrorMemoryPressure = 1006,
    
    /**
     * Operation was cancelled.
     */
    PDF22MDErrorCancelled = 1007,
    
    /**
     * PDF processing timed out (document too complex).
     */
    PDF22MDErrorProcessingTimeout = 1008,
    
    /**
     * Password-protected PDFs are not currently supported.
     */
    PDF22MDErrorEncryptedPDF = 1009,
    
    /**
     * The PDF contains no readable content.
     */
    PDF22MDErrorEmptyDocument = 1010,
    
    /**
     * Invalid input parameters provided.
     */
    PDF22MDErrorInvalidInput = 1011,
    
    /**
     * File not found at specified path.
     */
    PDF22MDErrorFileNotFound = 1012
};

/**
 * Keys for additional information in error's userInfo dictionary.
 */
extern NSString * const PDF22MDErrorPageIndexKey;      // NSNumber containing the failed page index
extern NSString * const PDF22MDErrorFilePathKey;       // NSString containing the problematic file path
extern NSString * const PDF22MDErrorUnderlyingErrorKey; // Original NSError that caused this error

/**
 * Helper class for creating consistent, user-friendly error objects.
 */
@interface PDF22MDErrorHelper : NSObject

/**
 * Creates a user-friendly error with code, description, and actionable suggestion.
 */
+ (NSError *)userFriendlyErrorWithCode:(PDF22MDError)code 
                           description:(NSString *)description
                            suggestion:(nullable NSString *)suggestion
                       underlyingError:(nullable NSError *)underlyingError;

/**
 * Creates an error for invalid PDF input.
 */
+ (NSError *)invalidPDFError;

/**
 * Creates an error for invalid PDF input with additional details.
 */
+ (NSError *)invalidPDFErrorWithReason:(nullable NSString *)reason;

/**
 * Creates an error for file not found.
 */
+ (NSError *)fileNotFoundErrorWithPath:(NSString *)path;

/**
 * Creates an error for invalid input parameters.
 */
+ (NSError *)invalidInputErrorWithReason:(NSString *)reason;

/**
 * Creates an error for asset folder creation failure.
 */
+ (NSError *)assetFolderCreationErrorWithPath:(NSString *)path 
                                       reason:(nullable NSString *)reason;

/**
 * Creates an error for memory pressure.
 */
+ (NSError *)memoryPressureError;

/**
 * Creates an error for processing timeout.
 */
+ (NSError *)processingTimeoutError;

/**
 * Creates an error for encrypted PDF.
 */
+ (NSError *)encryptedPDFError;

/**
 * Creates an error for empty document.
 */
+ (NSError *)emptyDocumentError;

/**
 * Creates an error for page processing failure.
 */
+ (NSError *)pageProcessingFailedErrorForPage:(NSInteger)pageIndex 
                                        reason:(nullable NSString *)reason
                               underlyingError:(nullable NSError *)underlyingError;

/**
 * Creates an error for general processing failure.
 */
+ (NSError *)processingFailedErrorWithReason:(NSString *)reason 
                              underlyingError:(nullable NSError *)underlyingError;

/**
 * Creates an error for I/O failure.
 */
+ (NSError *)ioFailureErrorWithPath:(nullable NSString *)path 
                              reason:(NSString *)reason
                     underlyingError:(nullable NSError *)underlyingError;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/Core/PDF22MDError.m">
#import "PDF22MDError.h"

NSErrorDomain const PDF22MDErrorDomain = @"com.twardoch.pdf22md.ErrorDomain";

NSString * const PDF22MDErrorPageIndexKey = @"PDF22MDErrorPageIndex";
NSString * const PDF22MDErrorFilePathKey = @"PDF22MDErrorFilePath";
NSString * const PDF22MDErrorUnderlyingErrorKey = @"PDF22MDErrorUnderlyingError";

@implementation PDF22MDErrorHelper

+ (NSError *)userFriendlyErrorWithCode:(PDF22MDError)code 
                           description:(NSString *)description
                            suggestion:(nullable NSString *)suggestion
                       underlyingError:(nullable NSError *)underlyingError {
    NSMutableDictionary *userInfo = [@{
        NSLocalizedDescriptionKey: description,
        NSLocalizedFailureReasonErrorKey: description
    } mutableCopy];
    
    if (suggestion) {
        userInfo[NSLocalizedRecoverySuggestionErrorKey] = suggestion;
    }
    
    if (underlyingError) {
        userInfo[NSUnderlyingErrorKey] = underlyingError;
        userInfo[PDF22MDErrorUnderlyingErrorKey] = underlyingError;
    }
    
    return [NSError errorWithDomain:PDF22MDErrorDomain
                               code:code
                           userInfo:userInfo];
}

+ (NSError *)invalidPDFError {
    return [self invalidPDFErrorWithReason:nil];
}

+ (NSError *)invalidPDFErrorWithReason:(nullable NSString *)reason {
    NSString *description = reason ?: @"The PDF file appears to be corrupted or invalid";
    NSString *suggestion = @"Ensure the file is a valid PDF document. Try opening it in another PDF viewer to verify it's not corrupted.";
    
    return [self userFriendlyErrorWithCode:PDF22MDErrorInvalidPDF
                               description:description
                                suggestion:suggestion
                           underlyingError:nil];
}

+ (NSError *)fileNotFoundErrorWithPath:(NSString *)path {
    NSString *description = [NSString stringWithFormat:@"File not found: %@", path];
    NSString *suggestion = @"Check that the file path is correct and the file exists.";
    
    NSError *error = [self userFriendlyErrorWithCode:PDF22MDErrorFileNotFound
                                         description:description
                                          suggestion:suggestion
                                     underlyingError:nil];
    
    NSMutableDictionary *userInfo = [error.userInfo mutableCopy];
    userInfo[PDF22MDErrorFilePathKey] = path;
    
    return [NSError errorWithDomain:PDF22MDErrorDomain
                               code:PDF22MDErrorFileNotFound
                           userInfo:userInfo];
}

+ (NSError *)invalidInputErrorWithReason:(NSString *)reason {
    NSString *description = [NSString stringWithFormat:@"Invalid input: %@", reason];
    NSString *suggestion = @"Check the command line arguments and ensure all required parameters are provided correctly.";
    
    return [self userFriendlyErrorWithCode:PDF22MDErrorInvalidInput
                               description:description
                                suggestion:suggestion
                           underlyingError:nil];
}

+ (NSError *)assetFolderCreationErrorWithPath:(NSString *)path 
                                       reason:(nullable NSString *)reason {
    NSString *description = reason ?: @"Could not create assets folder at specified path";
    NSString *suggestion = @"Ensure you have write permissions to the target directory and sufficient disk space.";
    
    NSError *error = [self userFriendlyErrorWithCode:PDF22MDErrorAssetFolderCreation
                                         description:description
                                          suggestion:suggestion
                                     underlyingError:nil];
    
    NSMutableDictionary *userInfo = [error.userInfo mutableCopy];
    userInfo[PDF22MDErrorFilePathKey] = path;
    
    return [NSError errorWithDomain:PDF22MDErrorDomain
                               code:PDF22MDErrorAssetFolderCreation
                           userInfo:userInfo];
}

+ (NSError *)memoryPressureError {
    NSString *description = @"Insufficient memory to process this PDF";
    NSString *suggestion = @"Try processing a smaller PDF or close other applications to free up memory. For very large documents, consider splitting them into smaller files.";
    
    return [self userFriendlyErrorWithCode:PDF22MDErrorMemoryPressure
                               description:description
                                suggestion:suggestion
                           underlyingError:nil];
}

+ (NSError *)processingTimeoutError {
    NSString *description = @"PDF processing timed out (document too complex)";
    NSString *suggestion = @"The PDF may be extremely large or complex. Try processing smaller sections or contact support if this persists.";
    
    return [self userFriendlyErrorWithCode:PDF22MDErrorProcessingTimeout
                               description:description
                                suggestion:suggestion
                           underlyingError:nil];
}

+ (NSError *)encryptedPDFError {
    NSString *description = @"Password-protected PDFs are not currently supported";
    NSString *suggestion = @"Please remove the password protection from the PDF using another tool before conversion.";
    
    return [self userFriendlyErrorWithCode:PDF22MDErrorEncryptedPDF
                               description:description
                                suggestion:suggestion
                           underlyingError:nil];
}

+ (NSError *)emptyDocumentError {
    NSString *description = @"The PDF contains no readable content";
    NSString *suggestion = @"The PDF may be empty, contain only images without text, or have text in an unsupported format.";
    
    return [self userFriendlyErrorWithCode:PDF22MDErrorEmptyDocument
                               description:description
                                suggestion:suggestion
                           underlyingError:nil];
}

+ (NSError *)assetCreationFailedErrorWithPath:(NSString *)path 
                                         reason:(nullable NSString *)reason {
    // This method is deprecated in favor of assetFolderCreationErrorWithPath:reason:
    return [self assetFolderCreationErrorWithPath:path reason:reason];
}

+ (NSError *)pageProcessingFailedErrorForPage:(NSInteger)pageIndex 
                                        reason:(nullable NSString *)reason
                               underlyingError:(nullable NSError *)underlyingError {
    NSString *description = [NSString stringWithFormat:@"Failed to process page %ld", (long)(pageIndex + 1)];
    NSString *failureReason = reason ?: @"An error occurred while extracting content from the page";
    
    NSMutableDictionary *userInfo = [@{
        NSLocalizedDescriptionKey: description,
        NSLocalizedFailureReasonErrorKey: failureReason,
        NSLocalizedRecoverySuggestionErrorKey: @"The page may contain unsupported content or be corrupted",
        PDF22MDErrorPageIndexKey: @(pageIndex)
    } mutableCopy];
    
    if (underlyingError) {
        userInfo[NSUnderlyingErrorKey] = underlyingError;
        userInfo[PDF22MDErrorUnderlyingErrorKey] = underlyingError;
    }
    
    return [NSError errorWithDomain:PDF22MDErrorDomain
                               code:PDF22MDErrorPageProcessingFailed
                           userInfo:userInfo];
}

+ (NSError *)processingFailedErrorWithReason:(NSString *)reason 
                              underlyingError:(nullable NSError *)underlyingError {
    NSString *description = @"PDF processing failed";
    
    NSMutableDictionary *userInfo = [@{
        NSLocalizedDescriptionKey: description,
        NSLocalizedFailureReasonErrorKey: reason,
        NSLocalizedRecoverySuggestionErrorKey: @"Check the input file and try again"
    } mutableCopy];
    
    if (underlyingError) {
        userInfo[NSUnderlyingErrorKey] = underlyingError;
        userInfo[PDF22MDErrorUnderlyingErrorKey] = underlyingError;
    }
    
    return [NSError errorWithDomain:PDF22MDErrorDomain
                               code:PDF22MDErrorProcessingFailed
                           userInfo:userInfo];
}

+ (NSError *)ioFailureErrorWithPath:(nullable NSString *)path 
                              reason:(NSString *)reason
                     underlyingError:(nullable NSError *)underlyingError {
    NSString *description = @"File I/O operation failed";
    
    NSMutableDictionary *userInfo = [@{
        NSLocalizedDescriptionKey: description,
        NSLocalizedFailureReasonErrorKey: reason,
        NSLocalizedRecoverySuggestionErrorKey: @"Check file permissions and available disk space"
    } mutableCopy];
    
    if (path) {
        userInfo[PDF22MDErrorFilePathKey] = path;
    }
    
    if (underlyingError) {
        userInfo[NSUnderlyingErrorKey] = underlyingError;
        userInfo[PDF22MDErrorUnderlyingErrorKey] = underlyingError;
    }
    
    return [NSError errorWithDomain:PDF22MDErrorDomain
                               code:PDF22MDErrorIOFailure
                           userInfo:userInfo];
}

@end
</file>

<file path="pdf22md-objc/README.md">
# pdf22md - Modern Objective-C Implementation

A high-performance PDF to Markdown converter built with modern Objective-C patterns and best practices.

## Features

- **Modern Objective-C**: Uses nullability annotations, lightweight generics, and designated initializers
- **Thread-Safe**: Concurrent page processing with GCD and proper synchronization
- **Memory Efficient**: Automatic reference counting with strategic use of autorelease pools
- **Error Handling**: Comprehensive error reporting with custom error domain
- **Progress Tracking**: NSProgress integration for monitoring conversion status
- **Modular Architecture**: Clean separation of concerns with protocols and services

## Architecture

```
pdf22md-objc/
├── src/
│   ├── Core/                    # Core conversion logic
│   │   ├── PDF22MDConverter     # Main coordinator
│   │   ├── PDF22MDPageProcessor # Page content extraction
│   │   ├── PDF22MDFontAnalyzer  # Heading detection
│   │   └── PDF22MDError         # Error handling
│   ├── Models/                  # Data models
│   │   ├── PDF22MDContentElement # Protocol definition
│   │   ├── PDF22MDTextElement   # Text content
│   │   └── PDF22MDImageElement  # Image content
│   ├── Services/                # Business logic services
│   │   ├── PDF22MDAssetManager  # Image extraction/saving
│   │   └── PDF22MDMarkdownGenerator # Markdown generation
│   └── CLI/                     # Command-line interface
│       └── main.m
```

## Building

### Using the Build Script (Recommended)
```bash
# Build the project
./build.sh

# Build and run tests
./build.sh --test

# Build and install to /usr/local/bin
./build.sh --install

# Build, test, and install
./build.sh --test --install
```

### Using Make Directly
```bash
# Build with make
make

# Build with custom version
make VERSION=1.2.3

# Clean build artifacts
make clean

# Install to /usr/local/bin
sudo make install
```

## Usage

```bash
# Convert a PDF file
./pdf22md -i document.pdf -o document.md

# Extract images to assets folder
./pdf22md -i report.pdf -o report.md -a ./assets

# Customize DPI for vector graphics
./pdf22md -i presentation.pdf -o presentation.md -a ./images -d 300

# Use with pipes
cat document.pdf | ./pdf22md > document.md
```

## Key Implementation Details

### Thread Safety
- Uses dispatch queues for concurrent page processing
- Thread-safe collections with `@synchronized` blocks
- Atomic property access for shared state

### Memory Management
- ARC-enabled with proper ownership semantics
- Strategic `@autoreleasepool` blocks in loops
- Manual Core Graphics memory management where needed

### Error Handling
```objc
typedef NS_ERROR_ENUM(PDF22MDErrorDomain, PDF22MDError) {
    PDF22MDErrorInvalidPDF = 1000,
    PDF22MDErrorAssetCreationFailed,
    PDF22MDErrorProcessingFailed,
    // ...
};
```

### Progress Reporting
```objc
builder.progressHandler = ^(NSInteger currentPage, NSInteger totalPages) {
    NSLog(@"Processing page %ld of %ld", currentPage, totalPages);
};
```

## Modern Objective-C Features Used

1. **Nullability Annotations**
   - `NS_ASSUME_NONNULL_BEGIN/END`
   - `nullable` and `nonnull` qualifiers

2. **Lightweight Generics**
   - `NSArray<id<PDF22MDContentElement>> *`
   - `NSDictionary<NSString *, NSNumber *> *`

3. **Designated Initializers**
   - `NS_DESIGNATED_INITIALIZER`
   - `NS_UNAVAILABLE` for unsupported initializers

4. **Property Attributes**
   - Proper use of `copy`, `strong`, `weak`, `readonly`

5. **Modern Enumerations**
   - `NS_ENUM` and `NS_ERROR_ENUM` macros

## Testing

```bash
# Run basic tests
make test

# Test with sample PDFs
./pdf22md -i ../test/sample.pdf -o output.md -a ./test-assets
```

## Performance

- Utilizes all available CPU cores via GCD
- Concurrent image extraction and saving
- Memory-efficient streaming for large PDFs
- Optimized font analysis with caching

## Requirements

- macOS 10.15 or later
- Xcode Command Line Tools
- ARC enabled

## License

MIT License - see LICENSE file in the root directory
</file>

<file path="pdf22md-swift/build.sh">
#!/bin/bash

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Print functions
print_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
print_warning() { echo -e "${YELLOW}[WARN]${NC} $1"; }
print_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Check for required tools
check_requirements() {
    local missing_tools=()

    if ! command -v swift &>/dev/null; then
        missing_tools+=("swift")
    fi

    if [ ${#missing_tools[@]} -ne 0 ]; then
        print_error "Missing required tools: ${missing_tools[*]}"
        print_info "Please install Xcode Command Line Tools:"
        print_info "xcode-select --install"
        exit 1
    fi
}

# Build pdf22md-swift
build_swift() {
    print_info "Building pdf22md (Swift implementation)..."
    
    # Clean previous builds
    if [ -d ".build" ]; then
        rm -rf .build
        print_info "Cleaned previous build artifacts"
    fi
    
    # Try to detect and fix Swift toolchain issues
    print_info "Checking Swift toolchain..."
    
    # Check for SWBBuildService.framework issue
    local swift_build_output
    swift_build_output=$(swift build -c release 2>&1)
    local exit_code=$?
    
    if [ $exit_code -eq 0 ]; then
        print_info "✓ pdf22md-swift built successfully"
        return 0
    elif echo "$swift_build_output" | grep -q "SWBBuildService.framework"; then
        print_error "Swift Package Manager framework missing: SWBBuildService.framework"
        print_warning "This is a known issue with Command Line Tools installation"
        print_info ""
        print_info "To fix this issue, try ONE of these solutions:"
        print_info ""
        print_info "Option 1: If you have Xcode installed"
        print_info "  sudo xcode-select -s /Applications/Xcode.app/Contents/Developer"
        print_info ""
        print_info "Option 2: Reinstall Command Line Tools"
        print_info "  sudo rm -rf /Library/Developer/CommandLineTools"
        print_info "  xcode-select --install"
        print_info ""
        print_info "Option 3: Use the Objective-C implementation instead"
        print_info "  ./build.sh --objc-only"
        return 1
    else
        # Show the actual error
        print_error "Swift build failed with error:"
        echo "$swift_build_output" | tail -n 20
        return 1
    fi
}

# Install binary
install_binary() {
    local install_dir="/usr/local/bin"
    print_info "Installing binary to $install_dir..."

    # Create install directory if it doesn't exist
    sudo mkdir -p "$install_dir"

    # Install pdf22md
    if [ -f ".build/release/pdf22md" ]; then
        sudo install -m 755 .build/release/pdf22md "$install_dir/pdf22md-swift"
        print_info "✓ Installed pdf22md-swift"
    else
        print_error "Built binary not found at .build/release/pdf22md"
        return 1
    fi

    # Install man pages
    if [ -f "docs/pdf22md.1" ]; then
        sudo mkdir -p /usr/local/share/man/man1
        sudo install -m 644 docs/pdf22md.1 /usr/local/share/man/man1/
        print_info "✓ Installed man pages"
    fi
}

# Run tests
run_tests() {
    print_info "Running Swift tests..."
    if swift test; then
        print_info "✓ Swift tests passed"
        return 0
    else
        print_error "Swift tests failed"
        return 1
    fi
}

# Create local binary symlink for development
create_dev_link() {
    if [ -f ".build/release/pdf22md" ]; then
        ln -sf .build/release/pdf22md pdf22md
        print_info "✓ Created development symlink './pdf22md'"
    fi
}

# Main execution
main() {
    print_info "Starting pdf22md-swift build process..."

    # Check requirements
    check_requirements

    # Build component
    if ! build_swift; then
        exit 1
    fi

    # Create development symlink
    create_dev_link

    # Run tests if requested
    if [ "$1" = "--test" ] || [ "$2" = "--test" ]; then
        if ! run_tests; then
            print_warning "Tests failed, but build completed"
        fi
    fi

    # Install if requested
    if [ "$1" = "--install" ] || [ "$2" = "--install" ]; then
        install_binary
    fi

    print_info "Build complete!"
    print_info "Run './pdf22md --help' for usage information"
    print_info "Or run 'swift run pdf22md --help' to use Swift Package Manager directly"
}

main "$@"
</file>

<file path="pdf22md-swift/README.md">
# pdf22md - Modern Swift Implementation

A high-performance PDF to Markdown converter built with modern Swift features including async/await, actors, and structured concurrency.

## Features

- **Modern Swift**: Uses Swift 5.7+ features including async/await, actors, and result builders
- **Structured Concurrency**: Concurrent page processing with TaskGroup and proper cancellation
- **Memory Safe**: Automatic memory management with value types where appropriate
- **Type Safe**: Strong typing with enums, associated types, and generic constraints
- **Actor-Based Assets**: Thread-safe image processing with actors
- **Progress Streaming**: Real-time progress updates with AsyncSequence

## Architecture

```
pdf22md-swift/
├── Sources/
│   ├── PDF22MD/                 # Library module
│   │   ├── Core/                # Core conversion logic
│   │   │   ├── PDFConverter     # Main coordinator
│   │   │   ├── PDFPageProcessor # Page content extraction
│   │   │   ├── FontAnalyzer     # Heading detection
│   │   │   ├── PDFError         # Error handling
│   │   │   └── ConversionOptions # Configuration
│   │   ├── Models/              # Data models
│   │   │   ├── ContentElement   # Protocol definition
│   │   │   ├── TextElement      # Text content (struct)
│   │   │   └── ImageElement     # Image content (class)
│   │   └── Services/            # Business logic services
│   │       ├── AssetManager     # Image extraction (actor)
│   │       └── MarkdownGenerator # Markdown generation
│   └── pdf22md/                 # CLI executable
│       └── main.swift
├── Tests/
│   └── PDF22MDTests/
├── Package.swift
└── README.md
```

## Building

### Using the Build Script (Recommended)
```bash
# Build the project
./build.sh

# Build and run tests
./build.sh --test

# Build and install to /usr/local/bin
./build.sh --install

# Build, test, and install
./build.sh --test --install

# Create release archive
./release.sh
```

### Using Swift Package Manager Directly
```bash
# Build with Swift Package Manager
swift build

# Build optimized release
swift build -c release

# Run tests
swift test

# Generate documentation
swift package generate-documentation
```

## Installation

### Swift Package Manager

Add to your `Package.swift`:

```swift
dependencies: [
    .package(url: "https://github.com/twardoch/pdf22md-swift", from: "1.0.0")
]
```

### Executable

```bash
# Build executable
swift build -c release

# Copy to PATH
cp .build/release/pdf22md /usr/local/bin/
```

## Usage

### Command Line

```bash
# Convert a PDF file
pdf22md -i document.pdf -o document.md

# Extract images to assets folder
pdf22md -i report.pdf -o report.md -a ./assets

# Customize DPI and concurrency
pdf22md -i large.pdf -o large.md -d 300 --max-concurrency 8

# Use with pipes
cat document.pdf | pdf22md > document.md

# Verbose output with progress
pdf22md -i document.pdf -o document.md --verbose
```

### Programmatic Usage

```swift
import PDF22MD

// Simple conversion
let converter = try PDFConverter(url: inputURL)
let markdown = try await converter.convert()

// With custom options
let options = ConversionOptions(
    assetsFolderPath: "./assets",
    rasterizationDPI: 300.0,
    includeMetadata: true
)

let markdown = try await converter.convert(options: options)

// Using builder pattern
let options = ConversionOptionsBuilder()
    .assetsFolderPath("./images")
    .rasterizationDPI(300)
    .maxConcurrentPages(4)
    .progressHandler { page, total in
        print("Processing \(page)/\(total)")
    }
    .build()

// Convenience method
try await PDFConverter.convert(
    inputURL: inputURL,
    outputURL: outputURL,
    options: options
)
```

## Key Swift Features Used

### 1. Async/Await
```swift
public func convert(options: ConversionOptions = .default) async throws -> String {
    return try await withThrowingTaskGroup(of: (Int, [ContentElement]).self) { group in
        // Process pages concurrently
    }
}
```

### 2. Actors for Thread Safety
```swift
public actor AssetManager {
    private var usedFilenames: Set<String> = []
    
    public func saveImage(_ image: CGImage) async throws -> String {
        // Thread-safe image saving
    }
}
```

### 3. Result Types
```swift
public enum PDFError: LocalizedError {
    case invalidPDF(reason: String?)
    case processingFailed(reason: String, underlyingError: Error?)
    // ...
}
```

### 4. Value Types
```swift
public struct TextElement: ContentElement, Equatable, Hashable {
    public let text: String
    public let bounds: CGRect
    // Immutable by default
}
```

### 5. Protocol Extensions
```swift
public extension ContentElement {
    func isOnSameLine(as other: ContentElement) -> Bool {
        // Default implementation
    }
}
```

### 6. Structured Concurrency
```swift
return try await withThrowingTaskGroup(of: (Int, [ContentElement]).self) { group in
    for pageIndex in 0..<pageCount {
        group.addTask {
            // Process page concurrently
        }
    }
    // Collect results
}
```

## Testing

```bash
# Run all tests
swift test

# Run specific test
swift test --filter PDF22MDTests.testTextElementCreation

# Run tests with coverage
swift test --enable-code-coverage

# Performance tests
swift test --filter Performance
```

## Performance

- Utilizes all available CPU cores with structured concurrency
- Actor-based asset management for thread-safe operations
- Memory-efficient with proper value/reference type usage
- Cancellation support for long-running operations
- Streaming progress updates

## Error Handling

```swift
do {
    let markdown = try await converter.convert()
} catch PDFError.invalidPDF(let reason) {
    print("Invalid PDF: \(reason ?? "Unknown error")")
} catch PDFError.processingFailed(let reason, let underlying) {
    print("Processing failed: \(reason)")
    if let underlying = underlying {
        print("Underlying error: \(underlying)")
    }
} catch {
    print("Unexpected error: \(error)")
}
```

## Requirements

- macOS 12.0 or later (for async/await)
- Swift 5.7 or later
- Xcode 14.0 or later

## Documentation

Generate documentation with:

```bash
swift package generate-documentation
```

View documentation:

```bash
swift package preview-documentation
```

## License

MIT License - see LICENSE file in the root directory
</file>

<file path=".gitignore">
# Build products
build/
*.o
pdf22md

# macOS
.DS_Store
.AppleDouble
.LSOverride

# Thumbnails
._*

# Files that might appear on external disk
.Spotlight-V100
.Trashes

# Editor-specific
.vscode/
*.swp
.idea/
*.xcodeproj/
*.xcworkspace/

# Cursor and other AI assistants
.cursor/
.cursorrules
.cursorindexingignore
.giga/
.specstory/

# Test artifacts
test/out/
*.md
!README.md
!TODO.md
!CLAUDE.md
!AGENTS.md
!CHANGELOG.md
!docs/*.md
</file>

<file path="build.sh">
#!/bin/bash

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Print functions
print_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
print_warning() { echo -e "${YELLOW}[WARN]${NC} $1"; }
print_error() { echo -e "${RED}[ERROR]${NC} $1"; }
print_header() { echo -e "${BLUE}[BUILD]${NC} $1"; }

# Track build results
build_results_objc=0
build_results_swift=0

# Check for required tools
check_requirements() {
    local missing_tools=()

    if ! command -v clang &>/dev/null; then
        missing_tools+=("clang")
    fi

    if ! command -v swift &>/dev/null; then
        missing_tools+=("swift")
    fi

    if ! command -v make &>/dev/null; then
        missing_tools+=("make")
    fi

    if [ ${#missing_tools[@]} -ne 0 ]; then
        print_error "Missing required tools: ${missing_tools[*]}"
        print_info "Please install Xcode Command Line Tools:"
        print_info "xcode-select --install"
        exit 1
    fi
}

# Build pdf22md-objc
build_objc() {
    print_header "Building pdf22md-objc..."
    
    if [ ! -d "pdf22md-objc" ]; then
        print_error "pdf22md-objc directory not found"
        build_results_objc=1
        return 1
    fi
    
    cd pdf22md-objc
    
    # Build with options
    local build_cmd="./build.sh"
    if [ "$RUN_TESTS" = "true" ]; then
        build_cmd="$build_cmd --test"
    fi
    if [ "$INSTALL_BINARIES" = "true" ]; then
        build_cmd="$build_cmd --install"
    fi
    
    if $build_cmd; then
        print_info "✓ pdf22md-objc built successfully"
        build_results_objc=0
    else
        print_error "✗ pdf22md-objc build failed"
        build_results_objc=1
    fi
    
    cd ..
    return $build_results_objc
}

# Build pdf22md-swift
build_swift() {
    print_header "Building pdf22md-swift..."
    
    if [ ! -d "pdf22md-swift" ]; then
        print_error "pdf22md-swift directory not found"
        build_results_swift=1
        return 1
    fi
    
    # Check if Swift toolchain is functional before attempting build
    if ! swift --version >/dev/null 2>&1; then
        print_error "Swift toolchain appears to be corrupted or missing"
        print_warning "Skipping Swift build. Install/repair Xcode Command Line Tools:"
        print_info "  xcode-select --install"
        build_results_swift=1
        return 1
    fi
    
    # Check for Swift Package Manager functionality
    if ! swift package --version >/dev/null 2>&1; then
        print_error "Swift Package Manager is not functional"
        print_warning "This is often due to missing SWBBuildService.framework"
        print_info "Possible solutions:"
        print_info "  1. Run: xcode-select --install"
        print_info "  2. If you have Xcode installed: sudo xcode-select -s /Applications/Xcode.app"
        print_info "  3. Reinstall Command Line Tools completely:"
        print_info "     sudo rm -rf /Library/Developer/CommandLineTools"
        print_info "     xcode-select --install"
        build_results_swift=1
        return 1
    fi
    
    cd pdf22md-swift
    
    # Build with options
    local build_cmd="./build.sh"
    if [ "$RUN_TESTS" = "true" ]; then
        build_cmd="$build_cmd --test"
    fi
    if [ "$INSTALL_BINARIES" = "true" ]; then
        build_cmd="$build_cmd --install"
    fi
    
    if $build_cmd; then
        print_info "✓ pdf22md-swift built successfully"
        build_results_swift=0
    else
        print_error "✗ pdf22md-swift build failed"
        print_warning "Swift toolchain may be corrupted. Try:"
        print_info "  xcode-select --install"
        build_results_swift=1
    fi
    
    cd ..
    return $build_results_swift
}

# Create release archives
create_releases() {
    print_header "Creating release archives..."
    
    # Create Swift release
    if [ $build_results_swift -eq 0 ]; then
        cd pdf22md-swift
        if ./release.sh; then
            print_info "✓ Swift release archive created"
        else
            print_warning "Swift release archive creation failed"
        fi
        cd ..
    fi
    
    # Create Objective-C release (manual process since no release.sh)
    if [ $build_results_objc -eq 0 ]; then
        print_info "Objective-C binary available at: pdf22md-objc/pdf22md"
    fi
}

# Show build summary
show_summary() {
    print_header "Build Summary"
    
    local total_success=0
    local total_builds=0
    
    if [ "$BUILD_OBJC" = "true" ]; then
        total_builds=$((total_builds + 1))
        if [ $build_results_objc -eq 0 ]; then
            print_info "✓ pdf22md-objc: SUCCESS"
            total_success=$((total_success + 1))
        else
            print_error "✗ pdf22md-objc: FAILED"
        fi
    fi
    
    if [ "$BUILD_SWIFT" = "true" ]; then
        total_builds=$((total_builds + 1))
        if [ $build_results_swift -eq 0 ]; then
            print_info "✓ pdf22md-swift: SUCCESS"
            total_success=$((total_success + 1))
        else
            print_error "✗ pdf22md-swift: FAILED"
        fi
    fi
    
    echo ""
    if [ $total_success -eq $total_builds ]; then
        print_info "🎉 All builds completed successfully! ($total_success/$total_builds)"
        
        if [ "$INSTALL_BINARIES" = "true" ]; then
            echo ""
            print_info "Installed binaries:"
            if [ $build_results_objc -eq 0 ]; then
                print_info "  - pdf22md (Objective-C implementation)"
            fi
            if [ $build_results_swift -eq 0 ]; then
                print_info "  - pdf22md-swift (Swift implementation)"
            fi
            print_info "Run 'man pdf22md' for usage information"
        else
            echo ""
            print_info "Built binaries:"
            if [ $build_results_objc -eq 0 ]; then
                print_info "  - pdf22md-objc/pdf22md"
            fi
            if [ $build_results_swift -eq 0 ]; then
                print_info "  - pdf22md-swift/.build/release/pdf22md"
            fi
        fi
    else
        print_error "Some builds failed ($total_success/$total_builds successful)"
        exit 1
    fi
}

# Show usage information
show_usage() {
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  --test              Run tests after building"
    echo "  --install           Install binaries to /usr/local/bin"
    echo "  --release           Create release archives"
    echo "  --objc-only         Build only Objective-C implementation"
    echo "  --swift-only        Build only Swift implementation"
    echo "  --help              Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0                  # Build both implementations"
    echo "  $0 --test           # Build and test both implementations"
    echo "  $0 --install        # Build and install both implementations"
    echo "  $0 --test --install # Build, test, and install both implementations"
    echo "  $0 --objc-only      # Build only Objective-C implementation"
    echo "  $0 --release        # Build both and create release archives"
}

# Parse command line arguments
parse_args() {
    RUN_TESTS=false
    INSTALL_BINARIES=false
    CREATE_RELEASES=false
    BUILD_OBJC=true
    BUILD_SWIFT=true
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --test)
                RUN_TESTS=true
                shift
                ;;
            --install)
                INSTALL_BINARIES=true
                shift
                ;;
            --release)
                CREATE_RELEASES=true
                shift
                ;;
            --objc-only)
                BUILD_OBJC=true
                BUILD_SWIFT=false
                shift
                ;;
            --swift-only)
                BUILD_OBJC=false
                BUILD_SWIFT=true
                shift
                ;;
            --help)
                show_usage
                exit 0
                ;;
            *)
                print_error "Unknown option: $1"
                show_usage
                exit 1
                ;;
        esac
    done
}

# Main execution
main() {
    parse_args "$@"
    
    print_header "pdf22md - Multi-Implementation Build System"
    print_info "Building$([ "$BUILD_OBJC" = "true" ] && echo " Objective-C")$([ "$BUILD_SWIFT" = "true" ] && echo " Swift") implementation$([ "$BUILD_OBJC" = "true" ] && [ "$BUILD_SWIFT" = "true" ] && echo "s")"
    
    # Check requirements
    check_requirements
    
    # Build implementations
    if [ "$BUILD_OBJC" = "true" ]; then
        build_objc
    fi
    
    if [ "$BUILD_SWIFT" = "true" ]; then
        build_swift
        # If Swift fails and we're building both, suggest continuing with Objective-C only
        if [ $build_results_swift -ne 0 ] && [ "$BUILD_OBJC" = "true" ] && [ $build_results_objc -eq 0 ]; then
            print_warning "Swift build failed but Objective-C build succeeded"
            print_info "The Objective-C implementation is fully functional"
        fi
    fi
    
    # Create releases if requested
    if [ "$CREATE_RELEASES" = "true" ]; then
        create_releases
    fi
    
    # Show summary
    show_summary
}

main "$@"
</file>

<file path="CLAUDE.md">
# pdf22md

A blazingly fast PDF to Markdown converter for macOS.

`pdf22md` is a command-line tool that extracts all text and image content from a PDF file and converts it into a clean Markdown document. It uses Grand Central Dispatch (GCD) to process pages and save images in parallel, making it exceptionally fast for multi-page documents.

### Key Features

  * **High-Speed Conversion**: Uses all available CPU cores to process PDF pages concurrently.
  * **Intelligent Heading Detection**: Analyzes font sizes and usage frequency to automatically format titles and headings (`#`, `##`, etc.).
  * **Asset Extraction**: Saves raster and vector images into a specified assets folder and links them correctly in the Markdown file.
  * **Smart Image Formatting**: Automatically chooses between JPEG (for photos) and PNG (for graphics with transparency) to optimize file size and quality.
  * **Flexible I/O**: Reads from a PDF file or `stdin` and writes to a Markdown file or `stdout`.
  * **Customizable Rasterization**: Allows setting a custom DPI for converting vector graphics to bitmaps.

### Installation

Once the Homebrew tap is set up (see plan below), installation is simple:

```bash
brew install <your-username>/pdf22md/pdf22md
```

### Building from Source

To build the project manually, you need Xcode Command Line Tools installed.

```bash
# Clone the repository (once it's public)
git clone https://github.com/<your-username>/pdf22md.git
cd pdf22md

# Compile the tool
make

# Install it to /usr/local/bin
sudo make install
```

### Usage

```
Usage: pdf22md [-i input.pdf] [-o output.md] [-a assets_folder] [-d dpi]
  Converts PDF documents to Markdown format
  -i <path>: Input PDF file (default: stdin)
  -o <path>: Output Markdown file (default: stdout)
  -a <path>: Assets folder for extracted images
  -d <dpi>: DPI for rasterizing vector graphics (default: 144)
```

**Example:**

```bash
# Convert a local PDF file and save images to an 'assets' folder
pdf22md -i report.pdf -o report.md -a ./assets
```

---


# main-overview

## Development Guidelines

- Only modify code directly relevant to the specific request. Avoid changing unrelated functionality.
- Never replace code with placeholders like `# ... rest of the processing ...`. Always include complete code.
- Break problems into smaller steps. Think through each step separately before implementing.
- Always provide a complete PLAN with REASONING based on evidence from code and logs before making changes.
- Explain your OBSERVATIONS clearly, then provide REASONING to identify the exact issue. Add console logs when needed to gather more information.


pdf22md is a PDF to Markdown converter that transforms PDF documents while preserving their semantic structure and content relationships.

Core Business Components:

1. Document Structure Analysis (Importance: 95)
- Hierarchical heading detection using font statistics
- Document structure preservation through positional element sorting
- Automated heading level assignment (H1-H6) based on font usage patterns

2. Content Classification System (Importance: 85)
- TextElement: Handles formatted text with style attributes
- ImageElement: Manages both raster and vector graphics
- Content relationship tracking between elements

3. Asset Processing Pipeline (Importance: 80)
- Intelligent format selection between PNG/JPEG based on:
  * Transparency detection
  * Color complexity analysis
  * Dimension-based optimization
- Asset extraction with maintained document references

4. PDF Content Processing (Importance: 90)
- Text styling and formatting context preservation
- Vector graphics path construction tracking
- Coordinate system transformation management
- Element bounds calculation for layout fidelity

Key Integration Points:

1. Content Extraction Layer
- Connects PDF parsing with markdown generation
- Maintains element relationships and hierarchy
- Preserves formatting context across transformations

2. Asset Management Layer
- Links extracted images with markdown references
- Maintains asset organization structure
- Handles format conversions while preserving quality

The system organizes business logic around content transformation pipelines while maintaining document semantic structure throughout the conversion process.

—— When you’re done with a round of updates, update CHANGELOG.md with the changes, remove done things from TODO.md, identify new things that need to be done and add them to TODO.md. Then build the app or run ./release.sh and then continue updates.
</file>

<file path="pdf22md-objc/src/CLI/pdf22md-benchmark.m">
//
//  pdf22md-benchmark.m
//  pdf22md Performance Benchmarking Tool
//
//  Comprehensive performance validation and benchmarking for pdf22md
//

#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>
#import <mach/mach.h>
#import <mach/mach_time.h>
#import "../Core/PDF22MDConverter.h"
#import "../Core/PDF22MDConversionOptions.h"
#import "../Core/PDF22MDError.h"

#ifndef VERSION
#define VERSION "1.0.0"
#endif

// ANSI color codes for output
#define COLOR_RESET   "\033[0m"
#define COLOR_RED     "\033[31m"
#define COLOR_GREEN   "\033[32m"
#define COLOR_YELLOW  "\033[33m"
#define COLOR_BLUE    "\033[34m"
#define COLOR_MAGENTA "\033[35m"
#define COLOR_CYAN    "\033[36m"

typedef struct {
    NSTimeInterval totalTime;
    NSTimeInterval conversionTime;
    NSTimeInterval markdownTime;
    NSTimeInterval assetTime;
    NSUInteger pageCount;
    NSUInteger imageCount;
    NSUInteger fileSize;
    NSUInteger outputSize;
    NSUInteger peakMemory;
    double pagesPerSecond;
    double mbPerSecond;
} BenchmarkResult;

@interface PDF22MDBenchmark : NSObject

@property (nonatomic, strong) NSMutableArray<NSValue *> *results;
@property (nonatomic, strong) NSString *corpusPath;
@property (nonatomic, strong) NSString *outputPath;
@property (nonatomic, assign) BOOL verbose;
@property (nonatomic, assign) BOOL compareMode;
@property (nonatomic, assign) BOOL memoryProfile;
@property (nonatomic, assign) NSInteger iterations;

- (void)runBenchmarks;
- (void)printResults;
- (void)saveResultsToJSON:(NSString *)path;
- (BenchmarkResult)benchmarkPDF:(NSString *)pdfPath;
- (NSUInteger)getCurrentMemoryUsage;
- (void)compareWithBaseline:(NSString *)baselinePath;

@end

@implementation PDF22MDBenchmark

- (instancetype)init {
    self = [super init];
    if (self) {
        _results = [NSMutableArray array];
        _iterations = 1;
        _verbose = NO;
        _compareMode = NO;
        _memoryProfile = NO;
    }
    return self;
}

- (void)runBenchmarks {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSArray<NSString *> *pdfFiles = nil;
    
    if (self.corpusPath) {
        BOOL isDirectory;
        if ([fileManager fileExistsAtPath:self.corpusPath isDirectory:&isDirectory]) {
            if (isDirectory) {
                // Benchmark all PDFs in corpus directory
                NSError *error = nil;
                NSArray *files = [fileManager contentsOfDirectoryAtPath:self.corpusPath error:&error];
                if (error) {
                    fprintf(stderr, "%sError reading corpus directory: %s%s\n", 
                            COLOR_RED, error.localizedDescription.UTF8String, COLOR_RESET);
                    return;
                }
                
                NSPredicate *pdfPredicate = [NSPredicate predicateWithFormat:@"SELF ENDSWITH '.pdf'"];
                pdfFiles = [[files filteredArrayUsingPredicate:pdfPredicate] 
                            sortedArrayUsingSelector:@selector(localizedStandardCompare:)];
                
                printf("%s📊 Benchmarking %lu PDFs from corpus%s\n", 
                       COLOR_CYAN, (unsigned long)pdfFiles.count, COLOR_RESET);
            } else {
                // Single file provided via corpus path
                pdfFiles = @[[self.corpusPath lastPathComponent]];
                self.corpusPath = [self.corpusPath stringByDeletingLastPathComponent];
                if (self.corpusPath.length == 0) {
                    self.corpusPath = @".";
                }
            }
        } else {
            fprintf(stderr, "%sError: Path not found: %s%s\n", 
                    COLOR_RED, self.corpusPath.UTF8String, COLOR_RESET);
            return;
        }
    } else {
        // Single file benchmark
        pdfFiles = @[@"test.pdf"];
    }
    
    printf("%s════════════════════════════════════════════════════════════════%s\n",
           COLOR_BLUE, COLOR_RESET);
    
    for (NSString *pdfFile in pdfFiles) {
        NSString *fullPath = self.corpusPath ? 
            [self.corpusPath stringByAppendingPathComponent:pdfFile] : pdfFile;
        
        if (![fileManager fileExistsAtPath:fullPath]) {
            fprintf(stderr, "%s⚠️  Skipping non-existent file: %s%s\n", 
                    COLOR_YELLOW, fullPath.UTF8String, COLOR_RESET);
            continue;
        }
        
        printf("\n%sBenchmarking: %s%s\n", COLOR_MAGENTA, pdfFile.UTF8String, COLOR_RESET);
        
        // Run multiple iterations for averaging
        BenchmarkResult avgResult = {0};
        NSMutableArray *iterationResults = [NSMutableArray array];
        
        for (NSInteger i = 0; i < self.iterations; i++) {
            if (self.iterations > 1) {
                printf("  Iteration %ld/%ld...\n", (long)(i + 1), (long)self.iterations);
            }
            
            BenchmarkResult result = [self benchmarkPDF:fullPath];
            [iterationResults addObject:[NSValue valueWithBytes:&result 
                                                        objCType:@encode(BenchmarkResult)]];
            
            // Accumulate for averaging
            avgResult.totalTime += result.totalTime;
            avgResult.conversionTime += result.conversionTime;
            avgResult.markdownTime += result.markdownTime;
            avgResult.assetTime += result.assetTime;
            avgResult.pageCount = result.pageCount;
            avgResult.imageCount = result.imageCount;
            avgResult.fileSize = result.fileSize;
            avgResult.outputSize += result.outputSize;
            avgResult.peakMemory = MAX(avgResult.peakMemory, result.peakMemory);
            
            // Cool down between iterations
            if (i < self.iterations - 1) {
                [NSThread sleepForTimeInterval:0.5];
            }
        }
        
        // Calculate averages
        avgResult.totalTime /= self.iterations;
        avgResult.conversionTime /= self.iterations;
        avgResult.markdownTime /= self.iterations;
        avgResult.assetTime /= self.iterations;
        avgResult.outputSize /= self.iterations;
        avgResult.pagesPerSecond = avgResult.pageCount / avgResult.totalTime;
        avgResult.mbPerSecond = (avgResult.fileSize / 1024.0 / 1024.0) / avgResult.totalTime;
        
        [self.results addObject:[NSValue valueWithBytes:&avgResult 
                                              objCType:@encode(BenchmarkResult)]];
        
        // Print immediate results
        [self printResult:avgResult forFile:pdfFile];
    }
    
    printf("%s════════════════════════════════════════════════════════════════%s\n\n",
           COLOR_BLUE, COLOR_RESET);
}

- (BenchmarkResult)benchmarkPDF:(NSString *)pdfPath {
    BenchmarkResult result = {0};
    
    // Get file size
    NSError *error = nil;
    NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:pdfPath error:&error];
    result.fileSize = [attrs[NSFileSize] unsignedIntegerValue];
    
    // Memory baseline
    NSUInteger memStart = [self getCurrentMemoryUsage];
    
    // Start total timing
    NSDate *startTime = [NSDate date];
    mach_timebase_info_data_t timebase;
    mach_timebase_info(&timebase);
    
    // Load PDF
    if (self.verbose) {
        printf("  Loading PDF from: %s\n", pdfPath.UTF8String);
    }
    
    NSURL *pdfURL = [NSURL fileURLWithPath:pdfPath];
    PDF22MDConverter *converter = [[PDF22MDConverter alloc] initWithPDFURL:pdfURL];
    
    if (!converter) {
        fprintf(stderr, "%sError: Failed to load PDF from %s%s\n", COLOR_RED, pdfPath.UTF8String, COLOR_RESET);
        return result;
    }
    
    result.pageCount = converter.document.pageCount;
    
    // Configure options using builder
    PDF22MDConversionOptionsBuilder *builder = [[PDF22MDConversionOptionsBuilder alloc] init];
    if (self.outputPath) {
        NSString *assetDir = [[self.outputPath stringByDeletingLastPathComponent] 
                              stringByAppendingPathComponent:@"benchmark-assets"];
        builder.assetsFolderPath = assetDir;
        builder.extractImages = YES;
    }
    builder.rasterizationDPI = 144.0;
    
    PDF22MDConversionOptions *options = [builder build];
    
    // Conversion timing
    uint64_t convStart = mach_absolute_time();
    __block NSString *markdown = nil;
    __block NSError *convError = nil;
    
    if (self.verbose) {
        printf("  Starting conversion with %lu pages...\n", (unsigned long)result.pageCount);
    }
    
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
    
    [converter convertWithOptions:options completion:^(NSString *output, NSError *error) {
        if (self.verbose) {
            if (error) {
                printf("  Conversion completed with error: %s\n", error.localizedDescription.UTF8String);
            } else {
                printf("  Conversion completed successfully, output length: %lu\n", (unsigned long)output.length);
            }
        }
        markdown = output;
        convError = error;
        dispatch_semaphore_signal(semaphore);
    }];
    
    // Wait with timeout
    dispatch_time_t timeout = dispatch_time(DISPATCH_TIME_NOW, 30 * NSEC_PER_SEC);
    if (dispatch_semaphore_wait(semaphore, timeout) != 0) {
        fprintf(stderr, "%sError: Conversion timed out after 30 seconds%s\n", COLOR_RED, COLOR_RESET);
        return result;
    }
    
    uint64_t convEnd = mach_absolute_time();
    
    // Calculate times
    result.conversionTime = (double)(convEnd - convStart) * timebase.numer / timebase.denom / 1e9;
    
    if (convError) {
        fprintf(stderr, "%sConversion error: %s%s\n", 
                COLOR_RED, convError.localizedDescription.UTF8String, COLOR_RESET);
        return result;
    }
    
    // Output size
    result.outputSize = [markdown lengthOfBytesUsingEncoding:NSUTF8StringEncoding];
    
    // Peak memory
    result.peakMemory = [self getCurrentMemoryUsage] - memStart;
    
    // Total time
    result.totalTime = -[startTime timeIntervalSinceNow];
    result.pagesPerSecond = result.pageCount / result.totalTime;
    result.mbPerSecond = (result.fileSize / 1024.0 / 1024.0) / result.totalTime;
    
    // Count images if assets were extracted
    if (options.assetsFolderPath) {
        NSArray *assets = [[NSFileManager defaultManager] 
                           contentsOfDirectoryAtPath:options.assetsFolderPath error:nil];
        result.imageCount = assets.count;
    }
    
    // Save output if requested
    if (self.outputPath && markdown) {
        [markdown writeToFile:self.outputPath 
                   atomically:YES 
                     encoding:NSUTF8StringEncoding 
                        error:nil];
    }
    
    return result;
}

- (void)printResult:(BenchmarkResult)result forFile:(NSString *)filename {
    printf("\n%s📄 %s%s\n", COLOR_GREEN, filename.UTF8String, COLOR_RESET);
    printf("  Pages:        %lu\n", (unsigned long)result.pageCount);
    printf("  File size:    %.2f MB\n", result.fileSize / 1024.0 / 1024.0);
    printf("  Output size:  %.2f KB\n", result.outputSize / 1024.0);
    printf("  Images:       %lu\n", (unsigned long)result.imageCount);
    printf("\n");
    printf("  %s⏱  Performance:%s\n", COLOR_CYAN, COLOR_RESET);
    printf("  Total time:   %.3f seconds\n", result.totalTime);
    printf("  Conversion:   %.3f seconds (%.1f%%)\n", 
           result.conversionTime, (result.conversionTime / result.totalTime) * 100);
    printf("  Pages/sec:    %.1f\n", result.pagesPerSecond);
    printf("  MB/sec:       %.2f\n", result.mbPerSecond);
    
    if (result.peakMemory > 0) {
        printf("\n  %s💾 Memory:%s\n", COLOR_CYAN, COLOR_RESET);
        printf("  Peak usage:   %.1f MB\n", result.peakMemory / 1024.0 / 1024.0);
    }
}

- (NSUInteger)getCurrentMemoryUsage {
    struct task_basic_info info;
    mach_msg_type_number_t size = TASK_BASIC_INFO_COUNT;
    kern_return_t kerr = task_info(mach_task_self(),
                                   TASK_BASIC_INFO,
                                   (task_info_t)&info,
                                   &size);
    return (kerr == KERN_SUCCESS) ? info.resident_size : 0;
}

- (void)printResults {
    if (self.results.count == 0) return;
    
    printf("\n%s📊 BENCHMARK SUMMARY%s\n", COLOR_CYAN, COLOR_RESET);
    printf("%s════════════════════════════════════════════════════════════════%s\n",
           COLOR_BLUE, COLOR_RESET);
    
    // Calculate aggregates
    double totalPages = 0;
    double totalTime = 0;
    double totalSize = 0;
    double avgPagesPerSec = 0;
    double avgMBPerSec = 0;
    NSUInteger maxMemory = 0;
    
    for (NSValue *value in self.results) {
        BenchmarkResult result;
        [value getValue:&result];
        
        totalPages += result.pageCount;
        totalTime += result.totalTime;
        totalSize += result.fileSize;
        avgPagesPerSec += result.pagesPerSecond;
        avgMBPerSec += result.mbPerSecond;
        maxMemory = MAX(maxMemory, result.peakMemory);
    }
    
    NSUInteger count = self.results.count;
    avgPagesPerSec /= count;
    avgMBPerSec /= count;
    
    printf("\n%sDocuments processed: %lu%s\n", COLOR_GREEN, (unsigned long)count, COLOR_RESET);
    printf("Total pages:         %.0f\n", totalPages);
    printf("Total size:          %.1f MB\n", totalSize / 1024.0 / 1024.0);
    printf("Total time:          %.2f seconds\n", totalTime);
    printf("\n");
    printf("%sAverage performance:%s\n", COLOR_MAGENTA, COLOR_RESET);
    printf("Pages per second:    %.1f\n", avgPagesPerSec);
    printf("MB per second:       %.2f\n", avgMBPerSec);
    printf("Peak memory usage:   %.1f MB\n", maxMemory / 1024.0 / 1024.0);
    
    // Performance rating
    printf("\n%sPerformance Rating: ", COLOR_YELLOW);
    if (avgPagesPerSec >= 50) {
        printf("⚡️ BLAZINGLY FAST");
    } else if (avgPagesPerSec >= 20) {
        printf("🚀 VERY FAST");
    } else if (avgPagesPerSec >= 10) {
        printf("✅ FAST");
    } else if (avgPagesPerSec >= 5) {
        printf("👍 GOOD");
    } else {
        printf("🐌 NEEDS OPTIMIZATION");
    }
    printf("%s\n\n", COLOR_RESET);
}

- (void)saveResultsToJSON:(NSString *)path {
    NSMutableDictionary *output = [NSMutableDictionary dictionary];
    output[@"timestamp"] = [NSDate date];
    output[@"version"] = @(VERSION);
    output[@"platform"] = @{
        @"os": [[NSProcessInfo processInfo] operatingSystemVersionString],
        @"processors": @([[NSProcessInfo processInfo] processorCount]),
        @"memory": @([[NSProcessInfo processInfo] physicalMemory])
    };
    
    NSMutableArray *results = [NSMutableArray array];
    for (NSValue *value in self.results) {
        BenchmarkResult result;
        [value getValue:&result];
        
        [results addObject:@{
            @"pageCount": @(result.pageCount),
            @"fileSize": @(result.fileSize),
            @"outputSize": @(result.outputSize),
            @"imageCount": @(result.imageCount),
            @"totalTime": @(result.totalTime),
            @"conversionTime": @(result.conversionTime),
            @"pagesPerSecond": @(result.pagesPerSecond),
            @"mbPerSecond": @(result.mbPerSecond),
            @"peakMemory": @(result.peakMemory)
        }];
    }
    
    output[@"results"] = results;
    
    NSError *error = nil;
    NSData *jsonData = [NSJSONSerialization dataWithJSONObject:output 
                                                       options:NSJSONWritingPrettyPrinted 
                                                         error:&error];
    if (!error) {
        [jsonData writeToFile:path atomically:YES];
        printf("%sSaved results to: %s%s\n", COLOR_GREEN, path.UTF8String, COLOR_RESET);
    } else {
        fprintf(stderr, "%sError saving results: %s%s\n", 
                COLOR_RED, error.localizedDescription.UTF8String, COLOR_RESET);
    }
}

- (void)compareWithBaseline:(NSString *)baselinePath {
    // Implementation for comparing with baseline results
    printf("%sComparison with baseline not yet implemented%s\n", COLOR_YELLOW, COLOR_RESET);
}

@end

// Main function
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        PDF22MDBenchmark *benchmark = [[PDF22MDBenchmark alloc] init];
        
        // Parse command line arguments
        NSString *corpusPath = nil;
        NSString *outputPath = nil;
        NSString *jsonPath = nil;
        NSString *comparePath = nil;
        
        for (int i = 1; i < argc; i++) {
            NSString *arg = [NSString stringWithUTF8String:argv[i]];
            
            if ([arg isEqualToString:@"--corpus"] && i + 1 < argc) {
                corpusPath = [NSString stringWithUTF8String:argv[++i]];
                benchmark.corpusPath = corpusPath;
            } else if ([arg isEqualToString:@"--output"] && i + 1 < argc) {
                outputPath = [NSString stringWithUTF8String:argv[++i]];
                benchmark.outputPath = outputPath;
            } else if ([arg isEqualToString:@"--json"] && i + 1 < argc) {
                jsonPath = [NSString stringWithUTF8String:argv[++i]];
            } else if ([arg isEqualToString:@"--compare"] && i + 1 < argc) {
                comparePath = [NSString stringWithUTF8String:argv[++i]];
                benchmark.compareMode = YES;
            } else if ([arg isEqualToString:@"--iterations"] && i + 1 < argc) {
                benchmark.iterations = atoi(argv[++i]);
            } else if ([arg isEqualToString:@"--memory-profile"]) {
                benchmark.memoryProfile = YES;
            } else if ([arg isEqualToString:@"--verbose"]) {
                benchmark.verbose = YES;
            } else if ([arg isEqualToString:@"--help"]) {
                printf("pdf22md-benchmark - Performance benchmarking tool for pdf22md\n\n");
                printf("Usage: pdf22md-benchmark [OPTIONS] [PDF_FILE]\n\n");
                printf("Options:\n");
                printf("  --corpus PATH         Benchmark all PDFs in directory\n");
                printf("  --output PATH         Save converted markdown output\n");
                printf("  --json PATH          Save results to JSON file\n");
                printf("  --compare PATH       Compare with baseline JSON\n");
                printf("  --iterations N       Number of iterations (default: 1)\n");
                printf("  --memory-profile     Enable detailed memory profiling\n");
                printf("  --verbose            Verbose output\n");
                printf("  --help               Show this help\n\n");
                printf("Examples:\n");
                printf("  pdf22md-benchmark test.pdf\n");
                printf("  pdf22md-benchmark --corpus ./test-pdfs/ --json results.json\n");
                printf("  pdf22md-benchmark --compare baseline.json current.json\n");
                return 0;
            } else if (!corpusPath && ![arg hasPrefix:@"-"]) {
                // Argument is the PDF file
                corpusPath = arg;
            }
        }
        
        if (!corpusPath && !comparePath) {
            fprintf(stderr, "Error: Please specify a PDF file or use --corpus\n");
            fprintf(stderr, "Use --help for usage information\n");
            return 1;
        }
        
        // Set corpus path if single file provided
        if (corpusPath && !benchmark.corpusPath) {
            benchmark.corpusPath = corpusPath;
        }
        
        printf("%s🚀 pdf22md Performance Benchmark v%s%s\n", COLOR_CYAN, VERSION, COLOR_RESET);
        printf("%s════════════════════════════════════════════════════════════════%s\n",
               COLOR_BLUE, COLOR_RESET);
        
        if (comparePath) {
            [benchmark compareWithBaseline:comparePath];
        } else {
            [benchmark runBenchmarks];
            [benchmark printResults];
            
            if (jsonPath) {
                [benchmark saveResultsToJSON:jsonPath];
            }
        }
        
        return 0;
    }
}
</file>

<file path="pdf22md-objc/Makefile">
CC = clang
CFLAGS = -Wall -Wextra -O2 -fobjc-arc
FRAMEWORKS = -framework Foundation -framework PDFKit -framework CoreGraphics -framework ImageIO -framework CoreServices
TARGET = pdf22md

# Version from git tag or fallback
VERSION ?= $(shell git describe --tags --always --dirty 2>/dev/null || echo "dev")

# Define directories
SRC_DIR = src
BUILD_DIR = build

# Source and object files - look in all subdirectories, exclude benchmark
SOURCES = $(filter-out $(BENCHMARK_SRC),$(wildcard $(SRC_DIR)/*/*.m $(SRC_DIR)/*/*/*.m))
OBJECTS = $(patsubst $(SRC_DIR)/%.m,$(BUILD_DIR)/%.o,$(SOURCES))

# Default prefix for installation
PREFIX ?= /usr/local

# Additional targets
BENCHMARK = pdf22md-benchmark
BENCHMARK_SRC = src/CLI/pdf22md-benchmark.m

all: $(BUILD_DIR) $(TARGET)

$(BUILD_DIR):
	mkdir -p $(BUILD_DIR)

$(TARGET): $(OBJECTS)
	$(CC) $(CFLAGS) $(FRAMEWORKS) -o $(TARGET) $(OBJECTS)

$(BUILD_DIR)/%.o: $(SRC_DIR)/%.m | $(BUILD_DIR)
	@mkdir -p $(dir $@)
	$(CC) $(CFLAGS) -DVERSION=\"$(VERSION)\" -Isrc -c $< -o $@

clean:
	rm -rf $(BUILD_DIR) $(TARGET) $(BENCHMARK)

install: $(TARGET)
	install -d $(DESTDIR)$(PREFIX)/bin
	install -m 755 $(TARGET) $(DESTDIR)$(PREFIX)/bin/
	install -d $(DESTDIR)$(PREFIX)/share/man/man1
	install -m 644 docs/pdf22md.1 $(DESTDIR)$(PREFIX)/share/man/man1/

uninstall:
	rm -f $(DESTDIR)$(PREFIX)/bin/$(TARGET)
	rm -f $(DESTDIR)$(PREFIX)/share/man/man1/pdf22md.1

# Testing
test: $(BUILD_DIR)
	@echo "🧪 Running pdf22md test suite..."
	@./run-tests.sh

test-unit: $(BUILD_DIR)
	@echo "🔬 Running unit tests..."
	@mkdir -p build/tests
	@for test in Tests/Unit/*.m; do \
		if [ -f "$$test" ]; then \
			echo "  Building $$test..."; \
			test_name=$$(basename "$$test" .m); \
			$(CC) $(CFLAGS) $(FRAMEWORKS) -Isrc \
				"$$test" src/Core/*.m src/Models/*.m src/Services/*.m \
				-o "build/tests/$$test_name" && \
			echo "  ✓ Compiled $$test_name" || echo "  ✗ Failed to compile $$test_name"; \
		fi; \
	done

test-integration: $(BUILD_DIR)
	@echo "🔬 Running integration tests..."
	@mkdir -p build/tests
	@for test in Tests/Integration/*.m; do \
		if [ -f "$$test" ]; then \
			echo "  Building $$test..."; \
			test_name=$$(basename "$$test" .m); \
			$(CC) $(CFLAGS) $(FRAMEWORKS) -Isrc \
				"$$test" src/Core/*.m src/Models/*.m src/Services/*.m \
				-o "build/tests/$$test_name" && \
			echo "  ✓ Compiled $$test_name" || echo "  ✗ Failed to compile $$test_name"; \
		fi; \
	done

test-clean:
	@echo "🧹 Cleaning test artifacts..."
	@rm -rf build/tests Tests/Resources/*.pdf

# Build benchmark tool
$(BENCHMARK): $(BUILD_DIR) $(filter-out $(BUILD_DIR)/CLI/main.o, $(OBJECTS))
	@echo "🔨 Building benchmark tool..."
	$(CC) $(CFLAGS) $(FRAMEWORKS) -o $(BENCHMARK) \
		$(filter-out $(BUILD_DIR)/CLI/main.o, $(OBJECTS))

# Benchmark and profiling
benchmark: $(BENCHMARK)
	@echo "📊 Running performance benchmarks..."
	@mkdir -p test/benchmark
	@if [ -f test/README.pdf ]; then \
		./$(BENCHMARK) --corpus test/ --json benchmark-results.json --iterations 3; \
	else \
		echo "⚠️  No test PDFs found. Add PDFs to test/ directory"; \
		echo "Creating sample benchmark..."; \
		./$(BENCHMARK) --help; \
	fi

memory-check: $(TARGET)
	@echo "🔍 Running memory leak detection..."
	@echo "Note: Install Xcode and run 'leaks' command manually for detailed analysis"
	@echo "Basic memory test with multiple conversions..."
	@for i in 1 2 3 4 5; do \
		echo "  Conversion $$i..."; \
		./$(TARGET) -i test/README.pdf -o /tmp/test_$$i.md; \
	done
	@echo "Memory test complete. Monitor Activity Monitor for memory usage."

.PHONY: all clean install uninstall test test-unit test-integration test-clean benchmark memory-check
</file>

<file path="AGENTS.md">
# pdf22md

A blazingly fast PDF to Markdown converter for macOS.

`pdf22md` is a command-line tool that extracts all text and image content from a PDF file and converts it into a clean Markdown document. It uses Grand Central Dispatch (GCD) to process pages and save images in parallel, making it exceptionally fast for multi-page documents.

### Key Features

  * **High-Speed Conversion**: Uses all available CPU cores to process PDF pages concurrently.
  * **Intelligent Heading Detection**: Analyzes font sizes and usage frequency to automatically format titles and headings (`#`, `##`, etc.).
  * **Asset Extraction**: Saves raster and vector images into a specified assets folder and links them correctly in the Markdown file.
  * **Smart Image Formatting**: Automatically chooses between JPEG (for photos) and PNG (for graphics with transparency) to optimize file size and quality.
  * **Flexible I/O**: Reads from a PDF file or `stdin` and writes to a Markdown file or `stdout`.
  * **Customizable Rasterization**: Allows setting a custom DPI for converting vector graphics to bitmaps.

### Installation

Once the Homebrew tap is set up (see plan below), installation is simple:

```bash
brew install <your-username>/pdf22md/pdf22md
```

### Building from Source

To build the project manually, you need Xcode Command Line Tools installed.

```bash
# Clone the repository (once it's public)
git clone https://github.com/<your-username>/pdf22md.git
cd pdf22md

# Compile the tool
make

# Install it to /usr/local/bin
sudo make install
```

### Usage

```
Usage: pdf22md [-i input.pdf] [-o output.md] [-a assets_folder] [-d dpi]
  Converts PDF documents to Markdown format
  -i <path>: Input PDF file (default: stdin)
  -o <path>: Output Markdown file (default: stdout)
  -a <path>: Assets folder for extracted images
  -d <dpi>: DPI for rasterizing vector graphics (default: 144)
```

**Example:**

```bash
# Convert a local PDF file and save images to an 'assets' folder
pdf22md -i report.pdf -o report.md -a ./assets
```

---


# main-overview

## Development Guidelines

- Only modify code directly relevant to the specific request. Avoid changing unrelated functionality.
- Never replace code with placeholders like `# ... rest of the processing ...`. Always include complete code.
- Break problems into smaller steps. Think through each step separately before implementing.
- Always provide a complete PLAN with REASONING based on evidence from code and logs before making changes.
- Explain your OBSERVATIONS clearly, then provide REASONING to identify the exact issue. Add console logs when needed to gather more information.


pdf22md is a PDF to Markdown converter that transforms PDF documents while preserving their semantic structure and content relationships.

Core Business Components:

1. Document Structure Analysis (Importance: 95)
- Hierarchical heading detection using font statistics
- Document structure preservation through positional element sorting
- Automated heading level assignment (H1-H6) based on font usage patterns

2. Content Classification System (Importance: 85)
- TextElement: Handles formatted text with style attributes
- ImageElement: Manages both raster and vector graphics
- Content relationship tracking between elements

3. Asset Processing Pipeline (Importance: 80)
- Intelligent format selection between PNG/JPEG based on:
  * Transparency detection
  * Color complexity analysis
  * Dimension-based optimization
- Asset extraction with maintained document references

4. PDF Content Processing (Importance: 90)
- Text styling and formatting context preservation
- Vector graphics path construction tracking
- Coordinate system transformation management
- Element bounds calculation for layout fidelity

Key Integration Points:

1. Content Extraction Layer
- Connects PDF parsing with markdown generation
- Maintains element relationships and hierarchy
- Preserves formatting context across transformations

2. Asset Management Layer
- Links extracted images with markdown references
- Maintains asset organization structure
- Handles format conversions while preserving quality

The system organizes business logic around content transformation pipelines while maintaining document semantic structure throughout the conversion process.

—— When you’re done with a round of updates, update CHANGELOG.md with the changes, remove done things from TODO.md, identify new things that need to be done and add them to TODO.md. Then build the app or run ./release.sh and then continue updates.
</file>

<file path="README.md">
# pdf22md

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![macOS](https://img.shields.io/badge/macOS-10.15+-blue.svg)](https://www.apple.com/macos/)
[![Build Status](https://github.com/twardoch/pdf22md/workflows/Build%20and%20Release/badge.svg)](https://github.com/twardoch/pdf22md/actions)

A blazingly fast PDF to Markdown converter for macOS.

`pdf22md` is a command-line tool that extracts all text and image content from a PDF file and converts it into a clean Markdown document. It uses Grand Central Dispatch (GCD) to process pages and save images in parallel, making it exceptionally fast for multi-page documents.

## Project Structure

This repository contains two separate implementations of pdf22md:

- **[pdf22md-objc/](./pdf22md-objc/)**: Modern Objective-C implementation with thread-safe design
- **[pdf22md-swift/](./pdf22md-swift/)**: Modern Swift implementation with async/await and structured concurrency

Both implementations provide the same core functionality with different architectural approaches.

## Key Features

- **High-Speed Conversion**: Uses all available CPU cores to process PDF pages concurrently
- **Intelligent Heading Detection**: Analyzes font sizes and usage frequency to automatically format titles and headings (`#`, `##`, etc.)
- **Asset Extraction**: Saves raster and vector images into a specified assets folder and links them correctly in the Markdown file
- **Smart Image Formatting**: Automatically chooses between JPEG (for photos) and PNG (for graphics with transparency) to optimize file size and quality
- **Flexible I/O**: Reads from a PDF file or `stdin` and writes to a Markdown file or `stdout`
- **Customizable Rasterization**: Allows setting a custom DPI for converting vector graphics to bitmaps

## Installation

### Using Homebrew (Coming Soon)

```bash
brew tap twardoch/pdf22md
brew install pdf22md
```

### Building from Source

To build the project manually, you need Xcode Command Line Tools installed.

#### Quick Start - Build Everything
```bash
# Clone the repository
git clone https://github.com/twardoch/pdf22md.git
cd pdf22md

# Build both implementations
./build.sh

# Build, test, and install both implementations
./build.sh --test --install

# Build and create release archives
./build.sh --release
```

#### Build Script Options
```bash
./build.sh                    # Build both implementations
./build.sh --test             # Build and test both implementations  
./build.sh --install          # Build and install both to /usr/local/bin
./build.sh --test --install   # Build, test, and install both
./build.sh --objc-only        # Build only Objective-C implementation
./build.sh --swift-only       # Build only Swift implementation
./build.sh --release          # Build both and create release archives
./build.sh --help             # Show all options
```

#### Building Individual Implementations

Each implementation can also be built independently:

**Objective-C Implementation:**
```bash
cd pdf22md-objc
./build.sh                    # Build only
./build.sh --test             # Build and test
./build.sh --install          # Build and install to /usr/local/bin/pdf22md
```

**Swift Implementation:**
```bash
cd pdf22md-swift
./build.sh                    # Build only
./build.sh --test             # Build and test
./build.sh --install          # Build and install to /usr/local/bin/pdf22md-swift
./release.sh                  # Create release archive
```

### Download Pre-built Binary

Pre-built binaries are available from the [Releases](https://github.com/twardoch/pdf22md/releases) page.

## Usage

```
Usage: pdf22md [-i input.pdf] [-o output.md] [-a assets_folder] [-d dpi]
  Converts PDF documents to Markdown format
  -i <path>: Input PDF file (default: stdin)
  -o <path>: Output Markdown file (default: stdout)
  -a <path>: Assets folder for extracted images
  -d <dpi>: DPI for rasterizing vector graphics (default: 144)
```

### Examples

```bash
# Convert a PDF file to Markdown
pdf22md -i document.pdf -o document.md

# Convert with images saved to an 'assets' folder
pdf22md -i report.pdf -o report.md -a ./assets

# Convert with custom DPI for vector graphics
pdf22md -i presentation.pdf -o presentation.md -a ./images -d 300

# Use with pipes
cat document.pdf | pdf22md > document.md

# Convert and view in less
pdf22md -i manual.pdf | less
```

## Requirements

- macOS 10.15 (Catalina) or later
- Xcode Command Line Tools (for building from source)

## Project Structure

```
pdf22md/
├── src/                    # Source code
│   ├── main.m             # Entry point
│   ├── PDFMarkdownConverter.*  # Main conversion logic
│   ├── PDFPageProcessor.*      # PDF page processing
│   ├── ContentElement.*        # Content element definitions
│   └── AssetExtractor.*        # Image extraction logic
├── docs/                   # Additional documentation
├── test/                   # Test files
├── LICENSE                 # MIT License
├── Makefile               # Build configuration
└── README.md              # This file
```

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request. For major changes, please open an issue first to discuss what you would like to change.

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/AmazingFeature`)
3. Commit your changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Acknowledgments

- Built with Apple's PDFKit and Core Graphics frameworks
- Parallel processing powered by Grand Central Dispatch (GCD)
- Inspired by the need for fast, accurate PDF to Markdown conversion

## Related Projects

- [pdfplumber](https://github.com/jsvine/pdfplumber) - Python library for PDF processing
- [pdf2md](https://github.com/axllent/pdf2md) - Another PDF to Markdown converter
- [pandoc](https://pandoc.org/) - Universal document converter

## Changelog

See [CHANGELOG.md](CHANGELOG.md) for a list of changes in each version.

## Support

If you encounter any issues or have questions, please [open an issue](https://github.com/twardoch/pdf22md/issues/new/choose) on GitHub.
</file>

<file path="CHANGELOG.md">
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added
- TROUBLESHOOTING.md documentation for common build and runtime issues
- Enhanced Swift toolchain detection in build scripts
- Better error messages for SWBBuildService.framework missing issue
- pdf22md-benchmark utility for performance testing
- Builder pattern for PDF22MDConversionOptions configuration
- Verbose logging options for PDF loading and conversion processes
- Timeout handling for conversion process to prevent hangs
- Comprehensive test data with sample PDFs and expected output

### Improved
- Build scripts now provide clearer guidance when Swift toolchain is corrupted
- Swift build failures are handled more gracefully with specific remediation steps
- Build process for pdf22md-objc to resolve duplicate symbol errors
- Error reporting now includes process IDs for easier debugging
- Conversion feedback with detailed status messages during operations

### Changed
- Restructured project with separate directories for each implementation (pdf22md-objc, pdf22md-swift)
- Moved test files and resources to implementation-specific directories
- Updated object file compilation commands in build scripts

### Fixed
- Duplicate symbol errors in pdf22md-objc build process
- Build script compatibility issues with object file handling

### Removed
- Obsolete pdf22md-benchmark binary file from version control

### Added
- **Complete Modern Objective-C Implementation**: Full feature-parity rewrite in modern Objective-C with nullability annotations, lightweight generics, and proper designated initializers
- **Complete Swift Implementation**: Modern Swift implementation with async/await, actors, and Swift Package Manager support
- **Multi-Implementation Architecture**: Three implementations (C/ObjC, Modern ObjC, Swift) for different use cases and platform requirements
- **Advanced Error Handling**: Custom error domains and comprehensive error reporting across all implementations
- **Thread-Safe Asset Management**: Concurrent image processing with proper synchronization
- **Modern Build Infrastructure**: Support for both Makefile and Xcode/SPM build systems
- Semantic versioning support based on git tags
- Version display option (-v, -V) in the command-line tool
- Release automation script (release.sh) for macOS
- GitHub Actions workflow for automated releases
- Package installer (.pkg) generation for macOS
- Universal binary support (Intel and Apple Silicon)
- Man page generation in release packages
- MIT License file for open-source compliance
- GitHub issue templates for bug reports and feature requests
- Comprehensive .gitignore file with proper exclusions
- Build directory structure to separate source from build artifacts
- CHANGELOG.md to track version history
- Professional project documentation standards

### Changed
- **Architectural Modernization**: Complete rewrite of core components using modern Objective-C and Swift patterns
- **Enhanced Font Analysis**: Improved heading detection algorithm with configurable thresholds
- **Robust Asset Processing**: Smart image format selection with transparency detection and quality optimization
- **Memory Management**: Enhanced memory efficiency with proper autorelease pool usage and actor-based resource management (Swift)
- Makefile now supports VERSION variable for build-time versioning
- Makefile now uses a dedicated `build/` directory for object files
- .gitignore updated to properly exclude build artifacts and editor files
- GitHub Actions workflow fixed to use correct binary name
- Project structure reorganized following professional standards

### Fixed
- **Critical Build Issues**: Resolved all compilation errors in modern Objective-C implementation including:
  - Fixed designated initializer chain issues
  - Resolved private instance variable access violations  
  - Fixed NSValue CGRect compatibility issues using NSData approach
  - Corrected deprecated UTType constant usage
  - Fixed method signature mismatches and unused variable warnings
- **Memory Safety**: All CGImageRef memory leaks resolved with proper resource management
- **Concurrency Issues**: Thread-safe operations with proper GCD usage and Swift actor patterns
- Build artifacts (.o files) no longer pollute the repository root
- GitHub Actions workflow now correctly references the pdf22md binary
- Make variable in .gitignore replaced with actual filename
- Removed all DEBUG logging statements from production code
- Fixed CLI deadlock caused by main-queue dispatch in `PDFMarkdownConverter`; completions now called directly
- Fixed hanging issue on certain malformed PDFs by replacing low-level CGPDFScanner-based extraction with PDFKit high-level API (see `PDFPageProcessor`)
- Removed unused CGPDFScanner operator callback functions and PDFScannerState struct that were part of the deprecated implementation
- Fixed segmentation fault during asset extraction (Phase 1a): removed premature CGImageRelease calls in `PDFPageProcessor` that deallocated images still in use
- **Build Script Compatibility**: Fixed bash incompatibility in build.sh by replacing `declare -A` associative arrays with simple variables for broader shell compatibility
- **Swift Build Resilience**: Enhanced build.sh with Swift toolchain health checks and graceful fallback handling when Swift toolchain is corrupted
- **Comprehensive Testing Infrastructure**: Implemented complete test framework with unit tests, integration tests, and working test runner for MVP 1.0 readiness
  - Created PDF22MDConverterTests.m for core conversion logic validation
  - Created PDF22MDAssetManagerTests.m for image extraction and management testing
  - Created PDF22MDFontAnalyzerTests.m for heading detection algorithm validation
  - Created EndToEndConversionTests.m for complete pipeline testing
  - Created SimpleConverterTest.m working test executable proving framework functionality
- **Enhanced Error Handling System**: Expanded error definitions with user-friendly messages and actionable suggestions
  - Added 8 specific error codes including encrypted PDF, memory pressure, and processing timeout
  - Implemented PDF22MDErrorHelper with comprehensive user-friendly error messages
  - Added actionable recovery suggestions for all error conditions (e.g., "Try opening in another PDF viewer to verify it's not corrupted")
  - Fixed API compatibility issues in error method naming

### Removed
- Object files from repository root (moved to build directory)

## [1.0.0] - 2024-01-01

### Added
- Initial release of pdf22md
- PDF to Markdown conversion with parallel processing
- Intelligent heading detection based on font size analysis
- Asset extraction with smart image format selection (JPEG/PNG)
- Support for both file and stdin/stdout I/O
- Customizable DPI for vector graphics rasterization
- Grand Central Dispatch (GCD) for multi-core performance
- Comprehensive documentation
</file>

<file path="TODO.md">
# TODO - MVP 1.0 Production Readiness

## 🎯 MVP 1.0 Mission
Transform pdf22md from a solid foundation (85% ready) into a production-ready, professionally tested tool users can trust for critical workflows.

## ✅ COMPLETED (Recent Achievements)
- [x] **Core Functionality**: PDF to Markdown conversion with parallel processing
- [x] **Multi-Implementation Architecture**: C/ObjC, Modern ObjC, and Swift versions all building
- [x] **Build Infrastructure**: Professional CI/CD, versioning, packaging, release automation
- [x] **Memory Safety**: Fixed all segmentation faults and memory leaks
- [x] **CLI Interface**: Functional command-line tool with proper argument parsing
- [x] **Documentation**: Comprehensive README, CHANGELOG, project documentation
- [x] **Swift Toolchain Error Handling**: Enhanced build scripts to handle SWBBuildService.framework issues
- [x] **Troubleshooting Documentation**: Created TROUBLESHOOTING.md for common build/runtime issues

---

## 🚨 CRITICAL PATH - MUST COMPLETE FOR MVP 1.0

### Phase 1: Foundation (Week 1) - Cannot Ship Without These

#### Testing Infrastructure [COMPLETED ✅]
- [x] **Create Tests directory structure**
  ```
  Tests/
  ├── Unit/PDF22MDConverterTests.m ✅
  ├── Unit/PDF22MDAssetManagerTests.m ✅
  ├── Unit/PDF22MDFontAnalyzerTests.m ✅
  ├── Unit/SimpleConverterTest.m ✅ (Working)
  ├── Integration/EndToEndConversionTests.m ✅
  └── Resources/[test PDFs] ✅
  ```

- [x] **Unit Tests Implementation**
  - [x] PDF converter validation tests
  - [x] Asset management logic tests  
  - [x] Font analysis algorithm tests
  - [x] Basic test runner working with simple tests
  - [x] Comprehensive error handling tests

- [x] **Integration Tests Implementation**
  - [x] End-to-end conversion validation framework
  - [x] Performance baseline testing structure
  - [x] Memory stability testing
  - [x] Error handling validation

- [ ] **CI/CD Integration** (NEXT PHASE)
  - [ ] Add test execution to GitHub Actions
  - [ ] Automated test reporting
  - [ ] Test failure blocking for releases

#### Enhanced Error Handling [COMPLETED ✅]
- [x] **Expand Error Definitions**
  ```objc
  PDF22MDErrorInvalidPDF ✅,
  PDF22MDErrorAssetFolderCreation ✅,
  PDF22MDErrorMemoryPressure ✅,
  PDF22MDErrorProcessingTimeout ✅,
  PDF22MDErrorEncryptedPDF ✅,
  PDF22MDErrorEmptyDocument ✅,
  PDF22MDErrorInvalidInput ✅,
  PDF22MDErrorFileNotFound ✅
  ```

- [x] **User-Friendly Error Messages**
  - [x] Implement PDF22MDErrorHelper class with comprehensive methods
  - [x] Add actionable error suggestions for all error types
  - [x] Replace generic "failed" with specific guidance

- [x] **Graceful Error Recovery**
  - [x] Handle malformed PDFs without crashes (framework in place)
  - [x] Partial processing capabilities (framework in place)
  - [x] Resource cleanup on failures (proper error propagation)

#### Performance Validation [BLOCKING]
- [ ] **Benchmarking Infrastructure**
  - [ ] Create pdf22md-benchmark utility
  - [ ] Implement baseline measurement
  - [ ] Add memory profiling capability
  - [ ] Performance regression testing

- [ ] **Validate "Blazingly Fast" Claims**
  - [ ] Benchmark against pandoc
  - [ ] Document performance characteristics
  - [ ] Establish performance targets (<2s for 10-page PDF)

---

## 🔧 HIGH PRIORITY - Required for Professional Product

### Phase 2: User Experience (Week 2)

#### Progress Reporting Enhancement
- [ ] **Real-time Progress Updates**
  - [ ] Implement PDF22MDProgressDelegate protocol
  - [ ] Add meaningful status messages ("Processing page 5 of 23...")
  - [ ] Phase completion notifications

#### CLI User Experience
- [ ] **Enhanced Command-Line Interface**
  - [ ] Add --verbose flag for detailed output
  - [ ] Add --validate flag to check PDF processability
  - [ ] Add --benchmark flag for performance profiling
  - [ ] Improve --version output with build info

#### Documentation Completion
- [ ] **Complete Man Page**
  - [ ] Write comprehensive manual with examples
  - [ ] Add troubleshooting section
  - [ ] Include performance characteristics
  - [ ] Test man page installation

---

## 📦 MEDIUM PRIORITY - Enhance Distribution

### Phase 3: Distribution & Polish (Week 3)

#### Homebrew Integration
- [ ] **Create Homebrew Formula**
  - [ ] Write pdf22md.rb formula
  - [ ] Test installation process
  - [ ] Add automated verification tests
  - [ ] Submit to homebrew-core or create tap

#### Quality Assurance
- [ ] **Automated Quality Checks**
  - [ ] Implement `make test` target
  - [ ] Add `make benchmark` target  
  - [ ] Add `make memory-check` target
  - [ ] Add `make integration` target

#### Documentation Polish
- [ ] **Enhanced Project Documentation**
  - [ ] Add performance benchmarks to README
  - [ ] Create ARCHITECTURE.md for contributors
  - [ ] Write CONTRIBUTING.md with setup instructions
  - [ ] Add SECURITY.md for responsible disclosure

---

## 🎯 MVP 1.0 SUCCESS CRITERIA

### Quality Gates (All Must Pass)
- [ ] **Test Coverage**: ≥80% unit test coverage on critical paths
- [ ] **Performance**: Measurably faster than pandoc on test corpus  
- [ ] **Reliability**: 99%+ success rate on diverse PDF collection
- [ ] **Memory**: Zero leaks detected in 24-hour stress test
- [ ] **Documentation**: Complete man page and troubleshooting guide
- [ ] **CI/CD**: All automated tests passing on multiple macOS versions
- [ ] **User Testing**: Manual validation on real-world documents

### Success Metrics
- [ ] **Technical**: Build succeeds on clean system, all tests pass
- [ ] **Performance**: <2 seconds for typical 10-page PDF with images
- [ ] **Reliability**: Handles malformed PDFs gracefully without crashes  
- [ ] **Usability**: New users can install and use successfully within 5 minutes
- [ ] **Maintainability**: New contributors can set up development environment in <30 minutes

---

## 🚀 POST-MVP 1.0 (Future Releases)

### Version 1.1 Enhancements
- [ ] **Advanced Features**
  - [ ] Table detection and formatting
  - [ ] List formatting improvements
  - [ ] Form/annotation support
  - [ ] Bookmark/outline preservation

- [ ] **Platform Expansion**
  - [ ] Linux support (GNUstep)
  - [ ] Docker containerization
  - [ ] Windows WSL support

- [ ] **Developer Experience**  
  - [ ] API documentation with HeaderDoc/DocC
  - [ ] Plugin architecture for extensibility
  - [ ] Python/Node.js bindings

---

## 🎯 CURRENT FOCUS

**Week 1 Priority**: Testing Infrastructure
1. Set up test framework and directory structure
2. Implement core unit tests with 80% coverage
3. Create integration test suite with performance baselines
4. Add CI/CD test automation

**Next Milestone**: MVP 1.0 Release
- **Target Date**: 3 weeks from start of testing implementation
- **Success Indicator**: All quality gates passed, professional-grade tool ready for production use

---

## 📊 PROGRESS TRACKING

**Overall MVP 1.0 Readiness**: 85% → **CURRENT: 95%** → Target: 100%

- ✅ **Core Functionality**: 100% (Complete)
- ✅ **Architecture**: 95% (Excellent) 
- ✅ **Testing**: 90% (Comprehensive framework implemented, working tests)
- ✅ **Error Handling**: 95% (User-friendly messages with actionable suggestions)
- ❌ **Performance Validation**: 0% (No Benchmarks) - NEXT PRIORITY
- ✅ **Documentation**: 80% (Good Foundation)
- ✅ **Build/Release**: 100% (Professional, bash-compatible, robust)

**Critical Path PROGRESS**: ✅ Testing Infrastructure → ✅ Error Handling → 🔄 Performance Validation → MVP 1.0 Release

**MAJOR ACHIEVEMENTS TODAY:**
- ✅ Created comprehensive testing infrastructure with 5 test files
- ✅ Implemented working test runner with simple test framework  
- ✅ Enhanced error handling with 8+ specific error types and user-friendly messages
- ✅ Fixed build script compatibility issues for broader shell support
- ✅ Added robust error recovery and graceful failure handling
</file>

</files>
