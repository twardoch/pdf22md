This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: docs
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.cursor/
  rules/
    content-element-models.mdc
    data-flow.mdc
    document-processing-algorithms.mdc
    image-processing-algorithms.mdc
.giga/
  specifications.json
.github/
  ISSUE_TEMPLATE/
    bug_report.md
    feature_request.md
  workflows/
    build-release.yml
    release.yml
pdf22md/
  Sources/
    PDF22MD/
      AssetExtractor.swift
      CGPDFImageExtractor.swift
      FontStatistics.swift
      PDFElement.swift
      PDFMarkdownConverter.swift
      PDFMarkdownConverterOptimized.swift
      PDFMarkdownConverterUltraOptimized.swift
      PDFPageProcessor.swift
      PDFPageProcessorOptimized.swift
    PDF22MDCli/
      main.swift
  test-resources/
    expected-outputs/
      README.md
  Tests/
    PDF22MDTests/
      PDF22MDTests.swift
  Package.resolved
  Package.swift
  README.md
.cursorrules
.gitignore
AGENTS.md
build.sh
CHANGELOG.md
CLAUDE.md
CONTRIBUTING.md
LICENSE
Makefile
PLAN.md
README.md
test_sw.sh
test.sh
TODO.md
TROUBLESHOOTING.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".cursor/rules/content-element-models.mdc">
---
description: Defines core content element models for representing text and image elements in PDF to Markdown conversion
globs: src/ContentElement.h,src/ContentElement.m,src/*.h,src/*.m
alwaysApply: false
---


# content-element-models

The content element model system implements two primary domain models for representing extracted PDF content:

### TextElement Model
Importance Score: 95
- Captures text-specific attributes:
  - Heading level detection based on font statistics
  - Formatting attributes (bold, italic)
  - Positional information for maintaining document structure
  - Font metrics for hierarchy analysis

### ImageElement Model  
Importance Score: 90
- Manages both raster and vector image content:
  - Source type tracking (vector vs raster)
  - Format classification for optimal storage
  - Asset path management for markdown linking
  - Dimension and transparency analysis

### Element Relationships
Importance Score: 85
- Maintains document hierarchy through:
  - Parent-child relationships between elements
  - Sequential ordering based on page position
  - Nested structure preservation
  - Cross-element references

Relevant Files:
- src/ContentElement.h
- src/ContentElement.m

$END$

 If you're using this file in context, clearly say in italics in one small line that "Context added by Giga content-element-models".
</file>

<file path=".cursor/rules/data-flow.mdc">
---
description: Defines data transformation pipelines and content flow between PDF parsing, processing, and Markdown generation components
globs: src/*.{h,m},lib/*.{h,m},include/*.h
alwaysApply: false
---


# data-flow

The data transformation pipeline consists of three main stages with distinct data flows:

### 1. PDF Content Extraction Flow (Importance: 95)
- Input PDF document stream parsed into discrete content elements
- Font metrics and statistics gathered during initial parse
- Text elements tagged with style attributes and positioning data
- Images separated into raster/vector categories with source metadata
- Element hierarchy maintained through page-position tracking

### 2. Parallel Processing Pipeline (Importance: 90)
- Page content distributed across worker threads via GCD
- Font statistics aggregated through thread-safe collection
- Synchronized element arrays preserve document ordering
- Concurrent image asset extraction with sequence preservation
- Vector graphics rasterization based on DPI settings

### 3. Markdown Generation Flow (Importance: 85)  
- Font hierarchy analysis converts to heading levels
- Image assets exported with optimized format selection
- Asset references inserted with relative path linking
- Text formatting attributes translated to Markdown syntax
- Document structure rebuilt from processed elements

Key Data Transformation Points:
- PDF content stream → ContentElement objects
- Font metrics → Heading level assignments
- Vector paths → Rasterized images
- Image data → Optimized asset files
- Structured content → Markdown syntax

Relevant Components:
- src/PDFMarkdownConverter.{h,m}
- src/ContentElement.{h,m}
- src/AssetExtractor.{h,m}
- src/PDFPageProcessor.{h,m}

$END$

 If you're using this file in context, clearly say in italics in one small line that "Context added by Giga data-flow".
</file>

<file path=".cursor/rules/document-processing-algorithms.mdc">
---
description: Specifications for document conversion algorithms, text analysis, and page processing in PDF-to-Markdown conversion
globs: src/PDFMarkdownConverter.*,src/PDFPageProcessor.*,src/ContentElement.*,src/AssetExtractor.*
alwaysApply: false
---


# document-processing-algorithms

## Core Processing Components (Importance: 95)

### Font Hierarchy Analysis
- Statistical font size frequency analysis for automatic heading level detection
- Threshold-based classification (<100 occurrences) to differentiate headings from body text
- Maintenance of document structure through position-based element sorting

Relevant files:
- `src/PDFMarkdownConverter.m`
- `src/PDFPageProcessor.m`

### Content Classification System
- Domain-specific content type categorization
- TextElement handling with formatting attributes (bold, italic, heading levels)
- ImageElement management with source type tracking (vector/raster)

Relevant files:
- `src/ContentElement.h`
- `src/ContentElement.m`

## Image Processing Logic (Importance: 85)

### Format Selection Algorithm
- PNG selection for:
  - Images with transparency
  - Graphics under 100x100 pixels
- JPEG selection for:
  - Photographic content
  - Images with >256 unique colors
- Color complexity sampling (10,000 pixel analysis)
- Alpha channel detection for format decisions

Relevant files:
- `src/AssetExtractor.m`

## Document Element Extraction (Importance: 90)

### Content Stream Processing
- Font style detection from PDF metadata
- Text positioning context preservation
- Vector graphics path construction tracking
- Image XObject extraction
- Bounds calculation for layout preservation

Relevant files:
- `src/PDFPageProcessor.m`
- `src/PDFMarkdownConverter.m`

$END$

 If you're using this file in context, clearly say in italics in one small line that "Context added by Giga document-processing-algorithms".
</file>

<file path=".cursor/rules/image-processing-algorithms.mdc">
---
description: Technical specification for image processing and optimization algorithms in PDF to Markdown conversion
globs: src/AssetExtractor.*,src/ImageProcessor.*,src/PDFImageExtractor.*,*.{png,jpg,jpeg}
alwaysApply: false
---


# image-processing-algorithms

The image processing system implements intelligent format selection and optimization for PDF asset extraction:

### Format Selection Algorithm (Importance: 85)
- Images with transparency -> PNG format
- Graphics <100x100 pixels -> PNG format 
- Photos/complex images (>256 colors) -> JPEG format
- Samples up to 10,000 pixels for color complexity analysis
- Checks for alpha channel presence in format decisions

### Asset Optimization (Importance: 75)
- Automatic quality optimization for photographs
- JPEG quality set to 85% for optimal size/quality balance
- Vector graphics rasterization at configurable DPI
- Smart asset directory management with relative path linking

Relevant files:
```
src/AssetExtractor.h
src/AssetExtractor.m
```

Key business rules:
1. Color complexity threshold: 256 unique colors
2. Small image threshold: 100x100 pixels
3. Sample size limit: 10,000 pixels
4. JPEG quality setting: 85%
5. Default vector DPI: 144

$END$

 If you're using this file in context, clearly say in italics in one small line that "Context added by Giga image-processing-algorithms".
</file>

<file path=".giga/specifications.json">
[
  {
    "fileName": "main-overview.mdc",
    "description": "Complete system overview documenting the PDF to Markdown conversion architecture, key components, and their interactions"
  },
  {
    "fileName": "document-processing-algorithms.mdc",
    "description": "Detailed documentation of core algorithms including font hierarchy analysis, heading detection, and parallel page processing using GCD"
  },
  {
    "fileName": "image-processing-algorithms.mdc",
    "description": "Documentation of image extraction, format optimization algorithms, and asset handling including transparency detection and color complexity analysis"
  },
  {
    "fileName": "content-element-models.mdc",
    "description": "Specification of TextElement and ImageElement data models, their attributes, and relationships within the document structure"
  },
  {
    "fileName": "data-flow.mdc",
    "description": "Documentation of data flow between components including PDF parsing, content extraction, parallel processing, and Markdown generation"
  }
]
</file>

<file path=".github/ISSUE_TEMPLATE/bug_report.md">
---
name: Bug report
about: Create a report to help us improve
title: ''
labels: bug
assignees: ''
---

**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:
1. Run command '...'
2. With PDF file '...'
3. See error

**Expected behavior**
A clear and concise description of what you expected to happen.

**System information:**
 - macOS version: [e.g. 14.0]
 - pdf22md version: [e.g. 1.0.0]

**Additional context**
Add any other context about the problem here.
</file>

<file path=".github/ISSUE_TEMPLATE/feature_request.md">
---
name: Feature request
about: Suggest an idea for this project
title: ''
labels: enhancement
assignees: ''
---

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is.

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.
</file>

<file path="pdf22md/Sources/PDF22MD/FontStatistics.swift">
import Foundation

/// Statistics about font usage in a PDF document
struct FontStatistics {
    let bodySizeThreshold: CGFloat
    let headingSizes: Set<CGFloat>
    let fontSizeFrequencies: [CGFloat: Int]
    
    func headingLevel(for fontSize: CGFloat) -> Int {
        guard headingSizes.contains(fontSize) else { return 0 }
        
        // Sort heading sizes from largest to smallest
        let sortedHeadingSizes = headingSizes.sorted(by: >)
        
        // Return heading level based on size order
        if let index = sortedHeadingSizes.firstIndex(of: fontSize) {
            return min(index + 1, 6) // H1-H6
        }
        
        return 0
    }
}
</file>

<file path="pdf22md/Sources/PDF22MD/PDFElement.swift">
import Foundation
import CoreGraphics

/// Protocol defining common properties for PDF content elements
protocol PDFElement {
    var bounds: CGRect { get }
    var pageIndex: Int { get }
}

/// Errors that can occur during PDF conversion
enum PDFConversionError: Error {
    case invalidPDF
    case fileNotFound
    case conversionFailed(String)
}

/// Represents a text element extracted from a PDF
struct TextElement: PDFElement {
    let text: String
    let bounds: CGRect
    let pageIndex: Int
    let fontSize: CGFloat
    let isBold: Bool
    let isItalic: Bool
    
    init(text: String, bounds: CGRect, pageIndex: Int, fontSize: CGFloat, isBold: Bool = false, isItalic: Bool = false) {
        self.text = text
        self.bounds = bounds
        self.pageIndex = pageIndex
        self.fontSize = fontSize
        self.isBold = isBold
        self.isItalic = isItalic
    }
}

/// Represents an image element extracted from a PDF
struct ImageElement: PDFElement {
    let image: CGImage?
    let bounds: CGRect
    let pageIndex: Int
    let isVectorSource: Bool
    let path: String
    
    init(image: CGImage? = nil, bounds: CGRect, pageIndex: Int, isVectorSource: Bool = false, path: String = "") {
        self.image = image
        self.bounds = bounds
        self.pageIndex = pageIndex
        self.isVectorSource = isVectorSource
        self.path = path
    }
}
</file>

<file path="pdf22md/Sources/PDF22MDCli/main.swift">
import Foundation
import ArgumentParser
import PDF22MD

@main
struct PDF22MDCommand: AsyncParsableCommand {
    static let configuration = CommandConfiguration(
        commandName: "pdf22md",
        abstract: "Converts PDF documents to Markdown format (Swift implementation)",
        version: "1.0.0"
    )
    
    @Option(name: .shortAndLong, help: "Input PDF file (default: stdin)")
    var input: String?
    
    @Option(name: .shortAndLong, help: "Output Markdown file (default: stdout)")
    var output: String?
    
    @Option(name: .shortAndLong, help: "Assets folder for extracted images")
    var assets: String?
    
    @Option(name: .shortAndLong, help: "DPI for rasterizing vector graphics (default: 144)")
    var dpi: Double = 144.0
    
    @Flag(name: .long, help: "Use optimized GCD implementation instead of async/await")
    var optimized: Bool = false
    
    @Flag(name: .long, help: "Use ultra-optimized implementation with NSString")
    var ultraOptimized: Bool = false
    
    func run() async throws {
        let inputURL: URL
        
        if let inputPath = input {
            inputURL = URL(fileURLWithPath: inputPath)
        } else {
            // Read from stdin into a temporary file
            let tempFile = FileManager.default.temporaryDirectory
                .appendingPathComponent(UUID().uuidString)
                .appendingPathExtension("pdf")
            let inputData = FileHandle.standardInput.readDataToEndOfFile()
            try inputData.write(to: tempFile)
            inputURL = tempFile
        }
        
        // Choose implementation
        if ultraOptimized {
            let converter = PDFMarkdownConverterUltraOptimized(
                pdfURL: inputURL,
                outputPath: output,
                assetsPath: assets,
                dpi: CGFloat(dpi)
            )
            try converter.convert()
        } else if optimized {
            let converter = PDFMarkdownConverterOptimized(
                pdfURL: inputURL,
                outputPath: output,
                assetsPath: assets,
                dpi: CGFloat(dpi)
            )
            try converter.convert()
        } else {
            let converter = PDFMarkdownConverter(
                pdfURL: inputURL,
                outputPath: output,
                assetsPath: assets,
                dpi: CGFloat(dpi)
            )
            try await converter.convert()
        }
        
        // Clean temp file if created
        if input == nil {
            try? FileManager.default.removeItem(at: inputURL)
        }
    }
}
</file>

<file path="pdf22md/test-resources/expected-outputs/README.md">
---
title: "README.md"
creator: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36 Edg/137.0.0.0"
producer: "Skia/PDF m137"
created: 2025-06-23T01:33:53+02:00
modified: 2025-06-23T01:33:53+02:00
pdf_metadata:
  page_count: 2
conversion:
  tool: "pdf22md"
  version: "v1.1.0-dirty"
  date: 2025-06-23T02:28:31+02:00
---

23/06/2025, 01:33 README.md

![Image](image_000.png)

![Image](image_001.png)

pdf22md

MIT

License MIT

License

10.15+

![Image](image_002.png)

![Image](image_003.png)

macOS 10.15+

macOS

Build and Release Build and Release passing passing

A blazingly fast PDF to Markdown converter for macOS.

pdf22md is a command-line tool that extracts all text and image content from a PDF file and converts it into a

![Image](image_004.png)

![Image](image_005.png)

![Image](image_006.png)

clean Markdown document. It uses Grand Central Dispatch (GCD) to process pages and save images in

parallel, making it exceptionally fast for multi-page documents.

Key Features

High-Speed Conversion: Uses all available CPU cores to process PDF pages concurrently

Intelligent Heading Detection: Analyzes font sizes and usage frequency to automatically format titles

![Image](image_007.png)

![Image](image_008.png)

![Image](image_009.png)

and headings ( # , ## , etc.)

Asset Extraction: Saves raster and vector images into a specified assets folder and links them correctly

in the Markdown file

Smart Image Formatting: Automatically chooses between JPEG (for photos) and PNG (for graphics with

transparency) to optimize file size and quality

Flexible I/O: Reads from a PDF file or stdin and writes to a Markdown file or stdout

![Image](image_010.png)

![Image](image_011.png)

![Image](image_012.png)

Customizable Rasterization: Allows setting a custom DPI for converting vector graphics to bitmaps

Installation

Using Homebrew (Coming Soon)

brew tap twardoch/pdf22md

brew install pdf22md

![Image](image_013.png)

![Image](image_014.png)

Building from Source

To build the project manually, you need Xcode Command Line Tools installed.

# Clone the repository

git clone https://github.com/twardoch/pdf22md.git

cd pdf22md

# Compile the tool

make

# Install it to /usr/local/bin (optional)

sudo make install

Download Pre-built Binary

Pre-built binaries are available from the Releases page.

Usage

Usage: pdf22md [-i input.pdf] [-o output.md] [-a assets

_

folder] [-d dpi]

Converts PDF documents to Markdown format

-i <path>: Input PDF file (default: stdin)

-o <path>: Output Markdown file (default: stdout)

-a <path>: Assets folder for extracted images

-d <dpi>: DPI for rasterizing vector graphics (default: 144)

Examples

# Convert a PDF file to Markdown

pdf22md -i document.pdf -o document.md

# Convert with images saved to an 'assets' folder

pdf22md -i report.pdf -o report.md -a ./assets

# Convert with custom DPI for vector graphics

pdf22md -i presentation.pdf -o presentation.md -a ./images -d 300

# Use with pipes

cat document.pdf | pdf22md > document.md

# Convert and view in less

pdf22md -i manual.pdf | less

Requirements

macOS 10.15 (Catalina) or later

Xcode Command Line Tools (for building from source)

Project Structure

pdf22md/

├── src/ # Source code

│ ├── main.m # Entry point

│ ├── PDFMarkdownConverter.* # Main conversion logic

│ ├── PDFPageProcessor.* # PDF page processing

│ ├── ContentElement.* # Content element definitions

│ └── AssetExtractor.* # Image extraction logic

├── docs/ # Additional documentation

├── test/ # Test files

file:///Users/adam/Developer/vcs/github.twardoch/pub/pdf22md/README.md 1/2

23/06/2025, 01:33 README.md

![Image](image_015.png)

![Image](image_016.png)

├── LICENSE # MIT License

├── Makefile # Build configuration

└── README.md # This file

Contributing

Contributions are welcome! Please feel free to submit a Pull Request. For major changes, please open an

![Image](image_017.png)

![Image](image_018.png)

![Image](image_019.png)

issue first to discuss what you

would like to change.

1. Fork the repository

2. Create your feature branch ( git checkout -b feature/AmazingFeature )

3. Commit your changes ( git commit -m 'Add some AmazingFeature' )

![Image](image_020.png)

![Image](image_021.png)

![Image](image_022.png)

4. Push to the branch ( git push origin feature/AmazingFeature )

5. Open a Pull Request

License

This project is licensed under the MIT License - see the LICENSE file for details.

Acknowledgments

![Image](image_023.png)

![Image](image_024.png)

![Image](image_025.png)

![Image](image_026.png)

![Image](image_027.png)

Built with Apple’s PDFKit and Core Graphics frameworks

Parallel processing powered by Grand Central Dispatch (GCD)

Inspired by the need for fast, accurate PDF to Markdown conversion

Related Projects

pdfplumber - Python library for PDF processing

![Image](image_028.png)

pdf2md - Another PDF to Markdown converter

![Image](image_029.png)

![Image](image_030.png)

![Image](image_031.png)

![Image](image_032.png)

pandoc - Universal document converter

Changelog

See CHANGELOG.md for a list of changes in each version.

Support

If you encounter any issues or have questions, please open an issue on GitHub.

![Image](image_033.png)

![Image](image_034.png)

file:///Users/adam/Developer/vcs/github.twardoch/pub/pdf22md/README.md 2/2
</file>

<file path="pdf22md/Tests/PDF22MDTests/PDF22MDTests.swift">
// this_file: pdf22md/Tests/PDF22MDTests/PDF22MDTests.swift

import XCTest
@testable import PDF22MD

final class PDF22MDTests: XCTestCase {
    
    // MARK: - Basic Tests
    
    func testBasicFunctionality() {
        // Add basic tests here when the Swift implementation is complete
        XCTAssertTrue(true)
    }
    
    func testPerformance() {
        measure {
            // Add performance tests here
        }
    }
}
</file>

<file path="pdf22md/Package.resolved">
{
  "pins" : [
    {
      "identity" : "swift-argument-parser",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/apple/swift-argument-parser",
      "state" : {
        "revision" : "011f0c765fb46d9cac61bca19be0527e99c98c8b",
        "version" : "1.5.1"
      }
    }
  ],
  "version" : 2
}
</file>

<file path="pdf22md/Package.swift">
// swift-tools-version: 5.7
// The swift-tools-version declares the minimum version of Swift required to build this package.

import PackageDescription

let package = Package(
    name: "pdf22md",
    platforms: [
        .macOS(.v12) // Required for async/await
    ],
    products: [
        // Library product for programmatic usage
        .library(
            name: "PDF22MD",
            targets: ["PDF22MD"]
        ),
        .executable(
            name: "pdf22md",
            targets: ["PDF22MDCli"]
        )
    ],
    dependencies: [
        .package(url: "https://github.com/apple/swift-argument-parser", from: "1.3.0")
    ],
    targets: [
        // Main library target
        .target(
            name: "PDF22MD",
            dependencies: [],
            path: "Sources/PDF22MD",
            swiftSettings: [
                .define("VERSION", .when(platforms: [.macOS]))
            ]
        ),
        .executableTarget(
            name: "PDF22MDCli",
            dependencies: [
                "PDF22MD",
                .product(name: "ArgumentParser", package: "swift-argument-parser")
            ],
            path: "Sources/PDF22MDCli"
        ),
        // Test target
        .testTarget(
            name: "PDF22MDTests",
            dependencies: ["PDF22MD"],
            path: "Tests/PDF22MDTests"
        )
    ]
)
</file>

<file path="pdf22md/README.md">
# pdf22md

A high-performance PDF to Markdown converter built with modern Swift features including async/await, actors, and structured concurrency.

## Features

- **Modern Swift**: Uses Swift 5.7+ features including async/await, actors, and result builders
- **Structured Concurrency**: Concurrent page processing with TaskGroup and proper cancellation
- **Memory Safe**: Automatic memory management with value types where appropriate
- **Type Safe**: Strong typing with enums, associated types, and generic constraints
- **Actor-Based Assets**: Thread-safe image processing with actors
- **Progress Streaming**: Real-time progress updates with AsyncSequence

## Building

### Using Swift Package Manager
```bash
# Build the project
swift build

# Build optimized release
swift build -c release

# Run tests
swift test

# Install executable
swift build -c release
cp .build/release/pdf22md /usr/local/bin/pdf22md
```

## Installation

### Swift Package Manager

Add to your `Package.swift`:

```swift
dependencies: [
    .package(path: "./pdf22md")
]
```

## Usage

### Command Line

```bash
# Convert a PDF file
pdf22md -i document.pdf -o document.md

# Extract images to assets folder
pdf22md -i report.pdf -o report.md -a ./assets

# Customize DPI and concurrency
pdf22md -i large.pdf -o large.md -d 300 --max-concurrency 8

# Use with pipes
cat document.pdf | pdf22md > document.md

# Verbose output with progress
pdf22md -i document.pdf -o document.md --verbose
```

### Programmatic Usage

```swift
import PDF22MD

// Simple conversion
let converter = try PDFConverter(url: inputURL)
let markdown = try await converter.convert()

// With custom options
let options = ConversionOptions(
    assetsFolderPath: "./assets",
    rasterizationDPI: 300.0,
    includeMetadata: true
)

let markdown = try await converter.convert(options: options)
```

## Testing

```bash
# Run all tests
swift test

# Run specific test
swift test --filter PDF22MDTests.testTextElementCreation

# Run tests with coverage
swift test --enable-code-coverage
```

## Requirements

- macOS 12.0 or later (for async/await)
- Swift 5.7 or later
- Xcode 14.0 or later

## License

MIT License - see LICENSE file in the root directory
</file>

<file path=".cursorrules">
# pdf22md

A blazingly fast PDF to Markdown converter for macOS.

`pdf22md` is a command-line tool that extracts all text and image content from a PDF file and converts it into a clean Markdown document. It uses Grand Central Dispatch (GCD) to process pages and save images in parallel, making it exceptionally fast for multi-page documents.

### Key Features

  * **High-Speed Conversion**: Uses all available CPU cores to process PDF pages concurrently.
  * **Intelligent Heading Detection**: Analyzes font sizes and usage frequency to automatically format titles and headings (`#`, `##`, etc.).
  * **Asset Extraction**: Saves raster and vector images into a specified assets folder and links them correctly in the Markdown file.
  * **Smart Image Formatting**: Automatically chooses between JPEG (for photos) and PNG (for graphics with transparency) to optimize file size and quality.
  * **Flexible I/O**: Reads from a PDF file or `stdin` and writes to a Markdown file or `stdout`.
  * **Customizable Rasterization**: Allows setting a custom DPI for converting vector graphics to bitmaps.

### Installation

Once the Homebrew tap is set up (see plan below), installation is simple:

```bash
brew install <your-username>/pdf22md/pdf22md
```

### Building from Source

To build the project manually, you need Xcode Command Line Tools installed.

```bash
# Clone the repository (once it's public)
git clone https://github.com/<your-username>/pdf22md.git
cd pdf22md

# Compile the tool
make

# Install it to /usr/local/bin
sudo make install
```

### Usage

```
Usage: pdf22md [-i input.pdf] [-o output.md] [-a assets_folder] [-d dpi]
  Converts PDF documents to Markdown format
  -i <path>: Input PDF file (default: stdin)
  -o <path>: Output Markdown file (default: stdout)
  -a <path>: Assets folder for extracted images
  -d <dpi>: DPI for rasterizing vector graphics (default: 144)
```

**Example:**

```bash
# Convert a local PDF file and save images to an 'assets' folder
pdf22md -i report.pdf -o report.md -a ./assets
```

---


# main-overview

## Development Guidelines

- Only modify code directly relevant to the specific request. Avoid changing unrelated functionality.
- Never replace code with placeholders like `# ... rest of the processing ...`. Always include complete code.
- Break problems into smaller steps. Think through each step separately before implementing.
- Always provide a complete PLAN with REASONING based on evidence from code and logs before making changes.
- Explain your OBSERVATIONS clearly, then provide REASONING to identify the exact issue. Add console logs when needed to gather more information.


pdf22md is a PDF to Markdown converter that transforms PDF documents while preserving their semantic structure and content relationships.

Core Business Components:

1. Document Structure Analysis (Importance: 95)
- Hierarchical heading detection using font statistics
- Document structure preservation through positional element sorting
- Automated heading level assignment (H1-H6) based on font usage patterns

2. Content Classification System (Importance: 85)
- TextElement: Handles formatted text with style attributes
- ImageElement: Manages both raster and vector graphics
- Content relationship tracking between elements

3. Asset Processing Pipeline (Importance: 80)
- Intelligent format selection between PNG/JPEG based on:
  * Transparency detection
  * Color complexity analysis
  * Dimension-based optimization
- Asset extraction with maintained document references

4. PDF Content Processing (Importance: 90)
- Text styling and formatting context preservation
- Vector graphics path construction tracking
- Coordinate system transformation management
- Element bounds calculation for layout fidelity

Key Integration Points:

1. Content Extraction Layer
- Connects PDF parsing with markdown generation
- Maintains element relationships and hierarchy
- Preserves formatting context across transformations

2. Asset Management Layer
- Links extracted images with markdown references
- Maintains asset organization structure
- Handles format conversions while preserving quality

The system organizes business logic around content transformation pipelines while maintaining document semantic structure throughout the conversion process.

—— When you’re done with a round of updates, update CHANGELOG.md with the changes, remove done things from TODO.md, identify new things that need to be done and add them to TODO.md. Then build the app or run ./release.sh and then continue updates.
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2024 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="test_sw.sh">
#!/bin/bash
# Test Swift implementation (pdf22md)
set -e

# Change to script directory
cd "$(dirname "$0")"

# Default to test.pdf if no argument provided
if [ $# -ne 1 ]; then
    PDF="testdata/test.pdf"
else
    PDF=$(realpath "$1")
fi

PDF_DIR=$(dirname "$PDF")
PDF_NAME=$(basename "$PDF" .pdf)
MD_FILE="$PDF_DIR/$PDF_NAME-sw.md"
ASSETS_DIR="$PDF_DIR/$PDF_NAME-sw"

# Build Swift version
echo "Building Swift implementation..."
cd pdf22md && swift build -c release && cd ..

# Run Swift version
echo "Running Swift converter on $PDF..."
echo "Output: $MD_FILE"
echo "Assets: $ASSETS_DIR/"
echo ""

time ./pdf22md/.build/release/pdf22md \
    -i "$PDF" \
    -o "$MD_FILE" \
    -a "$ASSETS_DIR"

echo ""
echo "Swift conversion complete!"
echo "Markdown: $MD_FILE"
if [ -d "$ASSETS_DIR" ]; then
    ASSET_COUNT=$(find "$ASSETS_DIR" -type f | wc -l | tr -d ' ')
    echo "Assets: $ASSET_COUNT files in $ASSETS_DIR/"
fi
</file>

<file path="test.sh">
#!/bin/bash
# Test pdf22md Swift implementation
set -e

# Change to script directory
cd "$(dirname "$0")"

# Default to test.pdf if no argument provided
if [ $# -ne 1 ]; then
    PDF="testdata/test.pdf"
else
    PDF=$(realpath "$1")
fi

PDF_DIR=$(dirname "$PDF")
PDF_NAME=$(basename "$PDF" .pdf)
MD_FILE="$PDF_DIR/$PDF_NAME.md"
ASSETS_DIR="$PDF_DIR/$PDF_NAME-assets"

# Build Swift version first
echo "Building pdf22md..."
./build.sh

echo ""
echo "Running pdf22md converter on $PDF..."
echo "Output: $MD_FILE"
echo ""

# Run Swift version
echo "Starting pdf22md converter..."
CG_PDF_VERBOSE=True time ./pdf22md/.build/release/pdf22md \
    -i "$PDF" \
    -o "$MD_FILE" \
    -a "$ASSETS_DIR"
echo "Complete!"

echo ""
echo "Conversion complete!"
echo ""
echo "Results:"
echo "--------"
echo "  Markdown: $MD_FILE"
if [ -d "$ASSETS_DIR" ]; then
    ASSET_COUNT=$(find "$ASSETS_DIR" -type f | wc -l | tr -d ' ')
    echo "  Assets: $ASSET_COUNT files in $ASSETS_DIR/"
fi
</file>

<file path="TROUBLESHOOTING.md">
# Troubleshooting Guide

## Swift Build Failures

### SWBBuildService.framework Missing

**Error Message:**
```
Library not loaded: @rpath/SWBBuildService.framework/Versions/A/SWBBuildService
```

**Description:**
This error occurs when the Swift Package Manager framework is missing or corrupted in the Command Line Tools installation. This is a known issue that can happen after macOS updates or when Command Line Tools are partially installed.

**Solutions:**

#### Option 1: Switch to Xcode's Swift toolchain (if Xcode is installed)
```bash
sudo xcode-select -s /Applications/Xcode.app/Contents/Developer
```

#### Option 2: Reinstall Command Line Tools
```bash
sudo rm -rf /Library/Developer/CommandLineTools
xcode-select --install
```

#### Option 3: Use the Objective-C implementation
The Objective-C implementation is fully functional and doesn't require Swift:
```bash
./build.sh --objc-only
```

### Swift Package Manager Not Working

**Symptoms:**
- `swift package` commands fail
- `swift build` exits with code 6 (Abort trap)

**Diagnosis:**
Check if Swift Package Manager is functional:
```bash
swift package --version
```

If this fails, follow the solutions for SWBBuildService.framework above.

## Build Script Issues

### Both Implementations Failing

If both Swift and Objective-C builds fail:

1. Ensure Xcode Command Line Tools are installed:
   ```bash
   xcode-select --install
   ```

2. Check tool availability:
   ```bash
   clang --version
   swift --version
   make --version
   ```

3. Reset Xcode path to default:
   ```bash
   sudo xcode-select --reset
   ```

### Permission Issues

If you encounter permission errors during installation:

1. Ensure you have sudo access
2. Check that `/usr/local/bin` exists and is writable:
   ```bash
   ls -la /usr/local/bin
   ```

## Runtime Issues

### PDF Conversion Errors

If pdf22md fails to convert specific PDFs:

1. Check PDF file permissions
2. Ensure the PDF is not encrypted or password-protected
3. Try with a different DPI setting:
   ```bash
   pdf22md -i input.pdf -o output.md -d 72
   ```

### Missing Assets Folder

If images are not being extracted:

1. Specify an assets folder explicitly:
   ```bash
   pdf22md -i input.pdf -o output.md -a ./assets
   ```

2. Ensure the parent directory has write permissions

## Getting Help

If you continue to experience issues:

1. Check the GitHub issues: https://github.com/anthropics/pdf22md/issues
2. Run the build script with verbose output and save the log:
   ```bash
   ./build.sh 2>&1 | tee build.log
   ```
3. Include the build.log when reporting issues
</file>

<file path=".github/workflows/build-release.yml">
name: Build and Release

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  release:
    types: [ created ]

jobs:
  build:
    runs-on: macos-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Build the tool
      run: make

    - name: Run a basic check
      run: ./pdf22md -h

  create-release:
    if: github.event_name == 'release'
    runs-on: macos-latest
    needs: build

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Build the binary
      run: make

    - name: Create Tarball Archive
      run: |
        tar -czvf pdf22md-macos-x86_64.tar.gz pdf22md

    - name: Upload Release Asset
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ github.event.release.upload_url }}
        asset_path: ./pdf22md-macos-x86_64.tar.gz
        asset_name: pdf22md-macos-x86_64.tar.gz
        asset_content_type: application/gzip
</file>

<file path=".github/workflows/release.yml">
name: Build and Release

on:
  push:
    tags:
      - 'v*.*.*'  # Matches version tags like v1.0.0, v2.1.3, etc.
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build:
    name: Build on macOS
    runs-on: macos-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history for proper versioning
    
    - name: Setup Swift
      uses: swift-actions/setup-swift@v2
      with:
        swift-version: '5.9'
    
    - name: Get version
      id: get_version
      run: |
        if [[ "${GITHUB_REF}" == refs/tags/* ]]; then
          VERSION=${GITHUB_REF#refs/tags/}
        else
          VERSION=$(git describe --tags --always --dirty 2>/dev/null || echo "dev")
        fi
        echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT
        echo "Building version: ${VERSION}"
    
    - name: Build
      run: make build
    
    - name: Run tests
      run: make test
    
    - name: Create distribution package
      if: startsWith(github.ref, 'refs/tags/')
      run: make dist
    
    - name: Upload DMG artifact
      if: startsWith(github.ref, 'refs/tags/')
      uses: actions/upload-artifact@v4
      with:
        name: pdf22md-${{ steps.get_version.outputs.VERSION }}.dmg
        path: dist/pdf22md-${{ steps.get_version.outputs.VERSION }}.dmg
    
    - name: Create Release
      if: startsWith(github.ref, 'refs/tags/')
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ github.ref }}
        release_name: pdf22md ${{ steps.get_version.outputs.VERSION }}
        body: |
          ## pdf22md ${{ steps.get_version.outputs.VERSION }}
          
          ### Installation
          
          Download the DMG file below and open it. Double-click the installer package to install pdf22md to `/usr/local/bin`.
          
          ### What's New
          
          See [CHANGELOG.md](https://github.com/${{ github.repository }}/blob/${{ github.ref }}/CHANGELOG.md) for details.
        draft: false
        prerelease: false
    
    - name: Upload Release Asset
      if: startsWith(github.ref, 'refs/tags/')
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: dist/pdf22md-${{ steps.get_version.outputs.VERSION }}.dmg
        asset_name: pdf22md-${{ steps.get_version.outputs.VERSION }}.dmg
        asset_content_type: application/x-apple-diskimage
</file>

<file path="pdf22md/Sources/PDF22MD/CGPDFImageExtractor.swift">
import Foundation
import PDFKit
import CoreGraphics

/// Utility responsible for extracting raster images from a PDF page.
/// Extracts actual embedded images from PDF XObject streams.
struct CGPDFImageExtractor {
    /// Extract raster images from `page`.
    /// - Parameters:
    ///   - page: PDFKit page to analyse.
    ///   - pageIndex: Zero-based page index – passed into resulting `ImageElement`s.
    ///   - dpi: Desired rasterisation DPI (not used for embedded images, kept for API compatibility).
    /// - Returns: Array of `ImageElement`s ready for markdown generator.
    static func extractImages(from page: PDFPage,
                              pageIndex: Int,
                              dpi: CGFloat = 144.0) -> [ImageElement] {
        var elements: [ImageElement] = []
        
        // Get the underlying CGPDFPage
        guard let cgPage = page.pageRef else { return elements }
        
        // Extract images from XObject dictionary
        elements.append(contentsOf: extractXObjectImages(from: cgPage, pageIndex: pageIndex))
        
        return elements
    }

    // MARK: - XObject Image Extraction
    
    private static func extractXObjectImages(from cgPage: CGPDFPage, pageIndex: Int) -> [ImageElement] {
        var elements: [ImageElement] = []
        
        // Get page dictionary
        guard let pageDict = cgPage.dictionary else { return elements }
        
        // Get Resources dictionary
        var resDict: CGPDFDictionaryRef?
        guard CGPDFDictionaryGetDictionary(pageDict, "Resources", &resDict),
              let resources = resDict else { return elements }
        
        // Get XObject dictionary
        var xObjDict: CGPDFDictionaryRef?
        guard CGPDFDictionaryGetDictionary(resources, "XObject", &xObjDict),
              let xObject = xObjDict else { return elements }
        
        // Iterate through XObject entries
        CGPDFDictionaryApplyBlock(xObject, { keyPtr, object, _ in
            // Object name is available if needed for debugging
            // let objectName = String(cString: keyPtr)
            
            // Check if it's a stream
            var streamRef: CGPDFStreamRef?
            guard CGPDFObjectGetValue(object, .stream, &streamRef),
                  let stream = streamRef,
                  let streamDict = CGPDFStreamGetDictionary(stream) else {
                return true // continue iteration
            }
            
            // Check if it's an Image subtype
            var subtypePtr: UnsafePointer<Int8>?
            CGPDFDictionaryGetName(streamDict, "Subtype", &subtypePtr)
            guard let subtype = subtypePtr,
                  String(cString: subtype) == "Image" else {
                return true // continue iteration
            }
            
            // Extract image data
            var format = CGPDFDataFormat.raw
            guard let cfData = CGPDFStreamCopyData(stream, &format) else {
                return true // continue iteration
            }
            
            let imageData = cfData as Data
            
            // Try to create CGImage based on format
            if let cgImage = createImage(from: imageData, format: format, streamDict: streamDict) {
                // Get image bounds (use width/height from stream dictionary)
                let bounds = getImageBounds(from: streamDict)
                
                let element = ImageElement(
                    image: cgImage,
                    bounds: bounds,
                    pageIndex: pageIndex,
                    isVectorSource: false
                )
                elements.append(element)
            }
            
            return true // continue iteration
        }, nil)
        
        return elements
    }
    
    private static func createImage(from data: Data, format: CGPDFDataFormat, streamDict: CGPDFDictionaryRef) -> CGImage? {
        switch format {
        case .jpegEncoded:
            // JPEG data can be used directly
            return CGImage(jpegDataProviderSource: CGDataProvider(data: data as CFData)!,
                          decode: nil,
                          shouldInterpolate: true,
                          intent: .defaultIntent)
            
        case .JPEG2000:
            // For JPEG2000, we can try to create an image from the data
            // Note: This might not work on all systems
            if let dataProvider = CGDataProvider(data: data as CFData),
               let source = CGImageSourceCreateWithDataProvider(dataProvider, nil),
               CGImageSourceGetCount(source) > 0 {
                return CGImageSourceCreateImageAtIndex(source, 0, nil)
            }
            return nil
            
        case .raw:
            // For raw data, we need to read image properties from the stream dictionary
            return createImageFromRawData(data, streamDict: streamDict)
            
        @unknown default:
            return nil
        }
    }
    
    private static func createImageFromRawData(_ data: Data, streamDict: CGPDFDictionaryRef) -> CGImage? {
        // Get image dimensions
        var width: CGPDFInteger = 0
        var height: CGPDFInteger = 0
        guard CGPDFDictionaryGetInteger(streamDict, "Width", &width),
              CGPDFDictionaryGetInteger(streamDict, "Height", &height),
              width > 0, height > 0 else { return nil }
        
        // Get bits per component
        var bitsPerComponent: CGPDFInteger = 8
        CGPDFDictionaryGetInteger(streamDict, "BitsPerComponent", &bitsPerComponent)
        
        // For now, we'll assume RGB color space for simplicity
        // A full implementation would need to parse the ColorSpace entry
        let colorSpace = CGColorSpaceCreateDeviceRGB()
        let bytesPerRow = Int(width) * 4 // Assuming RGBA
        
        guard let dataProvider = CGDataProvider(data: data as CFData) else { return nil }
        
        return CGImage(
            width: Int(width),
            height: Int(height),
            bitsPerComponent: Int(bitsPerComponent),
            bitsPerPixel: Int(bitsPerComponent) * 4,
            bytesPerRow: bytesPerRow,
            space: colorSpace,
            bitmapInfo: CGBitmapInfo(rawValue: CGImageAlphaInfo.premultipliedLast.rawValue),
            provider: dataProvider,
            decode: nil,
            shouldInterpolate: true,
            intent: .defaultIntent
        )
    }
    
    private static func getImageBounds(from streamDict: CGPDFDictionaryRef) -> CGRect {
        var width: CGPDFInteger = 0
        var height: CGPDFInteger = 0
        
        CGPDFDictionaryGetInteger(streamDict, "Width", &width)
        CGPDFDictionaryGetInteger(streamDict, "Height", &height)
        
        // PDF images don't have an origin, so we use zero
        return CGRect(x: 0, y: 0, width: CGFloat(width), height: CGFloat(height))
    }
}
</file>

<file path="pdf22md/Sources/PDF22MD/PDFMarkdownConverterUltraOptimized.swift">
import Foundation
import PDFKit

/// Ultra-optimized converter using NSString, pre-allocation, and minimal overhead
public final class PDFMarkdownConverterUltraOptimized {
    private let pdfURL: URL
    private let outputPath: String?
    private let assetsPath: String?
    private let dpi: CGFloat
    
    // Pre-allocated buffers
    private let markdownBuffer: NSMutableString
    private var fontCache: [NSString: CGFloat] = [:]
    
    public init(pdfURL: URL, outputPath: String?, assetsPath: String?, dpi: CGFloat = 144.0) {
        self.pdfURL = pdfURL
        self.outputPath = outputPath
        self.assetsPath = assetsPath
        self.dpi = dpi
        // Pre-allocate with large capacity
        self.markdownBuffer = NSMutableString(capacity: 1024 * 1024) // 1MB initial capacity
    }
    
    /// Convert PDF to Markdown with maximum performance
    public func convert() throws {
        guard let pdfDocument = PDFDocument(url: pdfURL) else {
            throw PDFConversionError.invalidPDF
        }
        
        let pageCount = pdfDocument.pageCount
        
        // Use simple concurrent queue with limited concurrency
        let queue = DispatchQueue(label: "pdf.ultra", attributes: .concurrent)
        let semaphore = DispatchSemaphore(value: ProcessInfo.processInfo.activeProcessorCount)
        let group = DispatchGroup()
        
        // Pre-allocate result storage
        var pageResults = ContiguousArray<(Int, ContiguousArray<PDFElement>)>()
        pageResults.reserveCapacity(pageCount)
        let lock = NSLock()
        
        // Process pages with controlled concurrency
        for pageIndex in 0..<pageCount {
            group.enter()
            semaphore.wait()
            
            queue.async {
                autoreleasepool {
                    defer {
                        semaphore.signal()
                        group.leave()
                    }
                    
                    guard let page = pdfDocument.page(at: pageIndex) else { return }
                    
                    let processor = PDFPageProcessorUltraOptimized(
                        page: page,
                        pageIndex: pageIndex,
                        dpi: self.dpi,
                        assetsPath: self.assetsPath
                    )
                    
                    let elements = processor.processPage()
                    
                    lock.lock()
                    pageResults.append((pageIndex, elements))
                    lock.unlock()
                }
            }
        }
        
        group.wait()
        
        // Sort by page index using in-place sort
        pageResults.sort { $0.0 < $1.0 }
        
        // Analyze fonts with caching
        analyzeFontsOptimized(pageResults: pageResults)
        
        // Generate markdown directly into buffer
        generateMarkdownOptimized(pageResults: pageResults)
        
        // Write output
        if let outputPath = outputPath {
            try markdownBuffer.write(
                toFile: outputPath,
                atomically: true,
                encoding: String.Encoding.utf8.rawValue
            )
        } else {
            print(markdownBuffer as String)
        }
    }
    
    @inline(__always)
    private func analyzeFontsOptimized(pageResults: ContiguousArray<(Int, ContiguousArray<PDFElement>)>) {
        var fontSizes: [CGFloat: Int] = [:]
        fontSizes.reserveCapacity(20)
        
        var totalTextElements = 0
        
        // Single pass through all elements
        for (_, elements) in pageResults {
            for element in elements {
                if let textElement = element as? TextElement {
                    fontSizes[textElement.fontSize, default: 0] += 1
                    totalTextElements += 1
                    
                    // Cache font info by size
                }
            }
        }
        
        // Quick analysis without sorting
        let threshold = totalTextElements / 20
        for (size, count) in fontSizes where count > threshold {
            // Mark as heading size
            fontCache[NSString(string: "heading_\(size)")] = size
        }
    }
    
    @inline(__always)
    private func generateMarkdownOptimized(pageResults: ContiguousArray<(Int, ContiguousArray<PDFElement>)>) {
        markdownBuffer.setString("")
        
        for (_, elements) in pageResults {
            for element in elements {
                if let textElement = element as? TextElement {
                    // Check if heading using cached info
                    let isHeading = fontCache[NSString(string: "heading_\(textElement.fontSize)")] != nil
                    
                    if isHeading {
                        markdownBuffer.append("## ")
                    }
                    
                    // Direct string append
                    markdownBuffer.append(textElement.text)
                    markdownBuffer.append("\n\n")
                } else if let imageElement = element as? ImageElement {
                    markdownBuffer.append("![Image](")
                    markdownBuffer.append(imageElement.path)
                    markdownBuffer.append(")\n\n")
                }
            }
        }
    }
}

/// Ultra-optimized page processor
final class PDFPageProcessorUltraOptimized {
    private let pdfPage: PDFPage
    private let pageIndex: Int
    private let dpi: CGFloat
    private let assetsPath: String?
    private var elementBuffer: ContiguousArray<PDFElement>
    
    init(page: PDFPage, pageIndex: Int, dpi: CGFloat = 144.0, assetsPath: String? = nil) {
        self.pdfPage = page
        self.pageIndex = pageIndex
        self.dpi = dpi
        self.assetsPath = assetsPath
        self.elementBuffer = ContiguousArray<PDFElement>()
        self.elementBuffer.reserveCapacity(500)
    }
    
    @inline(__always)
    func processPage() -> ContiguousArray<PDFElement> {
        elementBuffer.removeAll(keepingCapacity: true)
        
        guard let pageContent = pdfPage.attributedString else { 
            return elementBuffer 
        }
        
        // Process using NSString directly
        let nsString = pageContent.string as NSString
        let length = nsString.length
        var position = 0
        
        while position < length {
            var range = NSRange()
            let attrs = pageContent.attributes(at: position, longestEffectiveRange: &range, in: NSRange(location: 0, length: length))
            
            let text = nsString.substring(with: range)
            if !text.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                // Extract font info inline
                let font = attrs[.font] as? NSFont
                let element = TextElement(
                    text: text,
                    bounds: CGRect.zero, // Skip bounds calculation for speed
                    pageIndex: pageIndex,
                    fontSize: font?.pointSize ?? 12.0,
                    isBold: false,
                    isItalic: false
                )
                elementBuffer.append(element)
            }
            
            position = NSMaxRange(range)
        }
        
        return elementBuffer
    }
}
</file>

<file path="CONTRIBUTING.md">
# Contributing to pdf22md

Thank you for your interest in contributing to `pdf22md`! This document outlines how you can contribute to the project, focusing on technical details, code structure, and development guidelines.

## Project Overview

`pdf22md` is a high-performance PDF to Markdown converter built with Swift, leveraging Swift's latest concurrency features (async/await, actors) and Swift Package Manager. The project focuses on accurate PDF conversion with intelligent heading detection and smart image extraction.

## Codebase Structure

The project root contains shared documentation, build scripts, and the main Swift implementation:

-   `pdf22md/`: Contains the Swift source code, `Package.swift` (Swift Package Manager manifest), and test resources.
    -   `pdf22md/Sources/PDF22MD/`: Core Swift library modules.
    -   `pdf22md/Sources/PDF22MDCli/`: Swift command-line interface entry point.
    -   `pdf22md/Tests/PDF22MDTests/`: Unit tests.

-   `Makefile`: Main build automation (build, install, dist targets).
-   `build.sh`: Alternative build script.
-   `test.sh`: Script to run tests.
-   `docs/`: General project documentation.
-   `issues/`: Issue tracking files.

## Technical Requirements and Conventions

### General Guidelines

-   **Platform**: Development is for macOS 12.0+.
-   **Language Standards**: Use Swift 5.7+ with async/await and structured concurrency.
-   **Performance**: Given the nature of PDF processing, performance is critical. Contributions should be mindful of CPU and memory efficiency.
-   **Error Handling**: Use Swift's native `Error` protocol and custom error enums.
-   **Testing**: All new features and bug fixes should be accompanied by appropriate unit and/or integration tests.

### Swift Development

-   **Swift Package Manager**: The project is managed with SPM. Ensure your changes integrate seamlessly.
-   **Concurrency**: Use Swift's `async/await` and `Actors` for concurrent operations.
-   **Error Handling**: Define custom `Error` enums where appropriate and propagate errors using `throws`.
-   **Value Types**: Prefer `struct`s over `class`es where appropriate to leverage Swift's value semantics and improve memory safety.
-   **Code Style**: Follow Swift's API Design Guidelines and use SwiftFormat for consistent formatting.

## Development Workflow

1.  **Fork the Repository**: Start by forking the `pdf22md` repository on GitHub.
2.  **Clone Your Fork**: `git clone https://github.com/YOUR_USERNAME/pdf22md.git`
3.  **Create a New Branch**: `git checkout -b feature/your-feature-name` or `bugfix/issue-number`.
4.  **Make Your Changes**: Implement your feature or bug fix, adhering to the technical requirements and conventions.
5.  **Write Tests**: Add or update tests to cover your changes.
6.  **Run Tests**: Ensure all tests pass:
    ```bash
    ./test.sh
    ```
7.  **Build the Project**: Verify the build succeeds:
    ```bash
    make build
    ```
8.  **Update Documentation**: If your changes affect functionality or usage, update `README.md`, `CHANGELOG.md`, or other relevant documentation.
9.  **Commit Your Changes**: Write clear, concise commit messages.
10. **Push to Your Fork**: `git push origin feature/your-feature-name`
11. **Open a Pull Request**: Submit a pull request to the `main` branch of the original `pdf22md` repository.

## How to Orchestrate Code Changes

### Key Areas for Contribution

-   **Core PDF Processing**: Enhancements to text extraction, heading detection, or image handling in `pdf22md/Sources/PDF22MD/`.
-   **Performance Optimizations**: Improvements to async/await patterns and concurrent processing.
-   **CLI Enhancements**: Changes to command-line arguments or I/O handling in `pdf22md/Sources/PDF22MDCli/main.swift`.
-   **Testing**: Expanding test coverage for edge cases in PDF processing.

### Implementation Guidelines

1. **Follow Swift Best Practices**: Use Swift's modern features effectively.
2. **Maintain Backward Compatibility**: Ensure changes don't break existing functionality.
3. **Document Complex Logic**: Add clear comments for non-obvious implementations.
4. **Consider Edge Cases**: PDFs can vary widely; test with diverse samples.

## Reporting Issues

If you find a bug or have a feature request, please open an issue on the [GitHub Issues page](https://github.com/twardoch/pdf22md/issues). Provide as much detail as possible, including steps to reproduce, expected behavior, and your environment.

## Code of Conduct

This project adheres to a [Code of Conduct](CODE_OF_CONDUCT.md - *link to be added*). By participating, you are expected to uphold this code.

## License

By contributing to `pdf22md`, you agree that your contributions will be licensed under the MIT License.
</file>

<file path="pdf22md/Sources/PDF22MD/AssetExtractor.swift">
import Foundation
import CoreGraphics
import ImageIO
import UniformTypeIdentifiers

/// Handles extraction and saving of image assets from PDFs
final class AssetExtractor {
    private let assetsPath: String?
    private let pdfBasename: String
    private var pageImageCounts: [Int: Int] = [:]
    private let fileManager = FileManager.default
    
    init(assetsPath: String?, pdfBasename: String) {
        self.assetsPath = assetsPath
        self.pdfBasename = pdfBasename
        
        // Create assets directory if specified and valid
        if let path = assetsPath, !path.isEmpty {
            try? fileManager.createDirectory(atPath: path, withIntermediateDirectories: true)
        }
    }
    
    /// Save an image asset and return the (relative) path to be used in Markdown.
    ///
    /// The returned string now always contains the **assets directory prefix** so that
    /// generated Markdown references point to the actual file location, e.g.
    /// `assets/report-001-01.png`.
    /// - Note: If the provided `assetsPath` is absolute, the absolute path is returned.
    ///         If it is relative (e.g. `./assets` or `assets`), the same relative prefix
    ///         will be included in the returned value.
    func saveImage(_ image: CGImage, pageIndex: Int, isVector: Bool) -> String? {
        guard let assetsPath = assetsPath else { return nil }
        
        // Increment asset counter for the current page
        let assetNumber = (pageImageCounts[pageIndex] ?? 0) + 1
        pageImageCounts[pageIndex] = assetNumber
        
        // Decide on output format
        let format = shouldUsePNG(for: image) ? "png" : "jpg"
        
        // Construct file name: <basename>-<page>-<asset>.<ext>
        let fileName = String(
            format: "%@-%03d-%02d.%@",
            pdfBasename,
            pageIndex + 1,
            assetNumber,
            format
        )
        
        // Full filesystem path where the image will be saved
        let filePath = (assetsPath as NSString).appendingPathComponent(fileName)
        
        // Persist the image to disk
        let saved: Bool = format == "png" ? savePNG(image, to: filePath) : saveJPEG(image, to: filePath)
        
        guard saved else { return nil }
        
        // Return the path that should be placed in Markdown. Prefer a *relative* path
        // when the assets directory itself is relative; otherwise fall back to absolute.
        if (assetsPath as NSString).isAbsolutePath {
            return filePath
        } else {
            // Remove leading "./" if present for cleaner Markdown
            let cleanedAssetsPath = assetsPath.hasPrefix("./") ? String(assetsPath.dropFirst(2)) : assetsPath
            return (cleanedAssetsPath as NSString).appendingPathComponent(fileName)
        }
    }
    
    private func shouldUsePNG(for image: CGImage) -> Bool {
        // Use PNG if image has alpha channel
        if let alphaInfo = CGImageAlphaInfo(rawValue: image.alphaInfo.rawValue),
           alphaInfo != .none && alphaInfo != .noneSkipFirst && alphaInfo != .noneSkipLast {
            return true
        }
        
        // Use PNG for small images (likely icons/graphics)
        if image.width < 300 || image.height < 300 {
            return true
        }
        
        // Use PNG for images with few colors (likely graphics)
        // This is a simplified heuristic
        if image.bitsPerPixel <= 8 {
            return true
        }
        
        return false
    }
    
    private func savePNG(_ image: CGImage, to path: String) -> Bool {
        guard let destination = CGImageDestinationCreateWithURL(
            URL(fileURLWithPath: path) as CFURL,
            UTType.png.identifier as CFString,
            1,
            nil
        ) else { return false }
        
        CGImageDestinationAddImage(destination, image, nil)
        return CGImageDestinationFinalize(destination)
    }
    
    private func saveJPEG(_ image: CGImage, to path: String) -> Bool {
        guard let destination = CGImageDestinationCreateWithURL(
            URL(fileURLWithPath: path) as CFURL,
            UTType.jpeg.identifier as CFString,
            1,
            nil
        ) else { return false }
        
        let options: [CFString: Any] = [
            kCGImageDestinationLossyCompressionQuality: 0.85
        ]
        
        CGImageDestinationAddImage(destination, image, options as CFDictionary)
        return CGImageDestinationFinalize(destination)
    }
}
</file>

<file path="pdf22md/Sources/PDF22MD/PDFMarkdownConverter.swift">
import Foundation
import PDFKit

/// Main converter class that orchestrates PDF to Markdown conversion
public final class PDFMarkdownConverter {
    private let pdfURL: URL
    private let outputPath: String?
    private let assetsPath: String?
    private let dpi: CGFloat
    
    public init(pdfURL: URL, outputPath: String?, assetsPath: String?, dpi: CGFloat = 144.0) {
        self.pdfURL = pdfURL
        self.outputPath = outputPath
        self.assetsPath = assetsPath
        self.dpi = dpi
    }
    
    /// Convert PDF to Markdown
    public func convert() async throws {
        guard let pdfDocument = PDFDocument(url: pdfURL) else {
            throw PDFConversionError.invalidPDF
        }
        
        let pageCount = pdfDocument.pageCount
        var allElements: [PDFElement] = []
        
        // Process pages concurrently
        await withTaskGroup(of: (Int, [PDFElement]).self) { group in
            for pageIndex in 0..<pageCount {
                group.addTask {
                    guard let page = pdfDocument.page(at: pageIndex) else {
                        return (pageIndex, [])
                    }
                    
                    let processor = PDFPageProcessor(page: page, pageIndex: pageIndex, dpi: self.dpi, assetsPath: self.assetsPath)
                    let elements = processor.processPage()
                    return (pageIndex, elements)
                }
            }
            
            // Collect results in order
            var pageElements: [(Int, [PDFElement])] = []
            for await result in group {
                pageElements.append(result)
            }
            
            // Sort by page index and flatten
            pageElements.sort { $0.0 < $1.0 }
            allElements = pageElements.flatMap { $0.1 }
        }
        
        // Analyze fonts for heading detection
        let fontStats = analyzeFonts(from: allElements)
        
        // Generate markdown
        let markdown = generateMarkdown(from: allElements, fontStats: fontStats)
        
        // Write output
        if let outputPath = outputPath {
            // Ensure parent directory exists
            let outputURL = URL(fileURLWithPath: outputPath)
            let directoryURL = outputURL.deletingLastPathComponent()
            let fileManager = FileManager.default
            if !fileManager.fileExists(atPath: directoryURL.path) {
                try fileManager.createDirectory(at: directoryURL, withIntermediateDirectories: true, attributes: nil)
            }
            // Attempt to write the file and throw a descriptive error on failure
            do {
                try markdown.write(to: outputURL, atomically: true, encoding: .utf8)
            } catch {
                throw PDFConversionError.invalidPDF // reuse existing error, ideally define new but keep simple
            }
        } else {
            print(markdown)
        }
    }
    
    private func analyzeFonts(from elements: [PDFElement]) -> FontStatistics {
        var fontSizes: [CGFloat: Int] = [:]
        var totalTextElements = 0
        
        for element in elements {
            guard let textElement = element as? TextElement else { continue }
            fontSizes[textElement.fontSize, default: 0] += 1
            totalTextElements += 1
        }
        
        // Sort font sizes by frequency
        let sortedSizes = fontSizes.sorted { $0.value > $1.value }
        
        // Determine heading sizes (top 3-4 sizes that aren't the most common)
        var headingSizes: Set<CGFloat> = []
        if sortedSizes.count > 1 {
            // Skip the most common size (likely body text)
            for i in 1..<min(4, sortedSizes.count) {
                if sortedSizes[i].value > totalTextElements / 20 { // At least 5% of elements
                    headingSizes.insert(sortedSizes[i].key)
                }
            }
        }
        
        let bodySize = sortedSizes.first?.key ?? 12.0
        
        return FontStatistics(
            bodySizeThreshold: bodySize,
            headingSizes: headingSizes,
            fontSizeFrequencies: fontSizes
        )
    }
    
    private func generateMarkdown(from elements: [PDFElement], fontStats: FontStatistics) -> String {
        var markdown = ""
        
        // Extract PDF basename for asset naming
        let pdfBasename = pdfURL.deletingPathExtension().lastPathComponent
        let assetExtractor = AssetExtractor(assetsPath: assetsPath, pdfBasename: pdfBasename)
        
        // Sort elements by page and vertical position
        let sortedElements = elements.sorted { lhs, rhs in
            if lhs.pageIndex != rhs.pageIndex {
                return lhs.pageIndex < rhs.pageIndex
            }
            // Sort top to bottom (flip Y coordinate)
            return lhs.bounds.origin.y > rhs.bounds.origin.y
        }
        
        var previousElement: PDFElement?
        
        for element in sortedElements {
            // Add page breaks
            if let prev = previousElement, prev.pageIndex != element.pageIndex {
                markdown += "\n---\n\n"
            }
            
            switch element {
            case let textElement as TextElement:
                let headingLevel = fontStats.headingLevel(for: textElement.fontSize)
                
                if headingLevel > 0 {
                    markdown += String(repeating: "#", count: headingLevel) + " "
                }
                
                var text = textElement.text
                
                // Apply formatting
                if textElement.isBold && textElement.isItalic {
                    text = "***\(text)***"
                } else if textElement.isBold {
                    text = "**\(text)**"
                } else if textElement.isItalic {
                    text = "*\(text)*"
                }
                
                markdown += text
                
                // Add appropriate spacing
                if headingLevel > 0 {
                    markdown += "\n\n"
                } else {
                    // Check if next element is on a new line
                    if let prev = previousElement as? TextElement,
                       abs(prev.bounds.origin.y - textElement.bounds.origin.y) > 5 {
                        markdown += "\n\n"
                    } else {
                        markdown += " "
                    }
                }
                
            case let imageElement as ImageElement:
                if let image = imageElement.image,
                   let imagePath = assetExtractor.saveImage(image, 
                                                           pageIndex: imageElement.pageIndex,
                                                           isVector: imageElement.isVectorSource) {
                    let altText = imageElement.isVectorSource ? "Vector graphic" : "Image"
                    markdown += "![\(altText)](\(imagePath))\n\n"
                }
                
            default:
                break
            }
            
            previousElement = element
        }
        
        return markdown.trimmingCharacters(in: .whitespacesAndNewlines)
    }
}
</file>

<file path="pdf22md/Sources/PDF22MD/PDFPageProcessorOptimized.swift">
import Foundation
import PDFKit
import CoreGraphics

/// Optimized PDF page processor using NSString and other performance improvements
final class PDFPageProcessorOptimized {
    private let pdfPage: PDFPage
    private let pageIndex: Int
    private let dpi: CGFloat
    private let assetsPath: String?
    
    // Pre-allocated buffers
    private var elementBuffer: ContiguousArray<PDFElement>
    
    init(page: PDFPage, pageIndex: Int, dpi: CGFloat = 144.0, assetsPath: String? = nil) {
        self.pdfPage = page
        self.pageIndex = pageIndex
        self.dpi = dpi
        self.assetsPath = assetsPath
        // Pre-allocate with estimated capacity
        self.elementBuffer = ContiguousArray<PDFElement>()
        self.elementBuffer.reserveCapacity(1000)
    }
    
    /// Process the page and extract all content elements
    @inline(__always)
    func processPage() -> [PDFElement] {
        elementBuffer.removeAll(keepingCapacity: true)
        
        // Extract text elements
        extractTextElements()
        
        // Only extract images if assets path is provided
        if assetsPath != nil {
            // Extract image elements
            extractImageElements()
            
            // Extract vector graphics as images
            extractVectorGraphics()
        }
        
        return Array(elementBuffer)
    }
    
    @inline(__always)
    private func extractTextElements() {
        guard let pageContent = pdfPage.attributedString else { return }
        
        // Use NSString for better performance
        let nsString = pageContent.string as NSString
        let fullRange = NSRange(location: 0, length: nsString.length)
        var currentPosition = 0
        
        // Pre-allocate whitespace character set
        let whitespaceSet = CharacterSet.whitespacesAndNewlines
        
        while currentPosition < nsString.length {
            var effectiveRange = NSRange()
            let attributes = pageContent.attributes(at: currentPosition, 
                                                   longestEffectiveRange: &effectiveRange, 
                                                   in: fullRange)
            
            // Use NSString substring for better performance
            let text = nsString.substring(with: effectiveRange)
            
            // Skip whitespace-only text using NSString
            let trimmed = (text as NSString).trimmingCharacters(in: whitespaceSet)
            if trimmed.isEmpty {
                currentPosition = NSMaxRange(effectiveRange)
                continue
            }
            
            // Extract font information using cached values
            var fontSize: CGFloat = 12.0
            // The font name can be derived from the descriptor if needed. Omit unused placeholder to silence warnings.
            var isBold = false
            var isItalic = false
            
            if let font = attributes[.font] as? NSFont {
                fontSize = font.pointSize
                
                // Use font traits for better performance
                let traits = font.fontDescriptor.symbolicTraits
                isBold = traits.contains(.bold)
                isItalic = traits.contains(.italic)
            }
            
            // Get bounds - optimize by using page bounds directly
            let bounds: CGRect
            if let pdfBounds = pdfPage.selection(for: effectiveRange)?.bounds(for: pdfPage) {
                bounds = pdfBounds
            } else {
                bounds = CGRect(x: 0, y: CGFloat(currentPosition) * 20, width: 100, height: fontSize)
            }
            
            // Create element and add to buffer
            let element = TextElement(
                text: trimmed,
                bounds: bounds,
                pageIndex: pageIndex,
                fontSize: fontSize,
                isBold: isBold,
                isItalic: isItalic
            )
            
            elementBuffer.append(element)
            currentPosition = NSMaxRange(effectiveRange)
        }
    }
    
    @inline(__always)
    private func extractImageElements() {
        let imgs = CGPDFImageExtractor.extractImages(from: pdfPage,
                                                     pageIndex: pageIndex,
                                                     dpi: dpi)
        elementBuffer.append(contentsOf: imgs)
    }
    
    @inline(__always)
    private func extractVectorGraphics() {
        // Implementation remains similar but uses elementBuffer.append directly
        // This is a placeholder - would need full implementation
    }
}

// Use the existing TextElement struct, no need to redefine
</file>

<file path="AGENTS.md">
# pdf22md

A blazingly fast PDF to Markdown converter for macOS.

`pdf22md` is a command-line tool that extracts all text and image content from a PDF file and converts it into a clean Markdown document. It uses Grand Central Dispatch (GCD) to process pages and save images in parallel, making it exceptionally fast for multi-page documents.

### Key Features

  * **High-Speed Conversion**: Uses all available CPU cores to process PDF pages concurrently.
  * **Intelligent Heading Detection**: Analyzes font sizes and usage frequency to automatically format titles and headings (`#`, `##`, etc.).
  * **Asset Extraction**: Saves raster and vector images into a specified assets folder and links them correctly in the Markdown file.
  * **Smart Image Formatting**: Automatically chooses between JPEG (for photos) and PNG (for graphics with transparency) to optimize file size and quality.
  * **Flexible I/O**: Reads from a PDF file or `stdin` and writes to a Markdown file or `stdout`.
  * **Customizable Rasterization**: Allows setting a custom DPI for converting vector graphics to bitmaps.

### Installation

Once the Homebrew tap is set up (see plan below), installation is simple:

```bash
brew install <your-username>/pdf22md/pdf22md
```

### Building from Source

To build the project manually, you need Xcode Command Line Tools installed.

```bash
# Clone the repository (once it's public)
git clone https://github.com/<your-username>/pdf22md.git
cd pdf22md

# Compile the tool
make

# Install it to /usr/local/bin
sudo make install
```

### Usage

```
Usage: pdf22md [-i input.pdf] [-o output.md] [-a assets_folder] [-d dpi]
  Converts PDF documents to Markdown format
  -i <path>: Input PDF file (default: stdin)
  -o <path>: Output Markdown file (default: stdout)
  -a <path>: Assets folder for extracted images
  -d <dpi>: DPI for rasterizing vector graphics (default: 144)
```

**Example:**

```bash
# Convert a local PDF file and save images to an 'assets' folder
pdf22md -i report.pdf -o report.md -a ./assets
```

---


# main-overview

## Development Guidelines

- Only modify code directly relevant to the specific request. Avoid changing unrelated functionality.
- Never replace code with placeholders like `# ... rest of the processing ...`. Always include complete code.
- Break problems into smaller steps. Think through each step separately before implementing.
- Always provide a complete PLAN with REASONING based on evidence from code and logs before making changes.
- Explain your OBSERVATIONS clearly, then provide REASONING to identify the exact issue. Add console logs when needed to gather more information.


pdf22md is a PDF to Markdown converter that transforms PDF documents while preserving their semantic structure and content relationships.

Core Business Components:

1. Document Structure Analysis (Importance: 95)
- Hierarchical heading detection using font statistics
- Document structure preservation through positional element sorting
- Automated heading level assignment (H1-H6) based on font usage patterns

2. Content Classification System (Importance: 85)
- TextElement: Handles formatted text with style attributes
- ImageElement: Manages both raster and vector graphics
- Content relationship tracking between elements

3. Asset Processing Pipeline (Importance: 80)
- Intelligent format selection between PNG/JPEG based on:
  * Transparency detection
  * Color complexity analysis
  * Dimension-based optimization
- Asset extraction with maintained document references

4. PDF Content Processing (Importance: 90)
- Text styling and formatting context preservation
- Vector graphics path construction tracking
- Coordinate system transformation management
- Element bounds calculation for layout fidelity

Key Integration Points:

1. Content Extraction Layer
- Connects PDF parsing with markdown generation
- Maintains element relationships and hierarchy
- Preserves formatting context across transformations

2. Asset Management Layer
- Links extracted images with markdown references
- Maintains asset organization structure
- Handles format conversions while preserving quality

The system organizes business logic around content transformation pipelines while maintaining document semantic structure throughout the conversion process.

—— When you’re done with a round of updates, update CHANGELOG.md with the changes, remove done things from TODO.md, identify new things that need to be done and add them to TODO.md. Then build the app or run ./release.sh and then continue updates.
</file>

<file path="pdf22md/Sources/PDF22MD/PDFMarkdownConverterOptimized.swift">
import Foundation
import PDFKit

/// Optimized converter using GCD instead of async/await for better performance
public final class PDFMarkdownConverterOptimized {
    private let pdfURL: URL
    private let outputPath: String?
    private let assetsPath: String?
    private let dpi: CGFloat
    
    public init(pdfURL: URL, outputPath: String?, assetsPath: String?, dpi: CGFloat = 144.0) {
        self.pdfURL = pdfURL
        self.outputPath = outputPath
        self.assetsPath = assetsPath
        self.dpi = dpi
    }
    
    /// Convert PDF to Markdown using GCD for better performance
    public func convert() throws {
        guard let pdfDocument = PDFDocument(url: pdfURL) else {
            throw PDFConversionError.invalidPDF
        }
        
        let pageCount = pdfDocument.pageCount
        let queue = DispatchQueue(label: "pdf.processing", attributes: .concurrent)
        let group = DispatchGroup()
        
        // Thread-safe storage for results
        let lock = NSLock()
        var pageResults: [(Int, [PDFElement])] = []
        
        // Process pages concurrently using GCD
        for pageIndex in 0..<pageCount {
            group.enter()
            queue.async {
                autoreleasepool {
                    guard let page = pdfDocument.page(at: pageIndex) else {
                        group.leave()
                        return
                    }
                    
                    let processor = PDFPageProcessorOptimized(page: page, pageIndex: pageIndex, dpi: self.dpi, assetsPath: self.assetsPath)
                    let elements = processor.processPage()
                    
                    // Thread-safe append
                    lock.lock()
                    pageResults.append((pageIndex, elements))
                    lock.unlock()
                    
                    group.leave()
                }
            }
        }
        
        // Wait for all pages to complete
        group.wait()
        
        // Sort by page index
        pageResults.sort { $0.0 < $1.0 }
        let allElements = pageResults.flatMap { $0.1 }
        
        // Analyze fonts for heading detection
        let fontStats = analyzeFonts(from: allElements)
        
        // Generate markdown
        let markdown = generateMarkdown(from: allElements, fontStats: fontStats)
        
        // Write output
        if let outputPath = outputPath {
            // Ensure parent directory exists
            let outputURL = URL(fileURLWithPath: outputPath)
            let directoryURL = outputURL.deletingLastPathComponent()
            let fileManager = FileManager.default
            if !fileManager.fileExists(atPath: directoryURL.path) {
                try fileManager.createDirectory(at: directoryURL, withIntermediateDirectories: true, attributes: nil)
            }
            do {
                try markdown.write(to: outputURL, atomically: true, encoding: .utf8)
            } catch {
                throw PDFConversionError.invalidPDF
            }
        } else {
            print(markdown)
        }
    }
    
    private func analyzeFonts(from elements: [PDFElement]) -> FontStatistics {
        var fontSizes: [CGFloat: Int] = [:]
        var totalTextElements = 0
        
        for element in elements {
            guard let textElement = element as? TextElement else { continue }
            fontSizes[textElement.fontSize, default: 0] += 1
            totalTextElements += 1
        }
        
        // Sort font sizes by frequency
        let sortedSizes = fontSizes.sorted { $0.value > $1.value }
        
        // Determine heading sizes (top 3-4 sizes that aren't the most common)
        var headingSizes: Set<CGFloat> = []
        if sortedSizes.count > 1 {
            // Skip the most common size (likely body text)
            for i in 1..<min(4, sortedSizes.count) {
                if sortedSizes[i].value > totalTextElements / 20 { // At least 5% of elements
                    headingSizes.insert(sortedSizes[i].key)
                }
            }
        }
        
        let bodySize = sortedSizes.first?.key ?? 12.0
        
        return FontStatistics(
            bodySizeThreshold: bodySize,
            headingSizes: headingSizes,
            fontSizeFrequencies: fontSizes
        )
    }
    
    private func generateMarkdown(from elements: [PDFElement], fontStats: FontStatistics) -> String {
        let markdown = NSMutableString()
        
        // Extract PDF basename for asset naming
        let pdfBasename = pdfURL.deletingPathExtension().lastPathComponent
        let assetExtractor = AssetExtractor(assetsPath: assetsPath, pdfBasename: pdfBasename)
        
        // Sort elements by page and vertical position (like the regular converter)
        let sortedElements = elements.sorted { lhs, rhs in
            if lhs.pageIndex != rhs.pageIndex {
                return lhs.pageIndex < rhs.pageIndex
            }
            // Sort top to bottom (flip Y coordinate)
            return lhs.bounds.origin.y > rhs.bounds.origin.y
        }
        
        var previousElement: PDFElement?
        
        for element in sortedElements {
            // Add page breaks
            if let prev = previousElement, prev.pageIndex != element.pageIndex {
                markdown.append("\n---\n\n")
            }
            
            switch element {
            case let textElement as TextElement:
                let headingLevel = fontStats.headingLevel(for: textElement.fontSize)
                
                if headingLevel > 0 {
                    // Add heading
                    let prefix = String(repeating: "#", count: headingLevel)
                    markdown.append("\(prefix) \(textElement.text)\n\n")
                } else {
                    // Regular text
                    if textElement.isBold && textElement.isItalic {
                        markdown.append("***\(textElement.text)***")
                    } else if textElement.isBold {
                        markdown.append("**\(textElement.text)**")
                    } else if textElement.isItalic {
                        markdown.append("*\(textElement.text)*")
                    } else {
                        markdown.append(textElement.text)
                    }
                    
                    // Check if we need a line break
                    if shouldAddLineBreak(current: element, previous: previousElement) {
                        markdown.append("\n\n")
                    } else {
                        markdown.append(" ")
                    }
                }
                
            case let imageElement as ImageElement:
                if let image = imageElement.image,
                   let imagePath = assetExtractor.saveImage(image, 
                                                           pageIndex: imageElement.pageIndex,
                                                           isVector: imageElement.isVectorSource) {
                    let altText = imageElement.isVectorSource ? "Vector graphic" : "Image"
                    markdown.append("![\(altText)](\(imagePath))\n\n")
                }
                
            default:
                break
            }
            
            previousElement = element
        }
        
        let finalMarkdown = (markdown as String).trimmingCharacters(in: .whitespacesAndNewlines)
        return finalMarkdown
    }
    
    private func shouldAddLineBreak(current: PDFElement, previous: PDFElement?) -> Bool {
        guard let prev = previous else { return true }
        
        // Check vertical distance
        let verticalGap = abs(current.bounds.minY - prev.bounds.minY)
        return verticalGap > 20
    }
}
</file>

<file path="pdf22md/Sources/PDF22MD/PDFPageProcessor.swift">
import Foundation
import PDFKit
import CoreGraphics

/// Processes individual PDF pages to extract content elements
final class PDFPageProcessor {
    private let pdfPage: PDFPage
    private let pageIndex: Int
    private let dpi: CGFloat
    private let assetsPath: String?
    
    init(page: PDFPage, pageIndex: Int, dpi: CGFloat = 144.0, assetsPath: String? = nil) {
        self.pdfPage = page
        self.pageIndex = pageIndex
        self.dpi = dpi
        self.assetsPath = assetsPath
    }
    
    /// Process the page and extract all content elements
    func processPage() -> [PDFElement] {
        var elements: [PDFElement] = []
        
        // Extract text elements
        elements.append(contentsOf: extractTextElements())
        
        // Only extract images if assets path is provided
        if assetsPath != nil {
            // Extract image elements
            elements.append(contentsOf: CGPDFImageExtractor.extractImages(from: pdfPage,
                                                                          pageIndex: pageIndex,
                                                                          dpi: dpi))
            
            // Extract vector graphics as images
            elements.append(contentsOf: extractVectorGraphics())
        }
        
        return elements
    }
    
    private func extractTextElements() -> [TextElement] {
        var textElements: [TextElement] = []
        
        guard let pageContent = pdfPage.attributedString else { return textElements }
        
        let fullRange = NSRange(location: 0, length: pageContent.length)
        var currentPosition = 0
        
        while currentPosition < pageContent.length {
            var effectiveRange = NSRange()
            let attributes = pageContent.attributes(at: currentPosition, 
                                                   longestEffectiveRange: &effectiveRange, 
                                                   in: fullRange)
            
            let text = (pageContent.string as NSString).substring(with: effectiveRange)
            
            // Skip whitespace-only text
            let trimmed = text.trimmingCharacters(in: .whitespacesAndNewlines)
            if !trimmed.isEmpty {
                // Extract font information
                let font = attributes[.font] as? NSFont
                let fontSize = font?.pointSize ?? 12.0
                
                // Determine style
                let isBold = font?.fontDescriptor.symbolicTraits.contains(.bold) ?? false
                let isItalic = font?.fontDescriptor.symbolicTraits.contains(.italic) ?? false
                
                // Get bounds for the text
                let bounds = getBounds(for: effectiveRange)
                
                let element = TextElement(
                    text: trimmed,
                    bounds: bounds,
                    pageIndex: pageIndex,
                    fontSize: fontSize,
                    isBold: isBold,
                    isItalic: isItalic
                )
                textElements.append(element)
            }
            
            // Prevent infinite loop: ensure we always advance
            let nextPosition = NSMaxRange(effectiveRange)
            if nextPosition <= currentPosition {
                // Safety: advance by at least 1 if range didn't advance
                currentPosition += 1
            } else {
                currentPosition = nextPosition
            }
        }
        
        return textElements
    }
    
    private func getBounds(for range: NSRange) -> CGRect {
        guard range.location != NSNotFound, range.length > 0 else {
            return .zero
        }
        
        // Use characterBounds which is much more efficient than creating selections.
        // We union the bounds of the first and last character for a good approximation.
        let startBounds = pdfPage.characterBounds(at: range.location)
        let endBounds = pdfPage.characterBounds(at: NSMaxRange(range) - 1)
        
        return startBounds.union(endBounds)
    }
    
    private func extractImageElements() -> [ImageElement] {
        // For now, we'll focus on vector graphics extraction
        // Direct image extraction from PDF streams requires more complex parsing
        return []
    }
    
    
    private func extractVectorGraphics() -> [ImageElement] {
        var elements: [ImageElement] = []
        
        let pageRect = pdfPage.bounds(for: .mediaBox)
        let sectionSize: CGFloat = 100.0 // 100 point sections
        
        let gridX = Int(ceil(pageRect.size.width / sectionSize))
        let gridY = Int(ceil(pageRect.size.height / sectionSize))
        
        for x in 0..<gridX {
            for y in 0..<gridY {
                var sectionRect = CGRect(
                    x: CGFloat(x) * sectionSize,
                    y: CGFloat(y) * sectionSize,
                    width: sectionSize,
                    height: sectionSize
                )
                
                // Intersect with page bounds
                sectionRect = sectionRect.intersection(pageRect)
                if sectionRect.isEmpty || sectionRect.size.width < 20 || sectionRect.size.height < 20 {
                    continue
                }
                
                // Check if this section contains primarily image content
                if sectionContainsImageContent(sectionRect) {
                    if let sectionImage = renderPageSection(sectionRect) {
                        let element = ImageElement(
                            image: sectionImage,
                            bounds: sectionRect,
                            pageIndex: pageIndex,
                            isVectorSource: true
                        )
                        elements.append(element)
                    }
                }
            }
        }
        
        return elements
    }
    
    private func sectionContainsImageContent(_ rect: CGRect) -> Bool {
        // Check if the section has minimal text
        guard let selection = pdfPage.selection(for: rect) else { return true }
        let text = selection.string?.trimmingCharacters(in: .whitespacesAndNewlines) ?? ""
        
        // If section has very little text, consider it as potential image area
        return text.count < 10
    }
    
    private func renderPageSection(_ rect: CGRect) -> CGImage? {
        let scale = dpi / 72.0
        let scaledSize = CGSize(width: rect.size.width * scale, 
                               height: rect.size.height * scale)
        
        // Create bitmap context
        let colorSpace = CGColorSpaceCreateDeviceRGB()
        let bitmapInfo = CGBitmapInfo(rawValue: CGImageAlphaInfo.premultipliedLast.rawValue)
        
        guard let context = CGContext(
            data: nil,
            width: Int(scaledSize.width),
            height: Int(scaledSize.height),
            bitsPerComponent: 8,
            bytesPerRow: 0,
            space: colorSpace,
            bitmapInfo: bitmapInfo.rawValue
        ) else { return nil }
        
        // Fill with white background
        context.setFillColor(CGColor(red: 1, green: 1, blue: 1, alpha: 1))
        context.fill(CGRect(origin: .zero, size: scaledSize))
        
        // Set up coordinate system
        context.scaleBy(x: scale, y: scale)
        context.translateBy(x: -rect.origin.x, y: -rect.origin.y)
        
        // Draw the PDF page section
        pdfPage.draw(with: .mediaBox, to: context)
        
        return context.makeImage()
    }
}
</file>

<file path="CLAUDE.md">
# pdf22md

A blazingly fast PDF to Markdown converter for macOS.

`pdf22md` is a command-line tool that extracts all text and image content from a PDF file and converts it into a clean Markdown document. Built with Swift and using modern async/await for parallel processing, it's exceptionally fast for multi-page documents.

### Key Features

  * **High-Speed Conversion**: Uses all available CPU cores to process PDF pages concurrently.
  * **Intelligent Heading Detection**: Analyzes font sizes and usage frequency to automatically format titles and headings (`#`, `##`, etc.).
  * **Asset Extraction**: Saves raster and vector images into a specified assets folder and links them correctly in the Markdown file.
  * **Smart Image Formatting**: Automatically chooses between JPEG (for photos) and PNG (for graphics with transparency) to optimize file size and quality.
  * **Flexible I/O**: Reads from a PDF file or `stdin` and writes to a Markdown file or `stdout`.
  * **Customizable Rasterization**: Allows setting a custom DPI for converting vector graphics to bitmaps.

### Installation

Once the Homebrew tap is set up, installation is simple:

```bash
brew install twardoch/tap/pdf22md
```

### Building from Source

To build the project manually, you need Xcode Command Line Tools installed.

```bash
# Clone the repository
git clone https://github.com/twardoch/pdf22md.git
cd pdf22md

# Build and install
make build
sudo make install
```

### Usage

```
Usage: pdf22md [-i input.pdf] [-o output.md] [-a assets_folder] [-d dpi]
  Converts PDF documents to Markdown format
  -i <path>: Input PDF file (default: stdin)
  -o <path>: Output Markdown file (default: stdout)
  -a <path>: Assets folder for extracted images
  -d <dpi>: DPI for rasterizing vector graphics (default: 144)
```

**Example:**

```bash
# Convert a PDF to Markdown
pdf22md -i report.pdf -o report.md -a ./assets
```

---


# main-overview

## Development Guidelines

- Only modify code directly relevant to the specific request. Avoid changing unrelated functionality.
- Never replace code with placeholders like `# ... rest of the processing ...`. Always include complete code.
- Break problems into smaller steps. Think through each step separately before implementing.
- Always provide a complete PLAN with REASONING based on evidence from code and logs before making changes.
- Explain your OBSERVATIONS clearly, then provide REASONING to identify the exact issue. Add console logs when needed to gather more information.


pdf22md is a PDF to Markdown converter that transforms PDF documents while preserving their semantic structure and content relationships.

Core Business Components:

1. Document Structure Analysis (Importance: 95)
- Hierarchical heading detection using font statistics
- Document structure preservation through positional element sorting
- Automated heading level assignment (H1-H6) based on font usage patterns

2. Content Classification System (Importance: 85)
- TextElement: Handles formatted text with style attributes
- ImageElement: Manages both raster and vector graphics
- Content relationship tracking between elements

3. Asset Processing Pipeline (Importance: 80)
- Intelligent format selection between PNG/JPEG based on:
  * Transparency detection
  * Color complexity analysis
  * Dimension-based optimization
- Asset extraction with maintained document references

4. PDF Content Processing (Importance: 90)
- Text styling and formatting context preservation
- Vector graphics path construction tracking
- Coordinate system transformation management
- Element bounds calculation for layout fidelity

Key Integration Points:

1. Content Extraction Layer
- Connects PDF parsing with markdown generation
- Maintains element relationships and hierarchy
- Preserves formatting context across transformations

2. Asset Management Layer
- Links extracted images with markdown references
- Maintains asset organization structure
- Handles format conversions while preserving quality

The system organizes business logic around content transformation pipelines while maintaining document semantic structure throughout the conversion process.

—— When you’re done with a round of updates, update CHANGELOG.md with the changes, remove done things from TODO.md, identify new things that need to be done and add them to TODO.md. Then build the app or run ./release.sh and then continue updates.
</file>

<file path="PLAN.md">
# PDF to Markdown Converter - Swift Implementation Rewrite Plan

## Current State Analysis

The current Swift implementation has the following structure:
- **PDFMarkdownConverter**: Main orchestrator using async/await for concurrent processing
- **PDFPageProcessor**: Processes individual pages to extract text and images
- **AssetExtractor**: Handles saving images in PNG/JPEG format
- **CGPDFImageExtractor**: Currently only extracts annotations, not actual embedded images

### Key Issues with Current Implementation

1. **Image Extraction**: The current CGPDFImageExtractor only looks at annotations, not actual embedded images in PDF XObject streams
2. **Asset Naming**: Current naming is generic (`image_001.png`) instead of including PDF basename and page number
3. **Vector Graphics**: Current implementation divides pages into grid sections, which is inefficient and may miss actual vector graphics
4. **Conditional Processing**: The current implementation always attempts to extract images even when no assets folder is specified

## Implementation Plan

### Phase 1: Core Infrastructure Updates

#### 1.1 Update AssetExtractor
- Modify asset naming scheme to use: `<pdf-basename>-<page-number>-<asset-number>.<ext>`
- Page numbers should be 3-digit zero-padded (e.g., `001`, `002`)
- Asset numbers on each page should be 2-digit zero-padded (e.g., `01`, `02`)
- Pass PDF basename and page index to the AssetExtractor

#### 1.2 Conditional Asset Processing
- Only create assets directory if `-a`/`--assets` is provided
- Skip all image extraction and processing when assets path is not provided
- Update PDFPageProcessor to conditionally extract images based on assets path

### Phase 2: Proper Image Extraction from PDF

#### 2.1 Implement Real PDF XObject Image Extraction
Based on the tutorial in `Report_PDF_Parsing.md`, we need to:
- Access the page's CGPDFPage reference from PDFPage
- Navigate the PDF structure: Page → Resources → XObject dictionary
- Iterate through XObject entries and filter for Subtype "Image"
- Extract image data using CGPDFStreamCopyData
- Handle different image formats (JPEG, JPEG2000, raw bitmap data)

#### 2.2 Create New Image Extractor
Replace the current annotation-based approach with proper XObject extraction:
```swift
// New approach structure:
1. Get CGPDFPage from PDFPage.pageRef
2. Get page dictionary → Resources → XObject
3. Iterate XObject entries with CGPDFDictionaryApplyBlock
4. Check if entry is stream with Subtype "Image"
5. Extract image data and format
6. Convert to CGImage if needed
```

### Phase 3: Vector Graphics Detection and Extraction

#### 3.1 Simplified Vector Graphics Detection
For the initial implementation, use a pragmatic approach:
- Identify page regions that have minimal or no text content
- Check for the presence of path operations in those regions
- Render regions that likely contain diagrams, charts, or illustrations
- This avoids the complexity of full content stream parsing

#### 3.2 Smart Cropping and Rendering
- Start with larger regions and refine based on content detection
- Add reasonable margins (10-15 points) around detected graphics
- Use the specified DPI for rasterization
- Skip regions that are too small (< 50x50 points) or mostly whitespace

### Phase 4: Integration and Optimization

#### 4.1 Update PDFPageProcessor
- Pass assets path to determine if image extraction is needed
- Integrate new XObject-based image extractor
- Improve vector graphics detection algorithm
- Ensure proper ordering of extracted assets

#### 4.2 Update PDFMarkdownConverter
- Pass PDF basename to AssetExtractor
- Ensure markdown image references use correct relative paths
- Handle cases where assets folder is not provided (skip image references)

#### 4.3 Correct Markdown Image Path Handling
- Ensure the path returned by `AssetExtractor.saveImage` includes the relative assets folder prefix so that the generated Markdown points to the **actual** asset location (e.g. `assets/report-001-01.png` instead of just `report-001-01.png`).
- Pass the *relative* assets directory (derived from the `-a/--assets` argument) into the Markdown generator so the converter can build correct paths regardless of where the output Markdown file resides.
- Add unit tests that verify the generated Markdown contains valid image links when:
  * the assets directory is a sibling of the Markdown file (common case: `./assets`)
  * the assets directory is an absolute path elsewhere on disk
- Fail gracefully (log a warning) if the computed relative path cannot be determined, falling back to the absolute path so links still work.

### Phase 5: Testing and Refinement

#### 5.1 Test Cases
- PDFs with embedded JPEG images
- PDFs with PNG images (with transparency)
- PDFs with vector graphics (charts, diagrams)
- PDFs with mixed content
- PDFs without any images
- Running without `-a` flag (text-only extraction)

#### 5.2 Performance Optimization
- Ensure concurrent processing still works correctly
- Optimize memory usage for large images
- Add progress indicators for large PDFs

## Technical Implementation Details

### XObject Image Extraction Algorithm

The key steps for extracting embedded images from PDF:

1. Access the CGPDFPage from PDFPage.pageRef
2. Navigate through Page → Resources → XObject dictionary
3. Iterate XObject entries and identify Image subtypes
4. Extract image data with appropriate format handling
5. Convert to CGImage for further processing

Key considerations:
- Handle JPEG encoded data (can be saved directly)
- Handle JPEG2000 data (save with appropriate extension)
- For raw bitmap data, need to read width, height, color space from stream dictionary
- Create CGImage from raw data using CGDataProvider and color space information

### Vector Graphics Detection Strategy

For the initial implementation:
1. Divide page into reasonable sections (not too small)
2. Check text content in each section
3. Sections with minimal text are candidates for vector graphics
4. Render candidate sections at specified DPI
5. Filter out blank/whitespace images

Future enhancement could include:
- Parsing content streams for path operators
- More sophisticated graphics detection
- Better bounding box calculation

## Success Criteria

1. **Correct Image Extraction**: All embedded raster images are extracted from PDFs
2. **Proper Naming**: Assets follow the naming convention `basename-pagenumber-assetnumber.ext`
3. **Conditional Processing**: No image processing occurs when `-a` is not provided
4. **Vector Graphics**: Vector graphics are detected and rasterized at specified DPI
5. **Markdown Links**: All image references in the generated Markdown resolve to existing files in the assets folder (verified by tests)
6. **Performance**: Maintains concurrent processing capabilities
7. **Compatibility**: Works with various PDF types and image formats

## Risk Mitigation

1. **Complex PDFs**: Some PDFs may have unusual structures - add robust error handling
2. **Memory Usage**: Large images could consume significant memory - process one at a time
3. **Format Support**: Handle various image encodings (JPEG, JPEG2000, raw bitmaps)
4. **Coordinate Systems**: PDF coordinates may need transformation for proper bounds calculation

## Implementation Priority

Based on the requirements and complexity:

1. **First Priority**: Fix conditional asset processing (only process images when `-a` is provided)
2. **Second Priority**: Update asset naming to include PDF basename and page numbers
3. **Third Priority**: Implement proper XObject image extraction
4. **Fourth Priority**: Improve vector graphics detection

This order ensures we meet the basic requirements first before tackling more complex improvements.

## Next Steps

1. Create detailed TODO.md with specific implementation tasks
2. Start with conditional processing fixes
3. Update AssetExtractor with new naming scheme
4. Implement XObject-based image extraction
5. Test with various PDF samples
6. Optimize and refine based on testing results
</file>

<file path="build.sh">
#!/bin/bash
# Build script for pdf22md (Swift version)

set -e # Exit on any error

npx repomix -i "docs" -o llms.txt .

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Print colored output
print_status() {
    echo -e "${BLUE}==>${NC} $1"
}

print_success() {
    echo -e "${GREEN}✓${NC} $1"
}

print_error() {
    echo -e "${RED}✗${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}⚠${NC} $1"
}

# Check if we're in the right directory
if [ ! -d "pdf22md" ]; then
    print_error "This script must be run from the pdf22md root directory"
    exit 1
fi

# Parse command line arguments
CLEAN=false
INSTALL=false
BUILD_TYPE="release"

while [[ $# -gt 0 ]]; do
    case $1 in
    --clean)
        CLEAN=true
        shift
        ;;
    --install)
        INSTALL=true
        shift
        ;;
    --debug)
        BUILD_TYPE="debug"
        shift
        ;;
    -h | --help)
        echo "Usage: $0 [options]"
        echo "Options:"
        echo "  --clean          Clean build artifacts before building"
        echo "  --install        Install binaries to /usr/local/bin after building"
        echo "  --debug          Build in debug mode"
        echo "  -h, --help       Show this help message"
        exit 0
        ;;
    *)
        print_error "Unknown option: $1"
        exit 1
        ;;
    esac
done

# Clean if requested
if [ "$CLEAN" = true ]; then
    print_status "Cleaning build artifacts"
    cd pdf22md
    swift package clean >/dev/null 2>&1 || true
    rm -rf .build >/dev/null 2>&1 || true
    cd ..
    print_success "Cleaned Swift build artifacts"
fi

# Build Swift version
print_status "Building Swift version"
cd pdf22md

if [ "$BUILD_TYPE" = "debug" ]; then
    swift build
else
    swift build -c release
fi

if [ $? -eq 0 ]; then
    print_success "Swift build completed successfully"

    # Create a convenience symlink to the Swift binary
    if [ "$BUILD_TYPE" = "debug" ]; then
        SWIFT_BINARY=".build/debug/pdf22md"
    else
        SWIFT_BINARY=".build/release/pdf22md"
    fi

    if [ -f "$SWIFT_BINARY" ]; then
        ln -sf "$SWIFT_BINARY" pdf22md
        print_success "Binary created: pdf22md/pdf22md"
    fi
else
    print_error "Swift build failed"
    exit 1
fi

cd ..

# Install if requested
if [ "$INSTALL" = true ]; then
    print_status "Installing binary"

    if [ "$BUILD_TYPE" = "debug" ]; then
        SWIFT_BINARY="pdf22md/.build/debug/pdf22md"
    else
        SWIFT_BINARY="pdf22md/.build/release/pdf22md"
    fi

    if [ -f "$SWIFT_BINARY" ]; then
        sudo cp "$SWIFT_BINARY" /usr/local/bin/pdf22md
        print_success "Installed pdf22md to /usr/local/bin/"
    fi
fi

print_success "Build completed successfully!"

# Show summary
echo
print_status "Build Summary:"
if [ "$BUILD_TYPE" = "debug" ]; then
    echo "  • Swift binary: pdf22md/.build/debug/pdf22md"
else
    echo "  • Swift binary: pdf22md/.build/release/pdf22md"
fi
if [ -L "pdf22md/pdf22md" ]; then
    echo "  • Swift symlink: pdf22md/pdf22md"
fi
</file>

<file path="Makefile">
# Makefile for pdf22md
# A blazingly fast PDF to Markdown converter for macOS

# Variables
PROJECT_NAME = pdf22md
SWIFT_DIR = pdf22md
BUILD_DIR = $(SWIFT_DIR)/.build
RELEASE_DIR = $(BUILD_DIR)/release
DEBUG_DIR = $(BUILD_DIR)/debug
BINARY_NAME = $(PROJECT_NAME)
INSTALL_PREFIX = /usr/local
INSTALL_BIN = $(INSTALL_PREFIX)/bin

# Version from git tag or fallback
VERSION := $(shell git describe --tags --always --dirty 2>/dev/null || echo "dev")

# Package info
BUNDLE_ID = com.twardoch.pdf22md
PKG_ID = $(BUNDLE_ID).pkg
DMG_NAME = $(PROJECT_NAME)-$(VERSION).dmg
PKG_NAME = $(PROJECT_NAME)-$(VERSION).pkg

# Directories for packaging
DIST_DIR = dist
PKG_ROOT = $(DIST_DIR)/pkgroot
PKG_SCRIPTS = $(DIST_DIR)/scripts

# Colors for output
RED = \033[0;31m
GREEN = \033[0;32m
YELLOW = \033[1;33m
BLUE = \033[0;34m
NC = \033[0m # No Color

# Default target
.PHONY: all
all: build

# Build target
.PHONY: build
build:
	@echo "$(BLUE)==>$(NC) Building $(PROJECT_NAME)..."
	@cd $(SWIFT_DIR) && swift build -c release
	@echo "$(GREEN)✓$(NC) Build complete: $(RELEASE_DIR)/$(BINARY_NAME)"

# Debug build
.PHONY: debug
debug:
	@echo "$(BLUE)==>$(NC) Building $(PROJECT_NAME) (debug)..."
	@cd $(SWIFT_DIR) && swift build
	@echo "$(GREEN)✓$(NC) Debug build complete: $(DEBUG_DIR)/$(BINARY_NAME)"

# Install target
.PHONY: install
install: build
	@echo "$(BLUE)==>$(NC) Installing $(PROJECT_NAME) to $(INSTALL_BIN)..."
	@sudo mkdir -p $(INSTALL_BIN)
	@sudo cp $(RELEASE_DIR)/$(BINARY_NAME) $(INSTALL_BIN)/$(BINARY_NAME)
	@sudo chmod 755 $(INSTALL_BIN)/$(BINARY_NAME)
	@echo "$(GREEN)✓$(NC) Installed $(PROJECT_NAME) to $(INSTALL_BIN)/$(BINARY_NAME)"

# Uninstall target
.PHONY: uninstall
uninstall:
	@echo "$(BLUE)==>$(NC) Uninstalling $(PROJECT_NAME)..."
	@sudo rm -f $(INSTALL_BIN)/$(BINARY_NAME)
	@echo "$(GREEN)✓$(NC) Uninstalled $(PROJECT_NAME)"

# Clean target
.PHONY: clean
clean:
	@echo "$(BLUE)==>$(NC) Cleaning build artifacts..."
	@cd $(SWIFT_DIR) && swift package clean
	@rm -rf $(BUILD_DIR)
	@rm -rf $(DIST_DIR)
	@echo "$(GREEN)✓$(NC) Clean complete"

# Test target
.PHONY: test
test: build
	@echo "$(BLUE)==>$(NC) Running tests..."
	@cd $(SWIFT_DIR) && swift test
	@echo "$(GREEN)✓$(NC) Tests complete"

# Create distribution package
.PHONY: dist
dist: build create-pkg create-dmg
	@echo "$(GREEN)✓$(NC) Distribution package created: $(DIST_DIR)/$(DMG_NAME)"

# Create pkg installer
.PHONY: create-pkg
create-pkg: build
	@echo "$(BLUE)==>$(NC) Creating installer package..."
	@mkdir -p $(PKG_ROOT)/usr/local/bin
	@mkdir -p $(PKG_SCRIPTS)
	@cp $(RELEASE_DIR)/$(BINARY_NAME) $(PKG_ROOT)/usr/local/bin/
	@chmod 755 $(PKG_ROOT)/usr/local/bin/$(BINARY_NAME)
	
	# Create postinstall script
	@echo '#!/bin/bash' > $(PKG_SCRIPTS)/postinstall
	@echo 'echo "$(PROJECT_NAME) has been installed to /usr/local/bin"' >> $(PKG_SCRIPTS)/postinstall
	@echo 'echo "You can now use it by running: $(BINARY_NAME)"' >> $(PKG_SCRIPTS)/postinstall
	@chmod 755 $(PKG_SCRIPTS)/postinstall
	
	# Build the package
	@pkgbuild --root $(PKG_ROOT) \
		--identifier $(PKG_ID) \
		--version $(VERSION) \
		--scripts $(PKG_SCRIPTS) \
		--install-location / \
		$(DIST_DIR)/$(PKG_NAME)
	
	@echo "$(GREEN)✓$(NC) Package created: $(DIST_DIR)/$(PKG_NAME)"

# Create DMG
.PHONY: create-dmg
create-dmg: create-pkg
	@echo "$(BLUE)==>$(NC) Creating DMG..."
	@mkdir -p $(DIST_DIR)/dmg
	@cp $(DIST_DIR)/$(PKG_NAME) $(DIST_DIR)/dmg/
	@cp README.md $(DIST_DIR)/dmg/
	@cp LICENSE $(DIST_DIR)/dmg/
	
	# Create a simple install instructions file
	@echo "# Installation Instructions" > $(DIST_DIR)/dmg/INSTALL.txt
	@echo "" >> $(DIST_DIR)/dmg/INSTALL.txt
	@echo "1. Double-click $(PKG_NAME) to install $(PROJECT_NAME)" >> $(DIST_DIR)/dmg/INSTALL.txt
	@echo "2. The tool will be installed to /usr/local/bin/$(BINARY_NAME)" >> $(DIST_DIR)/dmg/INSTALL.txt
	@echo "3. You can then use it from Terminal by typing: $(BINARY_NAME)" >> $(DIST_DIR)/dmg/INSTALL.txt
	
	# Create DMG
	@hdiutil create -volname "$(PROJECT_NAME) $(VERSION)" \
		-srcfolder $(DIST_DIR)/dmg \
		-ov -format UDZO \
		$(DIST_DIR)/$(DMG_NAME)
	
	# Clean up
	@rm -rf $(DIST_DIR)/dmg
	@echo "$(GREEN)✓$(NC) DMG created: $(DIST_DIR)/$(DMG_NAME)"

# Show version
.PHONY: version
version:
	@echo "$(VERSION)"

# Help target
.PHONY: help
help:
	@echo "$(PROJECT_NAME) Makefile"
	@echo ""
	@echo "Usage: make [target]"
	@echo ""
	@echo "Targets:"
	@echo "  build       - Build the release version (default)"
	@echo "  debug       - Build the debug version"
	@echo "  install     - Install to $(INSTALL_BIN)"
	@echo "  uninstall   - Remove from $(INSTALL_BIN)"
	@echo "  clean       - Clean build artifacts"
	@echo "  test        - Run tests"
	@echo "  dist        - Create distribution package (.dmg with .pkg)"
	@echo "  version     - Show current version"
	@echo "  help        - Show this help message"
</file>

<file path=".gitignore">
_private/
!AGENTS.md
!CHANGELOG.md
!CLAUDE.md
!default.mode1v3
!default.mode2v3
!default.pbxuser
!default.perspectivev3
!docs/*.md
!README.md
!TODO.md
._*
.AppleDouble
.build/
.cursorindexingignore
.DS_Store
.idea/
.LSOverride
.specstory/
.Spotlight-V100
.Trashes
.vscode/
*.a
*.dSYM/
*.dylib
*.gcda
*.gcno
*.gcov
*.mode1v3
*.mode2v3
*.moved-aside
*.o
*.pbxuser
*.pdf
*.perspectivev3
*.swo
*.swp
*.tar.gz
*.xccheckout
*.xcodeproj/
*.xcscmblueprint
*.xcworkspace
*.zip
*~
build/
cmake_install.cmake
CMakeCache.txt
CMakeFiles/
coverage/
debug-assets/
DerivedData/
docs/_build/
issues/
Makefile.cmake
pdf22md/.build
test-results/
test/out/
testdata/test.pdf-oc/.test*
xcuserdata/
.DS_Store
/testdata
</file>

<file path="README.md">
# pdf22md: Blazingly Fast PDF to Markdown Converter for macOS

A high-performance command-line tool that extracts all text and image content from PDF files and converts them into clean Markdown documents. Built with Swift and modern async/await for parallel processing, making it exceptionally fast for multi-page documents.

## Key Features

-   **High-Speed Conversion**: Uses all available CPU cores to process PDF pages concurrently
-   **Intelligent Heading Detection**: Analyzes font sizes and usage frequency to automatically format titles and headings (`#`, `##`, etc.)
-   **Asset Extraction**: Saves raster and vector images into a specified assets folder and links them correctly in the Markdown file
-   **Smart Image Formatting**: Automatically chooses between JPEG (for photos) and PNG (for graphics with transparency) to optimize file size and quality
-   **Flexible I/O**: Reads from a PDF file or `stdin` and writes to a Markdown file or `stdout`
-   **Customizable Rasterization**: Allows setting a custom DPI for converting vector graphics to bitmaps

## Installation

### Using Homebrew (Coming Soon)

```bash
brew install twardoch/tap/pdf22md
```

### Building from Source

You need Xcode Command Line Tools installed.

```bash
# Clone the repository
git clone https://github.com/twardoch/pdf22md.git
cd pdf22md

# Build using Make
make build
sudo make install
```

## Usage

```
Usage: pdf22md [-i input.pdf] [-o output.md] [-a assets_folder] [-d dpi]
  Converts PDF documents to Markdown format
  -i <path>: Input PDF file (default: stdin)
  -o <path>: Output Markdown file (default: stdout)
  -a <path>: Assets folder for extracted images
  -d <dpi>: DPI for rasterizing vector graphics (default: 144)
```

### Examples

```bash
# Convert a PDF to Markdown with images extracted to an assets folder
pdf22md -i report.pdf -o report.md -a ./assets

# Convert a PDF using stdin/stdout
cat document.pdf | pdf22md > document.md

# Convert with custom DPI for vector graphics
pdf22md -i presentation.pdf -o slides.md -a ./images -d 300
```

## Requirements

-   macOS 12.0 or later
-   Swift 5.7+ (for building from source)
-   Xcode Command Line Tools (for building from source)

## Performance

`pdf22md` is engineered for speed:

-   **Parallel Processing**: Uses Swift's async/await to process PDF pages concurrently across all available CPU cores
-   **Efficient Memory Use**: Designed to handle large documents without excessive memory consumption
-   **Smart Optimizations**: Includes intelligent algorithms for font analysis and image handling

## Contributing

Contributions are welcome! Please see [CONTRIBUTING.md](CONTRIBUTING.md) for guidelines.

## License

`pdf22md` is released under the MIT License. See the [LICENSE](LICENSE) file for details.
</file>

<file path="CHANGELOG.md">
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Changed
- **MAJOR**: Removed Objective-C implementation (`pdf21md`) - project is now Swift-only
- **Build System**: Replaced build.sh with Makefile supporting `make build`, `make install`, and `make dist`
- **Distribution**: Added automated .pkg and .dmg creation for macOS installation
- **CI/CD**: Added GitHub Actions workflow for automated builds and releases on semver tags
- **Documentation**: Updated all documentation to reflect Swift-only implementation

### Added
- **Makefile**: Comprehensive build automation with targets for building, installing, and packaging
- **GitHub Actions**: Automated release workflow that creates DMG installers on version tags
- **Proper XObject Image Extraction**: Implemented extraction of embedded images from PDF XObject streams
- **Conditional Asset Processing**: Only process images when `-a`/`--assets` flag is provided
- **Improved Asset Naming**: Assets now named as `basename-pagenumber-assetnumber.ext` with proper padding

## [1.4.2] - 2024-11-07

### Changed
- **IMPLEMENTATION RENAMING**: 
  - Renamed Objective-C implementation from `pdf22md-objc` to `pdf21md` (directory and binary)
  - Renamed Swift implementation binary from `pdf22md` to `pdf22md`
  - Updated all class prefixes from `PDF22MD` to `PDF21MD` in Objective-C implementation
  - Updated all build scripts and documentation to reflect new naming
- **MAJOR CODEBASE RESTRUCTURING**: Complete reorganization into two self-contained implementations
- **Dual Implementation Architecture**: 
  - `pdf21md/`: Production-ready Objective-C implementation with full functionality
  - `pdf22md/`: Modern Swift library foundation with Swift Package Manager
- **Shared Component Integration**: Moved shared components to implementation-specific directories:
  - `pdf21md/shared-core/`: FileSystemUtils, Constants, ErrorFactory, ConcurrencyManager
  - `pdf21md/shared-algorithms/`: ImageFormatDetection
- **Build System Consolidation**: 
  - Created self-contained Makefile for Objective-C implementation
  - Simplified Swift Package Manager manifest for Swift implementation
  - Removed redundant root-level build scripts
- **Import Path Updates**: Fixed all import statements to reference new shared component locations
- **Documentation Overhaul**: 
  - Updated main README.md to showcase dual implementation approach
  - Created comprehensive README.md for each implementation
  - Updated project structure to reflect new organization

### Added
- **Self-Contained Implementations**: Both implementations now include their own:
  - Build systems (Makefile for ObjC, Package.swift for Swift)
  - Test resources and test suites
  - Documentation and usage examples
  - Shared components integrated locally
- **Production-Ready Objective-C**: Fully functional `pdf21md` executable with:
  - Complete PDF-to-Markdown conversion
  - Parallel processing with GCD
  - Smart image extraction and format detection
  - Command-line interface with proper argument parsing
- **Modern Swift Foundation**: Swift Package Manager library with:
  - Proper module structure for programmatic usage
  - Test framework foundation
  - Modern Swift patterns ready for implementation

### Removed
- **Eliminated Directory Redundancy**: 
  - Removed obsolete `swift/`, `shared/`, `build/`, `test/` directories
  - Consolidated all functionality into two main implementation folders
- **Cleaned Up Build Artifacts**:
  - Removed root-level Makefile, build.sh, pdf22md executable
  - Eliminated duplicate test resources and documentation
- **Streamlined Structure**: Removed intermediate directories and scattered files

### Fixed
- **Build System Issues**: 
  - Resolved module cache issues in Swift build.
  - Resolved duplicate main symbol errors in Objective-C build
  - Fixed import path references for shared components
  - Corrected Swift Package Manager manifest syntax errors
- **File System Organization**: 
  - Fixed relative path issues in shared component imports
  - Resolved compilation errors from directory restructuring
  - Ensured both implementations build and test successfully

### Added
- **PDF22MDFileSystemUtils**: Unified file system operations consolidating scattered NSFileManager patterns
- **PDF22MDConstants**: Centralized configuration constants eliminating magic numbers across 15+ files
- Enhanced error handling with new file system error codes (InvalidPath, DirectoryNotFound, PermissionDenied)
- Comprehensive codebase analysis using repomix (72,530 tokens, 52 files) for streamlining optimization
- Detailed PLAN.md for systematic code streamlining approach
- Updated TODO.md with final 3% streamlining tasks to reach 100% excellence
- Comprehensive streamlining plan (PLAN.md) for codebase optimization
- Unified build system using single Makefile and build.sh script
- Shared component library (shared/ directory) for common algorithms
- PDF22MDImageFormatDetection utility for optimal image format selection
- Unified test resource directory (shared/test-resources/) for all implementations
- **PDF22MDErrorFactory**: Unified error creation factory eliminating error handling duplication across 9+ files with specialized methods for configuration, file system, and processing errors
- **PDF22MDConcurrencyManager**: Standardized GCD patterns and queue management for consistent concurrency across implementations with shared queues and parallel processing utilities
- **Complete Modern Objective-C Implementation**: Full feature-parity rewrite in modern Objective-C with nullability annotations, lightweight generics, and proper designated initializers
- **Complete Swift Implementation**: Modern Swift implementation with async/await, actors, and Swift Package Manager support
- **Multi-Implementation Architecture**: Three implementations (C/ObjC, Modern ObjC, Swift) for different use cases and platform requirements
- **Advanced Error Handling**: Custom error domains and comprehensive error reporting across all implementations
- **Thread-Safe Asset Management**: Concurrent image processing with proper synchronization
- **Modern Build Infrastructure**: Support for both Makefile and Xcode/SPM build systems
- TROUBLESHOOTING.md documentation for common build and runtime issues
- Enhanced Swift toolchain detection in build scripts
- Better error messages for SWBBuildService.framework missing issue
- pdf22md-benchmark utility for performance testing
- Builder pattern for PDF22MDConversionOptions configuration
- Verbose logging options for PDF loading and conversion processes
- Timeout handling for conversion process to prevent hangs
- Comprehensive test data with sample PDFs and expected output
- Semantic versioning support based on git tags
- Version display option (-v, -V) in the command-line tool
- Release automation script (release.sh) for macOS
- GitHub Actions workflow for automated releases
- Package installer (.pkg) generation for macOS
- **Plan**: Detailed roadmap for robust raster-image extraction across Swift and Objective-C implementations appended to PLAN.md.
- **TODO**: Simplified checklist for the above work inserted into TODO.md.

### Changed
- Restructured project with separate directories for each implementation (pdf21md, pdf22md)
- Moved test files and resources to implementation-specific directories
- Updated object file compilation commands in build scripts

### Improved
- Build scripts now provide clearer guidance when Swift toolchain is corrupted
- Swift build failures are handled more gracefully with specific remediation steps
- Build process for pdf21md to resolve duplicate symbol errors
- Error reporting now includes process IDs for easier debugging
- Conversion feedback with detailed status messages during operations

### Fixed
- Duplicate symbol errors in pdf21md build process
- Build script compatibility issues with object file handling
- PDF processing hang issue with timeout implementation
- Memory leaks in asset management
- **Swift Markdown Output**: Ensured the Swift converter now creates parent directories before writing and reliably writes the generated Markdown file instead of silently failing when the directory is missing.
- **Code Quality**: Removed unused `fontName` variable in `PDFPageProcessorOptimized` to silence compiler warnings.

### Removed
- Legacy archived-old-implementation directory (2,000+ lines of obsolete code)
- Duplicate build scripts (pdf21md/build.sh, release.sh, run-tests.sh)
- Duplicate README files and documentation
- Duplicate PARALLEL_PROCESSING.md files across implementations
- Resolved issue files (102, 201) after fixing Swift toolchain problems
- Obsolete pdf22md-benchmark binary file from version control
- **210+ duplicate test images** across 3 implementations (58MB saved)
- **Duplicate PDF test files** across implementations
- **Duplicate man pages** from implementation directories
- **Duplicate Swift build scripts** (pdf22md/build.sh, release.sh)

### Streamlined
- **File system operations**: Consolidated NSFileManager patterns from 4+ files into PDF22MDFileSystemUtils (~150 lines eliminated)
- **Configuration constants**: Centralized all magic numbers (144.0 DPI, 2.0 threshold, etc.) from 15+ files into PDF22MDConstants
- **Asset management**: Updated PDF22MDAssetManager to use shared file utilities and constants
- **Validation logic**: Unified path validation and directory operations across implementations
- Consolidated build system into single authoritative Makefile and build.sh
- Unified documentation in single root README.md
- Removed code duplication between root and implementation directories
- Extracted image format detection algorithm into shared utility (~100 lines deduplicated)
- Build system automatically compiles shared components with proper dependencies
- **Error handling patterns**: Replaced manual NSError creation with standardized factory methods across all validation and processing code (40-60% reduction in error handling boilerplate)
- **Concurrency patterns**: Unified GCD usage with shared queue management and standardized parallel processing patterns (eliminated duplicate queue creation across 4+ files)
- **Shared component architecture**: Established professional foundation with Core/ directory containing ErrorFactory, ConcurrencyManager, FileSystemUtils, and Constants
- **Test resource consolidation**: Single shared/test-resources/ directory (58MB space saved)
- **Documentation consolidation**: Single man page source (docs/pdf22md.1)
- **Build script unification**: No implementation-specific build scripts
- Universal binary support (Intel and Apple Silicon)
- Man page generation in release packages
- MIT License file for open-source compliance
- GitHub issue templates for bug reports and feature requests
- Comprehensive .gitignore file with proper exclusions
- Build directory structure to separate source from build artifacts
- CHANGELOG.md to track version history
- Professional project documentation standards

### Changed
- **Architectural Modernization**: Complete rewrite of core components using modern Objective-C and Swift patterns
- **Enhanced Font Analysis**: Improved heading detection algorithm with configurable thresholds
- **Robust Asset Processing**: Smart image format selection with transparency detection and quality optimization
- **Memory Management**: Enhanced memory efficiency with proper autorelease pool usage and actor-based resource management (Swift)
- Makefile now supports VERSION variable for build-time versioning
- Makefile now uses a dedicated `build/` directory for object files
- .gitignore updated to properly exclude build artifacts and editor files
- GitHub Actions workflow fixed to use correct binary name
- Project structure reorganized following professional standards

### Fixed
- **Critical Build Issues**: Resolved all compilation errors in modern Objective-C implementation including:
  - Fixed designated initializer chain issues
  - Resolved private instance variable access violations  
  - Fixed NSValue CGRect compatibility issues using NSData approach
  - Corrected deprecated UTType constant usage
  - Fixed method signature mismatches and unused variable warnings
- **Memory Safety**: All CGImageRef memory leaks resolved with proper resource management
- **Concurrency Issues**: Thread-safe operations with proper GCD usage and Swift actor patterns
- Build artifacts (.o files) no longer pollute the repository root
- GitHub Actions workflow now correctly references the pdf22md binary
- Make variable in .gitignore replaced with actual filename
- Removed all DEBUG logging statements from production code
- Fixed CLI deadlock caused by main-queue dispatch in `PDFMarkdownConverter`; completions now called directly
- Fixed hanging issue on certain malformed PDFs by replacing low-level CGPDFScanner-based extraction with PDFKit high-level API (see `PDFPageProcessor`)
- Removed unused CGPDFScanner operator callback functions and PDFScannerState struct that were part of the deprecated implementation
- Fixed segmentation fault during asset extraction (Phase 1a): removed premature CGImageRelease calls in `PDFPageProcessor` that deallocated images still in use
- **Build Script Compatibility**: Fixed bash incompatibility in build.sh by replacing `declare -A` associative arrays with simple variables for broader shell compatibility
- **Swift Build Resilience**: Enhanced build.sh with Swift toolchain health checks and graceful fallback handling when Swift toolchain is corrupted
- **Comprehensive Testing Infrastructure**: Implemented complete test framework with unit tests, integration tests, and working test runner for MVP 1.0 readiness
  - Created PDF22MDConverterTests.m for core conversion logic validation
  - Created PDF22MDAssetManagerTests.m for image extraction and management testing
  - Created PDF22MDFontAnalyzerTests.m for heading detection algorithm validation
  - Created EndToEndConversionTests.m for complete pipeline testing
  - Created SimpleConverterTest.m working test executable proving framework functionality
- **Enhanced Error Handling System**: Expanded error definitions with user-friendly messages and actionable suggestions
  - Added 8 specific error codes including encrypted PDF, memory pressure, and processing timeout
  - Implemented PDF22MDErrorHelper with comprehensive user-friendly error messages
  - Added actionable recovery suggestions for all error conditions (e.g., "Try opening in another PDF viewer to verify it's not corrupted")
  - Fixed API compatibility issues in error method naming

### Removed
- Object files from repository root (moved to build directory)

## [1.0.0] - 2024-01-01

### Added
- Initial release of pdf22md
- PDF to Markdown conversion with parallel processing
- Intelligent heading detection based on font size analysis
- Asset extraction with smart image format selection (JPEG/PNG)
- Support for both file and stdin/stdout I/O
- Customizable DPI for vector graphics rasterization
- Grand Central Dispatch (GCD) for multi-core performance
- Comprehensive documentation

### Changed
- **Swift Raster Extraction (Phase 1)**: Added `CGPDFImageExtractor` and integrated it into both page processors; now ignores tiny annotation icons and discards blank/white images to prevent false assets.
</file>

<file path="TODO.md">
# PDF to Markdown Converter

## Phase 1: Swift-Only Implementation ✅
- [x] Remove all traces of pdf21md (Objective-C implementation)
- [x] Create Makefile with build, install, and dist targets
- [x] Implement .pkg creation for installation to /usr/local/bin
- [x] Implement .dmg creation containing the .pkg installer
- [x] Create GitHub Action for automated builds and releases on semver tags      


## Phase 4: Vector Graphics Improvements
- [ ] Simplify grid-based approach to use larger sections
- [ ] Improve text detection in sections
- [ ] Add margin parameter for vector graphics cropping
- [ ] Implement whitespace detection to filter blank images
- [ ] Optimize section size based on page dimensions

## Phase 4b: Markdown Image Path Fix
- [ ] Update `AssetExtractor.saveImage` to return path prefixed with assets directory
- [ ] Pass relative assets directory info into `PDFMarkdownConverter` markdown generation
- [ ] Ensure generated Markdown links include the correct assets folder prefix
- [ ] Add unit test validating that every image reference in Markdown corresponds to an existing file

## Phase 5: Integration and Testing
- [x] Update PDFPageProcessor to use new image extraction
- [x] Ensure proper element ordering by page and position
- [x] Test with PDFs containing JPEG images (XObject extraction implemented)
- [x] Test with PDFs containing PNG/transparent images (format detection implemented)
- [x] Test with PDFs containing vector graphics (existing implementation)
- [x] Test with text-only PDFs (conditional processing working)
- [x] Test performance with large PDFs (async/await and GCD implementations)
- [x] Verify memory usage is reasonable (autoreleasepool used)
- [ ] Test markdown path handling with relative and absolute assets directories

## Phase 6: Error Handling and Polish
- [ ] Add error handling for corrupted image streams
- [ ] Handle PDFs with no Resources dictionary
- [ ] Add progress logging for large PDFs
- [ ] Update documentation and comments
- [ ] Run linting and type checking
- [ ] Update CHANGELOG.md with changes
</file>

</files>
