This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.cursor/
  rules/
    content-element-models.mdc
    data-flow.mdc
    document-processing-algorithms.mdc
    image-processing-algorithms.mdc
.giga/
  specifications.json
.github/
  ISSUE_TEMPLATE/
    bug_report.md
    feature_request.md
  workflows/
    build-release.yml
    release.yml
docs/
  PARALLEL_PROCESSING.md
  pdf22md.1
pdf21md/
  shared-algorithms/
    PDF21MDImageFormatDetection.h
    PDF21MDImageFormatDetection.m
  shared-core/
    PDF21MDConcurrencyManager.h
    PDF21MDConcurrencyManager.m
    PDF21MDConstants.h
    PDF21MDConstants.m
    PDF21MDErrorFactory.h
    PDF21MDErrorFactory.m
    PDF21MDFileSystemUtils.h
    PDF21MDFileSystemUtils.m
  src/
    CLI/
      main.m
      pdf21md-benchmark.m
    Core/
      PDF21MDConversionOptions.h
      PDF21MDConversionOptions.m
      PDF21MDConverter.h
      PDF21MDConverter.m
      PDF21MDError.h
      PDF21MDError.m
      PDF21MDFontAnalyzer.h
      PDF21MDFontAnalyzer.m
      PDF21MDPageProcessor.h
      PDF21MDPageProcessor.m
    Models/
      PDF21MDContentElement.h
      PDF21MDImageElement.h
      PDF21MDImageElement.m
      PDF21MDTextElement.h
      PDF21MDTextElement.m
    Services/
      PDF21MDAssetManager.h
      PDF21MDAssetManager.m
      PDF21MDMarkdownGenerator.h
      PDF21MDMarkdownGenerator.m
  test-resources/
    expected-outputs/
      README.md
  Tests/
    Integration/
      EndToEndConversionTests.m
    Unit/
      AssetExtractorTests.m
      ContentElementTests.m
      PDF21MDAssetManagerTests.m
      PDF21MDConverterTests.m
      PDF21MDFontAnalyzerTests.m
      PDFMarkdownConverterTests.m
      SimpleConverterTest.m
  Makefile
  README.md
pdf22md/
  Sources/
    PDF22MD/
      AssetExtractor.swift
      FontStatistics.swift
      PDFElement.swift
      PDFMarkdownConverter.swift
      PDFMarkdownConverterOptimized.swift
      PDFMarkdownConverterUltraOptimized.swift
      PDFPageProcessor.swift
      PDFPageProcessorOptimized.swift
    PDF22MDCli/
      main.swift
  test-resources/
    expected-outputs/
      README.md
  Tests/
    PDF22MDTests/
      PDF22MDTests.swift
  Package.resolved
  Package.swift
  README.md
.cursorrules
.gitignore
AGENTS.md
build.sh
CHANGELOG.md
CLAUDE.md
CONTRIBUTING.md
LICENSE
PLAN.md
README.md
test_both.sh
TODO.md
TROUBLESHOOTING.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".cursor/rules/content-element-models.mdc">
---
description: Defines core content element models for representing text and image elements in PDF to Markdown conversion
globs: src/ContentElement.h,src/ContentElement.m,src/*.h,src/*.m
alwaysApply: false
---


# content-element-models

The content element model system implements two primary domain models for representing extracted PDF content:

### TextElement Model
Importance Score: 95
- Captures text-specific attributes:
  - Heading level detection based on font statistics
  - Formatting attributes (bold, italic)
  - Positional information for maintaining document structure
  - Font metrics for hierarchy analysis

### ImageElement Model  
Importance Score: 90
- Manages both raster and vector image content:
  - Source type tracking (vector vs raster)
  - Format classification for optimal storage
  - Asset path management for markdown linking
  - Dimension and transparency analysis

### Element Relationships
Importance Score: 85
- Maintains document hierarchy through:
  - Parent-child relationships between elements
  - Sequential ordering based on page position
  - Nested structure preservation
  - Cross-element references

Relevant Files:
- src/ContentElement.h
- src/ContentElement.m

$END$

 If you're using this file in context, clearly say in italics in one small line that "Context added by Giga content-element-models".
</file>

<file path=".cursor/rules/data-flow.mdc">
---
description: Defines data transformation pipelines and content flow between PDF parsing, processing, and Markdown generation components
globs: src/*.{h,m},lib/*.{h,m},include/*.h
alwaysApply: false
---


# data-flow

The data transformation pipeline consists of three main stages with distinct data flows:

### 1. PDF Content Extraction Flow (Importance: 95)
- Input PDF document stream parsed into discrete content elements
- Font metrics and statistics gathered during initial parse
- Text elements tagged with style attributes and positioning data
- Images separated into raster/vector categories with source metadata
- Element hierarchy maintained through page-position tracking

### 2. Parallel Processing Pipeline (Importance: 90)
- Page content distributed across worker threads via GCD
- Font statistics aggregated through thread-safe collection
- Synchronized element arrays preserve document ordering
- Concurrent image asset extraction with sequence preservation
- Vector graphics rasterization based on DPI settings

### 3. Markdown Generation Flow (Importance: 85)  
- Font hierarchy analysis converts to heading levels
- Image assets exported with optimized format selection
- Asset references inserted with relative path linking
- Text formatting attributes translated to Markdown syntax
- Document structure rebuilt from processed elements

Key Data Transformation Points:
- PDF content stream ‚Üí ContentElement objects
- Font metrics ‚Üí Heading level assignments
- Vector paths ‚Üí Rasterized images
- Image data ‚Üí Optimized asset files
- Structured content ‚Üí Markdown syntax

Relevant Components:
- src/PDFMarkdownConverter.{h,m}
- src/ContentElement.{h,m}
- src/AssetExtractor.{h,m}
- src/PDFPageProcessor.{h,m}

$END$

 If you're using this file in context, clearly say in italics in one small line that "Context added by Giga data-flow".
</file>

<file path=".cursor/rules/document-processing-algorithms.mdc">
---
description: Specifications for document conversion algorithms, text analysis, and page processing in PDF-to-Markdown conversion
globs: src/PDFMarkdownConverter.*,src/PDFPageProcessor.*,src/ContentElement.*,src/AssetExtractor.*
alwaysApply: false
---


# document-processing-algorithms

## Core Processing Components (Importance: 95)

### Font Hierarchy Analysis
- Statistical font size frequency analysis for automatic heading level detection
- Threshold-based classification (<100 occurrences) to differentiate headings from body text
- Maintenance of document structure through position-based element sorting

Relevant files:
- `src/PDFMarkdownConverter.m`
- `src/PDFPageProcessor.m`

### Content Classification System
- Domain-specific content type categorization
- TextElement handling with formatting attributes (bold, italic, heading levels)
- ImageElement management with source type tracking (vector/raster)

Relevant files:
- `src/ContentElement.h`
- `src/ContentElement.m`

## Image Processing Logic (Importance: 85)

### Format Selection Algorithm
- PNG selection for:
  - Images with transparency
  - Graphics under 100x100 pixels
- JPEG selection for:
  - Photographic content
  - Images with >256 unique colors
- Color complexity sampling (10,000 pixel analysis)
- Alpha channel detection for format decisions

Relevant files:
- `src/AssetExtractor.m`

## Document Element Extraction (Importance: 90)

### Content Stream Processing
- Font style detection from PDF metadata
- Text positioning context preservation
- Vector graphics path construction tracking
- Image XObject extraction
- Bounds calculation for layout preservation

Relevant files:
- `src/PDFPageProcessor.m`
- `src/PDFMarkdownConverter.m`

$END$

 If you're using this file in context, clearly say in italics in one small line that "Context added by Giga document-processing-algorithms".
</file>

<file path=".cursor/rules/image-processing-algorithms.mdc">
---
description: Technical specification for image processing and optimization algorithms in PDF to Markdown conversion
globs: src/AssetExtractor.*,src/ImageProcessor.*,src/PDFImageExtractor.*,*.{png,jpg,jpeg}
alwaysApply: false
---


# image-processing-algorithms

The image processing system implements intelligent format selection and optimization for PDF asset extraction:

### Format Selection Algorithm (Importance: 85)
- Images with transparency -> PNG format
- Graphics <100x100 pixels -> PNG format 
- Photos/complex images (>256 colors) -> JPEG format
- Samples up to 10,000 pixels for color complexity analysis
- Checks for alpha channel presence in format decisions

### Asset Optimization (Importance: 75)
- Automatic quality optimization for photographs
- JPEG quality set to 85% for optimal size/quality balance
- Vector graphics rasterization at configurable DPI
- Smart asset directory management with relative path linking

Relevant files:
```
src/AssetExtractor.h
src/AssetExtractor.m
```

Key business rules:
1. Color complexity threshold: 256 unique colors
2. Small image threshold: 100x100 pixels
3. Sample size limit: 10,000 pixels
4. JPEG quality setting: 85%
5. Default vector DPI: 144

$END$

 If you're using this file in context, clearly say in italics in one small line that "Context added by Giga image-processing-algorithms".
</file>

<file path=".giga/specifications.json">
[
  {
    "fileName": "main-overview.mdc",
    "description": "Complete system overview documenting the PDF to Markdown conversion architecture, key components, and their interactions"
  },
  {
    "fileName": "document-processing-algorithms.mdc",
    "description": "Detailed documentation of core algorithms including font hierarchy analysis, heading detection, and parallel page processing using GCD"
  },
  {
    "fileName": "image-processing-algorithms.mdc",
    "description": "Documentation of image extraction, format optimization algorithms, and asset handling including transparency detection and color complexity analysis"
  },
  {
    "fileName": "content-element-models.mdc",
    "description": "Specification of TextElement and ImageElement data models, their attributes, and relationships within the document structure"
  },
  {
    "fileName": "data-flow.mdc",
    "description": "Documentation of data flow between components including PDF parsing, content extraction, parallel processing, and Markdown generation"
  }
]
</file>

<file path=".github/ISSUE_TEMPLATE/bug_report.md">
---
name: Bug report
about: Create a report to help us improve
title: ''
labels: bug
assignees: ''
---

**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:
1. Run command '...'
2. With PDF file '...'
3. See error

**Expected behavior**
A clear and concise description of what you expected to happen.

**System information:**
 - macOS version: [e.g. 14.0]
 - pdf22md version: [e.g. 1.0.0]

**Additional context**
Add any other context about the problem here.
</file>

<file path=".github/ISSUE_TEMPLATE/feature_request.md">
---
name: Feature request
about: Suggest an idea for this project
title: ''
labels: enhancement
assignees: ''
---

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is.

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.
</file>

<file path=".cursorrules">
# pdf22md

A blazingly fast PDF to Markdown converter for macOS.

`pdf22md` is a command-line tool that extracts all text and image content from a PDF file and converts it into a clean Markdown document. It uses Grand Central Dispatch (GCD) to process pages and save images in parallel, making it exceptionally fast for multi-page documents.

### Key Features

  * **High-Speed Conversion**: Uses all available CPU cores to process PDF pages concurrently.
  * **Intelligent Heading Detection**: Analyzes font sizes and usage frequency to automatically format titles and headings (`#`, `##`, etc.).
  * **Asset Extraction**: Saves raster and vector images into a specified assets folder and links them correctly in the Markdown file.
  * **Smart Image Formatting**: Automatically chooses between JPEG (for photos) and PNG (for graphics with transparency) to optimize file size and quality.
  * **Flexible I/O**: Reads from a PDF file or `stdin` and writes to a Markdown file or `stdout`.
  * **Customizable Rasterization**: Allows setting a custom DPI for converting vector graphics to bitmaps.

### Installation

Once the Homebrew tap is set up (see plan below), installation is simple:

```bash
brew install <your-username>/pdf22md/pdf22md
```

### Building from Source

To build the project manually, you need Xcode Command Line Tools installed.

```bash
# Clone the repository (once it's public)
git clone https://github.com/<your-username>/pdf22md.git
cd pdf22md

# Compile the tool
make

# Install it to /usr/local/bin
sudo make install
```

### Usage

```
Usage: pdf22md [-i input.pdf] [-o output.md] [-a assets_folder] [-d dpi]
  Converts PDF documents to Markdown format
  -i <path>: Input PDF file (default: stdin)
  -o <path>: Output Markdown file (default: stdout)
  -a <path>: Assets folder for extracted images
  -d <dpi>: DPI for rasterizing vector graphics (default: 144)
```

**Example:**

```bash
# Convert a local PDF file and save images to an 'assets' folder
pdf22md -i report.pdf -o report.md -a ./assets
```

---


# main-overview

## Development Guidelines

- Only modify code directly relevant to the specific request. Avoid changing unrelated functionality.
- Never replace code with placeholders like `# ... rest of the processing ...`. Always include complete code.
- Break problems into smaller steps. Think through each step separately before implementing.
- Always provide a complete PLAN with REASONING based on evidence from code and logs before making changes.
- Explain your OBSERVATIONS clearly, then provide REASONING to identify the exact issue. Add console logs when needed to gather more information.


pdf22md is a PDF to Markdown converter that transforms PDF documents while preserving their semantic structure and content relationships.

Core Business Components:

1. Document Structure Analysis (Importance: 95)
- Hierarchical heading detection using font statistics
- Document structure preservation through positional element sorting
- Automated heading level assignment (H1-H6) based on font usage patterns

2. Content Classification System (Importance: 85)
- TextElement: Handles formatted text with style attributes
- ImageElement: Manages both raster and vector graphics
- Content relationship tracking between elements

3. Asset Processing Pipeline (Importance: 80)
- Intelligent format selection between PNG/JPEG based on:
  * Transparency detection
  * Color complexity analysis
  * Dimension-based optimization
- Asset extraction with maintained document references

4. PDF Content Processing (Importance: 90)
- Text styling and formatting context preservation
- Vector graphics path construction tracking
- Coordinate system transformation management
- Element bounds calculation for layout fidelity

Key Integration Points:

1. Content Extraction Layer
- Connects PDF parsing with markdown generation
- Maintains element relationships and hierarchy
- Preserves formatting context across transformations

2. Asset Management Layer
- Links extracted images with markdown references
- Maintains asset organization structure
- Handles format conversions while preserving quality

The system organizes business logic around content transformation pipelines while maintaining document semantic structure throughout the conversion process.

‚Äî‚Äî When you‚Äôre done with a round of updates, update CHANGELOG.md with the changes, remove done things from TODO.md, identify new things that need to be done and add them to TODO.md. Then build the app or run ./release.sh and then continue updates.
</file>

<file path="CONTRIBUTING.md">
# Contributing to pdf22md

Thank you for your interest in contributing to `pdf22md`! This document outlines how you can contribute to the project, focusing on technical details, code structure, and development guidelines.

## Project Overview

`pdf22md` is a PDF to Markdown converter with two primary implementations:

1.  **Objective-C Implementation (`pdf21md`)**: Located in the `pdf21md/` directory. This is the mature, production-ready version, optimized for macOS using Grand Central Dispatch (GCD) and native PDFKit integration.
2.  **Swift Implementation (`pdf22md`)**: Located in the `pdf22md/` directory. This is a modern implementation built with Swift Package Manager, leveraging Swift's latest concurrency features (async/await, actors).

Both implementations share the goal of high-performance, accurate PDF to Markdown conversion, including intelligent heading detection and smart image extraction.

## Codebase Structure

The project root contains shared documentation, build scripts, and the two main implementation directories:

-   `pdf21md/`: Contains the Objective-C source code, Makefile, and its specific test resources.
    -   `pdf21md/src/CLI/`: Command-line interface entry points.
    -   `pdf21md/src/Core/`: Core conversion logic, options, and error handling.
    -   `pdf21md/src/Models/`: Data models for PDF elements (text, images).
    -   `pdf21md/src/Services/`: Services like asset management and Markdown generation.
    -   `pdf21md/shared-core/`: Shared Objective-C utilities (concurrency, constants, error factory, file system).
    -   `pdf21md/shared-algorithms/`: Shared Objective-C algorithms (e.g., image format detection).
    -   `pdf21md/Tests/`: Unit and integration tests for the Objective-C version.

-   `pdf22md/`: Contains the Swift source code, `Package.swift` (Swift Package Manager manifest), and its specific test resources.
    -   `pdf22md/Sources/PDF22MD/`: Core Swift library modules.
    -   `pdf22md/Sources/PDF22MDCli/`: Swift command-line interface entry point.
    -   `pdf22md/Tests/PDF22MDTests/`: Unit tests for the Swift version.

-   `build.sh`: The main build script that compiles both implementations.
-   `test_both.sh`: Script to run tests for both implementations.
-   `docs/`: General project documentation.
-   `issues/`: Issue tracking files.

## Technical Requirements and Conventions

### General Guidelines

-   **Platform**: Development is primarily for macOS. Ensure compatibility with macOS 10.12+ for Objective-C and macOS 12.0+ for Swift.
-   **Language Standards**: Adhere to modern Objective-C (ARC, nullability annotations, lightweight generics) and Swift (Swift 5.7+, async/await, structured concurrency).
-   **Performance**: Given the nature of PDF processing, performance is critical. Contributions should be mindful of CPU and memory efficiency.
-   **Error Handling**: Use the established error handling patterns (e.g., `PDF21MDErrorFactory` for Objective-C, Swift's native `Error` protocol).
-   **Testing**: All new features and bug fixes should be accompanied by appropriate unit and/or integration tests.

### Objective-C (`pdf21md`)

-   **Prefixes**: All new classes and categories should use the `PDF21MD` prefix.
-   **Memory Management**: Use ARC. Avoid manual `retain`/`release`/`autorelease` calls.
-   **Concurrency**: Utilize `PDF21MDConcurrencyManager` for GCD-based parallel processing and queue management.
-   **File System Operations**: Use `PDF21MDFileSystemUtils` for all file and directory operations.
-   **Constants**: Refer to `PDF21MDConstants` for all configuration values and magic numbers.

### Swift (`pdf22md`)

-   **Swift Package Manager**: The project is managed with SPM. Ensure your changes integrate seamlessly.
-   **Concurrency**: Prefer Swift's `async/await` and `Actors` for concurrent operations.
-   **Error Handling**: Define custom `Error` enums where appropriate and propagate errors using `throws`.
-   **Value Types**: Prefer `struct`s over `class`es where appropriate to leverage Swift's value semantics and improve memory safety.

## Development Workflow

1.  **Fork the Repository**: Start by forking the `pdf22md` repository on GitHub.
2.  **Clone Your Fork**: `git clone https://github.com/YOUR_USERNAME/pdf22md.git`
3.  **Create a New Branch**: `git checkout -b feature/your-feature-name` or `bugfix/issue-number`.
4.  **Make Your Changes**: Implement your feature or bug fix, adhering to the technical requirements and conventions.
5.  **Write Tests**: Add or update tests to cover your changes.
6.  **Run Tests**: Ensure all tests pass for both implementations:
    ```bash
    ./test_both.sh
    ```
7.  **Build the Project**: Verify that both implementations build successfully:
    ```bash
    ./build.sh
    ```
8.  **Update Documentation**: If your changes affect functionality or usage, update `README.md`, `CHANGELOG.md`, or other relevant documentation.
9.  **Commit Your Changes**: Write clear, concise commit messages.
10. **Push to Your Fork**: `git push origin feature/your-feature-name`
11. **Open a Pull Request**: Submit a pull request to the `main` branch of the original `pdf22md` repository.

## How to Orchestrate Code Changes (Detailed)

### Identifying the Right Implementation

-   **General Features/Bug Fixes**: If a feature or bug fix applies to the core PDF conversion logic, it should ideally be implemented in *both* the Objective-C (`pdf21md`) and Swift (`pdf22md`) versions to maintain feature parity and ensure cross-language robustness. Look for existing patterns in both codebases.
-   **Performance Optimizations**: Analyze the performance bottlenecks. Some optimizations might be language-specific (e.g., GCD tuning for Objective-C, `async/await` patterns for Swift).
-   **CLI Enhancements**: Changes to command-line arguments or basic I/O will likely affect `pdf21md/src/CLI/main.m` and `pdf22md/Sources/PDF22MDCli/main.swift`.
-   **Shared Logic**: For logic that is truly independent of language-specific frameworks (e.g., complex algorithms), consider if it can be abstracted or if a direct port is more appropriate.

### Step-by-Step Implementation Example (Placeholder)

*(This section will be expanded with a detailed walkthrough of a typical code change, including how to apply it to both implementations, considerations for shared components, and testing strategies.)*

## Reporting Issues

If you find a bug or have a feature request, please open an issue on the [GitHub Issues page](https://github.com/twardoch/pdf22md/issues). Provide as much detail as possible, including steps to reproduce, expected behavior, and your environment.

## Code of Conduct

This project adheres to a [Code of Conduct](CODE_OF_CONDUCT.md - *link to be added*). By participating, you are expected to uphold this code.

## License

By contributing to `pdf22md`, you agree that your contributions will be licensed under the MIT License.
</file>

<file path="PLAN.md">
# PDF to Markdown Converter - Project Plan

## üö® **PRIORITY 1: Implementation Renaming (pdf21md / pdf22md)**

### Overview
The project will maintain two implementations with distinct names:
- **pdf21md**: Objective-C implementation (formerly pdf22md-objc)
- **pdf22md**: Swift implementation (formerly pdf22md-swift)

### Renaming Strategy - CRITICAL FIRST STEPS

#### Phase 1: Directory Structure (DO FIRST)
1. ‚úÖ Rename `pdf22md-objc/` directory to `pdf21md/`
2. Keep `pdf22md-swift/` directory as is (already correct)

#### Phase 2: Update Objective-C Implementation (pdf21md)
1. **Makefile Updates**:
   - Change target name from `pdf22md` to `pdf21md`
   - Update `BINARY_NAME = pdf21md`
   - Update installation path references

2. **Source Code Class Prefix Changes**:
   - Change all class prefixes from `PDF22MD` to `PDF21MD` in:
     - `src/CLI/` - all `.h` and `.m` files
     - `src/Core/` - all `.h` and `.m` files  
     - `src/Models/` - all `.h` and `.m` files
     - `src/Services/` - all `.h` and `.m` files
     - `shared-core/` - all utility classes
     - `shared-algorithms/` - all algorithm classes
     - `Tests/` - all test files
   - Update all `#import` statements to use new class names
   - Update all `@class` forward declarations

#### Phase 3: Update Swift Implementation (pdf22md)
1. **Package.swift**:
   - Change executable product name from `pdf22md-swift` to `pdf22md`
   - Update executable target name

2. **main.swift**:
   - Change `commandName` from `pdf22md-swift` to `pdf22md`

#### Phase 4: Update Build and Test Scripts
1. **build.sh**:
   - Replace all `pdf22md-objc` with `pdf21md`
   - Update binary paths and installation logic
   - Ensure both binaries are installed: `pdf21md` and `pdf22md`

2. **test_both.sh**:
   - Update all directory references
   - Update binary execution paths
   - Fix test output paths

3. **release.sh** (if exists):
   - Update all references

#### Phase 5: Update Documentation
1. **Main documentation**:
   - README.md - update all references
   - CHANGELOG.md - add renaming entry
   - TODO.md - update as linearized PLAN.md
   - CLAUDE.md - update project description

2. **Implementation docs**:
   - pdf21md/README.md (formerly pdf22md-objc/README.md)
   - pdf22md-swift/README.md

3. **Other docs**:
   - docs/pdf22md.1 - create separate man pages for pdf21md and pdf22md
   - Any other documentation files

## üö® **PRIORITY 2: Critical Bug Fix - No Markdown Output**

### Issue Summary
Both implementations currently:
- ‚úÖ Successfully process PDF pages
- ‚úÖ Extract and save images to assets folder (134 PNGs)
- ‚ùå **FAIL to generate the actual Markdown file**

### Root Cause Analysis
The conversion pipeline completes all steps except writing the final markdown file. Possible causes:
1. Text extraction returning empty results
2. Markdown generator producing empty string
3. File writing silently failing
4. Output path calculation errors

### Investigation Plan

#### Objective-C (pdf21md) Investigation
1. **Check PDF21MDConverter**:
   - Add logging for extracted elements count
   - Verify text elements are being created
   - Log markdown string before file write

2. **Check PDF21MDMarkdownGenerator**:
   - Validate input elements array
   - Log each markdown generation stage
   - Ensure non-empty output

3. **Check main.m**:
   - Add file write validation
   - Check output path permissions
   - Add fallback to stdout if file write fails

#### Swift (pdf22md) Investigation  
1. **Check PDFConverter**:
   - Verify text extraction logic exists
   - Log element extraction results
   - Validate markdown generation call

2. **Check MarkdownWriter**:
   - Ensure file writing is implemented
   - Add error handling for I/O operations
   - Validate output path

### Fix Implementation Steps
1. Add comprehensive logging throughout conversion pipeline
2. Implement missing markdown generation if not present
3. Add error handling and validation at each stage
4. Test with simple PDF to isolate issues
5. Ensure both implementations have feature parity

## Priority 3: Fix CMap Warnings

### Issue
"can't create CMap 'Adobe-Identity-UCS2'" warnings appear during processing

### Plan
1. Research PDF font encoding requirements
2. Check if warnings affect text extraction quality
3. Implement proper CMap handling or suppress if benign

## Priority 4: Minor Code Quality Fixes

### Swift Implementation
- Remove unused `fontName` variable in PDFPageProcessorOptimized.swift:70

## Implementation Roadmap

### Week 1: Critical Fixes
1. **Days 1-2**: Complete renaming of implementations
2. **Days 3-4**: Fix markdown output generation bug
3. **Day 5**: Test and validate fixes

### Week 2: Polish and Testing
1. Fix CMap warnings
2. Add comprehensive test coverage
3. Performance optimization
4. Documentation updates

### Week 3: Release Preparation
1. Create Homebrew formulas
2. Set up GitHub Actions CI/CD
3. Prepare release documentation
4. Community guidelines

## Success Criteria
1. ‚úÖ `pdf21md` (Objective-C) compiles and runs correctly
2. ‚úÖ `pdf22md` (Swift) compiles and runs correctly  
3. ‚úÖ Both tools successfully generate Markdown files from PDFs
4. ‚úÖ Image extraction works correctly
5. ‚úÖ No critical warnings or errors
6. ‚úÖ Documentation is accurate and complete
7. ‚úÖ Ready for public release

## Key Decisions
- Maintain two implementations with distinct binary names
- pdf21md for Objective-C (legacy/stable)
- pdf22md for Swift (modern/future)
- Focus on fixing critical bugs before adding new features
- Ensure both implementations have feature parity
</file>

<file path=".github/workflows/release.yml">
name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  build-and-release:
    runs-on: macos-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Full history for version tags
    
    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable
    
    - name: Get version from tag
      id: version
      run: |
        VERSION=${GITHUB_REF#refs/tags/v}
        echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
        echo "TAG=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
    
    - name: Build universal binary
      run: |
        # Build for Intel
        make clean
        make VERSION="${{ steps.version.outputs.VERSION }}" CFLAGS="-Wall -Wextra -O2 -fobjc-arc -arch x86_64"
        mv pdf22md pdf22md-x86_64
        
        # Build for Apple Silicon
        make clean
        make VERSION="${{ steps.version.outputs.VERSION }}" CFLAGS="-Wall -Wextra -O2 -fobjc-arc -arch arm64"
        mv pdf22md pdf22md-arm64
        
        # Create universal binary
        lipo -create -output pdf22md pdf22md-x86_64 pdf22md-arm64
        chmod +x pdf22md
        
        # Verify universal binary
        lipo -info pdf22md
        ./pdf22md -v
    
    - name: Create distribution package
      run: |
        # Create directory structure
        mkdir -p dist/usr/local/bin
        mkdir -p dist/usr/local/share/man/man1
        mkdir -p dist/usr/local/share/doc/pdf22md
        
        # Copy files
        cp pdf22md dist/usr/local/bin/
        cp LICENSE dist/usr/local/share/doc/pdf22md/
        cp README.md dist/usr/local/share/doc/pdf22md/
        cp docs/PARALLEL_PROCESSING.md dist/usr/local/share/doc/pdf22md/ || true
        
        # Create man page
        cat > dist/usr/local/share/man/man1/pdf22md.1 << EOF
        .TH PDF22MD 1 "$(date +'%B %Y')" "pdf22md ${{ steps.version.outputs.VERSION }}" "User Commands"
        .SH NAME
        pdf22md \- Convert PDF documents to Markdown format
        .SH SYNOPSIS
        .B pdf22md
        [\fB\-i\fR \fIinput.pdf\fR]
        [\fB\-o\fR \fIoutput.md\fR]
        [\fB\-a\fR \fIassets_folder\fR]
        [\fB\-d\fR \fIdpi\fR]
        [\fB\-v\fR]
        [\fB\-h\fR]
        .SH DESCRIPTION
        .B pdf22md
        is a high-performance PDF to Markdown converter for macOS that uses Grand Central Dispatch (GCD) for parallel processing.
        .SH OPTIONS
        .TP
        .BR \-i " " \fIpath\fR
        Input PDF file (default: stdin)
        .TP
        .BR \-o " " \fIpath\fR
        Output Markdown file (default: stdout)
        .TP
        .BR \-a " " \fIpath\fR
        Assets folder for extracted images
        .TP
        .BR \-d " " \fIdpi\fR
        DPI for rasterizing vector graphics (default: 144)
        .TP
        .BR \-v
        Display version information
        .TP
        .BR \-h
        Display help message
        .SH EXAMPLES
        .TP
        Convert a PDF file to Markdown:
        .B pdf22md -i document.pdf -o document.md
        .TP
        Convert with images saved to an assets folder:
        .B pdf22md -i report.pdf -o report.md -a ./assets
        .TP
        Use with pipes:
        .B cat document.pdf | pdf22md > document.md
        .SH AUTHOR
        Adam Twardoch
        .SH LICENSE
        MIT License
        EOF
    
    - name: Create installer package
      run: |
        # Create package info
        mkdir -p package_resources
        
        # Create postinstall script
        cat > package_resources/postinstall << 'EOF'
        #!/bin/bash
        # Update man database
        if command -v makewhatis >/dev/null 2>&1; then
            makewhatis /usr/local/share/man
        fi
        exit 0
        EOF
        chmod +x package_resources/postinstall
        
        # Build the package
        pkgbuild --root dist \
                 --identifier com.twardoch.pdf22md \
                 --version "${{ steps.version.outputs.VERSION }}" \
                 --scripts package_resources \
                 --ownership recommended \
                 pdf22md-${{ steps.version.outputs.VERSION }}.pkg
        
        # Create a distribution XML for productbuild (optional, for more control)
        cat > distribution.xml << EOF
        <?xml version="1.0" encoding="utf-8" standalone="yes"?>
        <installer-gui-script minSpecVersion="2.0">
            <title>pdf22md ${{ steps.version.outputs.VERSION }}</title>
            <organization>com.twardoch</organization>
            <domains enable_localSystem="true"/>
            <options customize="never" require-scripts="true" rootVolumeOnly="true"/>
            <pkg-ref id="com.twardoch.pdf22md">
                <bundle-version>
                    <bundle CFBundleVersion="${{ steps.version.outputs.VERSION }}" id="com.twardoch.pdf22md" path="pdf22md"/>
                </bundle-version>
            </pkg-ref>
            <choices-outline>
                <line choice="default">
                    <line choice="com.twardoch.pdf22md"/>
                </line>
            </choices-outline>
            <choice id="default" title="pdf22md" description="PDF to Markdown converter"/>
            <choice id="com.twardoch.pdf22md" visible="false">
                <pkg-ref id="com.twardoch.pdf22md"/>
            </choice>
            <pkg-ref id="com.twardoch.pdf22md" version="${{ steps.version.outputs.VERSION }}" onConclusion="none">pdf22md-${{ steps.version.outputs.VERSION }}.pkg</pkg-ref>
        </installer-gui-script>
        EOF
        
        # Sign the package if certificates are available
        if security find-identity -p basic -v | grep -q "Developer ID Installer"; then
            INSTALLER_CERT=$(security find-identity -p basic -v | grep "Developer ID Installer" | head -1 | awk '{print $2}')
            productsign --sign "$INSTALLER_CERT" \
                        pdf22md-${{ steps.version.outputs.VERSION }}.pkg \
                        pdf22md-${{ steps.version.outputs.VERSION }}-signed.pkg
            mv pdf22md-${{ steps.version.outputs.VERSION }}-signed.pkg pdf22md-${{ steps.version.outputs.VERSION }}.pkg
        fi
    
    - name: Create release archives
      run: |
        # Create tarball with binary and docs
        mkdir -p pdf22md-${{ steps.version.outputs.VERSION }}
        cp pdf22md pdf22md-${{ steps.version.outputs.VERSION }}/
        cp README.md LICENSE pdf22md-${{ steps.version.outputs.VERSION }}/
        cp -r docs pdf22md-${{ steps.version.outputs.VERSION }}/ || true
        tar -czf pdf22md-${{ steps.version.outputs.VERSION }}-macos.tar.gz pdf22md-${{ steps.version.outputs.VERSION }}
        
        # Create zip for those who prefer it
        zip -r pdf22md-${{ steps.version.outputs.VERSION }}-macos.zip pdf22md-${{ steps.version.outputs.VERSION }}
    
    - name: Generate release notes
      id: release_notes
      run: |
        # Get previous tag
        PREVIOUS_TAG=$(git tag -l 'v*' | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -2 | head -1)
        
        # Generate changelog
        if [ -n "$PREVIOUS_TAG" ]; then
          echo "## What's Changed" > release_notes.md
          echo "" >> release_notes.md
          git log --pretty=format:"* %s (%h)" ${PREVIOUS_TAG}..HEAD >> release_notes.md
        else
          echo "## Initial Release" > release_notes.md
          echo "" >> release_notes.md
          echo "First release of pdf22md!" >> release_notes.md
        fi
        
        echo "" >> release_notes.md
        echo "## Installation" >> release_notes.md
        echo "" >> release_notes.md
        echo "### Using the installer package (recommended):" >> release_notes.md
        echo '```bash' >> release_notes.md
        echo "curl -LO https://github.com/twardoch/pdf22md/releases/download/${{ steps.version.outputs.TAG }}/pdf22md-${{ steps.version.outputs.VERSION }}.pkg" >> release_notes.md
        echo "sudo installer -pkg pdf22md-${{ steps.version.outputs.VERSION }}.pkg -target /" >> release_notes.md
        echo '```' >> release_notes.md
        echo "" >> release_notes.md
        echo "### Manual installation:" >> release_notes.md
        echo '```bash' >> release_notes.md
        echo "curl -LO https://github.com/twardoch/pdf22md/releases/download/${{ steps.version.outputs.TAG }}/pdf22md-${{ steps.version.outputs.VERSION }}-macos.tar.gz" >> release_notes.md
        echo "tar -xzf pdf22md-${{ steps.version.outputs.VERSION }}-macos.tar.gz" >> release_notes.md
        echo "sudo cp pdf22md-${{ steps.version.outputs.VERSION }}/pdf22md /usr/local/bin/" >> release_notes.md
        echo '```' >> release_notes.md
    
    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        name: pdf22md ${{ steps.version.outputs.VERSION }}
        body_path: release_notes.md
        files: |
          pdf22md-${{ steps.version.outputs.VERSION }}.pkg
          pdf22md-${{ steps.version.outputs.VERSION }}-macos.tar.gz
          pdf22md-${{ steps.version.outputs.VERSION }}-macos.zip
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Update Homebrew formula
      run: |
        # This would typically update a homebrew tap repository
        # For now, we'll just output what should be done
        echo "To update Homebrew formula:"
        echo "1. Update the url to: https://github.com/twardoch/pdf22md/archive/refs/tags/${{ steps.version.outputs.TAG }}.tar.gz"
        echo "2. Update the sha256 hash"
        echo "3. Update the version in the formula"
</file>

<file path="docs/PARALLEL_PROCESSING.md">
# Parallel Processing in `pdf22md`

This document outlines the implementation of parallel processing in the `pdf22md` command-line tool for converting PDF documents to Markdown format.

## 1. Objective

The goal was to accelerate the conversion of multi-page PDF documents by processing multiple pages concurrently and saving extracted images in parallel.

## 2. Technology: Grand Central Dispatch (GCD)

Similar to `pdfupng`, we utilized Apple's **Grand Central Dispatch (GCD)** framework with the `dispatch_apply` function for parallel execution.

## 3. Implementation Details

### 3.1. Parallel Page Processing

The core changes were made within the `convertWithAssetsFolderPath:rasterizedDPI:completion:` method in `PDFMarkdownConverter.m`.

#### From Sequential to Concurrent

The original implementation used a sequential `for` loop:

```objc
for (NSInteger pageIndex = 0; pageIndex < pageCount; pageIndex++) {
    PDFPage *page = [self.pdfDocument pageAtIndex:pageIndex];
    // ... process page ...
}
```

This was replaced with:

```objc
dispatch_apply(pageCount, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t pageIndex) {
    @autoreleasepool {
        PDFPage *page = [self.pdfDocument pageAtIndex:pageIndex];
        // ... process page ...
    }
});
```

### 3.2. Thread Safety Measures

1. **Temporary Storage Arrays**: Instead of directly modifying shared arrays (`allElements`, `fontStats`), we create temporary per-page storage:

```objc
NSMutableArray<NSMutableArray<id<ContentElement>> *> *pageElementsArray = [NSMutableArray arrayWithCapacity:pageCount];
NSMutableArray<NSMutableDictionary *> *pageFontStatsArray = [NSMutableArray arrayWithCapacity:pageCount];
```

2. **Error Handling**: A shared boolean flag with synchronized access:

```objc
__block BOOL processingFailed = NO;
NSObject *lock = [[NSObject alloc] init];

// Inside parallel block
@synchronized(lock) {
    if (processingFailed) return;
}
```

3. **Result Merging**: After parallel processing completes, results are merged sequentially:

```objc
for (NSInteger i = 0; i < pageCount; i++) {
    [self.allElements addObjectsFromArray:pageElementsArray[i]];
    // Merge font statistics...
}
```

### 3.3. Parallel Image Saving

Image saving was also parallelized:

```objc
dispatch_apply(imageCount, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t index) {
    @autoreleasepool {
        ImageElement *imageElement = imageElements[index];
        NSString *savedPath = [assetExtractor saveImage:imageElement.image ...];
        if (savedPath) {
            @synchronized(imageElement) {
                imageElement.assetRelativePath = savedPath;
            }
        }
    }
});
```

### 3.4. Memory Management

Each parallel operation is wrapped in `@autoreleasepool` to ensure prompt deallocation of temporary objects and prevent memory spikes.

## 4. Performance Benefits

- **Multi-core Utilization**: Pages are processed on multiple CPU cores simultaneously
- **Reduced Total Time**: For PDFs with many pages, the speedup is nearly linear with the number of cores
- **Efficient Memory Usage**: Autoreleasepool prevents memory accumulation
- **Scalability**: The implementation automatically adapts to the available hardware

## 5. Considerations

- **Thread Safety**: All shared resources are protected with appropriate synchronization
- **Memory Overhead**: Each parallel task has its own memory footprint, but autoreleasepool keeps it manageable
- **I/O Bottlenecks**: Image saving may be limited by disk I/O speed rather than CPU
</file>

<file path="docs/pdf22md.1">
.TH PDF22MD 1 "June 2025" "pdf22md v1.0" "User Commands"
.SH NAME
pdf22md \- high-performance PDF to Markdown converter
.SH SYNOPSIS
.B pdf22md
[\fB\-i\fR \fIinput.pdf\fR]
[\fB\-o\fR \fIoutput.md\fR]
[\fB\-a\fR \fIassets_folder\fR]
[\fB\-d\fR \fIdpi\fR]
[\fB\-v\fR]
[\fB\-h\fR]
.SH DESCRIPTION
.B pdf22md
is a blazingly fast PDF to Markdown converter that extracts text and images from PDF documents and converts them into clean, structured Markdown format. It uses parallel processing to achieve high performance on multi-page documents.

The tool automatically detects heading hierarchy based on font size analysis, extracts images with intelligent format optimization (PNG/JPEG), and generates YAML frontmatter with document metadata.

.SH OPTIONS
.TP
\fB\-i\fR \fIinput.pdf\fR
Specify the input PDF file to convert. If not provided, pdf22md reads from standard input (stdin).
.TP
\fB\-o\fR \fIoutput.md\fR
Specify the output Markdown file. If not provided, pdf22md writes to standard output (stdout).
.TP
\fB\-a\fR \fIassets_folder\fR
Specify the folder where extracted images will be saved. The folder will be created if it doesn't exist. Images are automatically referenced in the generated Markdown with relative paths.
.TP
\fB\-d\fR \fIdpi\fR
Set the DPI (dots per inch) for rasterizing vector graphics. Default is 144. Higher values produce better quality but larger file sizes. Common values: 72 (screen), 144 (default), 300 (print quality).
.TP
\fB\-v\fR, \fB\-\-version\fR
Display version information and exit.
.TP
\fB\-h\fR, \fB\-\-help\fR
Display usage information and exit.

.SH EXAMPLES
.TP
Convert a PDF file to Markdown:
.B pdf22md \-i document.pdf \-o document.md

.TP
Extract images to an assets folder:
.B pdf22md \-i document.pdf \-o document.md \-a ./assets

.TP
Use higher DPI for better image quality:
.B pdf22md \-i document.pdf \-o document.md \-a ./assets \-d 300

.TP
Convert using pipes (stdin/stdout):
.B cat document.pdf | pdf22md > document.md

.TP
Process a document with custom settings:
.B pdf22md \-i report.pdf \-o report.md \-a ./images \-d 200

.SH INPUT/OUTPUT
.SS Input Sources
.B pdf22md
accepts PDF input from:
.IP ‚Ä¢ 2
File path specified with \fB\-i\fR flag
.IP ‚Ä¢ 2
Standard input (stdin) when no \fB\-i\fR flag is provided

.SS Output Destinations
Markdown output is written to:
.IP ‚Ä¢ 2
File path specified with \fB\-o\fR flag
.IP ‚Ä¢ 2
Standard output (stdout) when no \fB\-o\fR flag is provided

.SS Image Assets
When the \fB\-a\fR flag is used:
.IP ‚Ä¢ 2
Images are extracted and saved to the specified folder
.IP ‚Ä¢ 2
Filenames follow the pattern: image_001.png, image_002.jpg, etc.
.IP ‚Ä¢ 2
Format selection is automatic (PNG for graphics, JPEG for photos)
.IP ‚Ä¢ 2
Markdown contains relative references to the images

.SH FEATURES
.SS Intelligent Content Processing
.IP ‚Ä¢ 2
\fBHeading Detection\fR: Automatically identifies headings (H1-H6) based on font size analysis
.IP ‚Ä¢ 2
\fBText Extraction\fR: Preserves text formatting and structure
.IP ‚Ä¢ 2
\fBImage Processing\fR: Extracts both raster and vector graphics
.IP ‚Ä¢ 2
\fBSmart Formatting\fR: Maintains document hierarchy and readability

.SS Performance Optimizations
.IP ‚Ä¢ 2
\fBParallel Processing\fR: Uses all available CPU cores for maximum speed
.IP ‚Ä¢ 2
\fBMemory Efficiency\fR: Processes large documents without excessive memory usage
.IP ‚Ä¢ 2
\fBFormat Optimization\fR: Automatic PNG/JPEG selection based on image content

.SS Output Features
.IP ‚Ä¢ 2
\fBYAML Frontmatter\fR: Includes document metadata (title, author, creation date)
.IP ‚Ä¢ 2
\fBClean Markdown\fR: Well-structured output compatible with all Markdown processors
.IP ‚Ä¢ 2
\fBAsset Management\fR: Organized image extraction with proper linking

.SH FILE FORMATS
.SS Supported Input
.IP ‚Ä¢ 2
PDF files (version 1.4 and higher)
.IP ‚Ä¢ 2
Unencrypted PDFs (password-protected PDFs are not supported)
.IP ‚Ä¢ 2
PDFs with text, images, and vector graphics
.IP ‚Ä¢ 2
Multi-page documents of any size

.SS Generated Output
.IP ‚Ä¢ 2
\fBMarkdown (.md)\fR: GitHub Flavored Markdown compatible
.IP ‚Ä¢ 2
\fBImages (.png/.jpg)\fR: Extracted graphics in optimal formats
.IP ‚Ä¢ 2
\fBYAML Frontmatter\fR: Document metadata in standard format

.SH PERFORMANCE
Typical conversion speeds on modern hardware:
.IP ‚Ä¢ 2
Simple text documents: <1 second per page
.IP ‚Ä¢ 2
Complex documents with images: 2-5 seconds per page
.IP ‚Ä¢ 2
Large documents (100+ pages): Scales linearly with parallel processing

Memory usage is optimized for documents up to 1000 pages. Very large documents may require additional system memory.

.SH ERROR HANDLING
.B pdf22md
provides detailed error messages with suggestions for common issues:

.SS Common Errors and Solutions
.TP
\fBInvalid PDF file\fR
.IP ‚Ä¢ 2
Verify the file exists and is a valid PDF
.IP ‚Ä¢ 2
Check if the file is corrupted
.IP ‚Ä¢ 2
Ensure you have read permissions

.TP
\fBCannot create assets folder\fR
.IP ‚Ä¢ 2
Check if the parent directory exists
.IP ‚Ä¢ 2
Verify you have write permissions
.IP ‚Ä¢ 2
Ensure sufficient disk space

.TP
\fBPassword-protected PDF\fR
.IP ‚Ä¢ 2
Remove password protection using another tool first
.IP ‚Ä¢ 2
Use: qpdf \-\-decrypt input.pdf output.pdf

.TP
\fBMemory pressure\fR
.IP ‚Ä¢ 2
Close other applications to free memory
.IP ‚Ä¢ 2
Try using a lower DPI setting (\-d 72)
.IP ‚Ä¢ 2
Process smaller sections of large documents

.SH EXIT STATUS
.TP
.B 0
Successful conversion
.TP
.B 1
Error occurred (invalid input, processing failure, I/O error)

.SH ENVIRONMENT
No special environment variables are required. The tool uses standard macOS frameworks (PDFKit, CoreGraphics) and runs on macOS 10.15 and later.

.SH LIMITATIONS
.IP ‚Ä¢ 2
Password-protected PDFs are not supported
.IP ‚Ä¢ 2
Scanned PDFs without OCR text layer will only extract images
.IP ‚Ä¢ 2
Complex table layouts may not convert perfectly
.IP ‚Ä¢ 2
Some advanced PDF features (forms, annotations) are not preserved

.SH COMPATIBILITY
.SS Platform Support
.IP ‚Ä¢ 2
macOS 10.15 (Catalina) and later
.IP ‚Ä¢ 2
Intel and Apple Silicon processors
.IP ‚Ä¢ 2
Universal binary for optimal performance

.SS Markdown Compatibility
Output is compatible with:
.IP ‚Ä¢ 2
GitHub Flavored Markdown
.IP ‚Ä¢ 2
CommonMark specification
.IP ‚Ä¢ 2
Popular Markdown processors (pandoc, Jekyll, etc.)
.IP ‚Ä¢ 2
Static site generators (Hugo, Jekyll, Gatsby)

.SH FILES
.TP
.I ~/.pdf22md/
User configuration directory (future use)
.TP
.I /usr/local/bin/pdf22md
Default installation location
.TP
.I /usr/local/share/man/man1/pdf22md.1
This manual page

.SH EXAMPLES WORKFLOW
.SS Basic Document Conversion
.nf
# Convert a simple document
pdf22md \-i report.pdf \-o report.md

# Result: clean Markdown with YAML frontmatter
# Output includes: title, headings, body text, metadata
.fi

.SS Academic Paper with Images
.nf
# Convert research paper with figure extraction
pdf22md \-i paper.pdf \-o paper.md \-a figures \-d 300

# Result: 
# - paper.md with structured content
# - figures/ folder with high-quality images
# - Proper cross-references to figures
.fi

.SS Batch Processing
.nf
# Process multiple documents
for pdf in *.pdf; do
    pdf22md \-i "$pdf" \-o "${pdf%.pdf}.md" \-a "assets_${pdf%.pdf}"
done
.fi

.SS Integration with Other Tools
.nf
# Combine with pandoc for further processing
pdf22md \-i document.pdf | pandoc \-f markdown \-t html \-o document.html

# Use with static site generators
pdf22md \-i post.pdf \-o content/posts/post.md \-a static/images
.fi

.SH TROUBLESHOOTING
.SS Performance Issues
If conversion is slow:
.IP ‚Ä¢ 2
Check available memory and CPU usage
.IP ‚Ä¢ 2
Close unnecessary applications
.IP ‚Ä¢ 2
Try lower DPI setting for faster processing
.IP ‚Ä¢ 2
Process documents in smaller batches

.SS Quality Issues
If output quality is poor:
.IP ‚Ä¢ 2
Increase DPI setting (\-d 300) for better images
.IP ‚Ä¢ 2
Verify the source PDF has good quality text
.IP ‚Ä¢ 2
Check if the PDF has a proper text layer (not just scanned images)

.SS Memory Errors
For large documents:
.IP ‚Ä¢ 2
Ensure sufficient RAM (8GB+ recommended for large PDFs)
.IP ‚Ä¢ 2
Close other memory-intensive applications
.IP ‚Ä¢ 2
Split very large PDFs into smaller parts first

.SH REPORTING BUGS
Report bugs and feature requests at:
.UR https://github.com/twardoch/pdf22md/issues
.UE

Include in your report:
.IP ‚Ä¢ 2
pdf22md version (\fBpdf22md \-v\fR)
.IP ‚Ä¢ 2
macOS version
.IP ‚Ä¢ 2
Sample PDF file (if possible)
.IP ‚Ä¢ 2
Complete error message
.IP ‚Ä¢ 2
Steps to reproduce the issue

.SH AUTHORS
Written by Adam Twardoch and contributors.

.SH LICENSE
MIT License. See the LICENSE file for details.

.SH SEE ALSO
.BR pandoc (1),
.BR qpdf (1),
.BR pdftotext (1),
.BR markdown (7)

Project homepage: 
.UR https://github.com/twardoch/pdf22md
.UE
</file>

<file path="pdf21md/shared-core/PDF21MDConcurrencyManager.h">
//
//  PDF21MDConcurrencyManager.h
//  pdf21md - Shared Components
//
//  Standardized concurrency patterns and queue management
//  for consistent GCD usage across all implementations.
//

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

/**
 * Standardized concurrency manager providing unified GCD patterns
 * and queue management across all PDF21MD implementations.
 */
@interface PDF21MDConcurrencyManager : NSObject

#pragma mark - Shared Queue Access

/**
 * Shared concurrent queue for CPU-intensive operations.
 * Optimized for parallel processing tasks like page conversion.
 */
+ (dispatch_queue_t)sharedConcurrentQueue;

/**
 * Shared serial queue for file system operations.
 * Ensures thread-safe file access and prevents race conditions.
 */
+ (dispatch_queue_t)sharedFileAccessQueue;

/**
 * Shared serial queue for converter operations.
 * Manages conversion workflow and state consistency.
 */
+ (dispatch_queue_t)sharedConverterQueue;

/**
 * Shared global queue for background processing.
 * Standard system queue for general background tasks.
 */
+ (dispatch_queue_t)sharedBackgroundQueue;

#pragma mark - Concurrency Utilities

/**
 * Creates a dispatch group for coordinating multiple operations.
 */
+ (dispatch_group_t)createProcessingGroup;

/**
 * Creates a semaphore with specified concurrent operation limit.
 */
+ (dispatch_semaphore_t)createConcurrencySemaphoreWithLimit:(NSInteger)limit;

/**
 * Executes operation on concurrent queue with completion on main queue.
 */
+ (void)performConcurrentOperation:(void(^)(void))operation
                        completion:(nullable void(^)(void))completion;

/**
 * Executes operation on serial file access queue.
 */
+ (void)performFileOperation:(void(^)(void))operation
                  completion:(nullable void(^)(void))completion;

/**
 * Executes operation on converter queue.
 */
+ (void)performConverterOperation:(void(^)(void))operation
                       completion:(nullable void(^)(void))completion;

#pragma mark - Parallel Processing Patterns

/**
 * Processes array items in parallel with concurrency limit.
 * Uses dispatch groups and semaphores for optimal performance.
 */
+ (void)processItemsInParallel:(NSArray *)items
               concurrencyLimit:(NSInteger)limit
                      processor:(void(^)(id item, NSInteger index))processor
                     completion:(void(^)(void))completion;

/**
 * Processes array items in parallel with progress reporting.
 */
+ (void)processItemsInParallel:(NSArray *)items
               concurrencyLimit:(NSInteger)limit
                      processor:(void(^)(id item, NSInteger index))processor
                progressHandler:(nullable void(^)(NSInteger completedCount, NSInteger totalCount))progressHandler
                     completion:(void(^)(void))completion;

#pragma mark - Synchronization Utilities

/**
 * Waits for dispatch group with timeout.
 * Returns YES if completed within timeout, NO if timed out.
 */
+ (BOOL)waitForGroup:(dispatch_group_t)group
             timeout:(NSTimeInterval)timeoutSeconds;

/**
 * Waits for semaphore with timeout.
 * Returns YES if acquired within timeout, NO if timed out.
 */
+ (BOOL)waitForSemaphore:(dispatch_semaphore_t)semaphore
                 timeout:(NSTimeInterval)timeoutSeconds;

/**
 * Executes block on main queue, handling both main and background thread calls.
 */
+ (void)executeOnMainQueue:(void(^)(void))block;

/**
 * Executes block on main queue synchronously if on background thread,
 * immediately if already on main thread.
 */
+ (void)executeOnMainQueueSync:(void(^)(void))block;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf21md/shared-core/PDF21MDConcurrencyManager.m">
//
//  PDF21MDConcurrencyManager.m
//  pdf21md - Shared Components
//
//  Standardized concurrency patterns and queue management
//  for consistent GCD usage across all implementations.
//

#import "PDF21MDConcurrencyManager.h"

@implementation PDF21MDConcurrencyManager

#pragma mark - Shared Queue Access

+ (dispatch_queue_t)sharedConcurrentQueue {
    static dispatch_queue_t sharedQueue;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        sharedQueue = dispatch_queue_create("com.twardoch.pdf21md.concurrent", 
                                          DISPATCH_QUEUE_CONCURRENT);
    });
    return sharedQueue;
}

+ (dispatch_queue_t)sharedFileAccessQueue {
    static dispatch_queue_t sharedQueue;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        sharedQueue = dispatch_queue_create("com.twardoch.pdf21md.fileaccess", 
                                          DISPATCH_QUEUE_SERIAL);
    });
    return sharedQueue;
}

+ (dispatch_queue_t)sharedConverterQueue {
    static dispatch_queue_t sharedQueue;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        sharedQueue = dispatch_queue_create("com.twardoch.pdf21md.converter", 
                                          DISPATCH_QUEUE_SERIAL);
    });
    return sharedQueue;
}

+ (dispatch_queue_t)sharedBackgroundQueue {
    return dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
}

#pragma mark - Concurrency Utilities

+ (dispatch_group_t)createProcessingGroup {
    return dispatch_group_create();
}

+ (dispatch_semaphore_t)createConcurrencySemaphoreWithLimit:(NSInteger)limit {
    return dispatch_semaphore_create(limit);
}

+ (void)performConcurrentOperation:(void(^)(void))operation
                        completion:(nullable void(^)(void))completion {
    dispatch_async([self sharedConcurrentQueue], ^{
        operation();
        
        if (completion) {
            [self executeOnMainQueue:completion];
        }
    });
}

+ (void)performFileOperation:(void(^)(void))operation
                  completion:(nullable void(^)(void))completion {
    dispatch_async([self sharedFileAccessQueue], ^{
        operation();
        
        if (completion) {
            [self executeOnMainQueue:completion];
        }
    });
}

+ (void)performConverterOperation:(void(^)(void))operation
                       completion:(nullable void(^)(void))completion {
    dispatch_async([self sharedConverterQueue], ^{
        operation();
        
        if (completion) {
            [self executeOnMainQueue:completion];
        }
    });
}

#pragma mark - Parallel Processing Patterns

+ (void)processItemsInParallel:(NSArray *)items
               concurrencyLimit:(NSInteger)limit
                      processor:(void(^)(id item, NSInteger index))processor
                     completion:(void(^)(void))completion {
    [self processItemsInParallel:items
                 concurrencyLimit:limit
                        processor:processor
                  progressHandler:nil
                       completion:completion];
}

+ (void)processItemsInParallel:(NSArray *)items
               concurrencyLimit:(NSInteger)limit
                      processor:(void(^)(id item, NSInteger index))processor
                progressHandler:(nullable void(^)(NSInteger completedCount, NSInteger totalCount))progressHandler
                     completion:(void(^)(void))completion {
    if (items.count == 0) {
        [self executeOnMainQueue:completion];
        return;
    }
    
    dispatch_group_t processingGroup = [self createProcessingGroup];
    dispatch_semaphore_t concurrencySemaphore = [self createConcurrencySemaphoreWithLimit:limit];
    
    __block NSInteger completedCount = 0;
    NSInteger totalCount = items.count;
    
    for (NSInteger i = 0; i < totalCount; i++) {
        id item = items[i];
        
        dispatch_group_async(processingGroup, [self sharedBackgroundQueue], ^{
            dispatch_semaphore_wait(concurrencySemaphore, DISPATCH_TIME_FOREVER);
            
            processor(item, i);
            
            // Update progress if handler provided
            if (progressHandler) {
                @synchronized(self) {
                    completedCount++;
                    NSInteger currentCompleted = completedCount;
                    
                    [self executeOnMainQueue:^{
                        progressHandler(currentCompleted, totalCount);
                    }];
                }
            }
            
            dispatch_semaphore_signal(concurrencySemaphore);
        });
    }
    
    dispatch_group_notify(processingGroup, [self sharedBackgroundQueue], ^{
        [self executeOnMainQueue:completion];
    });
}

#pragma mark - Synchronization Utilities

+ (BOOL)waitForGroup:(dispatch_group_t)group
             timeout:(NSTimeInterval)timeoutSeconds {
    dispatch_time_t timeout = dispatch_time(DISPATCH_TIME_NOW, 
                                          (int64_t)(timeoutSeconds * NSEC_PER_SEC));
    return dispatch_group_wait(group, timeout) == 0;
}

+ (BOOL)waitForSemaphore:(dispatch_semaphore_t)semaphore
                 timeout:(NSTimeInterval)timeoutSeconds {
    dispatch_time_t timeout = dispatch_time(DISPATCH_TIME_NOW, 
                                          (int64_t)(timeoutSeconds * NSEC_PER_SEC));
    return dispatch_semaphore_wait(semaphore, timeout) == 0;
}

+ (void)executeOnMainQueue:(void(^)(void))block {
    if ([NSThread isMainThread]) {
        block();
    } else {
        dispatch_async(dispatch_get_main_queue(), block);
    }
}

+ (void)executeOnMainQueueSync:(void(^)(void))block {
    if ([NSThread isMainThread]) {
        block();
    } else {
        dispatch_sync(dispatch_get_main_queue(), block);
    }
}

@end
</file>

<file path="pdf21md/shared-core/PDF21MDConstants.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

#pragma mark - Default Configuration Values

extern const CGFloat PDF21MD_DEFAULT_DPI;
extern const CGFloat PDF21MD_DEFAULT_FONT_SIZE_THRESHOLD;
extern const NSInteger PDF21MD_MAX_HEADING_LEVEL;
extern const NSInteger PDF21MD_MIN_HEADING_LEVEL;
extern const NSInteger PDF21MD_DEFAULT_MAX_CONCURRENT_PAGES;

#pragma mark - Validation Limits

extern const NSInteger PDF21MD_MAXIMUM_DPI;
extern const NSInteger PDF21MD_MINIMUM_DPI;
extern const NSInteger PDF21MD_MAXIMUM_CONCURRENT_PAGES;
extern const NSInteger PDF21MD_MINIMUM_CONCURRENT_PAGES;
extern const CGFloat PDF21MD_MAXIMUM_FONT_SIZE_THRESHOLD;
extern const CGFloat PDF21MD_MINIMUM_FONT_SIZE_THRESHOLD;

#pragma mark - File and Asset Configuration

extern NSString * const PDF21MD_DEFAULT_ASSETS_DIRECTORY;
extern NSString * const _Nonnull PDF21MD_SUPPORTED_IMAGE_FORMATS[];
extern const NSUInteger PDF21MD_SUPPORTED_IMAGE_FORMATS_COUNT;

#pragma mark - Processing Configuration

extern const NSTimeInterval PDF21MD_DEFAULT_PROCESSING_TIMEOUT;
extern const NSUInteger PDF21MD_COLOR_COMPLEXITY_THRESHOLD;
extern const NSUInteger PDF21MD_SMALL_IMAGE_THRESHOLD;
extern const NSUInteger PDF21MD_LARGE_IMAGE_THRESHOLD;

#pragma mark - Memory and Performance

extern const NSUInteger PDF21MD_DEFAULT_QUEUE_PRIORITY;
extern const NSUInteger PDF21MD_MEMORY_WARNING_THRESHOLD_MB;

NS_ASSUME_NONNULL_END
</file>

<file path="pdf21md/shared-core/PDF21MDConstants.m">
#import "PDF21MDConstants.h"

#pragma mark - Default Configuration Values

const CGFloat PDF21MD_DEFAULT_DPI = 144.0;
const CGFloat PDF21MD_DEFAULT_FONT_SIZE_THRESHOLD = 2.0;
const NSInteger PDF21MD_MAX_HEADING_LEVEL = 6;
const NSInteger PDF21MD_MIN_HEADING_LEVEL = 1;

const NSInteger PDF21MD_DEFAULT_MAX_CONCURRENT_PAGES = 0; // Will be set to processor count at runtime

#pragma mark - Validation Limits

const NSInteger PDF21MD_MAXIMUM_DPI = 600;
const NSInteger PDF21MD_MINIMUM_DPI = 72;
const NSInteger PDF21MD_MAXIMUM_CONCURRENT_PAGES = 64;
const NSInteger PDF21MD_MINIMUM_CONCURRENT_PAGES = 1;
const CGFloat PDF21MD_MAXIMUM_FONT_SIZE_THRESHOLD = 10.0;
const CGFloat PDF21MD_MINIMUM_FONT_SIZE_THRESHOLD = 0.5;

#pragma mark - File and Asset Configuration

NSString * const PDF21MD_DEFAULT_ASSETS_DIRECTORY = @"assets";

NSString * const PDF21MD_SUPPORTED_IMAGE_FORMATS[] = {
    @"png",
    @"jpg", 
    @"jpeg",
    @"gif",
    @"tiff",
    @"tif",
    @"bmp",
    @"webp"
};

const NSUInteger PDF21MD_SUPPORTED_IMAGE_FORMATS_COUNT = 8;

#pragma mark - Processing Configuration

const NSTimeInterval PDF21MD_DEFAULT_PROCESSING_TIMEOUT = 30.0;
const NSUInteger PDF21MD_COLOR_COMPLEXITY_THRESHOLD = 256;
const NSUInteger PDF21MD_SMALL_IMAGE_THRESHOLD = 32;
const NSUInteger PDF21MD_LARGE_IMAGE_THRESHOLD = 2048;

#pragma mark - Memory and Performance

const NSUInteger PDF21MD_DEFAULT_QUEUE_PRIORITY = DISPATCH_QUEUE_PRIORITY_DEFAULT;
const NSUInteger PDF21MD_MEMORY_WARNING_THRESHOLD_MB = 100;
</file>

<file path="pdf21md/shared-core/PDF21MDErrorFactory.h">
//
//  PDF21MDErrorFactory.h
//  pdf21md - Shared Components
//
//  Unified error creation factory for consistent error handling
//  across all implementations and components.
//

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

// Forward declaration - error constants defined in implementation-specific headers
typedef NS_ENUM(NSInteger, PDF21MDError);

/**
 * Unified error factory for creating consistent, user-friendly error objects
 * across all PDF21MD implementations and components.
 */
@interface PDF21MDErrorFactory : NSObject

#pragma mark - Core Factory Methods

/**
 * Creates a user-friendly error with code, description, and actionable suggestion.
 */
+ (NSError *)createErrorForDomain:(NSErrorDomain)domain
                             code:(NSInteger)code
                      description:(NSString *)description
                       suggestion:(nullable NSString *)suggestion
                  underlyingError:(nullable NSError *)underlyingError;

#pragma mark - Configuration Error Factory Methods

/**
 * Creates an error for invalid configuration with specific validation details.
 */
+ (NSError *)invalidConfigurationErrorWithField:(NSString *)fieldName
                                         reason:(NSString *)reason
                                     suggestion:(NSString *)suggestion;

/**
 * Creates an error for invalid DPI value.
 */
+ (NSError *)invalidDPIErrorWithValue:(CGFloat)dpiValue;

/**
 * Creates an error for invalid concurrent pages value.
 */
+ (NSError *)invalidConcurrentPagesErrorWithValue:(NSInteger)pageCount;

/**
 * Creates an error for invalid heading level value.
 */
+ (NSError *)invalidHeadingLevelErrorWithValue:(NSInteger)headingLevel;

/**
 * Creates an error for invalid font size threshold.
 */
+ (NSError *)invalidFontSizeThresholdErrorWithValue:(CGFloat)threshold;

#pragma mark - File System Error Factory Methods

/**
 * Creates an error for invalid PDF input.
 */
+ (NSError *)invalidPDFErrorWithPath:(NSString *)path
                     underlyingError:(nullable NSError *)underlyingError;

/**
 * Creates an error for file not found.
 */
+ (NSError *)fileNotFoundErrorWithPath:(NSString *)path;

/**
 * Creates an error for invalid input parameters.
 */
+ (NSError *)invalidInputErrorWithReason:(NSString *)reason;

/**
 * Creates an error for asset folder creation failure.
 */
+ (NSError *)assetCreationErrorWithPath:(NSString *)path
                                 reason:(NSString *)reason;

/**
 * Creates a file system error with code, description, and suggestion.
 */
+ (NSError *)createFileSystemErrorWithCode:(NSInteger)code
                               description:(NSString *)description
                                suggestion:(NSString *)suggestion;

#pragma mark - Processing Error Factory Methods

/**
 * Creates an error for memory pressure.
 */
+ (NSError *)memoryPressureErrorWithContext:(NSString *)context;

/**
 * Creates an error for processing timeout.
 */
+ (NSError *)processingTimeoutErrorWithDuration:(NSTimeInterval)duration;

/**
 * Creates an error for encrypted PDF.
 */
+ (NSError *)encryptedPDFError;

/**
 * Creates an error for empty document.
 */
+ (NSError *)emptyDocumentError;

/**
 * Creates an error for page processing failure.
 */
+ (NSError *)pageProcessingFailedErrorForPage:(NSInteger)pageIndex 
                                       reason:(nullable NSString *)reason
                              underlyingError:(nullable NSError *)underlyingError;

/**
 * Creates an error for general processing failure.
 */
+ (NSError *)processingFailedErrorWithReason:(NSString *)reason 
                             underlyingError:(nullable NSError *)underlyingError;

/**
 * Creates an error for I/O failure.
 */
+ (NSError *)ioFailureErrorWithPath:(nullable NSString *)path 
                             reason:(NSString *)reason
                    underlyingError:(nullable NSError *)underlyingError;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf21md/shared-core/PDF21MDErrorFactory.m">
//
//  PDF21MDErrorFactory.m
//  pdf21md - Shared Components
//
//  Unified error creation factory for consistent error handling
//  across all implementations and components.
//

#import "PDF21MDErrorFactory.h"

// Import error constants from implementation-specific header
// This ensures we use the same error domain and codes consistently
extern NSErrorDomain const PDF21MDErrorDomain;

// Error codes - using constants to avoid redefinition
#define PDF21MDErrorInvalidConfiguration 1004
#define PDF21MDErrorInvalidPDF 1000
#define PDF21MDErrorFileNotFound 1012
#define PDF21MDErrorInvalidInput 1011
#define PDF21MDErrorAssetFolderCreation 1001
#define PDF21MDErrorMemoryPressure 1006
#define PDF21MDErrorProcessingTimeout 1008
#define PDF21MDErrorEncryptedPDF 1009
#define PDF21MDErrorEmptyDocument 1010
#define PDF21MDErrorPageProcessingFailed 1003
#define PDF21MDErrorProcessingFailed 1002
#define PDF21MDErrorIOFailure 1005

// Error keys
extern NSString * const PDF21MDErrorPageIndexKey;
extern NSString * const PDF21MDErrorFilePathKey;
extern NSString * const PDF21MDErrorUnderlyingErrorKey;

@implementation PDF21MDErrorFactory

#pragma mark - Core Factory Methods

+ (NSError *)createErrorForDomain:(NSErrorDomain)domain
                             code:(NSInteger)code
                      description:(NSString *)description
                       suggestion:(nullable NSString *)suggestion
                  underlyingError:(nullable NSError *)underlyingError {
    NSMutableDictionary *userInfo = [@{
        NSLocalizedDescriptionKey: description,
        NSLocalizedFailureReasonErrorKey: description
    } mutableCopy];
    
    if (suggestion) {
        userInfo[NSLocalizedRecoverySuggestionErrorKey] = suggestion;
    }
    
    if (underlyingError) {
        userInfo[NSUnderlyingErrorKey] = underlyingError;
        userInfo[PDF21MDErrorUnderlyingErrorKey] = underlyingError;
    }
    
    return [NSError errorWithDomain:domain
                               code:code
                           userInfo:userInfo];
}

#pragma mark - Configuration Error Factory Methods

+ (NSError *)invalidConfigurationErrorWithField:(NSString *)fieldName
                                         reason:(NSString *)reason
                                     suggestion:(NSString *)suggestion {
    NSString *description = [NSString stringWithFormat:@"Invalid %@: %@", fieldName, reason];
    
    return [self createErrorForDomain:PDF21MDErrorDomain
                                 code:PDF21MDErrorInvalidConfiguration
                          description:description
                           suggestion:suggestion
                      underlyingError:nil];
}

+ (NSError *)invalidDPIErrorWithValue:(CGFloat)dpiValue {
    NSString *reason = [NSString stringWithFormat:@"DPI value %.1f is invalid", dpiValue];
    NSString *suggestion = @"DPI must be between 1 and 600";
    
    return [self invalidConfigurationErrorWithField:@"rasterization DPI"
                                              reason:reason
                                          suggestion:suggestion];
}

+ (NSError *)invalidConcurrentPagesErrorWithValue:(NSInteger)pageCount {
    NSString *reason = [NSString stringWithFormat:@"concurrent pages value %ld is invalid", (long)pageCount];
    NSString *suggestion = @"Value must be between 1 and 64";
    
    return [self invalidConfigurationErrorWithField:@"max concurrent pages"
                                              reason:reason
                                          suggestion:suggestion];
}

+ (NSError *)invalidHeadingLevelErrorWithValue:(NSInteger)headingLevel {
    NSString *reason = [NSString stringWithFormat:@"heading level %ld is invalid", (long)headingLevel];
    NSString *suggestion = @"Heading level must be between 1 and 6";
    
    return [self invalidConfigurationErrorWithField:@"max heading level"
                                              reason:reason
                                          suggestion:suggestion];
}

+ (NSError *)invalidFontSizeThresholdErrorWithValue:(CGFloat)threshold {
    NSString *reason = [NSString stringWithFormat:@"font size threshold %.1f is invalid", threshold];
    NSString *suggestion = @"Threshold must be between 0.5 and 10.0 points";
    
    return [self invalidConfigurationErrorWithField:@"heading font size threshold"
                                              reason:reason
                                          suggestion:suggestion];
}

#pragma mark - File System Error Factory Methods

+ (NSError *)invalidPDFErrorWithPath:(NSString *)path
                     underlyingError:(nullable NSError *)underlyingError {
    NSString *description = [NSString stringWithFormat:@"The PDF file appears to be corrupted or invalid: %@", path];
    NSString *suggestion = @"Ensure the file is a valid PDF document. Try opening it in another PDF viewer to verify it's not corrupted.";
    
    NSError *error = [self createErrorForDomain:PDF21MDErrorDomain
                                           code:PDF21MDErrorInvalidPDF
                                    description:description
                                     suggestion:suggestion
                                underlyingError:underlyingError];
    
    NSMutableDictionary *userInfo = [error.userInfo mutableCopy];
    userInfo[PDF21MDErrorFilePathKey] = path;
    
    return [NSError errorWithDomain:PDF21MDErrorDomain
                               code:PDF21MDErrorInvalidPDF
                           userInfo:userInfo];
}

+ (NSError *)fileNotFoundErrorWithPath:(NSString *)path {
    NSString *description = [NSString stringWithFormat:@"File not found: %@", path];
    NSString *suggestion = @"Check that the file path is correct and the file exists.";
    
    NSError *error = [self createErrorForDomain:PDF21MDErrorDomain
                                           code:PDF21MDErrorFileNotFound
                                    description:description
                                     suggestion:suggestion
                                underlyingError:nil];
    
    NSMutableDictionary *userInfo = [error.userInfo mutableCopy];
    userInfo[PDF21MDErrorFilePathKey] = path;
    
    return [NSError errorWithDomain:PDF21MDErrorDomain
                               code:PDF21MDErrorFileNotFound
                           userInfo:userInfo];
}

+ (NSError *)invalidInputErrorWithReason:(NSString *)reason {
    NSString *description = [NSString stringWithFormat:@"Invalid input: %@", reason];
    NSString *suggestion = @"Check the command line arguments and ensure all required parameters are provided correctly.";
    
    return [self createErrorForDomain:PDF21MDErrorDomain
                                 code:PDF21MDErrorInvalidInput
                          description:description
                           suggestion:suggestion
                      underlyingError:nil];
}

+ (NSError *)assetCreationErrorWithPath:(NSString *)path
                                 reason:(NSString *)reason {
    NSString *description = [NSString stringWithFormat:@"Could not create assets folder at %@: %@", path, reason];
    NSString *suggestion = @"Ensure you have write permissions to the target directory and sufficient disk space.";
    
    NSError *error = [self createErrorForDomain:PDF21MDErrorDomain
                                           code:PDF21MDErrorAssetFolderCreation
                                    description:description
                                     suggestion:suggestion
                                underlyingError:nil];
    
    NSMutableDictionary *userInfo = [error.userInfo mutableCopy];
    userInfo[PDF21MDErrorFilePathKey] = path;
    
    return [NSError errorWithDomain:PDF21MDErrorDomain
                               code:PDF21MDErrorAssetFolderCreation
                           userInfo:userInfo];
}

+ (NSError *)createFileSystemErrorWithCode:(NSInteger)code
                               description:(NSString *)description
                                suggestion:(NSString *)suggestion {
    return [self createErrorForDomain:PDF21MDErrorDomain
                                 code:code
                          description:description
                           suggestion:suggestion
                      underlyingError:nil];
}

#pragma mark - Processing Error Factory Methods

+ (NSError *)memoryPressureErrorWithContext:(NSString *)context {
    NSString *description = [NSString stringWithFormat:@"Insufficient memory to process PDF during %@", context];
    NSString *suggestion = @"Try processing a smaller PDF or close other applications to free up memory. For very large documents, consider splitting them into smaller files.";
    
    return [self createErrorForDomain:PDF21MDErrorDomain
                                 code:PDF21MDErrorMemoryPressure
                          description:description
                           suggestion:suggestion
                      underlyingError:nil];
}

+ (NSError *)processingTimeoutErrorWithDuration:(NSTimeInterval)duration {
    NSString *description = [NSString stringWithFormat:@"PDF processing timed out after %.1f seconds (document too complex)", duration];
    NSString *suggestion = @"The PDF may be extremely large or complex. Try processing smaller sections or contact support if this persists.";
    
    return [self createErrorForDomain:PDF21MDErrorDomain
                                 code:PDF21MDErrorProcessingTimeout
                          description:description
                           suggestion:suggestion
                      underlyingError:nil];
}

+ (NSError *)encryptedPDFError {
    NSString *description = @"Password-protected PDFs are not currently supported";
    NSString *suggestion = @"Please remove the password protection from the PDF using another tool before conversion.";
    
    return [self createErrorForDomain:PDF21MDErrorDomain
                                 code:PDF21MDErrorEncryptedPDF
                          description:description
                           suggestion:suggestion
                      underlyingError:nil];
}

+ (NSError *)emptyDocumentError {
    NSString *description = @"The PDF contains no readable content";
    NSString *suggestion = @"The PDF may be empty, contain only images without text, or have text in an unsupported format.";
    
    return [self createErrorForDomain:PDF21MDErrorDomain
                                 code:PDF21MDErrorEmptyDocument
                          description:description
                           suggestion:suggestion
                      underlyingError:nil];
}

+ (NSError *)pageProcessingFailedErrorForPage:(NSInteger)pageIndex 
                                       reason:(nullable NSString *)reason
                              underlyingError:(nullable NSError *)underlyingError {
    NSString *description = [NSString stringWithFormat:@"Failed to process page %ld", (long)(pageIndex + 1)];
    NSString *failureReason = reason ?: @"An error occurred while extracting content from the page";
    
    NSMutableDictionary *userInfo = [@{
        NSLocalizedDescriptionKey: description,
        NSLocalizedFailureReasonErrorKey: failureReason,
        NSLocalizedRecoverySuggestionErrorKey: @"The page may contain unsupported content or be corrupted",
        PDF21MDErrorPageIndexKey: @(pageIndex)
    } mutableCopy];
    
    if (underlyingError) {
        userInfo[NSUnderlyingErrorKey] = underlyingError;
        userInfo[PDF21MDErrorUnderlyingErrorKey] = underlyingError;
    }
    
    return [NSError errorWithDomain:PDF21MDErrorDomain
                               code:PDF21MDErrorPageProcessingFailed
                           userInfo:userInfo];
}

+ (NSError *)processingFailedErrorWithReason:(NSString *)reason 
                             underlyingError:(nullable NSError *)underlyingError {
    NSString *description = @"PDF processing failed";
    
    NSMutableDictionary *userInfo = [@{
        NSLocalizedDescriptionKey: description,
        NSLocalizedFailureReasonErrorKey: reason,
        NSLocalizedRecoverySuggestionErrorKey: @"Check the input file and try again"
    } mutableCopy];
    
    if (underlyingError) {
        userInfo[NSUnderlyingErrorKey] = underlyingError;
        userInfo[PDF21MDErrorUnderlyingErrorKey] = underlyingError;
    }
    
    return [NSError errorWithDomain:PDF21MDErrorDomain
                               code:PDF21MDErrorProcessingFailed
                           userInfo:userInfo];
}

+ (NSError *)ioFailureErrorWithPath:(nullable NSString *)path 
                             reason:(NSString *)reason
                    underlyingError:(nullable NSError *)underlyingError {
    NSString *description = @"File I/O operation failed";
    
    NSMutableDictionary *userInfo = [@{
        NSLocalizedDescriptionKey: description,
        NSLocalizedFailureReasonErrorKey: reason,
        NSLocalizedRecoverySuggestionErrorKey: @"Check file permissions and available disk space"
    } mutableCopy];
    
    if (path) {
        userInfo[PDF21MDErrorFilePathKey] = path;
    }
    
    if (underlyingError) {
        userInfo[NSUnderlyingErrorKey] = underlyingError;
        userInfo[PDF21MDErrorUnderlyingErrorKey] = underlyingError;
    }
    
    return [NSError errorWithDomain:PDF21MDErrorDomain
                               code:PDF21MDErrorIOFailure
                           userInfo:userInfo];
}

@end
</file>

<file path="pdf21md/shared-core/PDF21MDFileSystemUtils.h">
#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

@interface PDF21MDFileSystemUtils : NSObject

#pragma mark - Directory Operations

+ (BOOL)createDirectoryAtPath:(NSString *)path error:(NSError *_Nullable *_Nullable)error;
+ (BOOL)directoryExistsAtPath:(NSString *)path;
+ (BOOL)ensureDirectoryExists:(NSString *)path error:(NSError *_Nullable *_Nullable)error;

#pragma mark - File Operations

+ (BOOL)fileExistsAtPath:(NSString *)path;
+ (BOOL)removeItemAtPath:(NSString *)path error:(NSError *_Nullable *_Nullable)error;
+ (NSString *)temporaryDirectoryPath;
+ (NSString *)documentsDirectoryPath;

#pragma mark - Path Utilities

+ (NSString *)sanitizeFileName:(NSString *)fileName;
+ (NSString *)uniqueFilePathForBaseName:(NSString *)baseName
                              extension:(NSString *)extension
                            inDirectory:(NSString *)directory;
+ (NSString *)pathByAppendingUniqueIdentifier:(NSString *)basePath;

#pragma mark - Validation

+ (BOOL)isValidFilePath:(NSString *)path error:(NSError *_Nullable *_Nullable)error;
+ (BOOL)hasWritePermissionForDirectory:(NSString *)path error:(NSError *_Nullable *_Nullable)error;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf21md/shared-core/PDF21MDFileSystemUtils.m">
#import "PDF21MDFileSystemUtils.h"
#import "PDF21MDErrorFactory.h"
#import "../src/Core/PDF21MDError.h"

@implementation PDF21MDFileSystemUtils

#pragma mark - Directory Operations

+ (BOOL)createDirectoryAtPath:(NSString *)path error:(NSError **)error {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    if ([fileManager fileExistsAtPath:path]) {
        return YES;
    }
    
    return [fileManager createDirectoryAtPath:path
                  withIntermediateDirectories:YES
                                   attributes:nil
                                        error:error];
}

+ (BOOL)directoryExistsAtPath:(NSString *)path {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    BOOL isDirectory;
    BOOL exists = [fileManager fileExistsAtPath:path isDirectory:&isDirectory];
    return exists && isDirectory;
}

+ (BOOL)ensureDirectoryExists:(NSString *)path error:(NSError **)error {
    if ([self directoryExistsAtPath:path]) {
        return YES;
    }
    
    return [self createDirectoryAtPath:path error:error];
}

#pragma mark - File Operations

+ (BOOL)fileExistsAtPath:(NSString *)path {
    return [[NSFileManager defaultManager] fileExistsAtPath:path];
}

+ (BOOL)removeItemAtPath:(NSString *)path error:(NSError **)error {
    if (![self fileExistsAtPath:path]) {
        return YES;
    }
    
    return [[NSFileManager defaultManager] removeItemAtPath:path error:error];
}

+ (NSString *)temporaryDirectoryPath {
    return NSTemporaryDirectory();
}

+ (NSString *)documentsDirectoryPath {
    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    return paths.firstObject ?: NSTemporaryDirectory();
}

#pragma mark - Path Utilities

+ (NSString *)sanitizeFileName:(NSString *)fileName {
    if (!fileName || fileName.length == 0) {
        return @"untitled";
    }
    
    NSCharacterSet *illegalCharacters = [NSCharacterSet characterSetWithCharactersInString:@"/:*?\"<>|\\"];
    NSString *sanitized = [[fileName componentsSeparatedByCharactersInSet:illegalCharacters] componentsJoinedByString:@"-"];
    
    sanitized = [sanitized stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    
    if (sanitized.length == 0) {
        return @"untitled";
    }
    
    if (sanitized.length > 255) {
        sanitized = [sanitized substringToIndex:255];
    }
    
    return sanitized;
}

+ (NSString *)uniqueFilePathForBaseName:(NSString *)baseName
                              extension:(NSString *)extension
                            inDirectory:(NSString *)directory {
    if (!baseName || !extension || !directory) {
        return nil;
    }
    
    NSString *sanitizedBaseName = [self sanitizeFileName:baseName];
    NSString *fileName = [NSString stringWithFormat:@"%@.%@", sanitizedBaseName, extension];
    NSString *filePath = [directory stringByAppendingPathComponent:fileName];
    
    if (![self fileExistsAtPath:filePath]) {
        return filePath;
    }
    
    NSInteger counter = 1;
    while (counter < 1000) {
        fileName = [NSString stringWithFormat:@"%@_%ld.%@", sanitizedBaseName, (long)counter, extension];
        filePath = [directory stringByAppendingPathComponent:fileName];
        
        if (![self fileExistsAtPath:filePath]) {
            return filePath;
        }
        
        counter++;
    }
    
    return nil;
}

+ (NSString *)pathByAppendingUniqueIdentifier:(NSString *)basePath {
    if (!basePath) {
        return nil;
    }
    
    if (![self fileExistsAtPath:basePath]) {
        return basePath;
    }
    
    NSString *directory = [basePath stringByDeletingLastPathComponent];
    NSString *fileName = [basePath lastPathComponent];
    NSString *extension = [fileName pathExtension];
    NSString *baseName = [fileName stringByDeletingPathExtension];
    
    return [self uniqueFilePathForBaseName:baseName extension:extension inDirectory:directory];
}

#pragma mark - Validation

+ (BOOL)isValidFilePath:(NSString *)path error:(NSError **)error {
    if (!path || path.length == 0) {
        if (error) {
            *error = [PDF21MDErrorFactory createFileSystemErrorWithCode:PDF21MDErrorInvalidPath
                                                            description:@"Path cannot be nil or empty"
                                                             suggestion:@"Provide a valid file path"];
        }
        return NO;
    }
    
    if (path.length > 4096) {
        if (error) {
            *error = [PDF21MDErrorFactory createFileSystemErrorWithCode:PDF21MDErrorInvalidPath
                                                            description:@"Path exceeds maximum length"
                                                             suggestion:@"Use a shorter file path"];
        }
        return NO;
    }
    
    NSCharacterSet *illegalCharacters = [NSCharacterSet characterSetWithCharactersInString:@"*?\"<>|"];
    if ([path rangeOfCharacterFromSet:illegalCharacters].location != NSNotFound) {
        if (error) {
            *error = [PDF21MDErrorFactory createFileSystemErrorWithCode:PDF21MDErrorInvalidPath
                                                            description:@"Path contains illegal characters"
                                                             suggestion:@"Remove characters: *?\"<>|"];
        }
        return NO;
    }
    
    return YES;
}

+ (BOOL)hasWritePermissionForDirectory:(NSString *)path error:(NSError **)error {
    if (![self directoryExistsAtPath:path]) {
        if (error) {
            *error = [PDF21MDErrorFactory createFileSystemErrorWithCode:PDF21MDErrorDirectoryNotFound
                                                            description:[NSString stringWithFormat:@"Directory does not exist: %@", path]
                                                             suggestion:@"Create the directory first or choose an existing one"];
        }
        return NO;
    }
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    if (![fileManager isWritableFileAtPath:path]) {
        if (error) {
            *error = [PDF21MDErrorFactory createFileSystemErrorWithCode:PDF21MDErrorPermissionDenied
                                                            description:[NSString stringWithFormat:@"No write permission for directory: %@", path]
                                                             suggestion:@"Check directory permissions or choose a different location"];
        }
        return NO;
    }
    
    return YES;
}

@end
</file>

<file path="pdf21md/src/CLI/pdf21md-benchmark.m">
//
//  pdf21md-benchmark.m
//  pdf21md Performance Benchmarking Tool
//
//  Comprehensive performance validation and benchmarking for pdf21md
//

#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>
#import <mach/mach.h>
#import <mach/mach_time.h>
#import "../Core/PDF21MDConverter.h"
#import "../Core/PDF21MDConversionOptions.h"
#import "../Core/PDF21MDError.h"

#ifndef VERSION
#define VERSION "1.0.0"
#endif

// ANSI color codes for output
#define COLOR_RESET   "\033[0m"
#define COLOR_RED     "\033[31m"
#define COLOR_GREEN   "\033[32m"
#define COLOR_YELLOW  "\033[33m"
#define COLOR_BLUE    "\033[34m"
#define COLOR_MAGENTA "\033[35m"
#define COLOR_CYAN    "\033[36m"

typedef struct {
    NSTimeInterval totalTime;
    NSTimeInterval conversionTime;
    NSTimeInterval markdownTime;
    NSTimeInterval assetTime;
    NSUInteger pageCount;
    NSUInteger imageCount;
    NSUInteger fileSize;
    NSUInteger outputSize;
    NSUInteger peakMemory;
    double pagesPerSecond;
    double mbPerSecond;
} BenchmarkResult;

@interface PDF21MDBenchmark : NSObject

@property (nonatomic, strong) NSMutableArray<NSValue *> *results;
@property (nonatomic, strong) NSString *corpusPath;
@property (nonatomic, strong) NSString *outputPath;
@property (nonatomic, assign) BOOL verbose;
@property (nonatomic, assign) BOOL compareMode;
@property (nonatomic, assign) BOOL memoryProfile;
@property (nonatomic, assign) NSInteger iterations;

- (void)runBenchmarks;
- (void)printResults;
- (void)saveResultsToJSON:(NSString *)path;
- (BenchmarkResult)benchmarkPDF:(NSString *)pdfPath;
- (NSUInteger)getCurrentMemoryUsage;
- (void)compareWithBaseline:(NSString *)baselinePath;

@end

@implementation PDF21MDBenchmark

- (instancetype)init {
    self = [super init];
    if (self) {
        _results = [NSMutableArray array];
        _iterations = 1;
        _verbose = NO;
        _compareMode = NO;
        _memoryProfile = NO;
    }
    return self;
}

- (void)runBenchmarks {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSArray<NSString *> *pdfFiles = nil;
    
    if (self.corpusPath) {
        BOOL isDirectory;
        if ([fileManager fileExistsAtPath:self.corpusPath isDirectory:&isDirectory]) {
            if (isDirectory) {
                // Benchmark all PDFs in corpus directory
                NSError *error = nil;
                NSArray *files = [fileManager contentsOfDirectoryAtPath:self.corpusPath error:&error];
                if (error) {
                    fprintf(stderr, "%sError reading corpus directory: %s%s\n", 
                            COLOR_RED, error.localizedDescription.UTF8String, COLOR_RESET);
                    return;
                }
                
                NSPredicate *pdfPredicate = [NSPredicate predicateWithFormat:@"SELF ENDSWITH '.pdf'"];
                pdfFiles = [[files filteredArrayUsingPredicate:pdfPredicate] 
                            sortedArrayUsingSelector:@selector(localizedStandardCompare:)];
                
                printf("%süìä Benchmarking %lu PDFs from corpus%s\n", 
                       COLOR_CYAN, (unsigned long)pdfFiles.count, COLOR_RESET);
            } else {
                // Single file provided via corpus path
                pdfFiles = @[[self.corpusPath lastPathComponent]];
                self.corpusPath = [self.corpusPath stringByDeletingLastPathComponent];
                if (self.corpusPath.length == 0) {
                    self.corpusPath = @".";
                }
            }
        } else {
            fprintf(stderr, "%sError: Path not found: %s%s\n", 
                    COLOR_RED, self.corpusPath.UTF8String, COLOR_RESET);
            return;
        }
    } else {
        // Single file benchmark
        pdfFiles = @[@"test.pdf"];
    }
    
    printf("%s‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê%s\n",
           COLOR_BLUE, COLOR_RESET);
    
    for (NSString *pdfFile in pdfFiles) {
        NSString *fullPath = self.corpusPath ? 
            [self.corpusPath stringByAppendingPathComponent:pdfFile] : pdfFile;
        
        if (![fileManager fileExistsAtPath:fullPath]) {
            fprintf(stderr, "%s‚ö†Ô∏è  Skipping non-existent file: %s%s\n", 
                    COLOR_YELLOW, fullPath.UTF8String, COLOR_RESET);
            continue;
        }
        
        printf("\n%sBenchmarking: %s%s\n", COLOR_MAGENTA, pdfFile.UTF8String, COLOR_RESET);
        
        // Run multiple iterations for averaging
        BenchmarkResult avgResult = {0};
        NSMutableArray *iterationResults = [NSMutableArray array];
        
        for (NSInteger i = 0; i < self.iterations; i++) {
            if (self.iterations > 1) {
                printf("  Iteration %ld/%ld...\n", (long)(i + 1), (long)self.iterations);
            }
            
            BenchmarkResult result = [self benchmarkPDF:fullPath];
            [iterationResults addObject:[NSValue valueWithBytes:&result 
                                                        objCType:@encode(BenchmarkResult)]];
            
            // Accumulate for averaging
            avgResult.totalTime += result.totalTime;
            avgResult.conversionTime += result.conversionTime;
            avgResult.markdownTime += result.markdownTime;
            avgResult.assetTime += result.assetTime;
            avgResult.pageCount = result.pageCount;
            avgResult.imageCount = result.imageCount;
            avgResult.fileSize = result.fileSize;
            avgResult.outputSize += result.outputSize;
            avgResult.peakMemory = MAX(avgResult.peakMemory, result.peakMemory);
            
            // Cool down between iterations
            if (i < self.iterations - 1) {
                [NSThread sleepForTimeInterval:0.5];
            }
        }
        
        // Calculate averages
        avgResult.totalTime /= self.iterations;
        avgResult.conversionTime /= self.iterations;
        avgResult.markdownTime /= self.iterations;
        avgResult.assetTime /= self.iterations;
        avgResult.outputSize /= self.iterations;
        avgResult.pagesPerSecond = avgResult.pageCount / avgResult.totalTime;
        avgResult.mbPerSecond = (avgResult.fileSize / 1024.0 / 1024.0) / avgResult.totalTime;
        
        [self.results addObject:[NSValue valueWithBytes:&avgResult 
                                              objCType:@encode(BenchmarkResult)]];
        
        // Print immediate results
        [self printResult:avgResult forFile:pdfFile];
    }
    
    printf("%s‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê%s\n\n",
           COLOR_BLUE, COLOR_RESET);
}

- (BenchmarkResult)benchmarkPDF:(NSString *)pdfPath {
    BenchmarkResult result = {0};
    
    // Get file size
    NSError *error = nil;
    NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:pdfPath error:&error];
    result.fileSize = [attrs[NSFileSize] unsignedIntegerValue];
    
    // Memory baseline
    NSUInteger memStart = [self getCurrentMemoryUsage];
    
    // Start total timing
    NSDate *startTime = [NSDate date];
    mach_timebase_info_data_t timebase;
    mach_timebase_info(&timebase);
    
    // Load PDF
    if (self.verbose) {
        printf("  Loading PDF from: %s\n", pdfPath.UTF8String);
    }
    
    NSURL *pdfURL = [NSURL fileURLWithPath:pdfPath];
    PDF21MDConverter *converter = [[PDF21MDConverter alloc] initWithPDFURL:pdfURL];
    
    if (!converter) {
        fprintf(stderr, "%sError: Failed to load PDF from %s%s\n", COLOR_RED, pdfPath.UTF8String, COLOR_RESET);
        return result;
    }
    
    result.pageCount = converter.document.pageCount;
    
    // Configure options using builder
    PDF21MDConversionOptionsBuilder *builder = [[PDF21MDConversionOptionsBuilder alloc] init];
    if (self.outputPath) {
        NSString *assetDir = [[self.outputPath stringByDeletingLastPathComponent] 
                              stringByAppendingPathComponent:@"benchmark-assets"];
        builder.assetsFolderPath = assetDir;
        builder.extractImages = YES;
    }
    builder.rasterizationDPI = 144.0;
    
    PDF21MDConversionOptions *options = [builder build];
    
    // Conversion timing
    uint64_t convStart = mach_absolute_time();
    __block NSString *markdown = nil;
    __block NSError *convError = nil;
    
    if (self.verbose) {
        printf("  Starting conversion with %lu pages...\n", (unsigned long)result.pageCount);
    }
    
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
    
    [converter convertWithOptions:options completion:^(NSString *output, NSError *error) {
        if (self.verbose) {
            if (error) {
                printf("  Conversion completed with error: %s\n", error.localizedDescription.UTF8String);
            } else {
                printf("  Conversion completed successfully, output length: %lu\n", (unsigned long)output.length);
            }
        }
        markdown = output;
        convError = error;
        dispatch_semaphore_signal(semaphore);
    }];
    
    // Wait with timeout
    dispatch_time_t timeout = dispatch_time(DISPATCH_TIME_NOW, 30 * NSEC_PER_SEC);
    if (dispatch_semaphore_wait(semaphore, timeout) != 0) {
        fprintf(stderr, "%sError: Conversion timed out after 30 seconds%s\n", COLOR_RED, COLOR_RESET);
        return result;
    }
    
    uint64_t convEnd = mach_absolute_time();
    
    // Calculate times
    result.conversionTime = (double)(convEnd - convStart) * timebase.numer / timebase.denom / 1e9;
    
    if (convError) {
        fprintf(stderr, "%sConversion error: %s%s\n", 
                COLOR_RED, convError.localizedDescription.UTF8String, COLOR_RESET);
        return result;
    }
    
    // Output size
    result.outputSize = [markdown lengthOfBytesUsingEncoding:NSUTF8StringEncoding];
    
    // Peak memory
    result.peakMemory = [self getCurrentMemoryUsage] - memStart;
    
    // Total time
    result.totalTime = -[startTime timeIntervalSinceNow];
    result.pagesPerSecond = result.pageCount / result.totalTime;
    result.mbPerSecond = (result.fileSize / 1024.0 / 1024.0) / result.totalTime;
    
    // Count images if assets were extracted
    if (options.assetsFolderPath) {
        NSArray *assets = [[NSFileManager defaultManager] 
                           contentsOfDirectoryAtPath:options.assetsFolderPath error:nil];
        result.imageCount = assets.count;
    }
    
    // Save output if requested
    if (self.outputPath && markdown) {
        [markdown writeToFile:self.outputPath 
                   atomically:YES 
                     encoding:NSUTF8StringEncoding 
                        error:nil];
    }
    
    return result;
}

- (void)printResult:(BenchmarkResult)result forFile:(NSString *)filename {
    printf("\n%süìÑ %s%s\n", COLOR_GREEN, filename.UTF8String, COLOR_RESET);
    printf("  Pages:        %lu\n", (unsigned long)result.pageCount);
    printf("  File size:    %.2f MB\n", result.fileSize / 1024.0 / 1024.0);
    printf("  Output size:  %.2f KB\n", result.outputSize / 1024.0);
    printf("  Images:       %lu\n", (unsigned long)result.imageCount);
    printf("\n");
    printf("  %s‚è±  Performance:%s\n", COLOR_CYAN, COLOR_RESET);
    printf("  Total time:   %.3f seconds\n", result.totalTime);
    printf("  Conversion:   %.3f seconds (%.1f%%)\n", 
           result.conversionTime, (result.conversionTime / result.totalTime) * 100);
    printf("  Pages/sec:    %.1f\n", result.pagesPerSecond);
    printf("  MB/sec:       %.2f\n", result.mbPerSecond);
    
    if (result.peakMemory > 0) {
        printf("\n  %süíæ Memory:%s\n", COLOR_CYAN, COLOR_RESET);
        printf("  Peak usage:   %.1f MB\n", result.peakMemory / 1024.0 / 1024.0);
    }
}

- (NSUInteger)getCurrentMemoryUsage {
    struct task_basic_info info;
    mach_msg_type_number_t size = TASK_BASIC_INFO_COUNT;
    kern_return_t kerr = task_info(mach_task_self(),
                                   TASK_BASIC_INFO,
                                   (task_info_t)&info,
                                   &size);
    return (kerr == KERN_SUCCESS) ? info.resident_size : 0;
}

- (void)printResults {
    if (self.results.count == 0) return;
    
    printf("\n%süìä BENCHMARK SUMMARY%s\n", COLOR_CYAN, COLOR_RESET);
    printf("%s‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê%s\n",
           COLOR_BLUE, COLOR_RESET);
    
    // Calculate aggregates
    double totalPages = 0;
    double totalTime = 0;
    double totalSize = 0;
    double avgPagesPerSec = 0;
    double avgMBPerSec = 0;
    NSUInteger maxMemory = 0;
    
    for (NSValue *value in self.results) {
        BenchmarkResult result;
        [value getValue:&result];
        
        totalPages += result.pageCount;
        totalTime += result.totalTime;
        totalSize += result.fileSize;
        avgPagesPerSec += result.pagesPerSecond;
        avgMBPerSec += result.mbPerSecond;
        maxMemory = MAX(maxMemory, result.peakMemory);
    }
    
    NSUInteger count = self.results.count;
    avgPagesPerSec /= count;
    avgMBPerSec /= count;
    
    printf("\n%sDocuments processed: %lu%s\n", COLOR_GREEN, (unsigned long)count, COLOR_RESET);
    printf("Total pages:         %.0f\n", totalPages);
    printf("Total size:          %.1f MB\n", totalSize / 1024.0 / 1024.0);
    printf("Total time:          %.2f seconds\n", totalTime);
    printf("\n");
    printf("%sAverage performance:%s\n", COLOR_MAGENTA, COLOR_RESET);
    printf("Pages per second:    %.1f\n", avgPagesPerSec);
    printf("MB per second:       %.2f\n", avgMBPerSec);
    printf("Peak memory usage:   %.1f MB\n", maxMemory / 1024.0 / 1024.0);
    
    // Performance rating
    printf("\n%sPerformance Rating: ", COLOR_YELLOW);
    if (avgPagesPerSec >= 50) {
        printf("‚ö°Ô∏è BLAZINGLY FAST");
    } else if (avgPagesPerSec >= 20) {
        printf("üöÄ VERY FAST");
    } else if (avgPagesPerSec >= 10) {
        printf("‚úÖ FAST");
    } else if (avgPagesPerSec >= 5) {
        printf("üëç GOOD");
    } else {
        printf("üêå NEEDS OPTIMIZATION");
    }
    printf("%s\n\n", COLOR_RESET);
}

- (void)saveResultsToJSON:(NSString *)path {
    NSMutableDictionary *output = [NSMutableDictionary dictionary];
    output[@"timestamp"] = [NSDate date];
    output[@"version"] = @(VERSION);
    output[@"platform"] = @{
        @"os": [[NSProcessInfo processInfo] operatingSystemVersionString],
        @"processors": @([[NSProcessInfo processInfo] processorCount]),
        @"memory": @([[NSProcessInfo processInfo] physicalMemory])
    };
    
    NSMutableArray *results = [NSMutableArray array];
    for (NSValue *value in self.results) {
        BenchmarkResult result;
        [value getValue:&result];
        
        [results addObject:@{
            @"pageCount": @(result.pageCount),
            @"fileSize": @(result.fileSize),
            @"outputSize": @(result.outputSize),
            @"imageCount": @(result.imageCount),
            @"totalTime": @(result.totalTime),
            @"conversionTime": @(result.conversionTime),
            @"pagesPerSecond": @(result.pagesPerSecond),
            @"mbPerSecond": @(result.mbPerSecond),
            @"peakMemory": @(result.peakMemory)
        }];
    }
    
    output[@"results"] = results;
    
    NSError *error = nil;
    NSData *jsonData = [NSJSONSerialization dataWithJSONObject:output 
                                                       options:NSJSONWritingPrettyPrinted 
                                                         error:&error];
    if (!error) {
        [jsonData writeToFile:path atomically:YES];
        printf("%sSaved results to: %s%s\n", COLOR_GREEN, path.UTF8String, COLOR_RESET);
    } else {
        fprintf(stderr, "%sError saving results: %s%s\n", 
                COLOR_RED, error.localizedDescription.UTF8String, COLOR_RESET);
    }
}

- (void)compareWithBaseline:(NSString *)baselinePath {
    // Implementation for comparing with baseline results
    printf("%sComparison with baseline not yet implemented%s\n", COLOR_YELLOW, COLOR_RESET);
}

@end

// Main function
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        PDF21MDBenchmark *benchmark = [[PDF21MDBenchmark alloc] init];
        
        // Parse command line arguments
        NSString *corpusPath = nil;
        NSString *outputPath = nil;
        NSString *jsonPath = nil;
        NSString *comparePath = nil;
        
        for (int i = 1; i < argc; i++) {
            NSString *arg = [NSString stringWithUTF8String:argv[i]];
            
            if ([arg isEqualToString:@"--corpus"] && i + 1 < argc) {
                corpusPath = [NSString stringWithUTF8String:argv[++i]];
                benchmark.corpusPath = corpusPath;
            } else if ([arg isEqualToString:@"--output"] && i + 1 < argc) {
                outputPath = [NSString stringWithUTF8String:argv[++i]];
                benchmark.outputPath = outputPath;
            } else if ([arg isEqualToString:@"--json"] && i + 1 < argc) {
                jsonPath = [NSString stringWithUTF8String:argv[++i]];
            } else if ([arg isEqualToString:@"--compare"] && i + 1 < argc) {
                comparePath = [NSString stringWithUTF8String:argv[++i]];
                benchmark.compareMode = YES;
            } else if ([arg isEqualToString:@"--iterations"] && i + 1 < argc) {
                benchmark.iterations = atoi(argv[++i]);
            } else if ([arg isEqualToString:@"--memory-profile"]) {
                benchmark.memoryProfile = YES;
            } else if ([arg isEqualToString:@"--verbose"]) {
                benchmark.verbose = YES;
            } else if ([arg isEqualToString:@"--help"]) {
                printf("pdf21md-benchmark - Performance benchmarking tool for pdf21md\n\n");
                printf("Usage: pdf21md-benchmark [OPTIONS] [PDF_FILE]\n\n");
                printf("Options:\n");
                printf("  --corpus PATH         Benchmark all PDFs in directory\n");
                printf("  --output PATH         Save converted markdown output\n");
                printf("  --json PATH          Save results to JSON file\n");
                printf("  --compare PATH       Compare with baseline JSON\n");
                printf("  --iterations N       Number of iterations (default: 1)\n");
                printf("  --memory-profile     Enable detailed memory profiling\n");
                printf("  --verbose            Verbose output\n");
                printf("  --help               Show this help\n\n");
                printf("Examples:\n");
                printf("  pdf21md-benchmark test.pdf\n");
                printf("  pdf21md-benchmark --corpus ./test-pdfs/ --json results.json\n");
                printf("  pdf21md-benchmark --compare baseline.json current.json\n");
                return 0;
            } else if (!corpusPath && ![arg hasPrefix:@"-"]) {
                // Argument is the PDF file
                corpusPath = arg;
            }
        }
        
        if (!corpusPath && !comparePath) {
            fprintf(stderr, "Error: Please specify a PDF file or use --corpus\n");
            fprintf(stderr, "Use --help for usage information\n");
            return 1;
        }
        
        // Set corpus path if single file provided
        if (corpusPath && !benchmark.corpusPath) {
            benchmark.corpusPath = corpusPath;
        }
        
        printf("%süöÄ pdf21md Performance Benchmark v%s%s\n", COLOR_CYAN, VERSION, COLOR_RESET);
        printf("%s‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê%s\n",
               COLOR_BLUE, COLOR_RESET);
        
        if (comparePath) {
            [benchmark compareWithBaseline:comparePath];
        } else {
            [benchmark runBenchmarks];
            [benchmark printResults];
            
            if (jsonPath) {
                [benchmark saveResultsToJSON:jsonPath];
            }
        }
        
        return 0;
    }
}
</file>

<file path="pdf21md/src/Core/PDF21MDConversionOptions.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

/**
 * Configuration options for PDF to Markdown conversion.
 * This class uses the builder pattern for convenient configuration.
 */
@interface PDF21MDConversionOptions : NSObject <NSCopying>

/**
 * Path to the folder where extracted assets (images) should be saved.
 * If nil, images will not be extracted.
 */
@property (nonatomic, copy, nullable) NSString *assetsFolderPath;

/**
 * DPI for rasterizing vector graphics.
 * Default is 144.0
 */
@property (nonatomic, assign) CGFloat rasterizationDPI;

/**
 * Maximum number of concurrent page processing operations.
 * Default is NSProcessInfo.processInfo.processorCount
 */
@property (nonatomic, assign) NSInteger maxConcurrentPages;

/**
 * Whether to include YAML frontmatter with metadata.
 * Default is YES
 */
@property (nonatomic, assign) BOOL includeMetadata;

/**
 * Whether to extract images from the PDF.
 * Default is YES (if assetsFolderPath is set)
 */
@property (nonatomic, assign) BOOL extractImages;

/**
 * Whether to preserve the PDF outline/bookmarks structure.
 * Default is YES
 */
@property (nonatomic, assign) BOOL preserveOutline;

/**
 * Minimum font size difference to consider for heading detection.
 * Default is 2.0 points
 */
@property (nonatomic, assign) CGFloat headingFontSizeThreshold;

/**
 * Maximum heading level to detect (1-6).
 * Default is 6
 */
@property (nonatomic, assign) NSInteger maxHeadingLevel;

/**
 * Progress handler called during conversion.
 * The handler receives the current page index and total page count.
 */
@property (nonatomic, copy, nullable) void (^progressHandler)(NSInteger currentPage, NSInteger totalPages);

/**
 * Creates default conversion options.
 */
+ (instancetype)defaultOptions;

/**
 * Validates the current options configuration.
 * @param error Set if validation fails
 * @return YES if valid, NO otherwise
 */
- (BOOL)validateWithError:(NSError * _Nullable * _Nullable)error;

@end

/**
 * Builder class for creating PDF21MDConversionOptions instances.
 */
@interface PDF21MDConversionOptionsBuilder : NSObject

@property (nonatomic, copy, nullable) NSString *assetsFolderPath;
@property (nonatomic, assign) CGFloat rasterizationDPI;
@property (nonatomic, assign) NSInteger maxConcurrentPages;
@property (nonatomic, assign) BOOL includeMetadata;
@property (nonatomic, assign) BOOL extractImages;
@property (nonatomic, assign) BOOL preserveOutline;
@property (nonatomic, assign) CGFloat headingFontSizeThreshold;
@property (nonatomic, assign) NSInteger maxHeadingLevel;
@property (nonatomic, copy, nullable) void (^progressHandler)(NSInteger currentPage, NSInteger totalPages);

- (PDF21MDConversionOptions *)build;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf21md/src/Core/PDF21MDConversionOptions.m">
#import "PDF21MDConversionOptions.h"
#import "PDF21MDError.h"
#import "../../shared-core/PDF21MDErrorFactory.h"
#import "../../shared-core/PDF21MDConstants.h"
#import "../../shared-core/PDF21MDFileSystemUtils.h"

@implementation PDF21MDConversionOptions

#pragma mark - Initialization

- (instancetype)init {
    self = [super init];
    if (self) {
        // Set default values
        _rasterizationDPI = PDF21MD_DEFAULT_DPI;
        _maxConcurrentPages = PDF21MD_DEFAULT_MAX_CONCURRENT_PAGES ?: [[NSProcessInfo processInfo] processorCount];
        _includeMetadata = YES;
        _extractImages = YES;
        _preserveOutline = YES;
        _headingFontSizeThreshold = PDF21MD_DEFAULT_FONT_SIZE_THRESHOLD;
        _maxHeadingLevel = PDF21MD_MAX_HEADING_LEVEL;
    }
    return self;
}

+ (instancetype)defaultOptions {
    return [[self alloc] init];
}

#pragma mark - NSCopying

- (id)copyWithZone:(nullable NSZone *)zone {
    PDF21MDConversionOptions *copy = [[PDF21MDConversionOptions allocWithZone:zone] init];
    
    copy.assetsFolderPath = self.assetsFolderPath;
    copy.rasterizationDPI = self.rasterizationDPI;
    copy.maxConcurrentPages = self.maxConcurrentPages;
    copy.includeMetadata = self.includeMetadata;
    copy.extractImages = self.extractImages;
    copy.preserveOutline = self.preserveOutline;
    copy.headingFontSizeThreshold = self.headingFontSizeThreshold;
    copy.maxHeadingLevel = self.maxHeadingLevel;
    copy.progressHandler = self.progressHandler;
    
    return copy;
}

#pragma mark - Validation

- (BOOL)validateWithError:(NSError * _Nullable * _Nullable)error {
    // Validate DPI
    if (self.rasterizationDPI < PDF21MD_MINIMUM_DPI || self.rasterizationDPI > PDF21MD_MAXIMUM_DPI) {
        if (error) {
            *error = [PDF21MDErrorFactory invalidDPIErrorWithValue:self.rasterizationDPI];
        }
        return NO;
    }
    
    // Validate concurrent pages
    if (self.maxConcurrentPages < PDF21MD_MINIMUM_CONCURRENT_PAGES || self.maxConcurrentPages > PDF21MD_MAXIMUM_CONCURRENT_PAGES) {
        if (error) {
            *error = [PDF21MDErrorFactory invalidConcurrentPagesErrorWithValue:self.maxConcurrentPages];
        }
        return NO;
    }
    
    // Validate heading level
    if (self.maxHeadingLevel < PDF21MD_MIN_HEADING_LEVEL || self.maxHeadingLevel > PDF21MD_MAX_HEADING_LEVEL) {
        if (error) {
            *error = [PDF21MDErrorFactory invalidHeadingLevelErrorWithValue:self.maxHeadingLevel];
        }
        return NO;
    }
    
    // Validate font size threshold
    if (self.headingFontSizeThreshold < PDF21MD_MINIMUM_FONT_SIZE_THRESHOLD || self.headingFontSizeThreshold > PDF21MD_MAXIMUM_FONT_SIZE_THRESHOLD) {
        if (error) {
            *error = [PDF21MDErrorFactory invalidFontSizeThresholdErrorWithValue:self.headingFontSizeThreshold];
        }
        return NO;
    }
    
    // Validate assets path if image extraction is enabled
    if (self.extractImages && self.assetsFolderPath) {
        NSError *validationError = nil;
        if (![PDF21MDFileSystemUtils isValidFilePath:self.assetsFolderPath error:&validationError]) {
            if (error) {
                *error = validationError;
            }
            return NO;
        }
    }
    
    return YES;
}

#pragma mark - Description

- (NSString *)description {
    return [NSString stringWithFormat:@"<%@: %p, assets=%@, dpi=%.0f, concurrent=%ld>",
            NSStringFromClass([self class]),
            self,
            self.assetsFolderPath ?: @"<none>",
            self.rasterizationDPI,
            (long)self.maxConcurrentPages];
}

@end

#pragma mark - Builder Implementation

@implementation PDF21MDConversionOptionsBuilder

- (instancetype)init {
    self = [super init];
    if (self) {
        // Initialize with default values
        PDF21MDConversionOptions *defaults = [PDF21MDConversionOptions defaultOptions];
        _rasterizationDPI = defaults.rasterizationDPI;
        _maxConcurrentPages = defaults.maxConcurrentPages;
        _includeMetadata = defaults.includeMetadata;
        _extractImages = defaults.extractImages;
        _preserveOutline = defaults.preserveOutline;
        _headingFontSizeThreshold = defaults.headingFontSizeThreshold;
        _maxHeadingLevel = defaults.maxHeadingLevel;
    }
    return self;
}

- (PDF21MDConversionOptions *)build {
    PDF21MDConversionOptions *options = [[PDF21MDConversionOptions alloc] init];
    
    options.assetsFolderPath = self.assetsFolderPath;
    options.rasterizationDPI = self.rasterizationDPI;
    options.maxConcurrentPages = self.maxConcurrentPages;
    options.includeMetadata = self.includeMetadata;
    options.extractImages = self.extractImages;
    options.preserveOutline = self.preserveOutline;
    options.headingFontSizeThreshold = self.headingFontSizeThreshold;
    options.maxHeadingLevel = self.maxHeadingLevel;
    options.progressHandler = self.progressHandler;
    
    return options;
}

@end
</file>

<file path="pdf21md/src/Core/PDF21MDConverter.h">
#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>

NS_ASSUME_NONNULL_BEGIN

@class PDF21MDConversionOptions;

/**
 * Main converter class that coordinates the PDF to Markdown conversion process.
 * This class manages the entire conversion pipeline including parallel processing,
 * content extraction, and markdown generation.
 */
@interface PDF21MDConverter : NSObject

/**
 * The PDF document being converted.
 */
@property (nonatomic, strong, readonly) PDFDocument *document;

/**
 * Progress object for tracking conversion progress.
 */
@property (nonatomic, strong, readonly) NSProgress *progress;

/**
 * Initializes a converter with PDF data.
 *
 * @param pdfData The PDF data to convert
 * @return A new converter instance, or nil if the PDF is invalid
 */
- (nullable instancetype)initWithPDFData:(NSData *)pdfData;

/**
 * Initializes a converter with a PDF file URL.
 *
 * @param pdfURL The URL of the PDF file to convert
 * @return A new converter instance, or nil if the PDF is invalid
 */
- (nullable instancetype)initWithPDFURL:(NSURL *)pdfURL;

/**
 * Designated initializer that creates a converter with both URL and document.
 * This is the real designated initializer that other initializers should call.
 *
 * @param pdfURL The URL of the PDF file (may be nil for data-based PDFs)
 * @param document The PDF document instance
 * @return A new converter instance, or nil if invalid
 */
- (nullable instancetype)initWithPDFURL:(nullable NSURL *)pdfURL document:(PDFDocument *)document NS_DESIGNATED_INITIALIZER;

- (instancetype)init NS_UNAVAILABLE;

/**
 * Converts the PDF to Markdown with the given options.
 * This method performs the conversion asynchronously on a background queue.
 *
 * @param options Conversion options (uses defaults if nil)
 * @param completion Completion handler called with the result or error
 */
- (void)convertWithOptions:(nullable PDF21MDConversionOptions *)options
                completion:(void (^)(NSString * _Nullable markdown, NSError * _Nullable error))completion;

/**
 * Cancels an ongoing conversion.
 * The completion handler will be called with a cancellation error.
 */
- (void)cancelConversion;

/**
 * Validates that the PDF can be converted.
 *
 * @param error Set if validation fails
 * @return YES if the PDF is valid for conversion, NO otherwise
 */
- (BOOL)validateDocumentWithError:(NSError * _Nullable * _Nullable)error;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf21md/src/Core/PDF21MDConverter.m">
#import "PDF21MDConverter.h"
#import "PDF21MDConversionOptions.h"
#import "PDF21MDPageProcessor.h"
#import "../Models/PDF21MDContentElement.h"
#import "../Models/PDF21MDImageElement.h"
#import "../Services/PDF21MDAssetManager.h"
#import "../Services/PDF21MDMarkdownGenerator.h"
#import "PDF21MDFontAnalyzer.h"
#import "PDF21MDError.h"
#import "../../shared-core/PDF21MDConcurrencyManager.h"

@interface PDF21MDConverter ()
@property (nonatomic, strong) dispatch_queue_t conversionQueue;
@property (nonatomic, strong) NSMutableArray<id<PDF21MDContentElement>> *allElements;
@property (nonatomic, strong) PDF21MDFontAnalyzer *fontAnalyzer;
@property (nonatomic, assign) BOOL isCancelled;
@end

@implementation PDF21MDConverter

#pragma mark - Initialization

- (nullable instancetype)initWithPDFData:(NSData *)pdfData {
    if (!pdfData || pdfData.length == 0) {
        return nil;
    }
    
    PDFDocument *document = [[PDFDocument alloc] initWithData:pdfData];
    if (!document) {
        return nil;
    }
    
    NSURL *tempURL = [NSURL URLWithString:@"data:application/pdf"];
    return [self initWithPDFURL:tempURL document:document];
}

- (nullable instancetype)initWithPDFURL:(NSURL *)pdfURL {
    if (!pdfURL) {
        return nil;
    }
    
    PDFDocument *document = [[PDFDocument alloc] initWithURL:pdfURL];
    if (!document) {
        return nil;
    }
    
    return [self initWithPDFURL:pdfURL document:document];
}

- (nullable instancetype)initWithPDFURL:(nullable NSURL *)pdfURL document:(PDFDocument *)document {
    if (!document) {
        return nil;
    }
    
    self = [super init];
    if (self) {
        _document = document;
        _conversionQueue = [PDF21MDConcurrencyManager sharedConverterQueue];
        _allElements = [NSMutableArray array];
        _fontAnalyzer = [[PDF21MDFontAnalyzer alloc] init];
        _progress = [NSProgress progressWithTotalUnitCount:[document pageCount]];
        _isCancelled = NO;
    }
    return self;
}

#pragma mark - Public Methods

- (void)convertWithOptions:(nullable PDF21MDConversionOptions *)options
                completion:(void (^)(NSString * _Nullable markdown, NSError * _Nullable error))completion {
    // Use default options if none provided
    if (!options) {
        options = [PDF21MDConversionOptions defaultOptions];
    }
    
    // Validate options
    NSError *validationError = nil;
    if (![options validateWithError:&validationError]) {
        completion(nil, validationError);
        return;
    }
    
    // Reset state
    self.isCancelled = NO;
    [self.allElements removeAllObjects];
    [self.fontAnalyzer reset];
    self.progress.completedUnitCount = 0;
    
    // Configure font analyzer
    self.fontAnalyzer.fontSizeThreshold = options.headingFontSizeThreshold;
    self.fontAnalyzer.maxHeadingLevel = options.maxHeadingLevel;
    
    // Perform conversion using shared concurrency manager
    [PDF21MDConcurrencyManager performConverterOperation:^{
        @autoreleasepool {
            NSError *error = nil;
            NSString *markdown = [self performConversionWithOptions:options error:&error];
            
            // Call completion on main queue
            [PDF21MDConcurrencyManager executeOnMainQueue:^{
                completion(markdown, error);
            }];
        }
    } completion:nil];
}

- (void)cancelConversion {
    self.isCancelled = YES;
    [self.progress cancel];
}

- (BOOL)validateDocumentWithError:(NSError * _Nullable * _Nullable)error {
    if (!self.document) {
        if (error) {
            *error = [PDF21MDErrorHelper invalidPDFErrorWithReason:@"Document is nil"];
        }
        return NO;
    }
    
    if ([self.document pageCount] == 0) {
        if (error) {
            *error = [PDF21MDErrorHelper invalidPDFErrorWithReason:@"Document has no pages"];
        }
        return NO;
    }
    
    if ([self.document isLocked]) {
        if (error) {
            *error = [PDF21MDErrorHelper invalidPDFErrorWithReason:@"Document is password protected"];
        }
        return NO;
    }
    
    return YES;
}

#pragma mark - Private Methods

- (nullable NSString *)performConversionWithOptions:(PDF21MDConversionOptions *)options
                                              error:(NSError * _Nullable * _Nullable)error {
    // Validate document
    if (![self validateDocumentWithError:error]) {
        return nil;
    }
    
    NSInteger pageCount = [self.document pageCount];
    
    // Create asset manager if needed
    PDF21MDAssetManager *assetManager = nil;
    if (options.extractImages && options.assetsFolderPath) {
        assetManager = [[PDF21MDAssetManager alloc] initWithAssetFolder:options.assetsFolderPath];
        if (!assetManager) {
            if (error) {
                *error = [PDF21MDErrorHelper assetFolderCreationErrorWithPath:options.assetsFolderPath
                                                                          reason:@"Failed to create asset manager"];
            }
            return nil;
        }
    }
    
    // Process pages in parallel
    NSMutableArray<NSMutableArray<id<PDF21MDContentElement>> *> *pageElementsArray = [NSMutableArray arrayWithCapacity:pageCount];
    NSMutableArray<PDF21MDFontAnalyzer *> *pageFontAnalyzers = [NSMutableArray arrayWithCapacity:pageCount];
    
    for (NSInteger i = 0; i < pageCount; i++) {
        [pageElementsArray addObject:[NSMutableArray array]];
        [pageFontAnalyzers addObject:[[PDF21MDFontAnalyzer alloc] init]];
    }
    
    // Create dispatch group for parallel processing
    dispatch_group_t processingGroup = dispatch_group_create();
    __block BOOL processingFailed = NO;
    __block NSError *processingError = nil;
    
    // Limit concurrency based on options
    dispatch_semaphore_t concurrencySemaphore = dispatch_semaphore_create(options.maxConcurrentPages);
    
    for (NSInteger pageIndex = 0; pageIndex < pageCount; pageIndex++) {
        if (self.isCancelled) {
            if (error) {
                *error = [NSError errorWithDomain:PDF21MDErrorDomain
                                             code:PDF21MDErrorCancelled
                                         userInfo:@{NSLocalizedDescriptionKey: @"Conversion was cancelled"}];
            }
            return nil;
        }
        
        dispatch_group_async(processingGroup, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            dispatch_semaphore_wait(concurrencySemaphore, DISPATCH_TIME_FOREVER);
            
            @autoreleasepool {
                if (!processingFailed && !self.isCancelled) {
                    PDFPage *page = [self.document pageAtIndex:pageIndex];
                    if (!page) {
                        processingFailed = YES;
                        processingError = [PDF21MDErrorHelper pageProcessingFailedErrorForPage:pageIndex
                                                                                        reason:@"Failed to get page"
                                                                               underlyingError:nil];
                    } else {
                        // Process page
                        PDF21MDPageProcessor *processor = [[PDF21MDPageProcessor alloc] initWithPDFPage:page
                                                                                             pageIndex:pageIndex
                                                                                                   dpi:options.rasterizationDPI];
                        processor.fontAnalyzer = pageFontAnalyzers[pageIndex];
                        
                        NSArray<id<PDF21MDContentElement>> *pageElements = [processor extractContentElements];
                        [pageElementsArray[pageIndex] addObjectsFromArray:pageElements];
                        
                        // Analyze fonts for this page
                        [pageFontAnalyzers[pageIndex] analyzeElements:pageElements];
                        
                        // Update progress
                        dispatch_async(dispatch_get_main_queue(), ^{
                            self.progress.completedUnitCount = pageIndex + 1;
                            if (options.progressHandler) {
                                options.progressHandler(pageIndex + 1, pageCount);
                            }
                        });
                    }
                }
            }
            
            dispatch_semaphore_signal(concurrencySemaphore);
        });
    }
    
    // Wait for all pages to complete with timeout
    dispatch_time_t timeout = dispatch_time(DISPATCH_TIME_NOW, 60 * NSEC_PER_SEC); // 60 seconds timeout
    long result = dispatch_group_wait(processingGroup, timeout);
    
    if (result != 0) {
        // Timeout occurred
        if (error) {
            *error = [PDF21MDErrorHelper processingFailedErrorWithReason:@"PDF processing timed out after 60 seconds. The PDF may be corrupted or too complex."
                                                       underlyingError:nil];
        }
        return nil;
    }
    
    if (processingFailed) {
        if (error) {
            *error = processingError ?: [PDF21MDErrorHelper processingFailedErrorWithReason:@"Unknown processing error"
                                                                              underlyingError:nil];
        }
        return nil;
    }
    
    if (self.isCancelled) {
        if (error) {
            *error = [NSError errorWithDomain:PDF21MDErrorDomain
                                         code:PDF21MDErrorCancelled
                                     userInfo:@{NSLocalizedDescriptionKey: @"Conversion was cancelled"}];
        }
        return nil;
    }
    
    // Merge results from all pages
    for (NSInteger i = 0; i < pageCount; i++) {
        [self.allElements addObjectsFromArray:pageElementsArray[i]];
        [self.fontAnalyzer mergeFontStatisticsFromAnalyzer:pageFontAnalyzers[i]];
    }
    
    // Analyze font hierarchy and assign heading levels
    [self.fontAnalyzer analyzeElements:self.allElements];
    [self.fontAnalyzer assignHeadingLevels:self.allElements];
    
    // Sort elements by page and position
    [self sortElements];
    
    // Extract and save images if needed
    if (assetManager) {
        [self extractImagesWithAssetManager:assetManager];
    }
    
    // Generate markdown
    PDF21MDMarkdownGenerator *generator = [[PDF21MDMarkdownGenerator alloc] initWithOptions:options];
    PDF21MDDocumentMetadata *metadata = [PDF21MDMarkdownGenerator extractMetadataFromDocument:self.document];
    
    NSString *markdown = [generator generateMarkdownFromElements:self.allElements withMetadata:metadata];
    
    return markdown;
}

- (void)sortElements {
    [self.allElements sortUsingComparator:^NSComparisonResult(id<PDF21MDContentElement> obj1, id<PDF21MDContentElement> obj2) {
        // First sort by page
        if (obj1.pageIndex != obj2.pageIndex) {
            return obj1.pageIndex < obj2.pageIndex ? NSOrderedAscending : NSOrderedDescending;
        }
        
        // Then sort by vertical position (top to bottom)
        CGFloat y1 = CGRectGetMaxY(obj1.bounds);
        CGFloat y2 = CGRectGetMaxY(obj2.bounds);
        
        if (fabs(y1 - y2) > 5.0) { // Tolerance for same line
            return y1 > y2 ? NSOrderedAscending : NSOrderedDescending;
        }
        
        // Finally sort by horizontal position (left to right)
        CGFloat x1 = CGRectGetMinX(obj1.bounds);
        CGFloat x2 = CGRectGetMinX(obj2.bounds);
        
        return x1 < x2 ? NSOrderedAscending : NSOrderedDescending;
    }];
}

- (void)extractImagesWithAssetManager:(PDF21MDAssetManager *)assetManager {
    NSMutableArray<PDF21MDImageElement *> *imageElements = [NSMutableArray array];
    
    for (id<PDF21MDContentElement> element in self.allElements) {
        if ([element isKindOfClass:[PDF21MDImageElement class]]) {
            [imageElements addObject:(PDF21MDImageElement *)element];
        }
    }
    
    if (imageElements.count == 0) {
        return;
    }
    
    // Save images in parallel
    dispatch_group_t imageGroup = dispatch_group_create();
    dispatch_queue_t imageQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    
    [imageElements enumerateObjectsUsingBlock:^(PDF21MDImageElement *imageElement, NSUInteger idx, BOOL * __unused stop) {
        dispatch_group_async(imageGroup, imageQueue, ^{
            @autoreleasepool {
                NSString *baseName = [NSString stringWithFormat:@"image_%03lu", (unsigned long)idx];
                [assetManager saveImageElement:imageElement withBaseName:baseName];
            }
        });
    }];
    
    dispatch_group_wait(imageGroup, DISPATCH_TIME_FOREVER);
}

@end
</file>

<file path="pdf21md/src/Core/PDF21MDError.h">
#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

/**
 * Error domain for all PDF21MD errors.
 */
extern NSErrorDomain const PDF21MDErrorDomain;

/**
 * Error codes used throughout the PDF21MD framework.
 */
typedef NS_ERROR_ENUM(PDF21MDErrorDomain, PDF21MDError) {
    /**
     * The provided PDF file or data is invalid or corrupted.
     */
    PDF21MDErrorInvalidPDF = 1000,
    
    /**
     * Failed to create the assets folder or save extracted images.
     */
    PDF21MDErrorAssetFolderCreation = 1001,
    
    /**
     * General processing failure during conversion.
     */
    PDF21MDErrorProcessingFailed = 1002,
    
    /**
     * One or more pages failed to process.
     */
    PDF21MDErrorPageProcessingFailed = 1003,
    
    /**
     * Invalid or missing configuration options.
     */
    PDF21MDErrorInvalidConfiguration = 1004,
    
    /**
     * I/O error reading or writing files.
     */
    PDF21MDErrorIOFailure = 1005,
    
    /**
     * Memory allocation failure or insufficient memory to process PDF.
     */
    PDF21MDErrorMemoryPressure = 1006,
    
    /**
     * Operation was cancelled.
     */
    PDF21MDErrorCancelled = 1007,
    
    /**
     * PDF processing timed out (document too complex).
     */
    PDF21MDErrorProcessingTimeout = 1008,
    
    /**
     * Password-protected PDFs are not currently supported.
     */
    PDF21MDErrorEncryptedPDF = 1009,
    
    /**
     * The PDF contains no readable content.
     */
    PDF21MDErrorEmptyDocument = 1010,
    
    /**
     * Invalid input parameters provided.
     */
    PDF21MDErrorInvalidInput = 1011,
    
    /**
     * File not found at specified path.
     */
    PDF21MDErrorFileNotFound = 1012,
    
    /**
     * Invalid file path provided.
     */
    PDF21MDErrorInvalidPath = 1013,
    
    /**
     * Directory not found or does not exist.
     */
    PDF21MDErrorDirectoryNotFound = 1014,
    
    /**
     * Permission denied for file system operation.
     */
    PDF21MDErrorPermissionDenied = 1015
};

/**
 * Keys for additional information in error's userInfo dictionary.
 */
extern NSString * const PDF21MDErrorPageIndexKey;      // NSNumber containing the failed page index
extern NSString * const PDF21MDErrorFilePathKey;       // NSString containing the problematic file path
extern NSString * const PDF21MDErrorUnderlyingErrorKey; // Original NSError that caused this error

/**
 * Helper class for creating consistent, user-friendly error objects.
 */
@interface PDF21MDErrorHelper : NSObject

/**
 * Creates a user-friendly error with code, description, and actionable suggestion.
 */
+ (NSError *)userFriendlyErrorWithCode:(PDF21MDError)code 
                           description:(NSString *)description
                            suggestion:(nullable NSString *)suggestion
                       underlyingError:(nullable NSError *)underlyingError;

/**
 * Creates an error for invalid PDF input.
 */
+ (NSError *)invalidPDFError;

/**
 * Creates an error for invalid PDF input with additional details.
 */
+ (NSError *)invalidPDFErrorWithReason:(nullable NSString *)reason;

/**
 * Creates an error for file not found.
 */
+ (NSError *)fileNotFoundErrorWithPath:(NSString *)path;

/**
 * Creates an error for invalid input parameters.
 */
+ (NSError *)invalidInputErrorWithReason:(NSString *)reason;

/**
 * Creates an error for asset folder creation failure.
 */
+ (NSError *)assetFolderCreationErrorWithPath:(NSString *)path 
                                       reason:(nullable NSString *)reason;

/**
 * Creates an error for memory pressure.
 */
+ (NSError *)memoryPressureError;

/**
 * Creates an error for processing timeout.
 */
+ (NSError *)processingTimeoutError;

/**
 * Creates an error for encrypted PDF.
 */
+ (NSError *)encryptedPDFError;

/**
 * Creates an error for empty document.
 */
+ (NSError *)emptyDocumentError;

/**
 * Creates an error for page processing failure.
 */
+ (NSError *)pageProcessingFailedErrorForPage:(NSInteger)pageIndex 
                                        reason:(nullable NSString *)reason
                               underlyingError:(nullable NSError *)underlyingError;

/**
 * Creates an error for general processing failure.
 */
+ (NSError *)processingFailedErrorWithReason:(NSString *)reason 
                              underlyingError:(nullable NSError *)underlyingError;

/**
 * Creates an error for I/O failure.
 */
+ (NSError *)ioFailureErrorWithPath:(nullable NSString *)path 
                              reason:(NSString *)reason
                     underlyingError:(nullable NSError *)underlyingError;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf21md/src/Core/PDF21MDError.m">
#import "PDF21MDError.h"

NSErrorDomain const PDF21MDErrorDomain = @"com.twardoch.pdf21md.ErrorDomain";

NSString * const PDF21MDErrorPageIndexKey = @"PDF21MDErrorPageIndex";
NSString * const PDF21MDErrorFilePathKey = @"PDF21MDErrorFilePath";
NSString * const PDF21MDErrorUnderlyingErrorKey = @"PDF21MDErrorUnderlyingError";

@implementation PDF21MDErrorHelper

+ (NSError *)userFriendlyErrorWithCode:(PDF21MDError)code 
                           description:(NSString *)description
                            suggestion:(nullable NSString *)suggestion
                       underlyingError:(nullable NSError *)underlyingError {
    NSMutableDictionary *userInfo = [@{
        NSLocalizedDescriptionKey: description,
        NSLocalizedFailureReasonErrorKey: description
    } mutableCopy];
    
    if (suggestion) {
        userInfo[NSLocalizedRecoverySuggestionErrorKey] = suggestion;
    }
    
    if (underlyingError) {
        userInfo[NSUnderlyingErrorKey] = underlyingError;
        userInfo[PDF21MDErrorUnderlyingErrorKey] = underlyingError;
    }
    
    return [NSError errorWithDomain:PDF21MDErrorDomain
                               code:code
                           userInfo:userInfo];
}

+ (NSError *)invalidPDFError {
    return [self invalidPDFErrorWithReason:nil];
}

+ (NSError *)invalidPDFErrorWithReason:(nullable NSString *)reason {
    NSString *description = reason ?: @"The PDF file appears to be corrupted or invalid";
    NSString *suggestion = @"Ensure the file is a valid PDF document. Try opening it in another PDF viewer to verify it's not corrupted.";
    
    return [self userFriendlyErrorWithCode:PDF21MDErrorInvalidPDF
                               description:description
                                suggestion:suggestion
                           underlyingError:nil];
}

+ (NSError *)fileNotFoundErrorWithPath:(NSString *)path {
    NSString *description = [NSString stringWithFormat:@"File not found: %@", path];
    NSString *suggestion = @"Check that the file path is correct and the file exists.";
    
    NSError *error = [self userFriendlyErrorWithCode:PDF21MDErrorFileNotFound
                                         description:description
                                          suggestion:suggestion
                                     underlyingError:nil];
    
    NSMutableDictionary *userInfo = [error.userInfo mutableCopy];
    userInfo[PDF21MDErrorFilePathKey] = path;
    
    return [NSError errorWithDomain:PDF21MDErrorDomain
                               code:PDF21MDErrorFileNotFound
                           userInfo:userInfo];
}

+ (NSError *)invalidInputErrorWithReason:(NSString *)reason {
    NSString *description = [NSString stringWithFormat:@"Invalid input: %@", reason];
    NSString *suggestion = @"Check the command line arguments and ensure all required parameters are provided correctly.";
    
    return [self userFriendlyErrorWithCode:PDF21MDErrorInvalidInput
                               description:description
                                suggestion:suggestion
                           underlyingError:nil];
}

+ (NSError *)assetFolderCreationErrorWithPath:(NSString *)path 
                                       reason:(nullable NSString *)reason {
    NSString *description = reason ?: @"Could not create assets folder at specified path";
    NSString *suggestion = @"Ensure you have write permissions to the target directory and sufficient disk space.";
    
    NSError *error = [self userFriendlyErrorWithCode:PDF21MDErrorAssetFolderCreation
                                         description:description
                                          suggestion:suggestion
                                     underlyingError:nil];
    
    NSMutableDictionary *userInfo = [error.userInfo mutableCopy];
    userInfo[PDF21MDErrorFilePathKey] = path;
    
    return [NSError errorWithDomain:PDF21MDErrorDomain
                               code:PDF21MDErrorAssetFolderCreation
                           userInfo:userInfo];
}

+ (NSError *)memoryPressureError {
    NSString *description = @"Insufficient memory to process this PDF";
    NSString *suggestion = @"Try processing a smaller PDF or close other applications to free up memory. For very large documents, consider splitting them into smaller files.";
    
    return [self userFriendlyErrorWithCode:PDF21MDErrorMemoryPressure
                               description:description
                                suggestion:suggestion
                           underlyingError:nil];
}

+ (NSError *)processingTimeoutError {
    NSString *description = @"PDF processing timed out (document too complex)";
    NSString *suggestion = @"The PDF may be extremely large or complex. Try processing smaller sections or contact support if this persists.";
    
    return [self userFriendlyErrorWithCode:PDF21MDErrorProcessingTimeout
                               description:description
                                suggestion:suggestion
                           underlyingError:nil];
}

+ (NSError *)encryptedPDFError {
    NSString *description = @"Password-protected PDFs are not currently supported";
    NSString *suggestion = @"Please remove the password protection from the PDF using another tool before conversion.";
    
    return [self userFriendlyErrorWithCode:PDF21MDErrorEncryptedPDF
                               description:description
                                suggestion:suggestion
                           underlyingError:nil];
}

+ (NSError *)emptyDocumentError {
    NSString *description = @"The PDF contains no readable content";
    NSString *suggestion = @"The PDF may be empty, contain only images without text, or have text in an unsupported format.";
    
    return [self userFriendlyErrorWithCode:PDF21MDErrorEmptyDocument
                               description:description
                                suggestion:suggestion
                           underlyingError:nil];
}

+ (NSError *)assetCreationFailedErrorWithPath:(NSString *)path 
                                         reason:(nullable NSString *)reason {
    // This method is deprecated in favor of assetFolderCreationErrorWithPath:reason:
    return [self assetFolderCreationErrorWithPath:path reason:reason];
}

+ (NSError *)pageProcessingFailedErrorForPage:(NSInteger)pageIndex 
                                        reason:(nullable NSString *)reason
                               underlyingError:(nullable NSError *)underlyingError {
    NSString *description = [NSString stringWithFormat:@"Failed to process page %ld", (long)(pageIndex + 1)];
    NSString *failureReason = reason ?: @"An error occurred while extracting content from the page";
    
    NSMutableDictionary *userInfo = [@{
        NSLocalizedDescriptionKey: description,
        NSLocalizedFailureReasonErrorKey: failureReason,
        NSLocalizedRecoverySuggestionErrorKey: @"The page may contain unsupported content or be corrupted",
        PDF21MDErrorPageIndexKey: @(pageIndex)
    } mutableCopy];
    
    if (underlyingError) {
        userInfo[NSUnderlyingErrorKey] = underlyingError;
        userInfo[PDF21MDErrorUnderlyingErrorKey] = underlyingError;
    }
    
    return [NSError errorWithDomain:PDF21MDErrorDomain
                               code:PDF21MDErrorPageProcessingFailed
                           userInfo:userInfo];
}

+ (NSError *)processingFailedErrorWithReason:(NSString *)reason 
                              underlyingError:(nullable NSError *)underlyingError {
    NSString *description = @"PDF processing failed";
    
    NSMutableDictionary *userInfo = [@{
        NSLocalizedDescriptionKey: description,
        NSLocalizedFailureReasonErrorKey: reason,
        NSLocalizedRecoverySuggestionErrorKey: @"Check the input file and try again"
    } mutableCopy];
    
    if (underlyingError) {
        userInfo[NSUnderlyingErrorKey] = underlyingError;
        userInfo[PDF21MDErrorUnderlyingErrorKey] = underlyingError;
    }
    
    return [NSError errorWithDomain:PDF21MDErrorDomain
                               code:PDF21MDErrorProcessingFailed
                           userInfo:userInfo];
}

+ (NSError *)ioFailureErrorWithPath:(nullable NSString *)path 
                              reason:(NSString *)reason
                     underlyingError:(nullable NSError *)underlyingError {
    NSString *description = @"File I/O operation failed";
    
    NSMutableDictionary *userInfo = [@{
        NSLocalizedDescriptionKey: description,
        NSLocalizedFailureReasonErrorKey: reason,
        NSLocalizedRecoverySuggestionErrorKey: @"Check file permissions and available disk space"
    } mutableCopy];
    
    if (path) {
        userInfo[PDF21MDErrorFilePathKey] = path;
    }
    
    if (underlyingError) {
        userInfo[NSUnderlyingErrorKey] = underlyingError;
        userInfo[PDF21MDErrorUnderlyingErrorKey] = underlyingError;
    }
    
    return [NSError errorWithDomain:PDF21MDErrorDomain
                               code:PDF21MDErrorIOFailure
                           userInfo:userInfo];
}

@end
</file>

<file path="pdf21md/src/Core/PDF21MDFontAnalyzer.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

@protocol PDF21MDContentElement;
@class PDF21MDTextElement;

/**
 * Font statistics for a particular font and size combination.
 */
@interface PDF21MDFontStatistics : NSObject
@property (nonatomic, copy, readonly) NSString *fontKey;
@property (nonatomic, copy, readonly) NSString *fontName;
@property (nonatomic, assign, readonly) CGFloat fontSize;
@property (nonatomic, assign, readonly) NSUInteger occurrenceCount;
@property (nonatomic, assign) NSInteger assignedHeadingLevel; // 0 for body text, 1-6 for headings

- (instancetype)initWithFontKey:(NSString *)fontKey
                       fontName:(NSString *)fontName
                       fontSize:(CGFloat)fontSize;

- (void)incrementOccurrenceCount;
- (void)addOccurrenceCount:(NSUInteger)count;

@end

/**
 * Analyzes font usage in PDF documents to detect heading hierarchy.
 */
@interface PDF21MDFontAnalyzer : NSObject

/**
 * The font size threshold for detecting headings.
 * Text with font size differences greater than this value may be considered headings.
 */
@property (nonatomic, assign) CGFloat fontSizeThreshold;

/**
 * Maximum heading level to assign (1-6).
 */
@property (nonatomic, assign) NSInteger maxHeadingLevel;

/**
 * Dictionary of font statistics keyed by font identifier.
 */
@property (nonatomic, strong, readonly) NSDictionary<NSString *, PDF21MDFontStatistics *> *fontStatistics;

/**
 * Initializes the analyzer with default settings.
 */
- (instancetype)init;

/**
 * Analyzes an array of content elements to build font statistics.
 * This should be called before assignHeadingLevels.
 *
 * @param elements Array of content elements to analyze
 */
- (void)analyzeElements:(NSArray<id<PDF21MDContentElement>> *)elements;

/**
 * Assigns heading levels to text elements based on font analysis.
 * Call this after analyzeElements.
 *
 * @param elements Array of content elements to process
 */
- (void)assignHeadingLevels:(NSArray<id<PDF21MDContentElement>> *)elements;

/**
 * Merges font statistics from another analyzer.
 * Useful for combining statistics from multiple pages.
 *
 * @param otherAnalyzer The analyzer to merge from
 */
- (void)mergeFontStatisticsFromAnalyzer:(PDF21MDFontAnalyzer *)otherAnalyzer;

/**
 * Resets all collected statistics.
 */
- (void)reset;

/**
 * Gets a sorted array of font statistics by size (largest first).
 */
- (NSArray<PDF21MDFontStatistics *> *)sortedFontStatistics;

/**
 * Creates a font key identifier from font properties.
 */
+ (NSString *)fontKeyForFontName:(nullable NSString *)fontName fontSize:(CGFloat)fontSize;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf21md/src/Core/PDF21MDFontAnalyzer.m">
#import "PDF21MDFontAnalyzer.h"
#import "../Models/PDF21MDContentElement.h"
#import "../Models/PDF21MDTextElement.h"

@implementation PDF21MDFontStatistics

- (instancetype)initWithFontKey:(NSString *)fontKey
                       fontName:(NSString *)fontName
                       fontSize:(CGFloat)fontSize {
    self = [super init];
    if (self) {
        _fontKey = [fontKey copy];
        _fontName = [fontName copy];
        _fontSize = fontSize;
        _occurrenceCount = 0;
        _assignedHeadingLevel = 0;
    }
    return self;
}

- (void)incrementOccurrenceCount {
    _occurrenceCount++;
}

- (void)addOccurrenceCount:(NSUInteger)count {
    _occurrenceCount += count;
}

- (NSString *)description {
    return [NSString stringWithFormat:@"<FontStats: %@ size=%.1f count=%lu level=%ld>",
            self.fontName, self.fontSize, (unsigned long)self.occurrenceCount, (long)self.assignedHeadingLevel];
}

@end

@interface PDF21MDFontAnalyzer ()
@property (nonatomic, strong) NSMutableDictionary<NSString *, PDF21MDFontStatistics *> *mutableFontStatistics;
@end

@implementation PDF21MDFontAnalyzer

#pragma mark - Initialization

- (instancetype)init {
    self = [super init];
    if (self) {
        _fontSizeThreshold = 2.0;
        _maxHeadingLevel = 6;
        _mutableFontStatistics = [NSMutableDictionary dictionary];
    }
    return self;
}

#pragma mark - Public Methods

- (void)analyzeElements:(NSArray<id<PDF21MDContentElement>> *)elements {
    for (id<PDF21MDContentElement> element in elements) {
        if ([element isKindOfClass:[PDF21MDTextElement class]]) {
            PDF21MDTextElement *textElement = (PDF21MDTextElement *)element;
            [self addTextElementToStatistics:textElement];
        }
    }
}

- (void)assignHeadingLevels:(NSArray<id<PDF21MDContentElement>> *)elements {
    // Get sorted font statistics
    NSArray<PDF21MDFontStatistics *> *sortedStats = [self sortedFontStatistics];
    
    if (sortedStats.count == 0) {
        return;
    }
    
    // Find the most common font size (likely body text)
    PDF21MDFontStatistics *mostCommonFont = nil;
    NSUInteger highestCount = 0;
    
    for (PDF21MDFontStatistics *stats in sortedStats) {
        if (stats.occurrenceCount > highestCount) {
            highestCount = stats.occurrenceCount;
            mostCommonFont = stats;
        }
    }
    
    CGFloat bodyFontSize = mostCommonFont ? mostCommonFont.fontSize : 12.0;
    
    // Assign heading levels based on size hierarchy
    NSInteger currentHeadingLevel = 1;
    CGFloat lastHeadingSize = CGFLOAT_MAX;
    
    for (PDF21MDFontStatistics *stats in sortedStats) {
        // Skip if this is likely body text
        if (stats == mostCommonFont) {
            stats.assignedHeadingLevel = 0;
            continue;
        }
        
        // Check if this font is significantly larger than body text
        CGFloat sizeDifference = stats.fontSize - bodyFontSize;
        
        if (sizeDifference >= self.fontSizeThreshold) {
            // This is a potential heading
            // Check if it's significantly different from the last heading size
            if (lastHeadingSize - stats.fontSize >= self.fontSizeThreshold) {
                currentHeadingLevel++;
            }
            
            if (currentHeadingLevel <= self.maxHeadingLevel) {
                stats.assignedHeadingLevel = currentHeadingLevel;
                lastHeadingSize = stats.fontSize;
            } else {
                // Too many heading levels, treat as body text
                stats.assignedHeadingLevel = 0;
            }
        } else {
            // Not large enough to be a heading
            stats.assignedHeadingLevel = 0;
        }
        
        // Additional heuristic: if occurrence count is very high, it's probably not a heading
        if (stats.occurrenceCount > highestCount * 0.5) {
            stats.assignedHeadingLevel = 0;
        }
    }
    
    // Apply heading levels to text elements
    for (id<PDF21MDContentElement> element in elements) {
        if ([element isKindOfClass:[PDF21MDTextElement class]]) {
            PDF21MDTextElement *textElement = (PDF21MDTextElement *)element;
            NSString *fontKey = [[self class] fontKeyForFontName:textElement.fontName 
                                                        fontSize:textElement.fontSize];
            PDF21MDFontStatistics *stats = self.mutableFontStatistics[fontKey];
            if (stats) {
                textElement.headingLevel = stats.assignedHeadingLevel;
            }
        }
    }
}

- (void)mergeFontStatisticsFromAnalyzer:(PDF21MDFontAnalyzer *)otherAnalyzer {
    [otherAnalyzer.fontStatistics enumerateKeysAndObjectsUsingBlock:^(NSString *key, PDF21MDFontStatistics *otherStats, BOOL * __unused stop) {
        PDF21MDFontStatistics *existingStats = self.mutableFontStatistics[key];
        
        if (existingStats) {
            // Merge occurrence counts
            [existingStats addOccurrenceCount:otherStats.occurrenceCount];
        } else {
            // Add new statistics
            PDF21MDFontStatistics *newStats = [[PDF21MDFontStatistics alloc] initWithFontKey:otherStats.fontKey
                                                                                    fontName:otherStats.fontName
                                                                                    fontSize:otherStats.fontSize];
            [newStats addOccurrenceCount:otherStats.occurrenceCount];
            self.mutableFontStatistics[key] = newStats;
        }
    }];
}

- (void)reset {
    [self.mutableFontStatistics removeAllObjects];
}

- (NSArray<PDF21MDFontStatistics *> *)sortedFontStatistics {
    NSArray<PDF21MDFontStatistics *> *allStats = [self.mutableFontStatistics allValues];
    
    // Sort by font size in descending order
    return [allStats sortedArrayUsingComparator:^NSComparisonResult(PDF21MDFontStatistics *obj1, PDF21MDFontStatistics *obj2) {
        if (obj1.fontSize > obj2.fontSize) {
            return NSOrderedAscending;
        } else if (obj1.fontSize < obj2.fontSize) {
            return NSOrderedDescending;
        } else {
            // Same size, sort by occurrence count
            if (obj1.occurrenceCount > obj2.occurrenceCount) {
                return NSOrderedAscending;
            } else if (obj1.occurrenceCount < obj2.occurrenceCount) {
                return NSOrderedDescending;
            }
            return NSOrderedSame;
        }
    }];
}

+ (NSString *)fontKeyForFontName:(nullable NSString *)fontName fontSize:(CGFloat)fontSize {
    NSString *name = fontName ?: @"Unknown";
    return [NSString stringWithFormat:@"%.1f-%@", fontSize, name];
}

#pragma mark - Properties

- (NSDictionary<NSString *, PDF21MDFontStatistics *> *)fontStatistics {
    return [self.mutableFontStatistics copy];
}

#pragma mark - Private Methods

- (void)addTextElementToStatistics:(PDF21MDTextElement *)textElement {
    // Skip empty text
    NSString *trimmedText = [textElement.text stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    if (trimmedText.length == 0) {
        return;
    }
    
    NSString *fontKey = [[self class] fontKeyForFontName:textElement.fontName fontSize:textElement.fontSize];
    
    PDF21MDFontStatistics *stats = self.mutableFontStatistics[fontKey];
    if (!stats) {
        stats = [[PDF21MDFontStatistics alloc] initWithFontKey:fontKey
                                                      fontName:textElement.fontName ?: @"Unknown"
                                                      fontSize:textElement.fontSize];
        self.mutableFontStatistics[fontKey] = stats;
    }
    
    [stats incrementOccurrenceCount];
}

@end
</file>

<file path="pdf21md/src/Core/PDF21MDPageProcessor.h">
#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

@protocol PDF21MDContentElement;
@class PDF21MDFontAnalyzer;

/**
 * Processes individual PDF pages to extract content elements.
 * Uses PDFKit's high-level API for safe and reliable content extraction.
 */
@interface PDF21MDPageProcessor : NSObject

/**
 * The PDF page being processed.
 */
@property (nonatomic, strong, readonly) PDFPage *pdfPage;

/**
 * The zero-based index of the page.
 */
@property (nonatomic, assign, readonly) NSInteger pageIndex;

/**
 * DPI for rasterizing vector graphics.
 */
@property (nonatomic, assign, readonly) CGFloat dpi;

/**
 * Font analyzer for this page (optional).
 */
@property (nonatomic, strong, nullable) PDF21MDFontAnalyzer *fontAnalyzer;

/**
 * Initializes a page processor for the given PDF page.
 *
 * @param pdfPage The PDF page to process
 * @param pageIndex The zero-based page index
 * @param dpi DPI for rasterization (default: 144)
 * @return A new page processor instance
 */
- (instancetype)initWithPDFPage:(PDFPage *)pdfPage
                      pageIndex:(NSInteger)pageIndex
                            dpi:(CGFloat)dpi NS_DESIGNATED_INITIALIZER;

- (instancetype)init NS_UNAVAILABLE;

/**
 * Extracts all content elements from the page.
 * This includes text and images.
 *
 * @return Array of content elements in reading order
 */
- (NSArray<id<PDF21MDContentElement>> *)extractContentElements;

/**
 * Extracts only text elements from the page.
 *
 * @return Array of text elements
 */
- (NSArray<id<PDF21MDContentElement>> *)extractTextElements;

/**
 * Extracts only image elements from the page.
 *
 * @return Array of image elements
 */
- (NSArray<id<PDF21MDContentElement>> *)extractImageElements;

/**
 * Captures vector graphics in the specified bounds as a rasterized image.
 *
 * @param bounds The area to capture
 * @param elements Array to add the captured image element to
 */
- (void)captureVectorGraphicsInBounds:(CGRect)bounds
                         withElements:(NSMutableArray<id<PDF21MDContentElement>> *)elements;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf21md/src/Core/PDF21MDPageProcessor.m">
#import "PDF21MDPageProcessor.h"
#import "../Models/PDF21MDTextElement.h"
#import "../Models/PDF21MDImageElement.h"
#import "PDF21MDFontAnalyzer.h"
#import <CoreGraphics/CoreGraphics.h>

#if TARGET_OS_MAC && !TARGET_OS_IPHONE
#import <AppKit/AppKit.h>
#import <AppKit/NSAttributedString.h>
#else
#import <UIKit/UIKit.h>
#endif

@interface PDF21MDPageProcessor ()
@property (nonatomic, assign) CGPDFPageRef cgPdfPage;
@end

@implementation PDF21MDPageProcessor

#pragma mark - Initialization

- (instancetype)initWithPDFPage:(PDFPage *)pdfPage
                      pageIndex:(NSInteger)pageIndex
                            dpi:(CGFloat)dpi {
    self = [super init];
    if (self) {
        _pdfPage = pdfPage;
        _pageIndex = pageIndex;
        _dpi = dpi;
        _cgPdfPage = [pdfPage pageRef];
    }
    return self;
}

#pragma mark - Public Methods

- (NSArray<id<PDF21MDContentElement>> *)extractContentElements {
    NSMutableArray<id<PDF21MDContentElement>> *elements = [NSMutableArray array];
    
    // Extract text elements
    NSArray *textElements = [self extractTextElements];
    [elements addObjectsFromArray:textElements];
    
    // Extract image elements
    NSArray *imageElements = [self extractImageElements];
    [elements addObjectsFromArray:imageElements];
    
    // Sort elements by position
    [self sortElementsByPosition:elements];
    
    return elements;
}

- (NSArray<id<PDF21MDContentElement>> *)extractTextElements {
    NSMutableArray<id<PDF21MDContentElement>> *elements = [NSMutableArray array];
    
    @try {
        // Use selections to iterate through text and get attributes
        // This is more robust than iterating through the attributed string directly
        PDFSelection *selection = [self.pdfPage selectionForRect:[self.pdfPage boundsForBox:kPDFDisplayBoxMediaBox]];
        NSArray<PDFSelection *> *selections = [selection selectionsByLine];
        
        for (PDFSelection *lineSelection in selections) {
            NSString *text = [lineSelection string];
            NSString *trimmed = [text stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
            
            if (trimmed.length > 0) {
                CGRect bounds = [lineSelection boundsForPage:self.pdfPage];
                NSAttributedString *attributedString = [lineSelection attributedString];
                
                if (attributedString.length > 0) {
                    NSDictionary *attributes = [attributedString attributesAtIndex:0 effectiveRange:NULL];
                    NSFont *font = attributes[NSFontAttributeName];
                    
                    NSString *fontName = font.fontName ?: @"Helvetica";
                    CGFloat fontSize = font.pointSize ?: 12.0;
                    BOOL isBold = (font.fontDescriptor.symbolicTraits & NSFontBoldTrait) != 0;
                    BOOL isItalic = (font.fontDescriptor.symbolicTraits & NSFontItalicTrait) != 0;
                    
                    PDF21MDTextElement *element = [[PDF21MDTextElement alloc] initWithText:trimmed
                                                                                    bounds:bounds
                                                                                 pageIndex:self.pageIndex
                                                                                  fontName:fontName
                                                                                  fontSize:fontSize
                                                                                    isBold:isBold
                                                                                  isItalic:isItalic];
                    [elements addObject:element];
                }
            }
        }
    } @catch (NSException *exception) {
        NSLog(@"Error extracting text from page %ld: %@", (long)self.pageIndex, exception.reason);
        return @[];
    }
    
    return elements;
}

- (NSArray<id<PDF21MDContentElement>> *)extractImageElements {
    NSMutableArray<id<PDF21MDContentElement>> *elements = [NSMutableArray array];
    
    @try {
        // Method 1: Extract images from annotations
        NSArray<PDFAnnotation *> *annotations = [self.pdfPage annotations];
    
    for (PDFAnnotation *annotation in annotations) {
        // Check if annotation might contain an image
        if ([self annotationMayContainImage:annotation]) {
            CGImageRef image = [self imageFromAnnotation:annotation];
            if (image) {
                PDF21MDImageElement *element = [[PDF21MDImageElement alloc] initWithImage:image
                                                                                   bounds:[annotation bounds]
                                                                                pageIndex:self.pageIndex
                                                                           isVectorSource:NO];
                [elements addObject:element];
                CGImageRelease(image);
            }
        }
    }
    
    // Method 2: Detect image regions by analyzing page content
    NSArray *imageRegions = [self detectImageRegionsInPage];
    for (NSData *regionData in imageRegions) {
        CGRect region;
        [regionData getBytes:&region length:sizeof(CGRect)];
        [self captureVectorGraphicsInBounds:region withElements:elements];
        }
        
    } @catch (NSException *exception) {
        NSLog(@"Error extracting images from page %ld: %@", (long)self.pageIndex, exception.reason);
        // Return what we have so far on error
    }
    
    return elements;
}

- (void)captureVectorGraphicsInBounds:(CGRect)bounds
                         withElements:(NSMutableArray<id<PDF21MDContentElement>> *)elements {
    // Expand bounds slightly to ensure we capture everything
    bounds = CGRectInset(bounds, -5, -5);
    
    // Calculate size at specified DPI
    CGFloat scale = self.dpi / 72.0;
    size_t width = (size_t)(CGRectGetWidth(bounds) * scale);
    size_t height = (size_t)(CGRectGetHeight(bounds) * scale);
    
    if (width == 0 || height == 0 || width > 4096 || height > 4096) {
        return;
    }
    
    // Create bitmap context
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, colorSpace,
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        return;
    }
    
    // Set white background
    CGContextSetRGBFillColor(context, 1.0, 1.0, 1.0, 1.0);
    CGContextFillRect(context, CGRectMake(0, 0, width, height));
    
    // Set up transformation to render just the bounds area
    CGContextSaveGState(context);
    CGContextScaleCTM(context, scale, scale);
    CGContextTranslateCTM(context, -bounds.origin.x, -bounds.origin.y);
    
    // Draw the PDF page
    CGContextDrawPDFPage(context, self.cgPdfPage);
    
    CGContextRestoreGState(context);
    
    // Create image
    CGImageRef image = CGBitmapContextCreateImage(context);
    CGContextRelease(context);
    
    if (image) {
        PDF21MDImageElement *element = [[PDF21MDImageElement alloc] initWithImage:image
                                                                           bounds:bounds
                                                                        pageIndex:self.pageIndex
                                                                   isVectorSource:YES];
        [elements addObject:element];
        CGImageRelease(image);
    }
}

#pragma mark - Private Methods

- (NSArray<NSString *> *)extractParagraphsFromPageText:(NSString *)pageText {
    // Split by multiple newlines to get paragraphs
    NSArray *components = [pageText componentsSeparatedByString:@"\n\n"];
    NSMutableArray *paragraphs = [NSMutableArray array];
    
    for (NSString *component in components) {
        // Further split by single newlines but join short lines
        NSArray *lines = [component componentsSeparatedByString:@"\n"];
        NSMutableString *paragraph = [NSMutableString string];
        
        for (NSString *line in lines) {
            NSString *trimmedLine = [line stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
            if (trimmedLine.length > 0) {
                if (paragraph.length > 0) {
                    // Add space between lines
                    [paragraph appendString:@" "];
                }
                [paragraph appendString:trimmedLine];
            }
        }
        
        if (paragraph.length > 0) {
            [paragraphs addObject:[paragraph copy]];
        }
    }
    
    return paragraphs;
}

- (NSDictionary *)extractFontInfoFromSelection:(PDFSelection *)selection {
    // Default font info
    NSMutableDictionary *fontInfo = [@{
        @"fontName": @"Helvetica",
        @"fontSize": @(12.0),
        @"isBold": @(NO),
        @"isItalic": @(NO)
    } mutableCopy];
    
    // PDFKit doesn't provide direct access to font information
    // This would require lower-level Core Graphics analysis
    // For now, we'll use heuristics based on the text content
    
    NSString *text = [selection string];
    if (text) {
        // Simple heuristic: all caps might indicate a heading
        if ([text isEqualToString:[text uppercaseString]] && text.length > 3) {
            fontInfo[@"fontSize"] = @(14.0);
            fontInfo[@"isBold"] = @(YES);
        }
    }
    
    return fontInfo;
}

- (BOOL)annotationMayContainImage:(PDFAnnotation *)annotation {
    // Check annotation type and bounds
    CGRect bounds = [annotation bounds];
    
    // Images typically have reasonable dimensions
    if (CGRectIsEmpty(bounds) || bounds.size.width < 10 || bounds.size.height < 10) {
        return NO;
    }
    
    // Check if it's not a text annotation
    NSString *contents = [annotation contents];
    if (contents && contents.length > 0) {
        return NO;
    }
    
    return YES;
}

- (CGImageRef)imageFromAnnotation:(PDFAnnotation *)annotation {
    CGRect bounds = [annotation bounds];
    
    // Create a bitmap context to render the annotation
    CGFloat scale = self.dpi / 72.0;
    size_t width = (size_t)(bounds.size.width * scale);
    size_t height = (size_t)(bounds.size.height * scale);
    
    if (width == 0 || height == 0 || width > 4096 || height > 4096) {
        return NULL;
    }
    
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, colorSpace,
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        return NULL;
    }
    
    // Set white background
    CGContextSetRGBFillColor(context, 1.0, 1.0, 1.0, 1.0);
    CGContextFillRect(context, CGRectMake(0, 0, width, height));
    
    // Transform context to match annotation bounds
    CGContextSaveGState(context);
    CGContextScaleCTM(context, scale, scale);
    
    // Draw just the annotation area from the page
    CGContextClipToRect(context, CGRectMake(0, 0, bounds.size.width, bounds.size.height));
    CGContextTranslateCTM(context, -bounds.origin.x, -bounds.origin.y);
    CGContextDrawPDFPage(context, self.cgPdfPage);
    
    CGContextRestoreGState(context);
    
    // Create image
    CGImageRef image = CGBitmapContextCreateImage(context);
    CGContextRelease(context);
    
    return image;
}

- (NSArray *)detectImageRegionsInPage {
    NSMutableArray *regions = [NSMutableArray array];
    
    // Simple heuristic: divide page into grid and check for non-text regions
    CGRect pageRect = [self.pdfPage boundsForBox:kPDFDisplayBoxMediaBox];
    CGFloat gridSize = 100.0;
    
    NSInteger gridX = (NSInteger)ceil(pageRect.size.width / gridSize);
    NSInteger gridY = (NSInteger)ceil(pageRect.size.height / gridSize);
    
    for (NSInteger x = 0; x < gridX; x++) {
        for (NSInteger y = 0; y < gridY; y++) {
            CGRect gridRect = CGRectMake(x * gridSize, y * gridSize, gridSize, gridSize);
            gridRect = CGRectIntersection(gridRect, pageRect);
            
            if (CGRectIsEmpty(gridRect) || gridRect.size.width < 20 || gridRect.size.height < 20) {
                continue;
            }
            
            // Check if this region contains primarily non-text content
            PDFSelection *selection = [self.pdfPage selectionForRect:gridRect];
            NSString *regionText = [[selection string] stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
            
            // If very little text, might be an image region
            if (regionText.length < 10) {
                NSData *rectData = [NSData dataWithBytes:&gridRect length:sizeof(CGRect)];
                [regions addObject:rectData];
            }
        }
    }
    
    // Merge adjacent regions
    return [self mergeAdjacentRegions:regions];
}

- (NSArray *)mergeAdjacentRegions:(NSArray *)regions {
    if (regions.count <= 1) {
        return regions;
    }
    
    NSMutableArray *mergedRegions = [NSMutableArray array];
    NSMutableSet *processedIndices = [NSMutableSet set];
    
    for (NSUInteger i = 0; i < regions.count; i++) {
        if ([processedIndices containsObject:@(i)]) {
            continue;
        }
        
        CGRect currentRect;
        [regions[i] getBytes:&currentRect length:sizeof(CGRect)];
        [processedIndices addObject:@(i)];
        
        // Try to merge with adjacent regions
        BOOL merged = YES;
        while (merged) {
            merged = NO;
            
            for (NSUInteger j = 0; j < regions.count; j++) {
                if ([processedIndices containsObject:@(j)]) {
                    continue;
                }
                
                CGRect otherRect;
                [regions[j] getBytes:&otherRect length:sizeof(CGRect)];
                
                // Check if rectangles are adjacent
                if (CGRectIntersectsRect(CGRectInset(currentRect, -10, -10), otherRect)) {
                    currentRect = CGRectUnion(currentRect, otherRect);
                    [processedIndices addObject:@(j)];
                    merged = YES;
                }
            }
        }
        
        NSData *rectData = [NSData dataWithBytes:&currentRect length:sizeof(CGRect)];
        [mergedRegions addObject:rectData];
    }
    
    return mergedRegions;
}

- (NSInteger)estimateLineCountForText:(NSString *)text inWidth:(CGFloat)width {
    // Simple estimation based on average character width
    CGFloat avgCharWidth = 7.0; // Approximate for 12pt font
    NSInteger charsPerLine = (NSInteger)(width / avgCharWidth);
    
    if (charsPerLine <= 0) {
        return 1;
    }
    
    return MAX(1, (text.length + charsPerLine - 1) / charsPerLine);
}

- (void)sortElementsByPosition:(NSMutableArray<id<PDF21MDContentElement>> *)elements {
    [elements sortUsingComparator:^NSComparisonResult(id<PDF21MDContentElement> obj1, id<PDF21MDContentElement> obj2) {
        // Sort by vertical position (top to bottom)
        CGFloat y1 = CGRectGetMaxY(obj1.bounds);
        CGFloat y2 = CGRectGetMaxY(obj2.bounds);
        
        if (fabs(y1 - y2) > 5.0) { // Tolerance for same line
            return y1 > y2 ? NSOrderedAscending : NSOrderedDescending;
        }
        
        // Same line, sort by horizontal position (left to right)
        CGFloat x1 = CGRectGetMinX(obj1.bounds);
        CGFloat x2 = CGRectGetMinX(obj2.bounds);
        
        return x1 < x2 ? NSOrderedAscending : NSOrderedDescending;
    }];
}

@end
</file>

<file path="pdf21md/src/Models/PDF21MDContentElement.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

/**
 * Protocol defining the interface for all content elements extracted from a PDF.
 * This includes text elements, image elements, and potentially other content types.
 */
@protocol PDF21MDContentElement <NSObject>

@required
/**
 * The bounding rectangle of this element in PDF coordinate space.
 */
@property (nonatomic, readonly) CGRect bounds;

/**
 * The zero-based index of the page this element was extracted from.
 */
@property (nonatomic, readonly) NSInteger pageIndex;

/**
 * Generates the Markdown representation of this element.
 * @return A string containing the Markdown formatted content, or nil if the element has no valid representation.
 */
- (nullable NSString *)markdownRepresentation;

@optional
/**
 * Additional metadata associated with this element.
 * The dictionary keys and values are element-type specific.
 */
- (NSDictionary<NSString *, id> *)metadata;

/**
 * The original extraction context for debugging purposes.
 */
- (NSString *)debugDescription;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf21md/src/Models/PDF21MDImageElement.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>
#import "PDF21MDContentElement.h"

NS_ASSUME_NONNULL_BEGIN

/**
 * Represents an image element extracted from a PDF page.
 * Handles both raster and vector graphics.
 */
@interface PDF21MDImageElement : NSObject <PDF21MDContentElement>

/**
 * The extracted image. Ownership is transferred to this object.
 */
@property (nonatomic, readonly) CGImageRef image;

/**
 * The bounding rectangle of this image in the PDF.
 */
@property (nonatomic, assign, readonly) CGRect bounds;

/**
 * The page index where this image was found.
 */
@property (nonatomic, assign, readonly) NSInteger pageIndex;

/**
 * Indicates whether this image was originally vector graphics.
 */
@property (nonatomic, assign, readonly) BOOL isVectorSource;

/**
 * The relative path to the saved asset file, if any.
 * This is set after the image has been extracted and saved.
 */
@property (nonatomic, copy, nullable) NSString *assetRelativePath;

/**
 * Designated initializer for creating an image element.
 *
 * @param image The CGImage (ownership is transferred)
 * @param bounds The bounding rectangle
 * @param pageIndex The page index
 * @param isVectorSource Whether this was originally vector graphics
 * @return A new image element instance
 */
- (instancetype)initWithImage:(CGImageRef)image
                       bounds:(CGRect)bounds
                    pageIndex:(NSInteger)pageIndex
               isVectorSource:(BOOL)isVectorSource NS_DESIGNATED_INITIALIZER;

- (instancetype)init NS_UNAVAILABLE;

/**
 * Analyzes the image to determine if JPEG compression would be suitable.
 * @return YES if JPEG is recommended, NO for PNG
 */
- (BOOL)shouldUseJPEGCompression;

/**
 * Gets the dimensions of the image.
 * @return The size in pixels
 */
- (CGSize)imageDimensions;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf21md/src/Models/PDF21MDImageElement.m">
#import "PDF21MDImageElement.h"

@implementation PDF21MDImageElement

#pragma mark - Initialization

- (instancetype)initWithImage:(CGImageRef)image
                       bounds:(CGRect)bounds
                    pageIndex:(NSInteger)pageIndex
               isVectorSource:(BOOL)isVectorSource {
    self = [super init];
    if (self) {
        _image = CGImageRetain(image);
        _bounds = bounds;
        _pageIndex = pageIndex;
        _isVectorSource = isVectorSource;
    }
    return self;
}

- (void)dealloc {
    if (_image) {
        CGImageRelease(_image);
    }
}

#pragma mark - PDF21MDContentElement Protocol

- (nullable NSString *)markdownRepresentation {
    if (!self.assetRelativePath) {
        return @"![Image](image-not-saved)";
    }
    
    return [NSString stringWithFormat:@"![Image](%@)", self.assetRelativePath];
}

- (NSDictionary<NSString *, id> *)metadata {
    CGSize dimensions = [self imageDimensions];
    
    return @{
        @"width": @(dimensions.width),
        @"height": @(dimensions.height),
        @"isVectorSource": @(self.isVectorSource),
        @"hasAlpha": @([self imageHasAlpha]),
        @"shouldUseJPEG": @([self shouldUseJPEGCompression])
    };
}

#pragma mark - Public Methods

- (CGSize)imageDimensions {
    if (!self.image) {
        return CGSizeZero;
    }
    
    return CGSizeMake(CGImageGetWidth(self.image), CGImageGetHeight(self.image));
}

- (BOOL)shouldUseJPEGCompression {
    if (!self.image) {
        return NO;
    }
    
    // If image has alpha channel, use PNG
    if ([self imageHasAlpha]) {
        return NO;
    }
    
    // For small images, use PNG
    CGSize dimensions = [self imageDimensions];
    if (dimensions.width * dimensions.height < 10000) { // Less than 100x100
        return NO;
    }
    
    // For vector sources, prefer PNG to maintain quality
    if (self.isVectorSource) {
        return NO;
    }
    
    // Analyze color complexity
    NSUInteger uniqueColors = [self estimateUniqueColorCount];
    
    // If we have many unique colors, it's likely a photograph - use JPEG
    return uniqueColors > 256;
}

#pragma mark - Private Methods

- (BOOL)imageHasAlpha {
    if (!self.image) {
        return NO;
    }
    
    CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(self.image);
    
    return alphaInfo != kCGImageAlphaNone &&
           alphaInfo != kCGImageAlphaNoneSkipFirst &&
           alphaInfo != kCGImageAlphaNoneSkipLast;
}

- (NSUInteger)estimateUniqueColorCount {
    if (!self.image) {
        return 0;
    }
    
    size_t width = CGImageGetWidth(self.image);
    size_t height = CGImageGetHeight(self.image);
    
    // Sample a subset of pixels for performance
    size_t sampleWidth = MIN(width, 100);
    size_t sampleHeight = MIN(height, 100);
    size_t __unused stepX = MAX(1, width / sampleWidth);
    size_t __unused stepY = MAX(1, height / sampleHeight);
    
    // Create a small bitmap context for sampling
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    size_t bytesPerRow = sampleWidth * 4;
    unsigned char *pixelData = calloc(sampleHeight * bytesPerRow, sizeof(unsigned char));
    
    if (!pixelData) {
        CGColorSpaceRelease(colorSpace);
        return 256; // Default to medium complexity
    }
    
    CGContextRef context = CGBitmapContextCreate(pixelData, sampleWidth, sampleHeight, 8, bytesPerRow, colorSpace,
                                                kCGImageAlphaNoneSkipLast | kCGBitmapByteOrder32Big);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        free(pixelData);
        return 256;
    }
    
    // Draw scaled image
    CGContextDrawImage(context, CGRectMake(0, 0, sampleWidth, sampleHeight), self.image);
    CGContextRelease(context);
    
    // Count unique colors
    NSMutableSet *uniqueColors = [NSMutableSet set];
    
    for (size_t y = 0; y < sampleHeight; y++) {
        for (size_t x = 0; x < sampleWidth; x++) {
            size_t offset = (y * bytesPerRow) + (x * 4);
            uint32_t color = (pixelData[offset] << 24) | 
                           (pixelData[offset + 1] << 16) | 
                           (pixelData[offset + 2] << 8) | 
                           pixelData[offset + 3];
            [uniqueColors addObject:@(color)];
            
            // Early exit if we already have many colors
            if (uniqueColors.count > 1000) {
                free(pixelData);
                return uniqueColors.count;
            }
        }
    }
    
    free(pixelData);
    return uniqueColors.count;
}

#pragma mark - NSObject

- (NSString *)description {
    CGSize dimensions = [self imageDimensions];
    return [NSString stringWithFormat:@"<%@: %p, size=%.0fx%.0f, bounds=%@, page=%ld>",
            NSStringFromClass([self class]),
            self,
            dimensions.width,
            dimensions.height,
            [NSString stringWithFormat:@"{{%.1f,%.1f},{%.1f,%.1f}}", self.bounds.origin.x, self.bounds.origin.y, self.bounds.size.width, self.bounds.size.height],
            (long)self.pageIndex];
}

- (NSString *)debugDescription {
    CGSize dimensions = [self imageDimensions];
    return [NSString stringWithFormat:@"<%@: %p> {\n  dimensions: %.0fx%.0f\n  bounds: %@\n  page: %ld\n  vector: %@\n  alpha: %@\n  path: %@\n}",
            NSStringFromClass([self class]),
            self,
            dimensions.width,
            dimensions.height,
            [NSString stringWithFormat:@"{{%.1f,%.1f},{%.1f,%.1f}}", self.bounds.origin.x, self.bounds.origin.y, self.bounds.size.width, self.bounds.size.height],
            (long)self.pageIndex,
            self.isVectorSource ? @"YES" : @"NO",
            [self imageHasAlpha] ? @"YES" : @"NO",
            self.assetRelativePath ?: @"<not saved>"];
}

- (BOOL)isEqual:(id)object {
    if (self == object) {
        return YES;
    }
    
    if (![object isKindOfClass:[PDF21MDImageElement class]]) {
        return NO;
    }
    
    PDF21MDImageElement *other = (PDF21MDImageElement *)object;
    
    return CGRectEqualToRect(self.bounds, other.bounds) &&
           self.pageIndex == other.pageIndex &&
           self.isVectorSource == other.isVectorSource &&
           (self.assetRelativePath == other.assetRelativePath || 
            [self.assetRelativePath isEqualToString:other.assetRelativePath]);
}

- (NSUInteger)hash {
    NSUInteger prime = 31;
    NSUInteger result = 1;
    
    result = prime * result + (NSUInteger)(self.bounds.origin.x + self.bounds.origin.y + self.bounds.size.width + self.bounds.size.height);
    result = prime * result + self.pageIndex;
    result = prime * result + (self.isVectorSource ? 1 : 0);
    result = prime * result + [self.assetRelativePath hash];
    
    return result;
}

@end
</file>

<file path="pdf21md/src/Models/PDF21MDTextElement.h">
#import <Foundation/Foundation.h>
#import "PDF21MDContentElement.h"

NS_ASSUME_NONNULL_BEGIN

/**
 * Represents a text element extracted from a PDF page.
 * Includes text content and associated styling information.
 */
@interface PDF21MDTextElement : NSObject <PDF21MDContentElement>

/**
 * The extracted text content. Never nil, but may be empty.
 */
@property (nonatomic, copy, readonly) NSString *text;

/**
 * The bounding rectangle of this text element.
 */
@property (nonatomic, assign, readonly) CGRect bounds;

/**
 * The page index where this text was found.
 */
@property (nonatomic, assign, readonly) NSInteger pageIndex;

/**
 * The font name used for this text, if available.
 */
@property (nonatomic, copy, nullable, readonly) NSString *fontName;

/**
 * The font size in points.
 */
@property (nonatomic, assign, readonly) CGFloat fontSize;

/**
 * Indicates if the text appears to be bold.
 */
@property (nonatomic, assign, readonly) BOOL isBold;

/**
 * Indicates if the text appears to be italic.
 */
@property (nonatomic, assign, readonly) BOOL isItalic;

/**
 * The detected heading level (0 for body text, 1-6 for headings).
 */
@property (nonatomic, assign) NSInteger headingLevel;

/**
 * Designated initializer for creating a text element.
 *
 * @param text The text content (required)
 * @param bounds The bounding rectangle
 * @param pageIndex The page index
 * @return A new text element instance
 */
- (instancetype)initWithText:(NSString *)text
                      bounds:(CGRect)bounds
                   pageIndex:(NSInteger)pageIndex;

/**
 * Convenience initializer with full styling information.
 *
 * @param text The text content
 * @param bounds The bounding rectangle
 * @param pageIndex The page index
 * @param fontName The font name (optional)
 * @param fontSize The font size
 * @param isBold Bold style flag
 * @param isItalic Italic style flag
 * @return A new text element instance
 */
- (instancetype)initWithText:(NSString *)text
                      bounds:(CGRect)bounds
                   pageIndex:(NSInteger)pageIndex
                    fontName:(nullable NSString *)fontName
                    fontSize:(CGFloat)fontSize
                      isBold:(BOOL)isBold
                    isItalic:(BOOL)isItalic NS_DESIGNATED_INITIALIZER;

- (instancetype)init NS_UNAVAILABLE;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf21md/src/Models/PDF21MDTextElement.m">
#import "PDF21MDTextElement.h"

@implementation PDF21MDTextElement

#pragma mark - Initialization

- (instancetype)initWithText:(NSString *)text
                      bounds:(CGRect)bounds
                   pageIndex:(NSInteger)pageIndex {
    return [self initWithText:text
                       bounds:bounds
                    pageIndex:pageIndex
                     fontName:nil
                     fontSize:12.0
                       isBold:NO
                     isItalic:NO];
}

- (instancetype)initWithText:(NSString *)text
                      bounds:(CGRect)bounds
                   pageIndex:(NSInteger)pageIndex
                    fontName:(nullable NSString *)fontName
                    fontSize:(CGFloat)fontSize
                      isBold:(BOOL)isBold
                    isItalic:(BOOL)isItalic {
    self = [super init];
    if (self) {
        _text = [text copy];
        _bounds = bounds;
        _pageIndex = pageIndex;
        _fontName = [fontName copy];
        _fontSize = fontSize;
        _isBold = isBold;
        _isItalic = isItalic;
        _headingLevel = 0; // Default to body text
    }
    return self;
}

#pragma mark - PDF21MDContentElement Protocol

- (nullable NSString *)markdownRepresentation {
    if (!self.text || self.text.length == 0) {
        return nil;
    }
    
    NSString *trimmedText = [self.text stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    if (trimmedText.length == 0) {
        return nil;
    }
    
    // Apply heading formatting
    if (self.headingLevel > 0 && self.headingLevel <= 6) {
        NSMutableString *heading = [NSMutableString string];
        for (NSInteger i = 0; i < self.headingLevel; i++) {
            [heading appendString:@"#"];
        }
        [heading appendString:@" "];
        [heading appendString:trimmedText];
        return heading;
    }
    
    // Apply bold/italic formatting
    NSString *formattedText = trimmedText;
    
    if (self.isBold && self.isItalic) {
        formattedText = [NSString stringWithFormat:@"***%@***", formattedText];
    } else if (self.isBold) {
        formattedText = [NSString stringWithFormat:@"**%@**", formattedText];
    } else if (self.isItalic) {
        formattedText = [NSString stringWithFormat:@"*%@*", formattedText];
    }
    
    return formattedText;
}

- (NSDictionary<NSString *, id> *)metadata {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    if (self.fontName) {
        metadata[@"fontName"] = self.fontName;
    }
    metadata[@"fontSize"] = @(self.fontSize);
    metadata[@"isBold"] = @(self.isBold);
    metadata[@"isItalic"] = @(self.isItalic);
    metadata[@"headingLevel"] = @(self.headingLevel);
    
    return [metadata copy];
}

#pragma mark - NSObject

- (NSString *)description {
    return [NSString stringWithFormat:@"<%@: %p, text='%@', bounds=%@, page=%ld>",
            NSStringFromClass([self class]),
            self,
            [self.text length] > 50 ? [[self.text substringToIndex:50] stringByAppendingString:@"..."] : self.text,
            [NSString stringWithFormat:@"{{%.1f,%.1f},{%.1f,%.1f}}", self.bounds.origin.x, self.bounds.origin.y, self.bounds.size.width, self.bounds.size.height],
            (long)self.pageIndex];
}

- (NSString *)debugDescription {
    return [NSString stringWithFormat:@"<%@: %p> {\n  text: '%@'\n  bounds: %@\n  page: %ld\n  font: %@\n  size: %.1f\n  bold: %@\n  italic: %@\n  heading: %ld\n}",
            NSStringFromClass([self class]),
            self,
            self.text,
            [NSString stringWithFormat:@"{{%.1f,%.1f},{%.1f,%.1f}}", self.bounds.origin.x, self.bounds.origin.y, self.bounds.size.width, self.bounds.size.height],
            (long)self.pageIndex,
            self.fontName ?: @"<unknown>",
            self.fontSize,
            self.isBold ? @"YES" : @"NO",
            self.isItalic ? @"YES" : @"NO",
            (long)self.headingLevel];
}

- (BOOL)isEqual:(id)object {
    if (self == object) {
        return YES;
    }
    
    if (![object isKindOfClass:[PDF21MDTextElement class]]) {
        return NO;
    }
    
    PDF21MDTextElement *other = (PDF21MDTextElement *)object;
    
    return [self.text isEqualToString:other.text] &&
           CGRectEqualToRect(self.bounds, other.bounds) &&
           self.pageIndex == other.pageIndex &&
           (self.fontName == other.fontName || [self.fontName isEqualToString:other.fontName]) &&
           self.fontSize == other.fontSize &&
           self.isBold == other.isBold &&
           self.isItalic == other.isItalic &&
           self.headingLevel == other.headingLevel;
}

- (NSUInteger)hash {
    NSUInteger prime = 31;
    NSUInteger result = 1;
    
    result = prime * result + [self.text hash];
    result = prime * result + (NSUInteger)(self.bounds.origin.x + self.bounds.origin.y + self.bounds.size.width + self.bounds.size.height);
    result = prime * result + self.pageIndex;
    result = prime * result + [self.fontName hash];
    result = prime * result + (NSUInteger)self.fontSize;
    result = prime * result + (self.isBold ? 1 : 0);
    result = prime * result + (self.isItalic ? 1 : 0);
    result = prime * result + self.headingLevel;
    
    return result;
}

@end
</file>

<file path="pdf21md/src/Services/PDF21MDAssetManager.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

@class PDF21MDImageElement;

/**
 * Manages the extraction and saving of assets (images) from PDF documents.
 * Thread-safe for concurrent image saving operations.
 */
@interface PDF21MDAssetManager : NSObject

/**
 * The base folder path where assets will be saved.
 */
@property (nonatomic, copy, readonly) NSString *assetsFolderPath;

/**
 * Initializes the asset manager with a folder path.
 * Creates the folder if it doesn't exist.
 *
 * @param folderPath The path where assets will be saved
 * @return A new instance, or nil if folder creation fails
 */
- (nullable instancetype)initWithAssetFolder:(NSString *)folderPath NS_DESIGNATED_INITIALIZER;

- (instancetype)init NS_UNAVAILABLE;

/**
 * Saves an image to the assets folder with automatic format selection.
 *
 * @param image The CGImage to save
 * @param isVectorSource Whether this image originated from vector graphics
 * @param baseName The base filename (without extension)
 * @return The relative path to the saved file, or nil on failure
 */
- (nullable NSString *)saveImage:(CGImageRef)image
                  isVectorSource:(BOOL)isVectorSource
                    withBaseName:(NSString *)baseName;

/**
 * Saves an image element to the assets folder.
 * Updates the element's assetRelativePath property on success.
 *
 * @param imageElement The image element to save
 * @param baseName The base filename (without extension)
 * @return The relative path to the saved file, or nil on failure
 */
- (nullable NSString *)saveImageElement:(PDF21MDImageElement *)imageElement
                           withBaseName:(NSString *)baseName;


/**
 * Gets the next available filename for the given base name.
 * Handles conflicts by appending numbers.
 *
 * @param baseName The desired base filename
 * @param extension The file extension (without dot)
 * @return A unique filename
 */
- (NSString *)uniqueFilenameForBaseName:(NSString *)baseName
                          withExtension:(NSString *)extension;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf21md/src/Services/PDF21MDAssetManager.m">
#import "PDF21MDAssetManager.h"
#import "../Models/PDF21MDImageElement.h"
#import "../../shared-algorithms/PDF21MDImageFormatDetection.h"
#import "../../shared-core/PDF21MDConcurrencyManager.h"
#import "../../shared-core/PDF21MDFileSystemUtils.h"
#import "../../shared-core/PDF21MDConstants.h"
#import <ImageIO/ImageIO.h>

@interface PDF21MDAssetManager ()
@property (nonatomic, strong) NSFileManager *fileManager;
@property (nonatomic, strong) dispatch_queue_t fileAccessQueue;
@property (nonatomic, strong) NSMutableSet<NSString *> *usedFilenames;
@end

@implementation PDF21MDAssetManager

#pragma mark - Initialization

- (nullable instancetype)initWithAssetFolder:(NSString *)folderPath {
    self = [super init];
    if (self) {
        _assetsFolderPath = [folderPath copy];
        _fileManager = [[NSFileManager alloc] init];
        _fileAccessQueue = [PDF21MDConcurrencyManager sharedFileAccessQueue];
        _usedFilenames = [NSMutableSet set];
        
        // Create assets folder if it doesn't exist
        NSError *error = nil;
        if (![PDF21MDFileSystemUtils ensureDirectoryExists:folderPath error:&error]) {
            NSLog(@"Failed to create assets folder: %@", error);
            return nil;
        }
    }
    return self;
}

#pragma mark - Public Methods

- (nullable NSString *)saveImage:(CGImageRef)image
                  isVectorSource:(BOOL)isVectorSource
                    withBaseName:(NSString *)baseName {
    if (!image) {
        return nil;
    }
    
    // Determine optimal format
    BOOL shouldUseJPEG = [PDF21MDImageFormatDetection shouldUseJPEGForImage:image isVectorSource:isVectorSource];
    
    NSString *extension = shouldUseJPEG ? @"jpg" : @"png";
    NSString *fileName = [self uniqueFilenameForBaseName:baseName withExtension:extension];
    NSString *fullPath = [self.assetsFolderPath stringByAppendingPathComponent:fileName];
    
    // Create destination
    NSURL *fileURL = [NSURL fileURLWithPath:fullPath];
    CGImageDestinationRef destination = CGImageDestinationCreateWithURL(
        (__bridge CFURLRef)fileURL,
        shouldUseJPEG ? (__bridge CFStringRef)@"public.jpeg" : (__bridge CFStringRef)@"public.png",
        1,
        NULL
    );
    
    if (!destination) {
        NSLog(@"Failed to create image destination for %@", fullPath);
        return nil;
    }
    
    // Set compression options
    NSDictionary *properties = nil;
    if (shouldUseJPEG) {
        properties = @{(__bridge NSString *)kCGImageDestinationLossyCompressionQuality: @(0.85)};
    } else {
        properties = @{(__bridge NSString *)kCGImagePropertyPNGCompressionFilter: @(1)};
    }
    
    // Add image to destination
    CGImageDestinationAddImage(destination, image, (__bridge CFDictionaryRef)properties);
    
    // Finalize
    BOOL success = CGImageDestinationFinalize(destination);
    CFRelease(destination);
    
    if (!success) {
        NSLog(@"Failed to save image to %@", fullPath);
        return nil;
    }
    
    // Return relative path (just the filename since it's in the assets folder)
    return fileName;
}

- (nullable NSString *)saveImageElement:(PDF21MDImageElement *)imageElement
                           withBaseName:(NSString *)baseName {
    NSString *savedPath = [self saveImage:imageElement.image
                           isVectorSource:imageElement.isVectorSource
                             withBaseName:baseName];
    
    if (savedPath) {
        imageElement.assetRelativePath = savedPath;
    }
    
    return savedPath;
}


- (NSString *)uniqueFilenameForBaseName:(NSString *)baseName
                          withExtension:(NSString *)extension {
    __block NSString *filename = nil;
    
    dispatch_sync(self.fileAccessQueue, ^{
        NSString *fullPath = [PDF21MDFileSystemUtils uniqueFilePathForBaseName:baseName
                                                                      extension:extension
                                                                    inDirectory:self.assetsFolderPath];
        if (fullPath) {
            filename = [fullPath lastPathComponent];
            [self.usedFilenames addObject:filename];
        } else {
            // Fallback to timestamp-based naming if unique path generation fails
            NSTimeInterval timestamp = [[NSDate date] timeIntervalSince1970];
            filename = [NSString stringWithFormat:@"%@_%.0f.%@", baseName, timestamp, extension];
            [self.usedFilenames addObject:filename];
        }
    });
    
    return filename;
}


@end
</file>

<file path="pdf21md/src/Services/PDF21MDMarkdownGenerator.h">
#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>

NS_ASSUME_NONNULL_BEGIN

@protocol PDF21MDContentElement;
@class PDF21MDConversionOptions;

/**
 * Metadata structure for YAML frontmatter generation.
 */
@interface PDF21MDDocumentMetadata : NSObject
@property (nonatomic, copy, nullable) NSString *title;
@property (nonatomic, copy, nullable) NSString *author;
@property (nonatomic, copy, nullable) NSString *subject;
@property (nonatomic, copy, nullable) NSArray<NSString *> *keywords;
@property (nonatomic, copy, nullable) NSString *creator;
@property (nonatomic, copy, nullable) NSString *producer;
@property (nonatomic, strong, nullable) NSDate *creationDate;
@property (nonatomic, strong, nullable) NSDate *modificationDate;
@property (nonatomic, assign) NSInteger pageCount;
@property (nonatomic, copy, nullable) NSString *pdfVersion;
@property (nonatomic, strong, nullable) PDFOutline *outline;
@end

/**
 * Generates Markdown output from PDF content elements.
 */
@interface PDF21MDMarkdownGenerator : NSObject

/**
 * Conversion options affecting markdown generation.
 */
@property (nonatomic, strong, readonly) PDF21MDConversionOptions *options;

/**
 * Initializes the generator with conversion options.
 *
 * @param options The conversion options to use
 * @return A new generator instance
 */
- (instancetype)initWithOptions:(PDF21MDConversionOptions *)options NS_DESIGNATED_INITIALIZER;

- (instancetype)init NS_UNAVAILABLE;

/**
 * Generates a complete markdown document from content elements.
 *
 * @param elements Array of content elements in reading order
 * @param metadata Document metadata for frontmatter
 * @return The generated markdown string
 */
- (NSString *)generateMarkdownFromElements:(NSArray<id<PDF21MDContentElement>> *)elements
                              withMetadata:(nullable PDF21MDDocumentMetadata *)metadata;

/**
 * Generates YAML frontmatter from document metadata.
 *
 * @param metadata The document metadata
 * @return YAML frontmatter string, or nil if includeMetadata is NO
 */
- (nullable NSString *)generateYAMLFrontmatter:(PDF21MDDocumentMetadata *)metadata;

/**
 * Generates markdown content from elements without frontmatter.
 *
 * @param elements Array of content elements
 * @return The markdown content
 */
- (NSString *)generateMarkdownContent:(NSArray<id<PDF21MDContentElement>> *)elements;

/**
 * Extracts metadata from a PDF document.
 *
 * @param document The PDF document
 * @return Populated metadata object
 */
+ (PDF21MDDocumentMetadata *)extractMetadataFromDocument:(PDFDocument *)document;

/**
 * Escapes a string for safe inclusion in YAML.
 *
 * @param string The string to escape
 * @return The escaped string
 */
+ (NSString *)escapeYAMLString:(NSString *)string;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf21md/src/Services/PDF21MDMarkdownGenerator.m">
#import "PDF21MDMarkdownGenerator.h"
#import "../Core/PDF21MDConversionOptions.h"
#import "../Models/PDF21MDContentElement.h"
#import "../Models/PDF21MDTextElement.h"

// Version string - should match the compiled version
#ifndef PDF21MD_VERSION
#define PDF21MD_VERSION "1.0.0"
#endif

@implementation PDF21MDDocumentMetadata
@end

@implementation PDF21MDMarkdownGenerator

#pragma mark - Initialization

- (instancetype)initWithOptions:(PDF21MDConversionOptions *)options {
    self = [super init];
    if (self) {
        _options = options;
    }
    return self;
}

#pragma mark - Public Methods

- (NSString *)generateMarkdownFromElements:(NSArray<id<PDF21MDContentElement>> *)elements
                              withMetadata:(nullable PDF21MDDocumentMetadata *)metadata {
    NSMutableString *markdown = [NSMutableString string];
    
    // Add YAML frontmatter if enabled
    if (self.options.includeMetadata && metadata) {
        NSString *frontmatter = [self generateYAMLFrontmatter:metadata];
        if (frontmatter) {
            [markdown appendString:frontmatter];
            [markdown appendString:@"\n"];
        }
    }
    
    // Generate content
    NSString *content = [self generateMarkdownContent:elements];
    [markdown appendString:content];
    
    // Clean up extra newlines
    NSString *finalMarkdown = [markdown stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    
    return finalMarkdown;
}

- (nullable NSString *)generateYAMLFrontmatter:(PDF21MDDocumentMetadata *)metadata {
    if (!self.options.includeMetadata) {
        return nil;
    }
    
    NSMutableString *yaml = [NSMutableString string];
    [yaml appendString:@"---\n"];
    
    // Basic metadata
    if (metadata.title && metadata.title.length > 0) {
        [yaml appendFormat:@"title: \"%@\"\n", [[self class] escapeYAMLString:metadata.title]];
    }
    
    if (metadata.author && metadata.author.length > 0) {
        [yaml appendFormat:@"author: \"%@\"\n", [[self class] escapeYAMLString:metadata.author]];
    }
    
    if (metadata.subject && metadata.subject.length > 0) {
        [yaml appendFormat:@"subject: \"%@\"\n", [[self class] escapeYAMLString:metadata.subject]];
    }
    
    // Keywords
    if (metadata.keywords && metadata.keywords.count > 0) {
        [yaml appendString:@"keywords:\n"];
        for (NSString *keyword in metadata.keywords) {
            [yaml appendFormat:@"  - \"%@\"\n", [[self class] escapeYAMLString:keyword]];
        }
    }
    
    // Creator and producer
    if (metadata.creator && metadata.creator.length > 0) {
        [yaml appendFormat:@"creator: \"%@\"\n", [[self class] escapeYAMLString:metadata.creator]];
    }
    
    if (metadata.producer && metadata.producer.length > 0) {
        [yaml appendFormat:@"producer: \"%@\"\n", [[self class] escapeYAMLString:metadata.producer]];
    }
    
    // Dates
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateFormat:@"yyyy-MM-dd'T'HH:mm:ssZZZZZ"];
    [formatter setLocale:[NSLocale localeWithLocaleIdentifier:@"en_US_POSIX"]];
    
    if (metadata.creationDate) {
        [yaml appendFormat:@"created: %@\n", [formatter stringFromDate:metadata.creationDate]];
    }
    
    if (metadata.modificationDate) {
        [yaml appendFormat:@"modified: %@\n", [formatter stringFromDate:metadata.modificationDate]];
    }
    
    // PDF specific metadata
    [yaml appendString:@"pdf_metadata:\n"];
    [yaml appendFormat:@"  page_count: %ld\n", (long)metadata.pageCount];
    
    if (metadata.pdfVersion && metadata.pdfVersion.length > 0) {
        [yaml appendFormat:@"  version: \"%@\"\n", metadata.pdfVersion];
    }
    
    // Outline/bookmarks
    if (self.options.preserveOutline && metadata.outline && [metadata.outline numberOfChildren] > 0) {
        [yaml appendString:@"  outline:\n"];
        [self appendOutlineToYAML:yaml outline:metadata.outline indent:@"    "];
    }
    
    // Conversion metadata
    [yaml appendString:@"conversion:\n"];
    [yaml appendString:@"  tool: \"pdf21md\"\n"];
    [yaml appendFormat:@"  version: \"%s\"\n", PDF21MD_VERSION];
    [yaml appendFormat:@"  date: %@\n", [formatter stringFromDate:[NSDate date]]];
    
    [yaml appendString:@"---\n"];
    
    return yaml;
}

- (NSString *)generateMarkdownContent:(NSArray<id<PDF21MDContentElement>> *)elements {
    NSMutableString *content = [NSMutableString string];
    
    id<PDF21MDContentElement> previousElement = nil;
    
    if (elements.count == 0) {
        NSLog(@"[DEBUG] No elements to generate markdown from.");
        return content;
    }

    for (id<PDF21MDContentElement> element in elements) {
        NSString *elementMarkdown = [element markdownRepresentation];
        if (!elementMarkdown || elementMarkdown.length == 0) {
            NSLog(@"[DEBUG] Element markdown representation is empty or nil for element: %@", element);
        }
        
        if (elementMarkdown && elementMarkdown.length > 0) {
            // Add appropriate spacing between elements
            if (previousElement) {
                // Check if we need extra spacing (e.g., between paragraphs)
                if ([self shouldAddExtraSpacingBetween:previousElement and:element]) {
                    [content appendString:@"\n\n"];
                } else {
                    [content appendString:@"\n"];
                }
            }
            
            [content appendString:elementMarkdown];
            previousElement = element;
        }
    }
    
    return content;
}

+ (PDF21MDDocumentMetadata *)extractMetadataFromDocument:(PDFDocument *)document {
    PDF21MDDocumentMetadata *metadata = [[PDF21MDDocumentMetadata alloc] init];
    
    // Get document attributes
    NSDictionary *attributes = [document documentAttributes];
    
    metadata.title = attributes[PDFDocumentTitleAttribute];
    metadata.author = attributes[PDFDocumentAuthorAttribute];
    metadata.subject = attributes[PDFDocumentSubjectAttribute];
    metadata.keywords = attributes[PDFDocumentKeywordsAttribute];
    metadata.creator = attributes[PDFDocumentCreatorAttribute];
    metadata.producer = attributes[PDFDocumentProducerAttribute];
    metadata.creationDate = attributes[PDFDocumentCreationDateAttribute];
    metadata.modificationDate = attributes[PDFDocumentModificationDateAttribute];
    
    metadata.pageCount = [document pageCount];
    metadata.outline = [document outlineRoot];
    
    // Try to extract PDF version
    metadata.pdfVersion = [self extractPDFVersionFromAttributes:attributes];
    
    return metadata;
}

+ (NSString *)escapeYAMLString:(NSString *)string {
    // Escape quotes and backslashes for YAML
    NSString *escaped = [string stringByReplacingOccurrencesOfString:@"\\" withString:@"\\\\"];
    escaped = [escaped stringByReplacingOccurrencesOfString:@"\"" withString:@"\\\""];
    escaped = [escaped stringByReplacingOccurrencesOfString:@"\n" withString:@"\\n"];
    escaped = [escaped stringByReplacingOccurrencesOfString:@"\r" withString:@"\\r"];
    escaped = [escaped stringByReplacingOccurrencesOfString:@"\t" withString:@"\\t"];
    return escaped;
}

#pragma mark - Private Methods

- (void)appendOutlineToYAML:(NSMutableString *)yaml outline:(PDFOutline *)outline indent:(NSString *)indent {
    for (NSUInteger i = 0; i < [outline numberOfChildren]; i++) {
        PDFOutline *child = [outline childAtIndex:i];
        NSString *label = [child label];
        
        if (label && label.length > 0) {
            [yaml appendFormat:@"%@- title: \"%@\"\n", indent, [[self class] escapeYAMLString:label]];
            
            PDFDestination *destination = [child destination];
            if (destination) {
                PDFPage *page = [destination page];
                if (page) {
                    // Note: We need the document to get page index, so this is an approximation
                    [yaml appendFormat:@"%@  page: %ld\n", indent, (long)1];
                }
            }
            
            if ([child numberOfChildren] > 0) {
                [yaml appendFormat:@"%@  children:\n", indent];
                NSString *newIndent = [indent stringByAppendingString:@"    "];
                [self appendOutlineToYAML:yaml outline:child indent:newIndent];
            }
        }
    }
}

+ (NSString *)extractPDFVersionFromAttributes:(NSDictionary *)attributes {
    // Look for PDF version in various attribute keys
    for (NSString *key in attributes) {
        id value = attributes[key];
        if ([value isKindOfClass:[NSString class]]) {
            NSString *stringValue = (NSString *)value;
            
            // Look for PDF version patterns
            NSRange pdfRange = [stringValue rangeOfString:@"PDF-" options:NSCaseInsensitiveSearch];
            if (pdfRange.location != NSNotFound) {
                // Extract version number after "PDF-"
                NSString *versionPart = [stringValue substringFromIndex:pdfRange.location];
                NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"PDF-?(\\d+\\.\\d+)"
                                                                                       options:NSRegularExpressionCaseInsensitive
                                                                                         error:nil];
                NSTextCheckingResult *match = [regex firstMatchInString:versionPart
                                                               options:0
                                                                 range:NSMakeRange(0, versionPart.length)];
                if (match && match.numberOfRanges > 1) {
                    return [versionPart substringWithRange:[match rangeAtIndex:1]];
                }
            }
        }
    }
    
    return nil;
}

- (BOOL)shouldAddExtraSpacingBetween:(id<PDF21MDContentElement>)element1 
                                 and:(id<PDF21MDContentElement>)element2 {
    // Add extra spacing between different element types
    if ([element1 class] != [element2 class]) {
        return YES;
    }
    
    // Add extra spacing after headings
    if ([element1 isKindOfClass:[PDF21MDTextElement class]]) {
        PDF21MDTextElement *textElement = (PDF21MDTextElement *)element1;
        if (textElement.headingLevel > 0) {
            return YES;
        }
    }
    
    // Add extra spacing between elements on different pages
    if (element1.pageIndex != element2.pageIndex) {
        return YES;
    }
    
    // Check vertical distance between elements
    CGFloat verticalDistance = fabs(CGRectGetMinY(element1.bounds) - CGRectGetMaxY(element2.bounds));
    if (verticalDistance > 20.0) { // Significant gap
        return YES;
    }
    
    return NO;
}

@end
</file>

<file path="pdf21md/test-resources/expected-outputs/README.md">
---
title: "README.md"
creator: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36 Edg/137.0.0.0"
producer: "Skia/PDF m137"
created: 2025-06-23T01:33:53+02:00
modified: 2025-06-23T01:33:53+02:00
pdf_metadata:
  page_count: 2
conversion:
  tool: "pdf22md"
  version: "v1.1.0-dirty"
  date: 2025-06-23T02:28:31+02:00
---

23/06/2025, 01:33 README.md

![Image](image_000.png)

![Image](image_001.png)

pdf22md

MIT

License MIT

License

10.15+

![Image](image_002.png)

![Image](image_003.png)

macOS 10.15+

macOS

Build and Release Build and Release passing passing

A blazingly fast PDF to Markdown converter for macOS.

pdf22md is a command-line tool that extracts all text and image content from a PDF file and converts it into a

![Image](image_004.png)

![Image](image_005.png)

![Image](image_006.png)

clean Markdown document. It uses Grand Central Dispatch (GCD) to process pages and save images in

parallel, making it exceptionally fast for multi-page documents.

Key Features

High-Speed Conversion: Uses all available CPU cores to process PDF pages concurrently

Intelligent Heading Detection: Analyzes font sizes and usage frequency to automatically format titles

![Image](image_007.png)

![Image](image_008.png)

![Image](image_009.png)

and headings ( # , ## , etc.)

Asset Extraction: Saves raster and vector images into a specified assets folder and links them correctly

in the Markdown file

Smart Image Formatting: Automatically chooses between JPEG (for photos) and PNG (for graphics with

transparency) to optimize file size and quality

Flexible I/O: Reads from a PDF file or stdin and writes to a Markdown file or stdout

![Image](image_010.png)

![Image](image_011.png)

![Image](image_012.png)

Customizable Rasterization: Allows setting a custom DPI for converting vector graphics to bitmaps

Installation

Using Homebrew (Coming Soon)

brew tap twardoch/pdf22md

brew install pdf22md

![Image](image_013.png)

![Image](image_014.png)

Building from Source

To build the project manually, you need Xcode Command Line Tools installed.

# Clone the repository

git clone https://github.com/twardoch/pdf22md.git

cd pdf22md

# Compile the tool

make

# Install it to /usr/local/bin (optional)

sudo make install

Download Pre-built Binary

Pre-built binaries are available from the Releases page.

Usage

Usage: pdf22md [-i input.pdf] [-o output.md] [-a assets

_

folder] [-d dpi]

Converts PDF documents to Markdown format

-i <path>: Input PDF file (default: stdin)

-o <path>: Output Markdown file (default: stdout)

-a <path>: Assets folder for extracted images

-d <dpi>: DPI for rasterizing vector graphics (default: 144)

Examples

# Convert a PDF file to Markdown

pdf22md -i document.pdf -o document.md

# Convert with images saved to an 'assets' folder

pdf22md -i report.pdf -o report.md -a ./assets

# Convert with custom DPI for vector graphics

pdf22md -i presentation.pdf -o presentation.md -a ./images -d 300

# Use with pipes

cat document.pdf | pdf22md > document.md

# Convert and view in less

pdf22md -i manual.pdf | less

Requirements

macOS 10.15 (Catalina) or later

Xcode Command Line Tools (for building from source)

Project Structure

pdf22md/

‚îú‚îÄ‚îÄ src/ # Source code

‚îÇ ‚îú‚îÄ‚îÄ main.m # Entry point

‚îÇ ‚îú‚îÄ‚îÄ PDFMarkdownConverter.* # Main conversion logic

‚îÇ ‚îú‚îÄ‚îÄ PDFPageProcessor.* # PDF page processing

‚îÇ ‚îú‚îÄ‚îÄ ContentElement.* # Content element definitions

‚îÇ ‚îî‚îÄ‚îÄ AssetExtractor.* # Image extraction logic

‚îú‚îÄ‚îÄ docs/ # Additional documentation

‚îú‚îÄ‚îÄ test/ # Test files

file:///Users/adam/Developer/vcs/github.twardoch/pub/pdf22md/README.md 1/2

23/06/2025, 01:33 README.md

![Image](image_015.png)

![Image](image_016.png)

‚îú‚îÄ‚îÄ LICENSE # MIT License

‚îú‚îÄ‚îÄ Makefile # Build configuration

‚îî‚îÄ‚îÄ README.md # This file

Contributing

Contributions are welcome! Please feel free to submit a Pull Request. For major changes, please open an

![Image](image_017.png)

![Image](image_018.png)

![Image](image_019.png)

issue first to discuss what you

would like to change.

1. Fork the repository

2. Create your feature branch ( git checkout -b feature/AmazingFeature )

3. Commit your changes ( git commit -m 'Add some AmazingFeature' )

![Image](image_020.png)

![Image](image_021.png)

![Image](image_022.png)

4. Push to the branch ( git push origin feature/AmazingFeature )

5. Open a Pull Request

License

This project is licensed under the MIT License - see the LICENSE file for details.

Acknowledgments

![Image](image_023.png)

![Image](image_024.png)

![Image](image_025.png)

![Image](image_026.png)

![Image](image_027.png)

Built with Apple‚Äôs PDFKit and Core Graphics frameworks

Parallel processing powered by Grand Central Dispatch (GCD)

Inspired by the need for fast, accurate PDF to Markdown conversion

Related Projects

pdfplumber - Python library for PDF processing

![Image](image_028.png)

pdf2md - Another PDF to Markdown converter

![Image](image_029.png)

![Image](image_030.png)

![Image](image_031.png)

![Image](image_032.png)

pandoc - Universal document converter

Changelog

See CHANGELOG.md for a list of changes in each version.

Support

If you encounter any issues or have questions, please open an issue on GitHub.

![Image](image_033.png)

![Image](image_034.png)

file:///Users/adam/Developer/vcs/github.twardoch/pub/pdf22md/README.md 2/2
</file>

<file path="pdf21md/Tests/Unit/AssetExtractorTests.m">
//
//  AssetExtractorTests.m
//  pdf22md
//
//  Unit tests for asset extraction and image processing functionality
//

#import <XCTest/XCTest.h>
#import <CoreGraphics/CoreGraphics.h>
#import <ImageIO/ImageIO.h>
#import "../../src/AssetExtractor.h"

@interface AssetExtractorTests : XCTestCase
@property (nonatomic, strong) AssetExtractor *extractor;
@property (nonatomic, strong) NSString *testAssetsPath;
@end

@implementation AssetExtractorTests

- (void)setUp {
    [super setUp];
    self.extractor = [[AssetExtractor alloc] init];
    
    // Create temporary test assets directory
    NSString *tempDir = NSTemporaryDirectory();
    self.testAssetsPath = [tempDir stringByAppendingPathComponent:@"pdf22md-test-assets"];
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    [fileManager createDirectoryAtPath:self.testAssetsPath 
           withIntermediateDirectories:YES 
                            attributes:nil 
                                 error:nil];
}

- (void)tearDown {
    // Clean up test assets directory
    NSFileManager *fileManager = [NSFileManager defaultManager];
    [fileManager removeItemAtPath:self.testAssetsPath error:nil];
    
    self.extractor = nil;
    self.testAssetsPath = nil;
    [super tearDown];
}

#pragma mark - Basic Functionality Tests

- (void)testExtractorInitialization {
    XCTAssertNotNil(self.extractor, @"AssetExtractor should initialize successfully");
}

- (void)testSetAssetsFolderPath {
    NSString *testPath = @"/tmp/test-assets";
    [self.extractor setAssetsFolderPath:testPath];
    
    // Note: We can't directly test the private property, but we can test that the method doesn't crash
    // and that subsequent operations work as expected
    XCTAssertTrue(YES, @"setAssetsFolderPath should complete without crashing");
}

#pragma mark - Image Format Detection Tests

- (void)testFormatOptimizationLogic {
    // Test the format optimization logic with synthetic images
    
    // Create a simple test image
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, 100, 100, 8, 0, colorSpace, 
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (context) {
        // Fill with a simple color
        CGContextSetRGBFillColor(context, 1.0, 0.0, 0.0, 1.0);
        CGContextFillRect(context, CGRectMake(0, 0, 100, 100));
        
        CGImageRef testImage = CGBitmapContextCreateImage(context);
        CGContextRelease(context);
        
        if (testImage) {
            // Test format decision logic
            BOOL shouldUseJPEG = [self.extractor shouldUseJPEGForImage:testImage];
            
            // For a simple solid color image, PNG should be preferred
            // (though the exact logic depends on implementation)
            XCTAssertTrue(shouldUseJPEG == YES || shouldUseJPEG == NO, 
                         @"shouldUseJPEGForImage should return a boolean value");
            
            CGImageRelease(testImage);
        }
    }
}

- (void)testImageSaving {
    // Test image saving functionality
    
    // Create a minimal test image
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, 50, 50, 8, 0, colorSpace, 
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (context) {
        // Create a gradient pattern for testing
        CGContextSetRGBFillColor(context, 0.5, 0.5, 1.0, 1.0);
        CGContextFillRect(context, CGRectMake(0, 0, 50, 50));
        
        CGImageRef testImage = CGBitmapContextCreateImage(context);
        CGContextRelease(context);
        
        if (testImage) {
            [self.extractor setAssetsFolderPath:self.testAssetsPath];
            
            NSString *savedPath = [self.extractor saveImage:testImage withBaseName:@"test_image"];
            
            if (savedPath) {
                // Verify the file was created
                NSString *fullPath = [self.testAssetsPath stringByAppendingPathComponent:savedPath];
                NSFileManager *fileManager = [NSFileManager defaultManager];
                XCTAssertTrue([fileManager fileExistsAtPath:fullPath], 
                             @"Saved image file should exist at path: %@", fullPath);
                
                // Verify it's a valid image file
                NSData *imageData = [NSData dataWithContentsOfFile:fullPath];
                XCTAssertNotNil(imageData, @"Should be able to read saved image data");
                XCTAssertTrue(imageData.length > 0, @"Saved image should have non-zero size");
            } else {
                XCTFail(@"saveImage should return a non-nil path");
            }
            
            CGImageRelease(testImage);
        }
    }
}

#pragma mark - File Naming Tests

- (void)testUniqueFileNaming {
    // Test that the extractor generates unique filenames
    [self.extractor setAssetsFolderPath:self.testAssetsPath];
    
    // Create multiple test images and verify unique naming
    for (int i = 0; i < 3; i++) {
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        CGContextRef context = CGBitmapContextCreate(NULL, 20, 20, 8, 0, colorSpace, 
                                                    kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
        CGColorSpaceRelease(colorSpace);
        
        if (context) {
            // Use different colors for each image
            CGFloat red = (i == 0) ? 1.0 : 0.0;
            CGFloat green = (i == 1) ? 1.0 : 0.0;
            CGFloat blue = (i == 2) ? 1.0 : 0.0;
            
            CGContextSetRGBFillColor(context, red, green, blue, 1.0);
            CGContextFillRect(context, CGRectMake(0, 0, 20, 20));
            
            CGImageRef testImage = CGBitmapContextCreateImage(context);
            CGContextRelease(context);
            
            if (testImage) {
                NSString *savedPath = [self.extractor saveImage:testImage withBaseName:@"test"];
                XCTAssertNotNil(savedPath, @"Should get a valid filename for image %d", i);
                
                CGImageRelease(testImage);
            }
        }
    }
    
    // Verify multiple files were created
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSArray *contents = [fileManager contentsOfDirectoryAtPath:self.testAssetsPath error:nil];
    XCTAssertTrue(contents.count >= 1, @"Should have created at least one image file");
}

#pragma mark - Error Handling Tests

- (void)testNilImageHandling {
    [self.extractor setAssetsFolderPath:self.testAssetsPath];
    
    NSString *result = [self.extractor saveImage:NULL withBaseName:@"test"];
    XCTAssertNil(result, @"Should return nil for NULL image");
}

- (void)testInvalidAssetsFolderHandling {
    // Test with invalid assets folder path
    NSString *invalidPath = @"/invalid/path/that/cannot/be/created";
    [self.extractor setAssetsFolderPath:invalidPath];
    
    // Create a test image
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, 10, 10, 8, 0, colorSpace, 
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (context) {
        CGContextSetRGBFillColor(context, 1.0, 1.0, 1.0, 1.0);
        CGContextFillRect(context, CGRectMake(0, 0, 10, 10));
        
        CGImageRef testImage = CGBitmapContextCreateImage(context);
        CGContextRelease(context);
        
        if (testImage) {
            NSString *result = [self.extractor saveImage:testImage withBaseName:@"test"];
            // Should handle the error gracefully (exact behavior depends on implementation)
            // At minimum, should not crash
            
            CGImageRelease(testImage);
        }
    }
}

#pragma mark - Performance Tests

- (void)testImageSavingPerformance {
    [self.extractor setAssetsFolderPath:self.testAssetsPath];
    
    [self measureBlock:^{
        // Create and save a test image
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        CGContextRef context = CGBitmapContextCreate(NULL, 100, 100, 8, 0, colorSpace, 
                                                    kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
        CGColorSpaceRelease(colorSpace);
        
        if (context) {
            CGContextSetRGBFillColor(context, 0.5, 0.5, 0.5, 1.0);
            CGContextFillRect(context, CGRectMake(0, 0, 100, 100));
            
            CGImageRef testImage = CGBitmapContextCreateImage(context);
            CGContextRelease(context);
            
            if (testImage) {
                [self.extractor saveImage:testImage withBaseName:@"perf_test"];
                CGImageRelease(testImage);
            }
        }
    }];
}

#pragma mark - Memory Management Tests

- (void)testMemoryManagement {
    // Test that multiple image operations don't cause memory issues
    [self.extractor setAssetsFolderPath:self.testAssetsPath];
    
    for (int i = 0; i < 10; i++) {
        @autoreleasepool {
            CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
            CGContextRef context = CGBitmapContextCreate(NULL, 50, 50, 8, 0, colorSpace, 
                                                        kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
            CGColorSpaceRelease(colorSpace);
            
            if (context) {
                CGContextSetRGBFillColor(context, (i % 3) / 3.0, ((i + 1) % 3) / 3.0, ((i + 2) % 3) / 3.0, 1.0);
                CGContextFillRect(context, CGRectMake(0, 0, 50, 50));
                
                CGImageRef testImage = CGBitmapContextCreateImage(context);
                CGContextRelease(context);
                
                if (testImage) {
                    NSString *baseName = [NSString stringWithFormat:@"memory_test_%d", i];
                    [self.extractor saveImage:testImage withBaseName:baseName];
                    CGImageRelease(testImage);
                }
            }
        }
    }
    
    // Verify files were created
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSArray *contents = [fileManager contentsOfDirectoryAtPath:self.testAssetsPath error:nil];
    XCTAssertTrue(contents.count > 0, @"Should have created image files during memory test");
}

@end
</file>

<file path="pdf21md/Tests/Unit/ContentElementTests.m">
//
//  ContentElementTests.m
//  pdf22md
//
//  Unit tests for ContentElement model and text/image element functionality
//

#import <XCTest/XCTest.h>
#import <CoreGraphics/CoreGraphics.h>
#import "../../src/ContentElement.h"

@interface ContentElementTests : XCTestCase
@end

@implementation ContentElementTests

- (void)setUp {
    [super setUp];
}

- (void)tearDown {
    [super tearDown];
}

#pragma mark - ContentElement Protocol Tests

- (void)testContentElementProtocolExists {
    // Verify that the ContentElement protocol exists and can be referenced
    Protocol *contentElementProtocol = @protocol(ContentElement);
    XCTAssertNotNil(contentElementProtocol, @"ContentElement protocol should exist");
}

#pragma mark - Text Element Tests

- (void)testTextElementCreation {
    // Test creation of text elements
    NSString *testText = @"Sample text content";
    CGRect testBounds = CGRectMake(10, 20, 200, 30);
    NSInteger testPage = 1;
    
    // Check if TextElement class exists and can be instantiated
    Class textElementClass = NSClassFromString(@"TextElement");
    if (textElementClass) {
        // Test basic instantiation
        id textElement = [[textElementClass alloc] init];
        XCTAssertNotNil(textElement, @"TextElement should be instantiable");
        
        // Test that it conforms to ContentElement protocol
        XCTAssertTrue([textElement conformsToProtocol:@protocol(ContentElement)], 
                     @"TextElement should conform to ContentElement protocol");
    } else {
        XCTFail(@"TextElement class should be available");
    }
}

- (void)testTextElementProperties {
    Class textElementClass = NSClassFromString(@"TextElement");
    if (textElementClass) {
        id textElement = [[textElementClass alloc] init];
        
        // Test basic property access (using KVC since we don't have direct access to the interface)
        NSString *testText = @"Test content";
        
        // Check if text property exists and can be set/get
        if ([textElement respondsToSelector:@selector(setText:)]) {
            [textElement performSelector:@selector(setText:) withObject:testText];
            
            if ([textElement respondsToSelector:@selector(text)]) {
                NSString *retrievedText = [textElement performSelector:@selector(text)];
                XCTAssertEqualObjects(retrievedText, testText, @"Text property should store and retrieve correctly");
            }
        }
        
        // Test bounds property if available
        if ([textElement respondsToSelector:@selector(setBounds:)]) {
            CGRect testBounds = CGRectMake(5, 10, 100, 20);
            NSValue *boundsValue = [NSValue valueWithCGRect:testBounds];
            [textElement performSelector:@selector(setBounds:) withObject:boundsValue];
            
            if ([textElement respondsToSelector:@selector(bounds)]) {
                NSValue *retrievedBounds = [textElement performSelector:@selector(bounds)];
                CGRect retrievedRect = [retrievedBounds CGRectValue];
                XCTAssertTrue(CGRectEqualToRect(retrievedRect, testBounds), 
                             @"Bounds property should store and retrieve correctly");
            }
        }
    }
}

#pragma mark - Image Element Tests

- (void)testImageElementCreation {
    Class imageElementClass = NSClassFromString(@"ImageElement");
    if (imageElementClass) {
        // Test basic instantiation
        id imageElement = [[imageElementClass alloc] init];
        XCTAssertNotNil(imageElement, @"ImageElement should be instantiable");
        
        // Test that it conforms to ContentElement protocol
        XCTAssertTrue([imageElement conformsToProtocol:@protocol(ContentElement)], 
                     @"ImageElement should conform to ContentElement protocol");
    } else {
        XCTFail(@"ImageElement class should be available");
    }
}

- (void)testImageElementWithCGImage {
    Class imageElementClass = NSClassFromString(@"ImageElement");
    if (imageElementClass) {
        // Create a test CGImage
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        CGContextRef context = CGBitmapContextCreate(NULL, 50, 50, 8, 0, colorSpace, 
                                                    kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
        CGColorSpaceRelease(colorSpace);
        
        if (context) {
            CGContextSetRGBFillColor(context, 1.0, 0.0, 0.0, 1.0);
            CGContextFillRect(context, CGRectMake(0, 0, 50, 50));
            
            CGImageRef testImage = CGBitmapContextCreateImage(context);
            CGContextRelease(context);
            
            if (testImage) {
                id imageElement = [[imageElementClass alloc] init];
                
                // Test image property if available
                if ([imageElement respondsToSelector:@selector(setImage:)]) {
                    // Note: CGImageRef is not an object, so we need to handle it appropriately
                    // This test may need adjustment based on the actual implementation
                    XCTAssertTrue(YES, @"Image element should be able to handle CGImageRef");
                }
                
                CGImageRelease(testImage);
            }
        }
    }
}

#pragma mark - Markdown Generation Tests

- (void)testMarkdownGeneration {
    // Test that elements can generate markdown representation
    Class textElementClass = NSClassFromString(@"TextElement");
    if (textElementClass) {
        id textElement = [[textElementClass alloc] init];
        
        if ([textElement respondsToSelector:@selector(markdownRepresentation)]) {
            NSString *markdown = [textElement performSelector:@selector(markdownRepresentation)];
            XCTAssertTrue([markdown isKindOfClass:[NSString class]], 
                         @"markdownRepresentation should return an NSString");
        } else {
            XCTFail(@"TextElement should implement markdownRepresentation method");
        }
    }
}

#pragma mark - Bounds and Positioning Tests

- (void)testBoundsHandling {
    // Test bounds property across different element types
    NSArray *elementClassNames = @[@"TextElement", @"ImageElement"];
    
    for (NSString *className in elementClassNames) {
        Class elementClass = NSClassFromString(className);
        if (elementClass) {
            id element = [[elementClass alloc] init];
            
            // Test bounds property
            if ([element respondsToSelector:@selector(bounds)]) {
                // Default bounds should be valid
                CGRect bounds = CGRectZero;
                if ([element respondsToSelector:@selector(bounds)]) {
                    NSValue *boundsValue = [element performSelector:@selector(bounds)];
                    if (boundsValue) {
                        bounds = [boundsValue CGRectValue];
                    }
                }
                
                // Bounds should be a valid rectangle (finite values)
                XCTAssertTrue(isfinite(bounds.origin.x) && isfinite(bounds.origin.y) && 
                             isfinite(bounds.size.width) && isfinite(bounds.size.height),
                             @"%@ bounds should have finite values", className);
            }
        }
    }
}

#pragma mark - Page Index Tests

- (void)testPageIndexProperty {
    // Test page index property across element types
    NSArray *elementClassNames = @[@"TextElement", @"ImageElement"];
    
    for (NSString *className in elementClassNames) {
        Class elementClass = NSClassFromString(className);
        if (elementClass) {
            id element = [[elementClass alloc] init];
            
            if ([element respondsToSelector:@selector(pageIndex)]) {
                NSInteger pageIndex = [[element performSelector:@selector(pageIndex)] integerValue];
                XCTAssertTrue(pageIndex >= 0, @"%@ pageIndex should be non-negative", className);
            }
            
            // Test setting page index if setter exists
            if ([element respondsToSelector:@selector(setPageIndex:)]) {
                NSInteger testPageIndex = 5;
                [element performSelector:@selector(setPageIndex:) withObject:@(testPageIndex)];
                
                if ([element respondsToSelector:@selector(pageIndex)]) {
                    NSInteger retrievedIndex = [[element performSelector:@selector(pageIndex)] integerValue];
                    XCTAssertEqual(retrievedIndex, testPageIndex, 
                                  @"%@ should store and retrieve pageIndex correctly", className);
                }
            }
        }
    }
}

#pragma mark - Memory Management Tests

- (void)testElementMemoryManagement {
    // Test that elements can be created and destroyed without memory issues
    for (int i = 0; i < 100; i++) {
        @autoreleasepool {
            Class textElementClass = NSClassFromString(@"TextElement");
            if (textElementClass) {
                id textElement = [[textElementClass alloc] init];
                
                // Set some properties to test memory handling
                if ([textElement respondsToSelector:@selector(setText:)]) {
                    NSString *testText = [NSString stringWithFormat:@"Test text %d", i];
                    [textElement performSelector:@selector(setText:) withObject:testText];
                }
                
                textElement = nil;
            }
            
            Class imageElementClass = NSClassFromString(@"ImageElement");
            if (imageElementClass) {
                id imageElement = [[imageElementClass alloc] init];
                imageElement = nil;
            }
        }
    }
    
    XCTAssertTrue(YES, @"Memory management test completed without crashes");
}

#pragma mark - Performance Tests

- (void)testElementCreationPerformance {
    [self measureBlock:^{
        for (int i = 0; i < 1000; i++) {
            @autoreleasepool {
                Class textElementClass = NSClassFromString(@"TextElement");
                if (textElementClass) {
                    id textElement = [[textElementClass alloc] init];
                    textElement = nil;
                }
            }
        }
    }];
}

- (void)testMarkdownGenerationPerformance {
    Class textElementClass = NSClassFromString(@"TextElement");
    if (textElementClass) {
        id textElement = [[textElementClass alloc] init];
        
        if ([textElement respondsToSelector:@selector(setText:)]) {
            [textElement performSelector:@selector(setText:) withObject:@"Sample text for performance testing"];
        }
        
        [self measureBlock:^{
            for (int i = 0; i < 1000; i++) {
                if ([textElement respondsToSelector:@selector(markdownRepresentation)]) {
                    [textElement performSelector:@selector(markdownRepresentation)];
                }
            }
        }];
    }
}

@end
</file>

<file path="pdf21md/Tests/Unit/PDF21MDAssetManagerTests.m">
//
//  PDF21MDAssetManagerTests.m
//  pdf22md-objc
//
//  Unit tests for PDF21MDAssetManager image extraction and management
//

#import <XCTest/XCTest.h>
#import "PDF21MDAssetManager.h"
#import "PDF21MDImageElement.h"
#import "PDF21MDError.h"

@interface PDF21MDAssetManagerTests : XCTestCase
@property (nonatomic, strong) PDF21MDAssetManager *assetManager;
@property (nonatomic, strong) NSString *tempAssetsPath;
@end

@implementation PDF21MDAssetManagerTests

- (void)setUp {
    [super setUp];
    
    // Create temporary assets directory
    self.tempAssetsPath = [NSTemporaryDirectory() stringByAppendingPathComponent:@"test-assets"];
    [[NSFileManager defaultManager] createDirectoryAtPath:self.tempAssetsPath 
                              withIntermediateDirectories:YES 
                                               attributes:nil 
                                                    error:nil];
    
    self.assetManager = [[PDF21MDAssetManager alloc] initWithAssetsPath:self.tempAssetsPath];
}

- (void)tearDown {
    // Clean up temporary directory
    [[NSFileManager defaultManager] removeItemAtPath:self.tempAssetsPath error:nil];
    self.assetManager = nil;
    [super tearDown];
}

#pragma mark - Initialization Tests

- (void)testAssetManagerInitialization {
    XCTAssertNotNil(self.assetManager, @"Asset manager should initialize successfully");
}

- (void)testInitializationWithNilPath {
    PDF21MDAssetManager *manager = [[PDF21MDAssetManager alloc] initWithAssetsPath:nil];
    XCTAssertNotNil(manager, @"Asset manager should handle nil assets path");
}

- (void)testAssetsDirectoryCreation {
    NSString *newPath = [NSTemporaryDirectory() stringByAppendingPathComponent:@"new-assets"];
    PDF21MDAssetManager *manager = [[PDF21MDAssetManager alloc] initWithAssetsPath:newPath];
    
    NSError *error = nil;
    BOOL success = [manager ensureAssetsDirectoryExists:&error];
    
    XCTAssertTrue(success, @"Should successfully create assets directory");
    XCTAssertNil(error, @"Should not return error when creating valid directory");
    
    BOOL isDirectory;
    BOOL exists = [[NSFileManager defaultManager] fileExistsAtPath:newPath isDirectory:&isDirectory];
    XCTAssertTrue(exists && isDirectory, @"Assets directory should exist and be a directory");
    
    // Clean up
    [[NSFileManager defaultManager] removeItemAtPath:newPath error:nil];
}

#pragma mark - Image Processing Tests

- (void)testImageElementCreation {
    // Create a simple test image (1x1 pixel)
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, 1, 1, 8, 4, colorSpace, kCGImageAlphaZero);
    CGImageRef cgImage = CGBitmapContextCreateImage(context);
    
    PDF21MDImageElement *element = [[PDF21MDImageElement alloc] initWithImage:cgImage 
                                                                        bounds:CGRectMake(0, 0, 100, 100) 
                                                                    pageNumber:1];
    
    XCTAssertNotNil(element, @"Should create image element successfully");
    XCTAssertEqual(element.pageNumber, 1, @"Page number should be set correctly");
    XCTAssertEqualWithAccuracy(element.bounds.size.width, 100.0, 0.1, @"Width should be set correctly");
    
    // Clean up
    CGImageRelease(cgImage);
    CGContextRelease(context);
    CGColorSpaceRelease(colorSpace);
}

- (void)testImageFormatSelection {
    // Test PNG selection for images with transparency
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, 10, 10, 8, 40, colorSpace, kCGImageAlphaFirst);
    CGImageRef transparentImage = CGBitmapContextCreateImage(context);
    
    NSString *format = [self.assetManager preferredFormatForImage:transparentImage];
    XCTAssertEqualObjects(format, @"png", @"Should prefer PNG for images with transparency");
    
    CGImageRelease(transparentImage);
    CGContextRelease(context);
    CGColorSpaceRelease(colorSpace);
}

- (void)testImageFilenameGeneration {
    NSString *filename1 = [self.assetManager generateFilenameForImageAtIndex:0 withFormat:@"png"];
    NSString *filename2 = [self.assetManager generateFilenameForImageAtIndex:1 withFormat:@"jpg"];
    NSString *filename3 = [self.assetManager generateFilenameForImageAtIndex:99 withFormat:@"png"];
    
    XCTAssertEqualObjects(filename1, @"image_001.png", @"Should generate correct filename for index 0");
    XCTAssertEqualObjects(filename2, @"image_002.jpg", @"Should generate correct filename for index 1");
    XCTAssertEqualObjects(filename3, @"image_100.png", @"Should generate correct filename for index 99");
}

#pragma mark - File Path Tests

- (void)testRelativePathGeneration {
    NSString *filename = @"image_001.png";
    NSString *relativePath = [self.assetManager relativePathForFilename:filename];
    
    NSString *expectedPath = [@"test-assets" stringByAppendingPathComponent:filename];
    XCTAssertEqualObjects(relativePath, expectedPath, @"Should generate correct relative path");
}

- (void)testAbsolutePathGeneration {
    NSString *filename = @"image_001.png";
    NSString *absolutePath = [self.assetManager absolutePathForFilename:filename];
    
    NSString *expectedPath = [self.tempAssetsPath stringByAppendingPathComponent:filename];
    XCTAssertEqualObjects(absolutePath, expectedPath, @"Should generate correct absolute path");
}

#pragma mark - Error Handling Tests

- (void)testInvalidAssetsPathHandling {
    // Try to create assets directory in a location that requires root access
    NSString *invalidPath = @"/usr/bin/invalid-assets";
    PDF21MDAssetManager *manager = [[PDF21MDAssetManager alloc] initWithAssetsPath:invalidPath];
    
    NSError *error = nil;
    BOOL success = [manager ensureAssetsDirectoryExists:&error];
    
    XCTAssertFalse(success, @"Should fail to create directory in invalid location");
    XCTAssertNotNil(error, @"Should return error for invalid directory creation");
    XCTAssertEqual(error.code, PDF21MDErrorAssetFolderCreation, @"Should return appropriate error code");
}

- (void)testNilImageHandling {
    NSString *result = [self.assetManager preferredFormatForImage:NULL];
    XCTAssertEqualObjects(result, @"png", @"Should default to PNG for nil image");
}

#pragma mark - Integration Tests

- (void)testCompleteImageSaveWorkflow {
    // Create a test image
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, 50, 50, 8, 200, colorSpace, kCGImageAlphaZero);
    
    // Draw something simple
    CGContextSetRGBFillColor(context, 1.0, 0.0, 0.0, 1.0);
    CGContextFillRect(context, CGRectMake(0, 0, 50, 50));
    
    CGImageRef testImage = CGBitmapContextCreateImage(context);
    
    // Test the save workflow
    NSError *error = nil;
    BOOL directoryCreated = [self.assetManager ensureAssetsDirectoryExists:&error];
    XCTAssertTrue(directoryCreated, @"Should create assets directory");
    
    NSString *filename = [self.assetManager generateFilenameForImageAtIndex:0 withFormat:@"png"];
    NSString *absolutePath = [self.assetManager absolutePathForFilename:filename];
    
    // Save image (this would normally be done by the asset manager)
    NSData *imageData = (__bridge_transfer NSData *)CGImagePNGRepresentation(testImage);
    BOOL saved = [imageData writeToFile:absolutePath atomically:YES];
    XCTAssertTrue(saved, @"Should save image successfully");
    
    // Verify file exists
    BOOL fileExists = [[NSFileManager defaultManager] fileExistsAtPath:absolutePath];
    XCTAssertTrue(fileExists, @"Saved image file should exist");
    
    // Clean up
    CGImageRelease(testImage);
    CGContextRelease(context);
    CGColorSpaceRelease(colorSpace);
}

#pragma mark - Performance Tests

- (void)testMultipleImageHandling {
    NSMutableArray *images = [NSMutableArray array];
    
    // Create multiple test images
    for (int i = 0; i < 10; i++) {
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        CGContextRef context = CGBitmapContextCreate(NULL, 10, 10, 8, 40, colorSpace, kCGImageAlphaZero);
        CGImageRef image = CGBitmapContextCreateImage(context);
        
        [images addObject:(__bridge id)image];
        
        CGContextRelease(context);
        CGColorSpaceRelease(colorSpace);
    }
    
    NSDate *startTime = [NSDate date];
    
    // Test filename generation for all images
    for (int i = 0; i < images.count; i++) {
        NSString *filename = [self.assetManager generateFilenameForImageAtIndex:i withFormat:@"png"];
        XCTAssertNotNil(filename, @"Should generate filename for image %d", i);
    }
    
    NSTimeInterval elapsed = [[NSDate date] timeIntervalSinceDate:startTime];
    XCTAssertLessThan(elapsed, 1.0, @"Should handle multiple images quickly");
    
    // Clean up images
    for (id image in images) {
        CGImageRelease((__bridge CGImageRef)image);
    }
}

// Helper function for PNG representation (normally would be in asset manager)
CFDataRef CGImagePNGRepresentation(CGImageRef image) {
    CFMutableDataRef data = CFDataCreateMutable(NULL, 0);
    CGImageDestinationRef destination = CGImageDestinationCreateWithData(data, kUTTypePNG, 1, NULL);
    
    if (destination) {
        CGImageDestinationAddImage(destination, image, NULL);
        CGImageDestinationFinalize(destination);
        CFRelease(destination);
    }
    
    return data;
}

@end
</file>

<file path="pdf21md/Tests/Unit/PDF21MDConverterTests.m">
//
//  PDF21MDConverterTests.m
//  pdf22md-objc
//
//  Unit tests for PDF21MDConverter core functionality
//

#import <XCTest/XCTest.h>
#import "PDF21MDConverter.h"
#import "PDF21MDConversionOptions.h"
#import "PDF21MDError.h"
#import "../../../shared/Core/PDF21MDErrorFactory.h"

@interface PDF21MDConverterTests : XCTestCase
@property (nonatomic, strong) PDF21MDConverter *converter;
@property (nonatomic, strong) PDF21MDConversionOptions *defaultOptions;
@property (nonatomic, strong) NSString *testResourcesPath;
@end

@implementation PDF21MDConverterTests

- (void)setUp {
    [super setUp];
    self.converter = [[PDF21MDConverter alloc] init];
    self.defaultOptions = [[PDF21MDConversionOptions alloc] init];
    
    // Set up test resources path
    NSBundle *bundle = [NSBundle bundleForClass:[self class]];
    self.testResourcesPath = [bundle.resourcePath stringByAppendingPathComponent:@"Tests/Resources"];
}

- (void)tearDown {
    self.converter = nil;
    self.defaultOptions = nil;
    [super tearDown];
}

#pragma mark - Initialization Tests

- (void)testConverterInitialization {
    XCTAssertNotNil(self.converter, @"Converter should initialize successfully");
}

- (void)testDefaultOptionsInitialization {
    XCTAssertNotNil(self.defaultOptions, @"Default options should initialize successfully");
    XCTAssertEqual(self.defaultOptions.dpi, 144, @"Default DPI should be 144");
    XCTAssertNil(self.defaultOptions.assetsPath, @"Default assets path should be nil");
}

#pragma mark - Input Validation Tests

- (void)testNilInputPathHandling {
    NSError *error = nil;
    NSString *result = [self.converter convertPDFAtPath:nil 
                                            withOptions:self.defaultOptions 
                                                  error:&error];
    
    XCTAssertNil(result, @"Should return nil for nil input path");
    XCTAssertNotNil(error, @"Should provide error for nil input path");
    XCTAssertEqual(error.code, PDF21MDErrorInvalidInput, @"Should return invalid input error");
}

- (void)testNonExistentFileHandling {
    NSError *error = nil;
    NSString *nonExistentPath = @"/tmp/nonexistent_file.pdf";
    NSString *result = [self.converter convertPDFAtPath:nonExistentPath 
                                            withOptions:self.defaultOptions 
                                                  error:&error];
    
    XCTAssertNil(result, @"Should return nil for nonexistent file");
    XCTAssertNotNil(error, @"Should provide error for nonexistent file");
    XCTAssertEqual(error.code, PDF21MDErrorFileNotFound, @"Should return file not found error");
}

- (void)testNonPDFFileHandling {
    NSError *error = nil;
    
    // Create a temporary text file
    NSString *tempPath = [NSTemporaryDirectory() stringByAppendingPathComponent:@"test.txt"];
    [@"This is not a PDF" writeToFile:tempPath 
                           atomically:YES 
                             encoding:NSUTF8StringEncoding 
                                error:nil];
    
    NSString *result = [self.converter convertPDFAtPath:tempPath 
                                            withOptions:self.defaultOptions 
                                                  error:&error];
    
    XCTAssertNil(result, @"Should return nil for non-PDF file");
    XCTAssertNotNil(error, @"Should provide error for non-PDF file");
    XCTAssertEqual(error.code, PDF21MDErrorInvalidPDF, @"Should return invalid PDF error");
    
    // Clean up
    [[NSFileManager defaultManager] removeItemAtPath:tempPath error:nil];
}

#pragma mark - Basic Conversion Tests

- (void)testBasicTextConversion {
    // This test would require a simple test PDF file
    // For now, we'll create a placeholder that demonstrates the expected behavior
    
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"simple-text.pdf"];
    
    // Skip test if resource file doesn't exist (expected during initial setup)
    if (![[NSFileManager defaultManager] fileExistsAtPath:testPDFPath]) {
        NSLog(@"Test PDF not found at %@, skipping test", testPDFPath);
        return;
    }
    
    NSError *error = nil;
    NSString *result = [self.converter convertPDFAtPath:testPDFPath 
                                            withOptions:self.defaultOptions 
                                                  error:&error];
    
    XCTAssertNotNil(result, @"Should successfully convert simple text PDF");
    XCTAssertNil(error, @"Should not return error for valid PDF");
    XCTAssertTrue([result containsString:@"#"], @"Should contain markdown headers");
    XCTAssertTrue(result.length > 0, @"Should return non-empty markdown");
}

#pragma mark - Options Validation Tests

- (void)testCustomDPIOption {
    PDF21MDConversionOptions *options = [[PDF21MDConversionOptions alloc] init];
    options.dpi = 300;
    
    XCTAssertEqual(options.dpi, 300, @"Should accept custom DPI value");
}

- (void)testAssetsPathOption {
    PDF21MDConversionOptions *options = [[PDF21MDConversionOptions alloc] init];
    options.assetsPath = @"/tmp/assets";
    
    XCTAssertEqualObjects(options.assetsPath, @"/tmp/assets", @"Should accept custom assets path");
}

#pragma mark - Memory Management Tests

- (void)testMemoryManagement {
    // Test that repeated conversions don't cause memory leaks
    for (int i = 0; i < 10; i++) {
        @autoreleasepool {
            PDF21MDConverter *tempConverter = [[PDF21MDConverter alloc] init];
            PDF21MDConversionOptions *tempOptions = [[PDF21MDConversionOptions alloc] init];
            
            XCTAssertNotNil(tempConverter, @"Converter should initialize in loop iteration %d", i);
            XCTAssertNotNil(tempOptions, @"Options should initialize in loop iteration %d", i);
        }
    }
}

#pragma mark - Error Handling Tests

- (void)testErrorMessageQuality {
    NSError *error = nil;
    NSString *result = [self.converter convertPDFAtPath:@"/nonexistent/path.pdf" 
                                            withOptions:self.defaultOptions 
                                                  error:&error];
    
    XCTAssertNil(result, @"Should return nil for invalid path");
    XCTAssertNotNil(error, @"Should provide error");
    XCTAssertNotNil(error.localizedDescription, @"Error should have localized description");
    XCTAssertTrue(error.localizedDescription.length > 0, @"Error description should not be empty");
    XCTAssertFalse([error.localizedDescription containsString:@"nil"], @"Error description should not contain 'nil'");
}

@end
</file>

<file path="pdf21md/Tests/Unit/PDF21MDFontAnalyzerTests.m">
//
//  PDF21MDFontAnalyzerTests.m
//  pdf22md-objc
//
//  Unit tests for PDF21MDFontAnalyzer heading detection logic
//

#import <XCTest/XCTest.h>
#import "PDF21MDFontAnalyzer.h"

@interface PDF21MDFontAnalyzerTests : XCTestCase
@property (nonatomic, strong) PDF21MDFontAnalyzer *analyzer;
@end

@implementation PDF21MDFontAnalyzerTests

- (void)setUp {
    [super setUp];
    self.analyzer = [[PDF21MDFontAnalyzer alloc] init];
}

- (void)tearDown {
    self.analyzer = nil;
    [super tearDown];
}

#pragma mark - Initialization Tests

- (void)testAnalyzerInitialization {
    XCTAssertNotNil(self.analyzer, @"Font analyzer should initialize successfully");
}

#pragma mark - Font Size Analysis Tests

- (void)testBasicFontSizeAnalysis {
    // Test the core font size analysis functionality
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    
    // Simulate typical document font usage
    fontSizes[@"12.0"] = @100;  // Body text - most frequent
    fontSizes[@"18.0"] = @5;    // Major heading
    fontSizes[@"16.0"] = @8;    // Minor heading
    fontSizes[@"14.0"] = @12;   // Subheading
    
    [self.analyzer analyzeFontSizes:fontSizes];
    
    // Test heading level assignment
    NSInteger h1Level = [self.analyzer headingLevelForFontSize:18.0];
    NSInteger h2Level = [self.analyzer headingLevelForFontSize:16.0];
    NSInteger h3Level = [self.analyzer headingLevelForFontSize:14.0];
    NSInteger bodyLevel = [self.analyzer headingLevelForFontSize:12.0];
    
    XCTAssertEqual(h1Level, 1, @"Largest non-body font should be H1");
    XCTAssertEqual(h2Level, 2, @"Second largest font should be H2");
    XCTAssertEqual(h3Level, 3, @"Third largest font should be H3");
    XCTAssertEqual(bodyLevel, 0, @"Most frequent font should be body text (level 0)");
}

- (void)testSingleFontSizeDocument {
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    fontSizes[@"12.0"] = @100;  // Only one font size
    
    [self.analyzer analyzeFontSizes:fontSizes];
    
    NSInteger level = [self.analyzer headingLevelForFontSize:12.0];
    XCTAssertEqual(level, 0, @"Single font size should be treated as body text");
}

- (void)testEmptyFontAnalysis {
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    
    [self.analyzer analyzeFontSizes:fontSizes];
    
    NSInteger level = [self.analyzer headingLevelForFontSize:12.0];
    XCTAssertEqual(level, 0, @"Unknown font size should default to body text");
}

#pragma mark - Edge Case Tests

- (void)testVerySmallFontSizes {
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    fontSizes[@"8.0"] = @50;    // Small body text
    fontSizes[@"10.0"] = @5;    // Slightly larger
    
    [self.analyzer analyzeFontSizes:fontSizes];
    
    NSInteger smallLevel = [self.analyzer headingLevelForFontSize:8.0];
    NSInteger largerLevel = [self.analyzer headingLevelForFontSize:10.0];
    
    XCTAssertEqual(smallLevel, 0, @"Most frequent small font should be body text");
    XCTAssertEqual(largerLevel, 1, @"Less frequent larger font should be heading");
}

- (void)testVeryLargeFontSizes {
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    fontSizes[@"12.0"] = @100;  // Body text
    fontSizes[@"72.0"] = @1;    // Very large title
    fontSizes[@"48.0"] = @2;    // Large heading
    fontSizes[@"36.0"] = @3;    // Medium heading
    
    [self.analyzer analyzeFontSizes:fontSizes];
    
    NSInteger titleLevel = [self.analyzer headingLevelForFontSize:72.0];
    NSInteger h1Level = [self.analyzer headingLevelForFontSize:48.0];
    NSInteger h2Level = [self.analyzer headingLevelForFontSize:36.0];
    
    XCTAssertEqual(titleLevel, 1, @"Largest font should be H1");
    XCTAssertEqual(h1Level, 2, @"Second largest should be H2");
    XCTAssertEqual(h2Level, 3, @"Third largest should be H3");
}

#pragma mark - Frequency Analysis Tests

- (void)testFrequencyBasedBodyTextDetection {
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    fontSizes[@"12.0"] = @200;  // Very frequent - clearly body text
    fontSizes[@"14.0"] = @150;  // Also frequent - might be body text too
    fontSizes[@"18.0"] = @5;    // Infrequent - heading
    
    [self.analyzer analyzeFontSizes:fontSizes];
    
    NSInteger mostFrequentLevel = [self.analyzer headingLevelForFontSize:12.0];
    NSInteger secondFrequentLevel = [self.analyzer headingLevelForFontSize:14.0];
    NSInteger infrequentLevel = [self.analyzer headingLevelForFontSize:18.0];
    
    XCTAssertEqual(mostFrequentLevel, 0, @"Most frequent font should be body text");
    // The second most frequent could be body or heading depending on algorithm
    XCTAssertTrue(infrequentLevel > 0, @"Infrequent large font should be a heading");
}

#pragma mark - Heading Level Limits Tests

- (void)testMaximumHeadingLevels {
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    fontSizes[@"12.0"] = @100;  // Body
    
    // Add many different heading sizes
    for (int i = 1; i <= 10; i++) {
        fontSizes[[NSString stringWithFormat:@"%.1f", 12.0 + i * 2]] = @(10 - i);
    }
    
    [self.analyzer analyzeFontSizes:fontSizes];
    
    // Check that we don't exceed H6 (level 6)
    NSInteger maxLevel = 0;
    for (NSString *sizeStr in fontSizes.allKeys) {
        CGFloat size = [sizeStr floatValue];
        NSInteger level = [self.analyzer headingLevelForFontSize:size];
        if (level > maxLevel) {
            maxLevel = level;
        }
    }
    
    XCTAssertLessThanOrEqual(maxLevel, 6, @"Should not exceed H6 (level 6)");
}

#pragma mark - Performance Tests

- (void)testLargeFontSetPerformance {
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    
    // Create a large set of font sizes to test performance
    for (int i = 8; i <= 72; i++) {
        fontSizes[[NSString stringWithFormat:@"%.1f", (CGFloat)i]] = @(arc4random() % 100 + 1);
    }
    
    NSDate *startTime = [NSDate date];
    [self.analyzer analyzeFontSizes:fontSizes];
    NSTimeInterval elapsed = [[NSDate date] timeIntervalSinceDate:startTime];
    
    XCTAssertLessThan(elapsed, 1.0, @"Font analysis should complete within 1 second for large font set");
}

#pragma mark - Algorithm Consistency Tests

- (void)testConsistentResults {
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    fontSizes[@"12.0"] = @100;
    fontSizes[@"16.0"] = @10;
    fontSizes[@"20.0"] = @5;
    
    // Run analysis multiple times
    [self.analyzer analyzeFontSizes:fontSizes];
    NSInteger firstRun16 = [self.analyzer headingLevelForFontSize:16.0];
    NSInteger firstRun20 = [self.analyzer headingLevelForFontSize:20.0];
    
    [self.analyzer analyzeFontSizes:fontSizes];
    NSInteger secondRun16 = [self.analyzer headingLevelForFontSize:16.0];
    NSInteger secondRun20 = [self.analyzer headingLevelForFontSize:20.0];
    
    XCTAssertEqual(firstRun16, secondRun16, @"Font analysis should be consistent across runs");
    XCTAssertEqual(firstRun20, secondRun20, @"Font analysis should be consistent across runs");
}

@end
</file>

<file path="pdf21md/Tests/Unit/PDFMarkdownConverterTests.m">
//
//  PDFMarkdownConverterTests.m
//  pdf22md
//
//  Unit tests for core PDF to Markdown conversion functionality
//

#import <XCTest/XCTest.h>
#import "../../src/PDFMarkdownConverter.h"
#import "../../src/AssetExtractor.h"
#import "../../src/ContentElement.h"

@interface PDFMarkdownConverterTests : XCTestCase
@property (nonatomic, strong) PDFMarkdownConverter *converter;
@property (nonatomic, strong) NSString *testResourcesPath;
@end

@implementation PDFMarkdownConverterTests

- (void)setUp {
    [super setUp];
    self.converter = [[PDFMarkdownConverter alloc] init];
    
    // Set up test resources path
    NSBundle *testBundle = [NSBundle bundleForClass:[self class]];
    self.testResourcesPath = [testBundle.bundlePath stringByAppendingPathComponent:@"Resources"];
    
    // Ensure test resources directory exists
    NSFileManager *fileManager = [NSFileManager defaultManager];
    if (![fileManager fileExistsAtPath:self.testResourcesPath]) {
        [fileManager createDirectoryAtPath:self.testResourcesPath 
               withIntermediateDirectories:YES 
                                attributes:nil 
                                     error:nil];
    }
}

- (void)tearDown {
    self.converter = nil;
    self.testResourcesPath = nil;
    [super tearDown];
}

#pragma mark - Basic Functionality Tests

- (void)testConverterInitialization {
    XCTAssertNotNil(self.converter, @"PDFMarkdownConverter should initialize successfully");
}

- (void)testInvalidPDFHandling {
    // Test with nil input
    NSString *result = [self.converter convertPDFAtPath:nil 
                                          assetsFolderPath:nil 
                                                       dpi:144];
    XCTAssertNil(result, @"Converter should return nil for nil input path");
    
    // Test with non-existent file
    NSString *nonExistentPath = @"/path/that/does/not/exist.pdf";
    result = [self.converter convertPDFAtPath:nonExistentPath 
                               assetsFolderPath:nil 
                                            dpi:144];
    XCTAssertNil(result, @"Converter should return nil for non-existent file");
}

- (void)testEmptyStringHandling {
    // Test with empty string
    NSString *result = [self.converter convertPDFAtPath:@"" 
                                          assetsFolderPath:nil 
                                                       dpi:144];
    XCTAssertNil(result, @"Converter should return nil for empty string path");
}

- (void)testDPIParameterValidation {
    // Create a minimal test PDF path (we'll use an existing test file)
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"simple-test.pdf"];
    
    // Test with invalid DPI values
    NSString *result = [self.converter convertPDFAtPath:testPDFPath 
                                          assetsFolderPath:nil 
                                                       dpi:0];
    // Should still work with fallback DPI or return error gracefully
    // The exact behavior depends on implementation, but should not crash
    
    result = [self.converter convertPDFAtPath:testPDFPath 
                               assetsFolderPath:nil 
                                            dpi:-144];
    // Should handle negative DPI gracefully
}

#pragma mark - Asset Folder Tests

- (void)testAssetFolderCreation {
    NSString *tempDir = NSTemporaryDirectory();
    NSString *testAssetsFolder = [tempDir stringByAppendingPathComponent:@"test-assets"];
    
    // Clean up any existing test folder
    NSFileManager *fileManager = [NSFileManager defaultManager];
    [fileManager removeItemAtPath:testAssetsFolder error:nil];
    
    // Verify folder doesn't exist initially
    XCTAssertFalse([fileManager fileExistsAtPath:testAssetsFolder], 
                   @"Test assets folder should not exist initially");
    
    // Test folder creation during conversion (with a valid PDF)
    // For now, just test that the method accepts the parameter
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"simple-test.pdf"];
    [self.converter convertPDFAtPath:testPDFPath 
                      assetsFolderPath:testAssetsFolder 
                                   dpi:144];
    
    // Clean up
    [fileManager removeItemAtPath:testAssetsFolder error:nil];
}

#pragma mark - Memory Management Tests

- (void)testMemoryManagement {
    // Test that converter handles multiple conversions without memory issues
    for (int i = 0; i < 10; i++) {
        @autoreleasepool {
            PDFMarkdownConverter *tempConverter = [[PDFMarkdownConverter alloc] init];
            
            // Test with nil path to avoid actual file I/O
            NSString *result = [tempConverter convertPDFAtPath:nil 
                                               assetsFolderPath:nil 
                                                            dpi:144];
            XCTAssertNil(result, @"Should handle nil input gracefully");
            
            tempConverter = nil;
        }
    }
}

#pragma mark - Performance Tests

- (void)testPerformanceBaseline {
    // Simple performance test to establish baseline
    [self measureBlock:^{
        // Test basic object creation and method call
        PDFMarkdownConverter *converter = [[PDFMarkdownConverter alloc] init];
        [converter convertPDFAtPath:nil assetsFolderPath:nil dpi:144];
    }];
}

#pragma mark - Error Handling Tests

- (void)testErrorConditions {
    // Test various error conditions that should be handled gracefully
    NSArray *invalidPaths = @[
        @"",
        @"not-a-pdf.txt",
        @"/dev/null",
        @"~/nonexistent/path/file.pdf"
    ];
    
    for (NSString *invalidPath in invalidPaths) {
        NSString *result = [self.converter convertPDFAtPath:invalidPath 
                                            assetsFolderPath:nil 
                                                         dpi:144];
        XCTAssertNil(result, @"Should handle invalid path gracefully: %@", invalidPath);
    }
}

#pragma mark - Integration Points Tests

- (void)testAssetExtractorIntegration {
    // Test that converter properly integrates with AssetExtractor
    // This is a basic smoke test for the integration
    AssetExtractor *extractor = [[AssetExtractor alloc] init];
    XCTAssertNotNil(extractor, @"AssetExtractor should initialize for integration testing");
}

- (void)testContentElementIntegration {
    // Test that converter properly works with ContentElement classes
    // This verifies the model layer integration
    XCTAssertTrue([NSClassFromString(@"ContentElement") conformsToProtocol:@protocol(NSObject)], 
                  @"ContentElement should be available for integration");
}

@end
</file>

<file path="pdf22md/Sources/PDF22MD/AssetExtractor.swift">
import Foundation
import CoreGraphics
import ImageIO
import UniformTypeIdentifiers

/// Handles extraction and saving of image assets from PDFs
final class AssetExtractor {
    private let assetsPath: String?
    private var imageCounter = 0
    private let fileManager = FileManager.default
    
    init(assetsPath: String?) {
        self.assetsPath = assetsPath
        
        // Create assets directory if specified
        if let path = assetsPath {
            try? fileManager.createDirectory(atPath: path, withIntermediateDirectories: true)
        }
    }
    
    /// Save an image asset and return the relative path for markdown reference
    func saveImage(_ image: CGImage, isVector: Bool) -> String? {
        guard let assetsPath = assetsPath else { return nil }
        
        imageCounter += 1
        
        // Determine format based on image characteristics
        let format = shouldUsePNG(for: image) ? "png" : "jpg"
        let fileName = String(format: "image_%03d.%@", imageCounter, format)
        let filePath = (assetsPath as NSString).appendingPathComponent(fileName)
        
        // Save the image
        let saved = format == "png" 
            ? savePNG(image, to: filePath)
            : saveJPEG(image, to: filePath)
        
        return saved ? fileName : nil
    }
    
    private func shouldUsePNG(for image: CGImage) -> Bool {
        // Use PNG if image has alpha channel
        if let alphaInfo = CGImageAlphaInfo(rawValue: image.alphaInfo.rawValue),
           alphaInfo != .none && alphaInfo != .noneSkipFirst && alphaInfo != .noneSkipLast {
            return true
        }
        
        // Use PNG for small images (likely icons/graphics)
        if image.width < 300 || image.height < 300 {
            return true
        }
        
        // Use PNG for images with few colors (likely graphics)
        // This is a simplified heuristic
        if image.bitsPerPixel <= 8 {
            return true
        }
        
        return false
    }
    
    private func savePNG(_ image: CGImage, to path: String) -> Bool {
        guard let destination = CGImageDestinationCreateWithURL(
            URL(fileURLWithPath: path) as CFURL,
            UTType.png.identifier as CFString,
            1,
            nil
        ) else { return false }
        
        CGImageDestinationAddImage(destination, image, nil)
        return CGImageDestinationFinalize(destination)
    }
    
    private func saveJPEG(_ image: CGImage, to path: String) -> Bool {
        guard let destination = CGImageDestinationCreateWithURL(
            URL(fileURLWithPath: path) as CFURL,
            UTType.jpeg.identifier as CFString,
            1,
            nil
        ) else { return false }
        
        let options: [CFString: Any] = [
            kCGImageDestinationLossyCompressionQuality: 0.85
        ]
        
        CGImageDestinationAddImage(destination, image, options as CFDictionary)
        return CGImageDestinationFinalize(destination)
    }
}
</file>

<file path="pdf22md/Sources/PDF22MD/FontStatistics.swift">
import Foundation

/// Statistics about font usage in a PDF document
struct FontStatistics {
    let bodySizeThreshold: CGFloat
    let headingSizes: Set<CGFloat>
    let fontSizeFrequencies: [CGFloat: Int]
    
    func headingLevel(for fontSize: CGFloat) -> Int {
        guard headingSizes.contains(fontSize) else { return 0 }
        
        // Sort heading sizes from largest to smallest
        let sortedHeadingSizes = headingSizes.sorted(by: >)
        
        // Return heading level based on size order
        if let index = sortedHeadingSizes.firstIndex(of: fontSize) {
            return min(index + 1, 6) // H1-H6
        }
        
        return 0
    }
}
</file>

<file path="pdf22md/Sources/PDF22MD/PDFElement.swift">
import Foundation
import CoreGraphics

/// Protocol defining common properties for PDF content elements
protocol PDFElement {
    var bounds: CGRect { get }
    var pageIndex: Int { get }
}

/// Errors that can occur during PDF conversion
enum PDFConversionError: Error {
    case invalidPDF
    case fileNotFound
    case conversionFailed(String)
}

/// Represents a text element extracted from a PDF
struct TextElement: PDFElement {
    let text: String
    let bounds: CGRect
    let pageIndex: Int
    let fontSize: CGFloat
    let isBold: Bool
    let isItalic: Bool
    
    init(text: String, bounds: CGRect, pageIndex: Int, fontSize: CGFloat, isBold: Bool = false, isItalic: Bool = false) {
        self.text = text
        self.bounds = bounds
        self.pageIndex = pageIndex
        self.fontSize = fontSize
        self.isBold = isBold
        self.isItalic = isItalic
    }
}

/// Represents an image element extracted from a PDF
struct ImageElement: PDFElement {
    let image: CGImage?
    let bounds: CGRect
    let pageIndex: Int
    let isVectorSource: Bool
    let path: String
    
    init(image: CGImage? = nil, bounds: CGRect, pageIndex: Int, isVectorSource: Bool = false, path: String = "") {
        self.image = image
        self.bounds = bounds
        self.pageIndex = pageIndex
        self.isVectorSource = isVectorSource
        self.path = path
    }
}
</file>

<file path="pdf22md/Sources/PDF22MD/PDFMarkdownConverter.swift">
import Foundation
import PDFKit

/// Main converter class that orchestrates PDF to Markdown conversion
public final class PDFMarkdownConverter {
    private let pdfURL: URL
    private let outputPath: String?
    private let assetsPath: String?
    private let dpi: CGFloat
    
    public init(pdfURL: URL, outputPath: String?, assetsPath: String?, dpi: CGFloat = 144.0) {
        self.pdfURL = pdfURL
        self.outputPath = outputPath
        self.assetsPath = assetsPath
        self.dpi = dpi
    }
    
    /// Convert PDF to Markdown
    public func convert() async throws {
        guard let pdfDocument = PDFDocument(url: pdfURL) else {
            throw PDFConversionError.invalidPDF
        }
        
        let pageCount = pdfDocument.pageCount
        var allElements: [PDFElement] = []
        
        // Process pages concurrently
        await withTaskGroup(of: (Int, [PDFElement]).self) { group in
            for pageIndex in 0..<pageCount {
                group.addTask {
                    guard let page = pdfDocument.page(at: pageIndex) else {
                        return (pageIndex, [])
                    }
                    
                    let processor = PDFPageProcessor(page: page, pageIndex: pageIndex, dpi: self.dpi)
                    let elements = processor.processPage()
                    return (pageIndex, elements)
                }
            }
            
            // Collect results in order
            var pageElements: [(Int, [PDFElement])] = []
            for await result in group {
                pageElements.append(result)
            }
            
            // Sort by page index and flatten
            pageElements.sort { $0.0 < $1.0 }
            allElements = pageElements.flatMap { $0.1 }
        }
        
        // Analyze fonts for heading detection
        let fontStats = analyzeFonts(from: allElements)
        
        // Generate markdown
        let markdown = generateMarkdown(from: allElements, fontStats: fontStats)
        
        // Write output
        if let outputPath = outputPath {
            try markdown.write(toFile: outputPath, atomically: true, encoding: String.Encoding.utf8)
        } else {
            print(markdown)
        }
    }
    
    private func analyzeFonts(from elements: [PDFElement]) -> FontStatistics {
        var fontSizes: [CGFloat: Int] = [:]
        var totalTextElements = 0
        
        for element in elements {
            guard let textElement = element as? TextElement else { continue }
            fontSizes[textElement.fontSize, default: 0] += 1
            totalTextElements += 1
        }
        
        // Sort font sizes by frequency
        let sortedSizes = fontSizes.sorted { $0.value > $1.value }
        
        // Determine heading sizes (top 3-4 sizes that aren't the most common)
        var headingSizes: Set<CGFloat> = []
        if sortedSizes.count > 1 {
            // Skip the most common size (likely body text)
            for i in 1..<min(4, sortedSizes.count) {
                if sortedSizes[i].value > totalTextElements / 20 { // At least 5% of elements
                    headingSizes.insert(sortedSizes[i].key)
                }
            }
        }
        
        let bodySize = sortedSizes.first?.key ?? 12.0
        
        return FontStatistics(
            bodySizeThreshold: bodySize,
            headingSizes: headingSizes,
            fontSizeFrequencies: fontSizes
        )
    }
    
    private func generateMarkdown(from elements: [PDFElement], fontStats: FontStatistics) -> String {
        var markdown = ""
        let assetExtractor = AssetExtractor(assetsPath: assetsPath)
        
        // Sort elements by page and vertical position
        let sortedElements = elements.sorted { lhs, rhs in
            if lhs.pageIndex != rhs.pageIndex {
                return lhs.pageIndex < rhs.pageIndex
            }
            // Sort top to bottom (flip Y coordinate)
            return lhs.bounds.origin.y > rhs.bounds.origin.y
        }
        
        var previousElement: PDFElement?
        
        for element in sortedElements {
            // Add page breaks
            if let prev = previousElement, prev.pageIndex != element.pageIndex {
                markdown += "\n---\n\n"
            }
            
            switch element {
            case let textElement as TextElement:
                let headingLevel = fontStats.headingLevel(for: textElement.fontSize)
                
                if headingLevel > 0 {
                    markdown += String(repeating: "#", count: headingLevel) + " "
                }
                
                var text = textElement.text
                
                // Apply formatting
                if textElement.isBold && textElement.isItalic {
                    text = "***\(text)***"
                } else if textElement.isBold {
                    text = "**\(text)**"
                } else if textElement.isItalic {
                    text = "*\(text)*"
                }
                
                markdown += text
                
                // Add appropriate spacing
                if headingLevel > 0 {
                    markdown += "\n\n"
                } else {
                    // Check if next element is on a new line
                    if let prev = previousElement as? TextElement,
                       abs(prev.bounds.origin.y - textElement.bounds.origin.y) > 5 {
                        markdown += "\n\n"
                    } else {
                        markdown += " "
                    }
                }
                
            case let imageElement as ImageElement:
                if let image = imageElement.image,
                   let imagePath = assetExtractor.saveImage(image, 
                                                           isVector: imageElement.isVectorSource) {
                    let altText = imageElement.isVectorSource ? "Vector graphic" : "Image"
                    markdown += "![\(altText)](\(imagePath))\n\n"
                }
                
            default:
                break
            }
            
            previousElement = element
        }
        
        return markdown.trimmingCharacters(in: .whitespacesAndNewlines)
    }
}
</file>

<file path="pdf22md/Sources/PDF22MD/PDFMarkdownConverterOptimized.swift">
import Foundation
import PDFKit

/// Optimized converter using GCD instead of async/await for better performance
public final class PDFMarkdownConverterOptimized {
    private let pdfURL: URL
    private let outputPath: String?
    private let assetsPath: String?
    private let dpi: CGFloat
    
    public init(pdfURL: URL, outputPath: String?, assetsPath: String?, dpi: CGFloat = 144.0) {
        self.pdfURL = pdfURL
        self.outputPath = outputPath
        self.assetsPath = assetsPath
        self.dpi = dpi
    }
    
    /// Convert PDF to Markdown using GCD for better performance
    public func convert() throws {
        guard let pdfDocument = PDFDocument(url: pdfURL) else {
            throw PDFConversionError.invalidPDF
        }
        
        let pageCount = pdfDocument.pageCount
        let queue = DispatchQueue(label: "pdf.processing", attributes: .concurrent)
        let group = DispatchGroup()
        
        // Thread-safe storage for results
        let lock = NSLock()
        var pageResults: [(Int, [PDFElement])] = []
        
        // Process pages concurrently using GCD
        for pageIndex in 0..<pageCount {
            group.enter()
            queue.async {
                autoreleasepool {
                    guard let page = pdfDocument.page(at: pageIndex) else {
                        group.leave()
                        return
                    }
                    
                    let processor = PDFPageProcessorOptimized(page: page, pageIndex: pageIndex, dpi: self.dpi)
                    let elements = processor.processPage()
                    
                    // Thread-safe append
                    lock.lock()
                    pageResults.append((pageIndex, elements))
                    lock.unlock()
                    
                    group.leave()
                }
            }
        }
        
        // Wait for all pages to complete
        group.wait()
        
        // Sort by page index
        pageResults.sort { $0.0 < $1.0 }
        let allElements = pageResults.flatMap { $0.1 }
        
        // Analyze fonts for heading detection
        let fontStats = analyzeFonts(from: allElements)
        
        // Generate markdown
        let markdown = generateMarkdown(from: allElements, fontStats: fontStats)
        
        // Write output
        if let outputPath = outputPath {
            try markdown.write(toFile: outputPath, atomically: true, encoding: String.Encoding.utf8)
        } else {
            print(markdown)
        }
    }
    
    private func analyzeFonts(from elements: [PDFElement]) -> FontStatistics {
        var fontSizes: [CGFloat: Int] = [:]
        var totalTextElements = 0
        
        for element in elements {
            guard let textElement = element as? TextElement else { continue }
            fontSizes[textElement.fontSize, default: 0] += 1
            totalTextElements += 1
        }
        
        // Sort font sizes by frequency
        let sortedSizes = fontSizes.sorted { $0.value > $1.value }
        
        // Determine heading sizes (top 3-4 sizes that aren't the most common)
        var headingSizes: Set<CGFloat> = []
        if sortedSizes.count > 1 {
            // Skip the most common size (likely body text)
            for i in 1..<min(4, sortedSizes.count) {
                if sortedSizes[i].value > totalTextElements / 20 { // At least 5% of elements
                    headingSizes.insert(sortedSizes[i].key)
                }
            }
        }
        
        let bodySize = sortedSizes.first?.key ?? 12.0
        
        return FontStatistics(
            bodySizeThreshold: bodySize,
            headingSizes: headingSizes,
            fontSizeFrequencies: fontSizes
        )
    }
    
    private func generateMarkdown(from elements: [PDFElement], fontStats: FontStatistics) -> String {
        let markdown = NSMutableString()
        let assetExtractor = AssetExtractor(assetsPath: assetsPath)
        var previousElement: PDFElement?
        
        for element in elements {
            switch element {
            case let textElement as TextElement:
                let headingLevel = fontStats.headingLevel(for: textElement.fontSize)
                
                if headingLevel > 0 {
                    // Add heading
                    let prefix = String(repeating: "#", count: headingLevel)
                    markdown.append("\(prefix) \(textElement.text)\n\n")
                } else {
                    // Regular text
                    if textElement.isBold && textElement.isItalic {
                        markdown.append("***\(textElement.text)***")
                    } else if textElement.isBold {
                        markdown.append("**\(textElement.text)**")
                    } else if textElement.isItalic {
                        markdown.append("*\(textElement.text)*")
                    } else {
                        markdown.append(textElement.text)
                    }
                    
                    // Check if we need a line break
                    if shouldAddLineBreak(current: element, previous: previousElement) {
                        markdown.append("\n\n")
                    } else {
                        markdown.append(" ")
                    }
                }
                
            case let imageElement as ImageElement:
                if let image = imageElement.image,
                   let imagePath = assetExtractor.saveImage(image, isVector: imageElement.isVectorSource) {
                    let altText = imageElement.isVectorSource ? "Vector graphic" : "Image"
                    markdown.append("![\(altText)](\(imagePath))\n\n")
                }
                
            default:
                break
            }
            
            previousElement = element
        }
        
        return (markdown as String).trimmingCharacters(in: .whitespacesAndNewlines)
    }
    
    private func shouldAddLineBreak(current: PDFElement, previous: PDFElement?) -> Bool {
        guard let prev = previous else { return true }
        
        // Check vertical distance
        let verticalGap = abs(current.bounds.minY - prev.bounds.minY)
        return verticalGap > 20
    }
}
</file>

<file path="pdf22md/Sources/PDF22MD/PDFMarkdownConverterUltraOptimized.swift">
import Foundation
import PDFKit

/// Ultra-optimized converter using NSString, pre-allocation, and minimal overhead
public final class PDFMarkdownConverterUltraOptimized {
    private let pdfURL: URL
    private let outputPath: String?
    private let assetsPath: String?
    private let dpi: CGFloat
    
    // Pre-allocated buffers
    private let markdownBuffer: NSMutableString
    private var fontCache: [NSString: CGFloat] = [:]
    
    public init(pdfURL: URL, outputPath: String?, assetsPath: String?, dpi: CGFloat = 144.0) {
        self.pdfURL = pdfURL
        self.outputPath = outputPath
        self.assetsPath = assetsPath
        self.dpi = dpi
        // Pre-allocate with large capacity
        self.markdownBuffer = NSMutableString(capacity: 1024 * 1024) // 1MB initial capacity
    }
    
    /// Convert PDF to Markdown with maximum performance
    public func convert() throws {
        guard let pdfDocument = PDFDocument(url: pdfURL) else {
            throw PDFConversionError.invalidPDF
        }
        
        let pageCount = pdfDocument.pageCount
        
        // Use simple concurrent queue with limited concurrency
        let queue = DispatchQueue(label: "pdf.ultra", attributes: .concurrent)
        let semaphore = DispatchSemaphore(value: ProcessInfo.processInfo.activeProcessorCount)
        let group = DispatchGroup()
        
        // Pre-allocate result storage
        var pageResults = ContiguousArray<(Int, ContiguousArray<PDFElement>)>()
        pageResults.reserveCapacity(pageCount)
        let lock = NSLock()
        
        // Process pages with controlled concurrency
        for pageIndex in 0..<pageCount {
            group.enter()
            semaphore.wait()
            
            queue.async {
                autoreleasepool {
                    defer {
                        semaphore.signal()
                        group.leave()
                    }
                    
                    guard let page = pdfDocument.page(at: pageIndex) else { return }
                    
                    let processor = PDFPageProcessorUltraOptimized(
                        page: page,
                        pageIndex: pageIndex,
                        dpi: self.dpi
                    )
                    
                    let elements = processor.processPage()
                    
                    lock.lock()
                    pageResults.append((pageIndex, elements))
                    lock.unlock()
                }
            }
        }
        
        group.wait()
        
        // Sort by page index using in-place sort
        pageResults.sort { $0.0 < $1.0 }
        
        // Analyze fonts with caching
        analyzeFontsOptimized(pageResults: pageResults)
        
        // Generate markdown directly into buffer
        generateMarkdownOptimized(pageResults: pageResults)
        
        // Write output
        if let outputPath = outputPath {
            try markdownBuffer.write(
                toFile: outputPath,
                atomically: true,
                encoding: String.Encoding.utf8.rawValue
            )
        } else {
            print(markdownBuffer as String)
        }
    }
    
    @inline(__always)
    private func analyzeFontsOptimized(pageResults: ContiguousArray<(Int, ContiguousArray<PDFElement>)>) {
        var fontSizes: [CGFloat: Int] = [:]
        fontSizes.reserveCapacity(20)
        
        var totalTextElements = 0
        
        // Single pass through all elements
        for (_, elements) in pageResults {
            for element in elements {
                if let textElement = element as? TextElement {
                    fontSizes[textElement.fontSize, default: 0] += 1
                    totalTextElements += 1
                    
                    // Cache font info by size
                }
            }
        }
        
        // Quick analysis without sorting
        let threshold = totalTextElements / 20
        for (size, count) in fontSizes where count > threshold {
            // Mark as heading size
            fontCache[NSString(string: "heading_\(size)")] = size
        }
    }
    
    @inline(__always)
    private func generateMarkdownOptimized(pageResults: ContiguousArray<(Int, ContiguousArray<PDFElement>)>) {
        markdownBuffer.setString("")
        
        for (_, elements) in pageResults {
            for element in elements {
                if let textElement = element as? TextElement {
                    // Check if heading using cached info
                    let isHeading = fontCache[NSString(string: "heading_\(textElement.fontSize)")] != nil
                    
                    if isHeading {
                        markdownBuffer.append("## ")
                    }
                    
                    // Direct string append
                    markdownBuffer.append(textElement.text)
                    markdownBuffer.append("\n\n")
                } else if let imageElement = element as? ImageElement {
                    markdownBuffer.append("![Image](")
                    markdownBuffer.append(imageElement.path)
                    markdownBuffer.append(")\n\n")
                }
            }
        }
    }
}

/// Ultra-optimized page processor
final class PDFPageProcessorUltraOptimized {
    private let pdfPage: PDFPage
    private let pageIndex: Int
    private let dpi: CGFloat
    private var elementBuffer: ContiguousArray<PDFElement>
    
    init(page: PDFPage, pageIndex: Int, dpi: CGFloat = 144.0) {
        self.pdfPage = page
        self.pageIndex = pageIndex
        self.dpi = dpi
        self.elementBuffer = ContiguousArray<PDFElement>()
        self.elementBuffer.reserveCapacity(500)
    }
    
    @inline(__always)
    func processPage() -> ContiguousArray<PDFElement> {
        elementBuffer.removeAll(keepingCapacity: true)
        
        guard let pageContent = pdfPage.attributedString else { 
            return elementBuffer 
        }
        
        // Process using NSString directly
        let nsString = pageContent.string as NSString
        let length = nsString.length
        var position = 0
        
        while position < length {
            var range = NSRange()
            let attrs = pageContent.attributes(at: position, longestEffectiveRange: &range, in: NSRange(location: 0, length: length))
            
            let text = nsString.substring(with: range)
            if !text.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                // Extract font info inline
                let font = attrs[.font] as? NSFont
                let element = TextElement(
                    text: text,
                    bounds: CGRect.zero, // Skip bounds calculation for speed
                    pageIndex: pageIndex,
                    fontSize: font?.pointSize ?? 12.0,
                    isBold: false,
                    isItalic: false
                )
                elementBuffer.append(element)
            }
            
            position = NSMaxRange(range)
        }
        
        return elementBuffer
    }
}
</file>

<file path="pdf22md/Sources/PDF22MD/PDFPageProcessor.swift">
import Foundation
import PDFKit
import CoreGraphics

/// Processes individual PDF pages to extract content elements
final class PDFPageProcessor {
    private let pdfPage: PDFPage
    private let pageIndex: Int
    private let dpi: CGFloat
    
    init(page: PDFPage, pageIndex: Int, dpi: CGFloat = 144.0) {
        self.pdfPage = page
        self.pageIndex = pageIndex
        self.dpi = dpi
    }
    
    /// Process the page and extract all content elements
    func processPage() -> [PDFElement] {
        var elements: [PDFElement] = []
        
        // Extract text elements
        elements.append(contentsOf: extractTextElements())
        
        // Extract image elements
        elements.append(contentsOf: extractImageElements())
        
        // Extract vector graphics as images
        elements.append(contentsOf: extractVectorGraphics())
        
        return elements
    }
    
    private func extractTextElements() -> [TextElement] {
        var textElements: [TextElement] = []
        
        guard let pageContent = pdfPage.attributedString else { return textElements }
        
        let fullRange = NSRange(location: 0, length: pageContent.length)
        var currentPosition = 0
        
        while currentPosition < pageContent.length {
            var effectiveRange = NSRange()
            let attributes = pageContent.attributes(at: currentPosition, 
                                                   longestEffectiveRange: &effectiveRange, 
                                                   in: fullRange)
            
            let text = (pageContent.string as NSString).substring(with: effectiveRange)
            
            // Skip whitespace-only text
            let trimmed = text.trimmingCharacters(in: .whitespacesAndNewlines)
            if !trimmed.isEmpty {
                // Extract font information
                let font = attributes[.font] as? NSFont
                let fontSize = font?.pointSize ?? 12.0
                
                // Determine style
                let isBold = font?.fontDescriptor.symbolicTraits.contains(.bold) ?? false
                let isItalic = font?.fontDescriptor.symbolicTraits.contains(.italic) ?? false
                
                // Get bounds for the text
                let bounds = getBounds(for: effectiveRange)
                
                let element = TextElement(
                    text: trimmed,
                    bounds: bounds,
                    pageIndex: pageIndex,
                    fontSize: fontSize,
                    isBold: isBold,
                    isItalic: isItalic
                )
                textElements.append(element)
            }
            
            currentPosition = NSMaxRange(effectiveRange)
        }
        
        return textElements
    }
    
    private func getBounds(for range: NSRange) -> CGRect {
        guard range.location != NSNotFound, range.length > 0 else {
            return .zero
        }
        
        // Use characterBounds which is much more efficient than creating selections.
        // We union the bounds of the first and last character for a good approximation.
        let startBounds = pdfPage.characterBounds(at: range.location)
        let endBounds = pdfPage.characterBounds(at: NSMaxRange(range) - 1)
        
        return startBounds.union(endBounds)
    }
    
    private func extractImageElements() -> [ImageElement] {
        // For now, we'll focus on vector graphics extraction
        // Direct image extraction from PDF streams requires more complex parsing
        return []
    }
    
    
    private func extractVectorGraphics() -> [ImageElement] {
        var elements: [ImageElement] = []
        
        let pageRect = pdfPage.bounds(for: .mediaBox)
        let sectionSize: CGFloat = 100.0 // 100 point sections
        
        let gridX = Int(ceil(pageRect.size.width / sectionSize))
        let gridY = Int(ceil(pageRect.size.height / sectionSize))
        
        for x in 0..<gridX {
            for y in 0..<gridY {
                var sectionRect = CGRect(
                    x: CGFloat(x) * sectionSize,
                    y: CGFloat(y) * sectionSize,
                    width: sectionSize,
                    height: sectionSize
                )
                
                // Intersect with page bounds
                sectionRect = sectionRect.intersection(pageRect)
                if sectionRect.isEmpty || sectionRect.size.width < 20 || sectionRect.size.height < 20 {
                    continue
                }
                
                // Check if this section contains primarily image content
                if sectionContainsImageContent(sectionRect) {
                    if let sectionImage = renderPageSection(sectionRect) {
                        let element = ImageElement(
                            image: sectionImage,
                            bounds: sectionRect,
                            pageIndex: pageIndex,
                            isVectorSource: true
                        )
                        elements.append(element)
                    }
                }
            }
        }
        
        return elements
    }
    
    private func sectionContainsImageContent(_ rect: CGRect) -> Bool {
        // Check if the section has minimal text
        guard let selection = pdfPage.selection(for: rect) else { return true }
        let text = selection.string?.trimmingCharacters(in: .whitespacesAndNewlines) ?? ""
        
        // If section has very little text, consider it as potential image area
        return text.count < 10
    }
    
    private func renderPageSection(_ rect: CGRect) -> CGImage? {
        let scale = dpi / 72.0
        let scaledSize = CGSize(width: rect.size.width * scale, 
                               height: rect.size.height * scale)
        
        // Create bitmap context
        let colorSpace = CGColorSpaceCreateDeviceRGB()
        let bitmapInfo = CGBitmapInfo(rawValue: CGImageAlphaInfo.premultipliedLast.rawValue)
        
        guard let context = CGContext(
            data: nil,
            width: Int(scaledSize.width),
            height: Int(scaledSize.height),
            bitsPerComponent: 8,
            bytesPerRow: 0,
            space: colorSpace,
            bitmapInfo: bitmapInfo.rawValue
        ) else { return nil }
        
        // Fill with white background
        context.setFillColor(CGColor(red: 1, green: 1, blue: 1, alpha: 1))
        context.fill(CGRect(origin: .zero, size: scaledSize))
        
        // Set up coordinate system
        context.scaleBy(x: scale, y: scale)
        context.translateBy(x: -rect.origin.x, y: -rect.origin.y)
        
        // Draw the PDF page section
        pdfPage.draw(with: .mediaBox, to: context)
        
        return context.makeImage()
    }
}
</file>

<file path="pdf22md/Sources/PDF22MD/PDFPageProcessorOptimized.swift">
import Foundation
import PDFKit
import CoreGraphics

/// Optimized PDF page processor using NSString and other performance improvements
final class PDFPageProcessorOptimized {
    private let pdfPage: PDFPage
    private let pageIndex: Int
    private let dpi: CGFloat
    
    // Pre-allocated buffers
    private var elementBuffer: ContiguousArray<PDFElement>
    
    init(page: PDFPage, pageIndex: Int, dpi: CGFloat = 144.0) {
        self.pdfPage = page
        self.pageIndex = pageIndex
        self.dpi = dpi
        // Pre-allocate with estimated capacity
        self.elementBuffer = ContiguousArray<PDFElement>()
        self.elementBuffer.reserveCapacity(1000)
    }
    
    /// Process the page and extract all content elements
    @inline(__always)
    func processPage() -> [PDFElement] {
        elementBuffer.removeAll(keepingCapacity: true)
        
        // Extract text elements
        extractTextElements()
        
        // Extract image elements
        extractImageElements()
        
        // Extract vector graphics as images
        extractVectorGraphics()
        
        return Array(elementBuffer)
    }
    
    @inline(__always)
    private func extractTextElements() {
        guard let pageContent = pdfPage.attributedString else { return }
        
        // Use NSString for better performance
        let nsString = pageContent.string as NSString
        let fullRange = NSRange(location: 0, length: nsString.length)
        var currentPosition = 0
        
        // Pre-allocate whitespace character set
        let whitespaceSet = CharacterSet.whitespacesAndNewlines
        
        while currentPosition < nsString.length {
            var effectiveRange = NSRange()
            let attributes = pageContent.attributes(at: currentPosition, 
                                                   longestEffectiveRange: &effectiveRange, 
                                                   in: fullRange)
            
            // Use NSString substring for better performance
            let text = nsString.substring(with: effectiveRange)
            
            // Skip whitespace-only text using NSString
            let trimmed = (text as NSString).trimmingCharacters(in: whitespaceSet)
            if trimmed.isEmpty {
                currentPosition = NSMaxRange(effectiveRange)
                continue
            }
            
            // Extract font information using cached values
            var fontSize: CGFloat = 12.0
            let fontName = "Helvetica"
            var isBold = false
            var isItalic = false
            
            if let font = attributes[.font] as? NSFont {
                fontSize = font.pointSize
                
                // Use font traits for better performance
                let traits = font.fontDescriptor.symbolicTraits
                isBold = traits.contains(.bold)
                isItalic = traits.contains(.italic)
            }
            
            // Get bounds - optimize by using page bounds directly
            let bounds: CGRect
            if let pdfBounds = pdfPage.selection(for: effectiveRange)?.bounds(for: pdfPage) {
                bounds = pdfBounds
            } else {
                bounds = CGRect(x: 0, y: CGFloat(currentPosition) * 20, width: 100, height: fontSize)
            }
            
            // Create element and add to buffer
            let element = TextElement(
                text: trimmed,
                bounds: bounds,
                pageIndex: pageIndex,
                fontSize: fontSize,
                isBold: isBold,
                isItalic: isItalic
            )
            
            elementBuffer.append(element)
            currentPosition = NSMaxRange(effectiveRange)
        }
    }
    
    @inline(__always)
    private func extractImageElements() {
        // Implementation remains similar but uses elementBuffer.append directly
        // This is a placeholder - would need full implementation
    }
    
    @inline(__always)
    private func extractVectorGraphics() {
        // Implementation remains similar but uses elementBuffer.append directly
        // This is a placeholder - would need full implementation
    }
}

// Use the existing TextElement struct, no need to redefine
</file>

<file path="pdf22md/Sources/PDF22MDCli/main.swift">
import Foundation
import ArgumentParser
import PDF22MD

@main
struct PDF22MDCommand: AsyncParsableCommand {
    static let configuration = CommandConfiguration(
        commandName: "pdf22md",
        abstract: "Converts PDF documents to Markdown format (Swift implementation)",
        version: "1.0.0"
    )
    
    @Option(name: .shortAndLong, help: "Input PDF file (default: stdin)")
    var input: String?
    
    @Option(name: .shortAndLong, help: "Output Markdown file (default: stdout)")
    var output: String?
    
    @Option(name: .shortAndLong, help: "Assets folder for extracted images")
    var assets: String?
    
    @Option(name: .shortAndLong, help: "DPI for rasterizing vector graphics (default: 144)")
    var dpi: Double = 144.0
    
    @Flag(name: .long, help: "Use optimized GCD implementation instead of async/await")
    var optimized: Bool = false
    
    @Flag(name: .long, help: "Use ultra-optimized implementation with NSString")
    var ultraOptimized: Bool = false
    
    func run() async throws {
        let inputURL: URL
        
        if let inputPath = input {
            inputURL = URL(fileURLWithPath: inputPath)
        } else {
            // Read from stdin into a temporary file
            let tempFile = FileManager.default.temporaryDirectory
                .appendingPathComponent(UUID().uuidString)
                .appendingPathExtension("pdf")
            let inputData = FileHandle.standardInput.readDataToEndOfFile()
            try inputData.write(to: tempFile)
            inputURL = tempFile
        }
        
        // Choose implementation
        if ultraOptimized {
            let converter = PDFMarkdownConverterUltraOptimized(
                pdfURL: inputURL,
                outputPath: output,
                assetsPath: assets,
                dpi: CGFloat(dpi)
            )
            try converter.convert()
        } else if optimized {
            let converter = PDFMarkdownConverterOptimized(
                pdfURL: inputURL,
                outputPath: output,
                assetsPath: assets,
                dpi: CGFloat(dpi)
            )
            try converter.convert()
        } else {
            let converter = PDFMarkdownConverter(
                pdfURL: inputURL,
                outputPath: output,
                assetsPath: assets,
                dpi: CGFloat(dpi)
            )
            try await converter.convert()
        }
        
        // Clean temp file if created
        if input == nil {
            try? FileManager.default.removeItem(at: inputURL)
        }
    }
}
</file>

<file path="pdf22md/test-resources/expected-outputs/README.md">
---
title: "README.md"
creator: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36 Edg/137.0.0.0"
producer: "Skia/PDF m137"
created: 2025-06-23T01:33:53+02:00
modified: 2025-06-23T01:33:53+02:00
pdf_metadata:
  page_count: 2
conversion:
  tool: "pdf22md"
  version: "v1.1.0-dirty"
  date: 2025-06-23T02:28:31+02:00
---

23/06/2025, 01:33 README.md

![Image](image_000.png)

![Image](image_001.png)

pdf22md

MIT

License MIT

License

10.15+

![Image](image_002.png)

![Image](image_003.png)

macOS 10.15+

macOS

Build and Release Build and Release passing passing

A blazingly fast PDF to Markdown converter for macOS.

pdf22md is a command-line tool that extracts all text and image content from a PDF file and converts it into a

![Image](image_004.png)

![Image](image_005.png)

![Image](image_006.png)

clean Markdown document. It uses Grand Central Dispatch (GCD) to process pages and save images in

parallel, making it exceptionally fast for multi-page documents.

Key Features

High-Speed Conversion: Uses all available CPU cores to process PDF pages concurrently

Intelligent Heading Detection: Analyzes font sizes and usage frequency to automatically format titles

![Image](image_007.png)

![Image](image_008.png)

![Image](image_009.png)

and headings ( # , ## , etc.)

Asset Extraction: Saves raster and vector images into a specified assets folder and links them correctly

in the Markdown file

Smart Image Formatting: Automatically chooses between JPEG (for photos) and PNG (for graphics with

transparency) to optimize file size and quality

Flexible I/O: Reads from a PDF file or stdin and writes to a Markdown file or stdout

![Image](image_010.png)

![Image](image_011.png)

![Image](image_012.png)

Customizable Rasterization: Allows setting a custom DPI for converting vector graphics to bitmaps

Installation

Using Homebrew (Coming Soon)

brew tap twardoch/pdf22md

brew install pdf22md

![Image](image_013.png)

![Image](image_014.png)

Building from Source

To build the project manually, you need Xcode Command Line Tools installed.

# Clone the repository

git clone https://github.com/twardoch/pdf22md.git

cd pdf22md

# Compile the tool

make

# Install it to /usr/local/bin (optional)

sudo make install

Download Pre-built Binary

Pre-built binaries are available from the Releases page.

Usage

Usage: pdf22md [-i input.pdf] [-o output.md] [-a assets

_

folder] [-d dpi]

Converts PDF documents to Markdown format

-i <path>: Input PDF file (default: stdin)

-o <path>: Output Markdown file (default: stdout)

-a <path>: Assets folder for extracted images

-d <dpi>: DPI for rasterizing vector graphics (default: 144)

Examples

# Convert a PDF file to Markdown

pdf22md -i document.pdf -o document.md

# Convert with images saved to an 'assets' folder

pdf22md -i report.pdf -o report.md -a ./assets

# Convert with custom DPI for vector graphics

pdf22md -i presentation.pdf -o presentation.md -a ./images -d 300

# Use with pipes

cat document.pdf | pdf22md > document.md

# Convert and view in less

pdf22md -i manual.pdf | less

Requirements

macOS 10.15 (Catalina) or later

Xcode Command Line Tools (for building from source)

Project Structure

pdf22md/

‚îú‚îÄ‚îÄ src/ # Source code

‚îÇ ‚îú‚îÄ‚îÄ main.m # Entry point

‚îÇ ‚îú‚îÄ‚îÄ PDFMarkdownConverter.* # Main conversion logic

‚îÇ ‚îú‚îÄ‚îÄ PDFPageProcessor.* # PDF page processing

‚îÇ ‚îú‚îÄ‚îÄ ContentElement.* # Content element definitions

‚îÇ ‚îî‚îÄ‚îÄ AssetExtractor.* # Image extraction logic

‚îú‚îÄ‚îÄ docs/ # Additional documentation

‚îú‚îÄ‚îÄ test/ # Test files

file:///Users/adam/Developer/vcs/github.twardoch/pub/pdf22md/README.md 1/2

23/06/2025, 01:33 README.md

![Image](image_015.png)

![Image](image_016.png)

‚îú‚îÄ‚îÄ LICENSE # MIT License

‚îú‚îÄ‚îÄ Makefile # Build configuration

‚îî‚îÄ‚îÄ README.md # This file

Contributing

Contributions are welcome! Please feel free to submit a Pull Request. For major changes, please open an

![Image](image_017.png)

![Image](image_018.png)

![Image](image_019.png)

issue first to discuss what you

would like to change.

1. Fork the repository

2. Create your feature branch ( git checkout -b feature/AmazingFeature )

3. Commit your changes ( git commit -m 'Add some AmazingFeature' )

![Image](image_020.png)

![Image](image_021.png)

![Image](image_022.png)

4. Push to the branch ( git push origin feature/AmazingFeature )

5. Open a Pull Request

License

This project is licensed under the MIT License - see the LICENSE file for details.

Acknowledgments

![Image](image_023.png)

![Image](image_024.png)

![Image](image_025.png)

![Image](image_026.png)

![Image](image_027.png)

Built with Apple‚Äôs PDFKit and Core Graphics frameworks

Parallel processing powered by Grand Central Dispatch (GCD)

Inspired by the need for fast, accurate PDF to Markdown conversion

Related Projects

pdfplumber - Python library for PDF processing

![Image](image_028.png)

pdf2md - Another PDF to Markdown converter

![Image](image_029.png)

![Image](image_030.png)

![Image](image_031.png)

![Image](image_032.png)

pandoc - Universal document converter

Changelog

See CHANGELOG.md for a list of changes in each version.

Support

If you encounter any issues or have questions, please open an issue on GitHub.

![Image](image_033.png)

![Image](image_034.png)

file:///Users/adam/Developer/vcs/github.twardoch/pub/pdf22md/README.md 2/2
</file>

<file path="pdf22md/Tests/PDF22MDTests/PDF22MDTests.swift">
// this_file: pdf22md/Tests/PDF22MDTests/PDF22MDTests.swift

import XCTest
@testable import PDF22MD

final class PDF22MDTests: XCTestCase {
    
    // MARK: - Basic Tests
    
    func testBasicFunctionality() {
        // Add basic tests here when the Swift implementation is complete
        XCTAssertTrue(true)
    }
    
    func testPerformance() {
        measure {
            // Add performance tests here
        }
    }
}
</file>

<file path="pdf22md/Package.resolved">
{
  "pins" : [
    {
      "identity" : "swift-argument-parser",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/apple/swift-argument-parser",
      "state" : {
        "revision" : "011f0c765fb46d9cac61bca19be0527e99c98c8b",
        "version" : "1.5.1"
      }
    }
  ],
  "version" : 2
}
</file>

<file path="pdf22md/Package.swift">
// swift-tools-version: 5.7
// The swift-tools-version declares the minimum version of Swift required to build this package.

import PackageDescription

let package = Package(
    name: "pdf22md",
    platforms: [
        .macOS(.v12) // Required for async/await
    ],
    products: [
        // Library product for programmatic usage
        .library(
            name: "PDF22MD",
            targets: ["PDF22MD"]
        ),
        .executable(
            name: "pdf22md",
            targets: ["PDF22MDCli"]
        )
    ],
    dependencies: [
        .package(url: "https://github.com/apple/swift-argument-parser", from: "1.3.0")
    ],
    targets: [
        // Main library target
        .target(
            name: "PDF22MD",
            dependencies: [],
            path: "Sources/PDF22MD",
            swiftSettings: [
                .define("VERSION", .when(platforms: [.macOS]))
            ]
        ),
        .executableTarget(
            name: "PDF22MDCli",
            dependencies: [
                "PDF22MD",
                .product(name: "ArgumentParser", package: "swift-argument-parser")
            ],
            path: "Sources/PDF22MDCli"
        ),
        // Test target
        .testTarget(
            name: "PDF22MDTests",
            dependencies: ["PDF22MD"],
            path: "Tests/PDF22MDTests"
        )
    ]
)
</file>

<file path="pdf22md/README.md">
# pdf22md

A high-performance PDF to Markdown converter built with modern Swift features including async/await, actors, and structured concurrency.

## Features

- **Modern Swift**: Uses Swift 5.7+ features including async/await, actors, and result builders
- **Structured Concurrency**: Concurrent page processing with TaskGroup and proper cancellation
- **Memory Safe**: Automatic memory management with value types where appropriate
- **Type Safe**: Strong typing with enums, associated types, and generic constraints
- **Actor-Based Assets**: Thread-safe image processing with actors
- **Progress Streaming**: Real-time progress updates with AsyncSequence

## Building

### Using Swift Package Manager
```bash
# Build the project
swift build

# Build optimized release
swift build -c release

# Run tests
swift test

# Install executable
swift build -c release
cp .build/release/pdf22md /usr/local/bin/pdf22md
```

## Installation

### Swift Package Manager

Add to your `Package.swift`:

```swift
dependencies: [
    .package(path: "./pdf22md")
]
```

## Usage

### Command Line

```bash
# Convert a PDF file
pdf22md -i document.pdf -o document.md

# Extract images to assets folder
pdf22md -i report.pdf -o report.md -a ./assets

# Customize DPI and concurrency
pdf22md -i large.pdf -o large.md -d 300 --max-concurrency 8

# Use with pipes
cat document.pdf | pdf22md > document.md

# Verbose output with progress
pdf22md -i document.pdf -o document.md --verbose
```

### Programmatic Usage

```swift
import PDF22MD

// Simple conversion
let converter = try PDFConverter(url: inputURL)
let markdown = try await converter.convert()

// With custom options
let options = ConversionOptions(
    assetsFolderPath: "./assets",
    rasterizationDPI: 300.0,
    includeMetadata: true
)

let markdown = try await converter.convert(options: options)
```

## Testing

```bash
# Run all tests
swift test

# Run specific test
swift test --filter PDF22MDTests.testTextElementCreation

# Run tests with coverage
swift test --enable-code-coverage
```

## Requirements

- macOS 12.0 or later (for async/await)
- Swift 5.7 or later
- Xcode 14.0 or later

## License

MIT License - see LICENSE file in the root directory
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2024 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="TROUBLESHOOTING.md">
# Troubleshooting Guide

## Swift Build Failures

### SWBBuildService.framework Missing

**Error Message:**
```
Library not loaded: @rpath/SWBBuildService.framework/Versions/A/SWBBuildService
```

**Description:**
This error occurs when the Swift Package Manager framework is missing or corrupted in the Command Line Tools installation. This is a known issue that can happen after macOS updates or when Command Line Tools are partially installed.

**Solutions:**

#### Option 1: Switch to Xcode's Swift toolchain (if Xcode is installed)
```bash
sudo xcode-select -s /Applications/Xcode.app/Contents/Developer
```

#### Option 2: Reinstall Command Line Tools
```bash
sudo rm -rf /Library/Developer/CommandLineTools
xcode-select --install
```

#### Option 3: Use the Objective-C implementation
The Objective-C implementation is fully functional and doesn't require Swift:
```bash
./build.sh --objc-only
```

### Swift Package Manager Not Working

**Symptoms:**
- `swift package` commands fail
- `swift build` exits with code 6 (Abort trap)

**Diagnosis:**
Check if Swift Package Manager is functional:
```bash
swift package --version
```

If this fails, follow the solutions for SWBBuildService.framework above.

## Build Script Issues

### Both Implementations Failing

If both Swift and Objective-C builds fail:

1. Ensure Xcode Command Line Tools are installed:
   ```bash
   xcode-select --install
   ```

2. Check tool availability:
   ```bash
   clang --version
   swift --version
   make --version
   ```

3. Reset Xcode path to default:
   ```bash
   sudo xcode-select --reset
   ```

### Permission Issues

If you encounter permission errors during installation:

1. Ensure you have sudo access
2. Check that `/usr/local/bin` exists and is writable:
   ```bash
   ls -la /usr/local/bin
   ```

## Runtime Issues

### PDF Conversion Errors

If pdf22md fails to convert specific PDFs:

1. Check PDF file permissions
2. Ensure the PDF is not encrypted or password-protected
3. Try with a different DPI setting:
   ```bash
   pdf22md -i input.pdf -o output.md -d 72
   ```

### Missing Assets Folder

If images are not being extracted:

1. Specify an assets folder explicitly:
   ```bash
   pdf22md -i input.pdf -o output.md -a ./assets
   ```

2. Ensure the parent directory has write permissions

## Getting Help

If you continue to experience issues:

1. Check the GitHub issues: https://github.com/anthropics/pdf22md/issues
2. Run the build script with verbose output and save the log:
   ```bash
   ./build.sh 2>&1 | tee build.log
   ```
3. Include the build.log when reporting issues
</file>

<file path=".github/workflows/build-release.yml">
name: Build and Release

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  release:
    types: [ created ]

jobs:
  build:
    runs-on: macos-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Build the tool
      run: make

    - name: Run a basic check
      run: ./pdf22md -h

  create-release:
    if: github.event_name == 'release'
    runs-on: macos-latest
    needs: build

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Build the binary
      run: make

    - name: Create Tarball Archive
      run: |
        tar -czvf pdf22md-macos-x86_64.tar.gz pdf22md

    - name: Upload Release Asset
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ github.event.release.upload_url }}
        asset_path: ./pdf22md-macos-x86_64.tar.gz
        asset_name: pdf22md-macos-x86_64.tar.gz
        asset_content_type: application/gzip
</file>

<file path="pdf21md/shared-algorithms/PDF21MDImageFormatDetection.h">
//
//  PDF21MDImageFormatDetection.h
//  pdf21md - Shared Components
//
//  Shared utility for determining optimal image format (JPEG vs PNG)
//  based on image characteristics and source type.
//

#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

/**
 * Shared utility class for image format detection and optimization.
 * Determines whether to use JPEG or PNG format based on image characteristics.
 */
@interface PDF21MDImageFormatDetection : NSObject

/**
 * Determines whether JPEG format should be used for an image.
 * 
 * @param image The CGImageRef to analyze
 * @param isVectorSource Whether the image originates from a vector source
 * @return YES if JPEG is recommended, NO if PNG is recommended
 */
+ (BOOL)shouldUseJPEGForImage:(CGImageRef)image 
               isVectorSource:(BOOL)isVectorSource;

/**
 * Estimates the number of unique colors in an image through sampling.
 * Used to determine color complexity for format selection.
 * 
 * @param image The CGImageRef to analyze
 * @return Estimated number of unique colors (capped at practical limits)
 */
+ (NSUInteger)estimateUniqueColorCountForImage:(CGImageRef)image;

/**
 * Returns the recommended file extension for an image.
 * 
 * @param image The CGImageRef to analyze
 * @param isVectorSource Whether the image originates from a vector source
 * @return "jpg" or "png" based on analysis
 */
+ (NSString *)recommendedExtensionForImage:(CGImageRef)image 
                            isVectorSource:(BOOL)isVectorSource;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf21md/shared-algorithms/PDF21MDImageFormatDetection.m">
//
//  PDF21MDImageFormatDetection.m
//  pdf21md - Shared Components
//
//  Shared utility for determining optimal image format (JPEG vs PNG)
//  based on image characteristics and source type.
//

#import "PDF21MDImageFormatDetection.h"

@implementation PDF21MDImageFormatDetection

+ (BOOL)shouldUseJPEGForImage:(CGImageRef)image 
               isVectorSource:(BOOL)isVectorSource {
    if (!image) {
        return NO;
    }
    
    // Get image properties
    size_t width = CGImageGetWidth(image);
    size_t height = CGImageGetHeight(image);
    CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(image);
    
    // If image has alpha channel, use PNG
    if (alphaInfo != kCGImageAlphaNone &&
        alphaInfo != kCGImageAlphaNoneSkipFirst &&
        alphaInfo != kCGImageAlphaNoneSkipLast) {
        return NO;
    }
    
    // For small images, use PNG
    if (width * height < 10000) { // Less than 100x100
        return NO;
    }
    
    // For vector sources, prefer PNG to maintain quality
    if (isVectorSource) {
        return NO;
    }
    
    // Analyze color complexity
    NSUInteger uniqueColors = [self estimateUniqueColorCountForImage:image];
    
    // If we have many unique colors, it's likely a photograph - use JPEG
    return uniqueColors > 256;
}

+ (NSUInteger)estimateUniqueColorCountForImage:(CGImageRef)image {
    if (!image) {
        return 0;
    }
    
    size_t width = CGImageGetWidth(image);
    size_t height = CGImageGetHeight(image);
    
    // Don't analyze extremely large images - assume they're complex
    if (width * height > 4000000) { // Larger than ~2000x2000
        return 10000; // Assume high complexity
    }
    
    // Create a bitmap context for pixel analysis
    uint32_t *pixelData = malloc(sizeof(uint32_t));
    if (!pixelData) {
        return 0;
    }
    
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(pixelData, 1, 1, 8, 4,
                                               colorSpace,
                                               kCGImageAlphaPremultipliedLast |
                                               kCGBitmapByteOrder32Big);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        free(pixelData);
        return 0;
    }
    
    // Sample the image at regular intervals
    size_t stepX = MAX(1, width / 100);   // Sample ~100 points horizontally
    size_t stepY = MAX(1, height / 100);  // Sample ~100 points vertically
    
    // Count unique colors by sampling
    NSMutableSet *uniqueColors = [NSMutableSet set];
    
    for (size_t y = 0; y < height; y += stepY) {
        for (size_t x = 0; x < width; x += stepX) {
            // Draw a single pixel
            CGContextClearRect(context, CGRectMake(0, 0, 1, 1));
            CGContextDrawImage(context, CGRectMake(-x, -y, width, height), image);
            
            uint32_t color = pixelData[0];
            [uniqueColors addObject:@(color)];
            
            // Early exit if we already have many colors
            if (uniqueColors.count > 1000) {
                break;
            }
        }
        
        if (uniqueColors.count > 1000) {
            break;
        }
    }
    
    CGContextRelease(context);
    free(pixelData);
    
    return uniqueColors.count;
}

+ (NSString *)recommendedExtensionForImage:(CGImageRef)image 
                            isVectorSource:(BOOL)isVectorSource {
    return [self shouldUseJPEGForImage:image isVectorSource:isVectorSource] ? @"jpg" : @"png";
}

@end
</file>

<file path="pdf21md/src/CLI/main.m">
#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>
#import "../Core/PDF21MDConverter.h"
#import "../Core/PDF21MDConversionOptions.h"

#ifndef VERSION
#define VERSION "1.0.0"
#endif

void printUsage(const char *programName) {
    fprintf(stderr, "Usage: %s [-i input.pdf] [-o output.md] [-a assets_folder] [-d dpi] [-v] [-h] [--debug]\n", programName);
    fprintf(stderr, "  Converts PDF documents to Markdown format\n");
    fprintf(stderr, "  -i <path>: Input PDF file (default: stdin)\n");
    fprintf(stderr, "  -o <path>: Output Markdown file (default: stdout)\n");
    fprintf(stderr, "  -a <path>: Assets folder for extracted images\n");
    fprintf(stderr, "  -d <dpi>: DPI for rasterizing vector graphics (default: 144)\n");
    fprintf(stderr, "  -v: Display version information\n");
    fprintf(stderr, "  -h: Display this help message\n");
    fprintf(stderr, "  --debug: Enable debug output for troubleshooting\n");
}

void printVersion() {
    printf("pdf21md version %s\n", VERSION);
}

int main(int argc, const char *argv[]) {
    @autoreleasepool {
        NSString *inputPath = nil;
        NSString *outputPath = nil;
        NSString *assetsPath = nil;
        CGFloat dpi = 144.0;
        BOOL debugMode = NO;
        
        // Check for --debug flag and filter it out for getopt
        char **filtered_argv = malloc(argc * sizeof(char*));
        int filtered_argc = 0;
        
        for (int i = 0; i < argc; i++) {
            if (strcmp(argv[i], "--debug") == 0) {
                debugMode = YES;
            } else {
                filtered_argv[filtered_argc++] = (char*)argv[i];
            }
        }
        
        // Parse command line arguments
        int opt;
        optind = 1; // Reset getopt
        while ((opt = getopt(filtered_argc, filtered_argv, "i:o:a:d:hvV")) != -1) {
            switch (opt) {
                case 'i':
                    inputPath = [NSString stringWithUTF8String:optarg];
                    break;
                case 'o':
                    outputPath = [NSString stringWithUTF8String:optarg];
                    break;
                case 'a':
                    assetsPath = [NSString stringWithUTF8String:optarg];
                    break;
                case 'd':
                    dpi = atof(optarg);
                    if (dpi <= 0) {
                        fprintf(stderr, "Invalid DPI value: %s\n", optarg);
                        return 1;
                    }
                    break;
                case 'h':
                    printUsage(argv[0]);
                    return 0;
                case 'v':
                case 'V':
                    printVersion();
                    return 0;
                default:
                    printUsage(argv[0]);
                    return 1;
            }
        }
        
        // Free the filtered argv
        free(filtered_argv);
        
        if (debugMode) {
            fprintf(stderr, "[DEBUG] Input path: %s\n", inputPath ? [inputPath UTF8String] : "(stdin)");
            fprintf(stderr, "[DEBUG] Output path: %s\n", outputPath ? [outputPath UTF8String] : "(stdout)");
            fprintf(stderr, "[DEBUG] Assets path: %s\n", assetsPath ? [assetsPath UTF8String] : "(none)");
            fprintf(stderr, "[DEBUG] DPI: %.1f\n", dpi);
        }
        
        // Initialize converter
        PDF21MDConverter *converter = nil;
        
        if (inputPath) {
            // Read from file
            NSURL *pdfURL = [NSURL fileURLWithPath:inputPath];
            if (debugMode) {
                fprintf(stderr, "[DEBUG] Loading PDF from: %s\n", [inputPath UTF8String]);
            }
            converter = [[PDF21MDConverter alloc] initWithPDFURL:pdfURL];
            if (!converter) {
                fprintf(stderr, "Failed to load PDF from: %s\n", [inputPath UTF8String]);
                return 1;
            }
            if (debugMode) {
                fprintf(stderr, "[DEBUG] PDF loaded successfully\n");
            }
        } else {
            // Read from stdin
            NSFileHandle *stdinHandle = [NSFileHandle fileHandleWithStandardInput];
            NSData *pdfData = [stdinHandle readDataToEndOfFile];
            
            if (!pdfData || [pdfData length] == 0) {
                fprintf(stderr, "No PDF data received from stdin\n");
                return 1;
            }
            
            converter = [[PDF21MDConverter alloc] initWithPDFData:pdfData];
            if (!converter) {
                fprintf(stderr, "Failed to create PDF document from stdin data\n");
                return 1;
            }
        }
        
        // Create conversion options
        PDF21MDConversionOptionsBuilder *builder = [[PDF21MDConversionOptionsBuilder alloc] init];
        builder.assetsFolderPath = assetsPath;
        builder.rasterizationDPI = dpi;
        builder.extractImages = (assetsPath != nil);
        
        if (debugMode) {
            fprintf(stderr, "[DEBUG] Extract images: %s\n", (assetsPath != nil) ? "YES" : "NO");
        }
        
        // Add progress handler for interactive terminals (or debug mode)
        if (isatty(STDERR_FILENO) || debugMode) {
            builder.progressHandler = ^(NSInteger currentPage, NSInteger totalPages) {
                if (debugMode) {
                    fprintf(stderr, "[DEBUG] Processing page %ld of %ld...\n", (long)currentPage, (long)totalPages);
                } else {
                    fprintf(stderr, "\rProcessing page %ld of %ld...", (long)currentPage, (long)totalPages);
                    fflush(stderr);
                }
            };
        }
        
        PDF21MDConversionOptions *options = [builder build];
        
        if (debugMode) {
            fprintf(stderr, "[DEBUG] Starting conversion...\n");
        }
        
        // Perform conversion
        __block NSString *markdown = nil;
        __block NSError *conversionError = nil;
        
        dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
        
        [converter convertWithOptions:options
                           completion:^(NSString *result, NSError *error) {
            markdown = result;
            conversionError = error;
            dispatch_semaphore_signal(semaphore);
        }];
        
        // Wait for completion
        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
        
        if (isatty(STDERR_FILENO) && options.progressHandler && !debugMode) {
            fprintf(stderr, "\n"); // Clear progress line
        }
        
        if (debugMode) {
            fprintf(stderr, "[DEBUG] Conversion completed\n");
        }
        
        if (conversionError) {
            fprintf(stderr, "Conversion failed: %s\n", 
                    [[conversionError localizedDescription] UTF8String]);
            return 1;
        }
        
        if (debugMode) {
            if (markdown) {
                NSUInteger length = [markdown length];
                NSString *preview = length > 100 ? [markdown substringToIndex:100] : markdown;
                // Replace newlines with literal \n for debug output
                preview = [preview stringByReplacingOccurrencesOfString:@"\n" withString:@"\\n"];
                fprintf(stderr, "[DEBUG] Markdown generated: %lu characters\n", (unsigned long)length);
                fprintf(stderr, "[DEBUG] Markdown preview: %s%s\n", [preview UTF8String], 
                        length > 100 ? "..." : "");
            } else {
                fprintf(stderr, "[DEBUG] ERROR: Markdown is nil!\n");
            }
        }
        
        // Write output
        if (outputPath) {
            // Write to file
            if (debugMode) {
                fprintf(stderr, "[DEBUG] Writing to file: %s\n", [outputPath UTF8String]);
                
                // Check if parent directory exists
                NSString *parentDir = [outputPath stringByDeletingLastPathComponent];
                NSFileManager *fileManager = [NSFileManager defaultManager];
                BOOL isDirectory;
                if ([fileManager fileExistsAtPath:parentDir isDirectory:&isDirectory] && isDirectory) {
                    fprintf(stderr, "[DEBUG] Parent directory exists: %s\n", [parentDir UTF8String]);
                } else {
                    fprintf(stderr, "[DEBUG] WARNING: Parent directory does not exist: %s\n", [parentDir UTF8String]);
                }
                
                // Check if we can write to the directory
                if ([fileManager isWritableFileAtPath:parentDir]) {
                    fprintf(stderr, "[DEBUG] Parent directory is writable\n");
                } else {
                    fprintf(stderr, "[DEBUG] WARNING: Parent directory is not writable\n");
                }
            }
            
            NSError *writeError = nil;
            BOOL success = [markdown writeToFile:outputPath
                                      atomically:YES
                                        encoding:NSUTF8StringEncoding
                                           error:&writeError];
            if (!success) {
                fprintf(stderr, "Failed to write output file: %s\n",
                        [[writeError localizedDescription] UTF8String]);
                return 1;
            }
            
            if (debugMode) {
                fprintf(stderr, "[DEBUG] File write successful\n");
                
                // Verify the file was written
                NSFileManager *fileManager = [NSFileManager defaultManager];
                if ([fileManager fileExistsAtPath:outputPath]) {
                    NSDictionary *attributes = [fileManager attributesOfItemAtPath:outputPath error:nil];
                    NSNumber *fileSize = attributes[NSFileSize];
                    fprintf(stderr, "[DEBUG] Output file created, size: %lld bytes\n", [fileSize longLongValue]);
                } else {
                    fprintf(stderr, "[DEBUG] ERROR: Output file was not created!\n");
                }
            }
        } else {
            // Write to stdout
            NSFileHandle *stdoutHandle = [NSFileHandle fileHandleWithStandardOutput];
            NSData *markdownData = [markdown dataUsingEncoding:NSUTF8StringEncoding];
            [stdoutHandle writeData:markdownData];
            
            // Add newline if not present
            if (![markdown hasSuffix:@"\n"]) {
                [stdoutHandle writeData:[@"\n" dataUsingEncoding:NSUTF8StringEncoding]];
            }
        }
        
        return 0;
    }
}
</file>

<file path="pdf21md/Tests/Integration/EndToEndConversionTests.m">
//
//  EndToEndConversionTests.m
//  pdf22md-objc
//
//  Integration tests for complete PDF to Markdown conversion pipeline
//

#import <XCTest/XCTest.h>
#import "PDF21MDConverter.h"
#import "PDF21MDConversionOptions.h"
#import "PDF21MDError.h"

@interface EndToEndConversionTests : XCTestCase
@property (nonatomic, strong) PDF21MDConverter *converter;
@property (nonatomic, strong) NSString *testResourcesPath;
@property (nonatomic, strong) NSString *tempOutputPath;
@end

@implementation EndToEndConversionTests

- (void)setUp {
    [super setUp];
    self.converter = [[PDF21MDConverter alloc] init];
    
    // Set up test resources path
    NSBundle *bundle = [NSBundle bundleForClass:[self class]];
    self.testResourcesPath = [bundle.resourcePath stringByAppendingPathComponent:@"Tests/Resources"];
    
    // Create temporary output directory
    self.tempOutputPath = [NSTemporaryDirectory() stringByAppendingPathComponent:@"pdf22md-test-output"];
    [[NSFileManager defaultManager] createDirectoryAtPath:self.tempOutputPath 
                              withIntermediateDirectories:YES 
                                               attributes:nil 
                                                    error:nil];
}

- (void)tearDown {
    // Clean up temporary directory
    [[NSFileManager defaultManager] removeItemAtPath:self.tempOutputPath error:nil];
    self.converter = nil;
    [super tearDown];
}

#pragma mark - Complete Workflow Tests

- (void)testSimpleTextDocumentConversion {
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"simple-text.pdf"];
    
    // Skip test if resource file doesn't exist
    if (![self fileExistsAtPath:testPDFPath]) {
        NSLog(@"Test PDF 'simple-text.pdf' not found, skipping test");
        return;
    }
    
    PDF21MDConversionOptions *options = [[PDF21MDConversionOptions alloc] init];
    options.assetsPath = [self.tempOutputPath stringByAppendingPathComponent:@"assets"];
    
    NSError *error = nil;
    NSString *markdown = [self.converter convertPDFAtPath:testPDFPath 
                                              withOptions:options 
                                                    error:&error];
    
    XCTAssertNotNil(markdown, @"Should successfully convert simple text PDF");
    XCTAssertNil(error, @"Should not return error for valid PDF conversion");
    
    // Validate markdown structure
    [self validateBasicMarkdownStructure:markdown];
    
    // Check that assets directory was created (even if empty)
    BOOL isDirectory;
    BOOL assetsExist = [[NSFileManager defaultManager] fileExistsAtPath:options.assetsPath 
                                                            isDirectory:&isDirectory];
    XCTAssertTrue(assetsExist && isDirectory, @"Assets directory should be created");
}

- (void)testComplexDocumentWithImages {
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"complex-with-images.pdf"];
    
    if (![self fileExistsAtPath:testPDFPath]) {
        NSLog(@"Test PDF 'complex-with-images.pdf' not found, skipping test");
        return;
    }
    
    PDF21MDConversionOptions *options = [[PDF21MDConversionOptions alloc] init];
    options.assetsPath = [self.tempOutputPath stringByAppendingPathComponent:@"assets"];
    options.dpi = 200; // Higher DPI for quality
    
    NSError *error = nil;
    NSString *markdown = [self.converter convertPDFAtPath:testPDFPath 
                                              withOptions:options 
                                                    error:&error];
    
    XCTAssertNotNil(markdown, @"Should successfully convert complex PDF with images");
    XCTAssertNil(error, @"Should not return error for valid PDF conversion");
    
    // Validate markdown structure
    [self validateBasicMarkdownStructure:markdown];
    
    // Check for image references in markdown
    XCTAssertTrue([markdown containsString:@"!["], @"Should contain image references");
    XCTAssertTrue([markdown containsString:@"assets/"], @"Should reference assets directory");
    
    // Verify that image files were actually created
    NSArray *assetFiles = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:options.assetsPath error:nil];
    XCTAssertTrue(assetFiles.count > 0, @"Should extract at least one asset file");
    
    // Verify image file formats
    for (NSString *filename in assetFiles) {
        XCTAssertTrue([filename hasSuffix:@".png"] || [filename hasSuffix:@".jpg"], 
                      @"Asset files should be PNG or JPG format");
    }
}

- (void)testLargeDocumentPerformance {
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"large-document.pdf"];
    
    if (![self fileExistsAtPath:testPDFPath]) {
        NSLog(@"Test PDF 'large-document.pdf' not found, skipping test");
        return;
    }
    
    PDF21MDConversionOptions *options = [[PDF21MDConversionOptions alloc] init];
    options.assetsPath = [self.tempOutputPath stringByAppendingPathComponent:@"assets"];
    
    NSDate *startTime = [NSDate date];
    
    NSError *error = nil;
    NSString *markdown = [self.converter convertPDFAtPath:testPDFPath 
                                              withOptions:options 
                                                    error:&error];
    
    NSTimeInterval elapsed = [[NSDate date] timeIntervalSinceDate:startTime];
    
    XCTAssertNotNil(markdown, @"Should successfully convert large PDF");
    XCTAssertNil(error, @"Should not return error for valid large PDF");
    XCTAssertLessThan(elapsed, 30.0, @"Large document conversion should complete within 30 seconds");
    
    NSLog(@"Large document conversion time: %.2f seconds", elapsed);
}

#pragma mark - Error Handling Integration Tests

- (void)testMalformedPDFHandling {
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"malformed.pdf"];
    
    if (![self fileExistsAtPath:testPDFPath]) {
        NSLog(@"Test PDF 'malformed.pdf' not found, skipping test");
        return;
    }
    
    PDF21MDConversionOptions *options = [[PDF21MDConversionOptions alloc] init];
    
    NSError *error = nil;
    NSString *markdown = [self.converter convertPDFAtPath:testPDFPath 
                                              withOptions:options 
                                                    error:&error];
    
    // Should either succeed with partial content or fail gracefully
    if (markdown) {
        XCTAssertNil(error, @"If conversion succeeds, should not return error");
        XCTAssertTrue(markdown.length > 0, @"If conversion succeeds, should return content");
    } else {
        XCTAssertNotNil(error, @"If conversion fails, should return meaningful error");
        XCTAssertNotEqual(error.code, 0, @"Error should have meaningful error code");
        XCTAssertTrue(error.localizedDescription.length > 0, @"Error should have description");
    }
}

- (void)testEncryptedPDFHandling {
    // This test would require an encrypted PDF sample
    // For now, we'll test the expected behavior
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"encrypted.pdf"];
    
    if (![self fileExistsAtPath:testPDFPath]) {
        NSLog(@"Test PDF 'encrypted.pdf' not found, skipping test");
        return;
    }
    
    PDF21MDConversionOptions *options = [[PDF21MDConversionOptions alloc] init];
    
    NSError *error = nil;
    NSString *markdown = [self.converter convertPDFAtPath:testPDFPath 
                                              withOptions:options 
                                                    error:&error];
    
    XCTAssertNil(markdown, @"Should not convert encrypted PDF without password");
    XCTAssertNotNil(error, @"Should return error for encrypted PDF");
    XCTAssertEqual(error.code, PDF21MDErrorEncryptedPDF, @"Should return encrypted PDF error code");
}

#pragma mark - Memory Stress Tests

- (void)testMemoryStabilityUnderLoad {
    // Test multiple conversions to ensure memory stability
    PDF21MDConversionOptions *options = [[PDF21MDConversionOptions alloc] init];
    options.assetsPath = [self.tempOutputPath stringByAppendingPathComponent:@"stress-assets"];
    
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"simple-text.pdf"];
    
    if (![self fileExistsAtPath:testPDFPath]) {
        NSLog(@"Test PDF not found, creating minimal test for memory stability");
        return;
    }
    
    // Run multiple conversions
    for (int i = 0; i < 5; i++) {
        @autoreleasepool {
            NSError *error = nil;
            NSString *markdown = [self.converter convertPDFAtPath:testPDFPath 
                                                      withOptions:options 
                                                            error:&error];
            
            XCTAssertNotNil(markdown, @"Conversion %d should succeed", i + 1);
            XCTAssertNil(error, @"Conversion %d should not return error", i + 1);
        }
    }
}

#pragma mark - Output Validation Tests

- (void)testMarkdownOutputQuality {
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"simple-text.pdf"];
    
    if (![self fileExistsAtPath:testPDFPath]) {
        NSLog(@"Test PDF not found, skipping output quality test");
        return;
    }
    
    PDF21MDConversionOptions *options = [[PDF21MDConversionOptions alloc] init];
    
    NSError *error = nil;
    NSString *markdown = [self.converter convertPDFAtPath:testPDFPath 
                                              withOptions:options 
                                                    error:&error];
    
    XCTAssertNotNil(markdown, @"Should produce markdown output");
    
    if (markdown) {
        [self validateAdvancedMarkdownStructure:markdown];
    }
}

- (void)testExpectedOutputComparison {
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"simple-text.pdf"];
    NSString *expectedPath = [self.testResourcesPath stringByAppendingPathComponent:@"expected-outputs/simple-text.md"];
    
    if (![self fileExistsAtPath:testPDFPath] || ![self fileExistsAtPath:expectedPath]) {
        NSLog(@"Test files not found, skipping expected output comparison");
        return;
    }
    
    PDF21MDConversionOptions *options = [[PDF21MDConversionOptions alloc] init];
    
    NSError *error = nil;
    NSString *actualMarkdown = [self.converter convertPDFAtPath:testPDFPath 
                                                    withOptions:options 
                                                          error:&error];
    
    NSString *expectedMarkdown = [NSString stringWithContentsOfFile:expectedPath 
                                                           encoding:NSUTF8StringEncoding 
                                                              error:nil];
    
    XCTAssertNotNil(actualMarkdown, @"Should produce actual markdown");
    XCTAssertNotNil(expectedMarkdown, @"Should load expected markdown");
    
    if (actualMarkdown && expectedMarkdown) {
        // Normalize whitespace for comparison
        NSString *normalizedActual = [self normalizeWhitespace:actualMarkdown];
        NSString *normalizedExpected = [self normalizeWhitespace:expectedMarkdown];
        
        XCTAssertEqualObjects(normalizedActual, normalizedExpected, 
                              @"Actual output should match expected output");
    }
}

#pragma mark - Helper Methods

- (BOOL)fileExistsAtPath:(NSString *)path {
    return [[NSFileManager defaultManager] fileExistsAtPath:path];
}

- (void)validateBasicMarkdownStructure:(NSString *)markdown {
    XCTAssertTrue(markdown.length > 0, @"Markdown should not be empty");
    
    // Should not contain raw PDF artifacts
    XCTAssertFalse([markdown containsString:@"%%PDF"], @"Should not contain PDF header");
    XCTAssertFalse([markdown containsString:@"endobj"], @"Should not contain PDF objects");
    
    // Should be valid UTF-8
    NSData *data = [markdown dataUsingEncoding:NSUTF8StringEncoding];
    XCTAssertNotNil(data, @"Markdown should be valid UTF-8");
}

- (void)validateAdvancedMarkdownStructure:(NSString *)markdown {
    [self validateBasicMarkdownStructure:markdown];
    
    // Check for proper markdown formatting
    NSArray *lines = [markdown componentsSeparatedByString:@"\n"];
    
    BOOL hasHeadings = NO;
    BOOL hasContent = NO;
    
    for (NSString *line in lines) {
        NSString *trimmed = [line stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
        
        if ([trimmed hasPrefix:@"#"]) {
            hasHeadings = YES;
            // Validate heading format
            XCTAssertTrue([trimmed rangeOfString:@"# "].location != NSNotFound ||
                         [trimmed rangeOfString:@"## "].location != NSNotFound ||
                         [trimmed rangeOfString:@"### "].location != NSNotFound,
                         @"Headings should have proper spacing");
        }
        
        if (trimmed.length > 0 && ![trimmed hasPrefix:@"#"] && ![trimmed hasPrefix:@"!"]) {
            hasContent = YES;
        }
    }
    
    // Don't require headings for all documents, but if present, they should be formatted correctly
    if (hasHeadings) {
        XCTAssertTrue(hasContent, @"Document with headings should also have content");
    }
}

- (NSString *)normalizeWhitespace:(NSString *)text {
    // Normalize line endings and excessive whitespace for comparison
    NSString *normalized = [text stringByReplacingOccurrencesOfString:@"\r\n" withString:@"\n"];
    normalized = [normalized stringByReplacingOccurrencesOfString:@"\r" withString:@"\n"];
    
    // Remove trailing whitespace from lines
    NSMutableArray *lines = [[normalized componentsSeparatedByString:@"\n"] mutableCopy];
    for (NSInteger i = 0; i < lines.count; i++) {
        lines[i] = [lines[i] stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
    }
    
    return [lines componentsJoinedByString:@"\n"];
}

@end
</file>

<file path="pdf21md/Tests/Unit/SimpleConverterTest.m">
//
//  SimpleConverterTest.m
//  pdf22md-objc
//
//  Simple test without XCTest framework dependency
//

#import <Foundation/Foundation.h>
#import "Core/PDF21MDConverter.h"
#import "Core/PDF21MDConversionOptions.h"
#import "Core/PDF21MDError.h"

// Simple assertion macro for non-XCTest testing
#define ASSERT(condition, message) \
    if (!(condition)) { \
        printf("‚ùå ASSERT FAILED: %s - %s\n", #condition, message); \
        return 1; \
    } else { \
        printf("‚úÖ ASSERT PASSED: %s\n", #condition); \
    }

int main(int argc, char *argv[]) {
    @autoreleasepool {
        printf("üß™ Running Simple Converter Tests\n");
        printf("==================================\n");
        
        // Test 1: Options initialization
        PDF21MDConversionOptions *options = [[PDF21MDConversionOptions alloc] init];
        ASSERT(options != nil, "Options should initialize successfully");
        ASSERT(options.rasterizationDPI == 144.0, "Default DPI should be 144");
        
        // Test 2: Default options creation
        PDF21MDConversionOptions *defaultOptions = [PDF21MDConversionOptions defaultOptions];
        ASSERT(defaultOptions != nil, "Default options should initialize successfully");
        
        // Test 3: Error handling for nil URL
        PDF21MDConverter *converter = [[PDF21MDConverter alloc] initWithPDFURL:nil];
        ASSERT(converter == nil, "Should return nil for nil URL");
        
        // Test 4: Error handling for non-existent file  
        NSURL *nonExistentURL = [NSURL fileURLWithPath:@"/nonexistent/file.pdf"];
        converter = [[PDF21MDConverter alloc] initWithPDFURL:nonExistentURL];
        ASSERT(converter == nil, "Should return nil for non-existent file");
        
        // Test 5: Error helper methods
        NSError *testError = [PDF21MDErrorHelper invalidPDFError];
        ASSERT(testError != nil, "Error helper should create error");
        ASSERT(testError.localizedDescription != nil, "Error should have localized description");
        ASSERT(testError.localizedDescription.length > 0, "Error description should not be empty");
        
        // Test 6: File not found error
        NSError *fileError = [PDF21MDErrorHelper fileNotFoundErrorWithPath:@"/test/path"];
        ASSERT(fileError != nil, "Should create file not found error");
        ASSERT(fileError.code == PDF21MDErrorFileNotFound, "Should have correct error code");
        
        printf("\nüéâ All simple tests passed!\n");
        return 0;
    }
}
</file>

<file path="pdf21md/Makefile">
# pdf21md Makefile
# this_file: pdf21md/Makefile

CC = clang
CFLAGS = -Wall -Wextra -std=c11 -O2
OBJCFLAGS = -fobjc-arc -framework Foundation -framework CoreGraphics -framework PDFKit -framework ImageIO -framework AppKit
TARGET = pdf21md
SRCDIR = src
SOURCES = $(SRCDIR)/CLI/main.m $(wildcard $(SRCDIR)/Core/*.m) $(wildcard $(SRCDIR)/Models/*.m) $(wildcard $(SRCDIR)/Services/*.m) $(wildcard shared-core/*.m) $(wildcard shared-algorithms/*.m)
HEADERS = $(wildcard $(SRCDIR)/**/*.h) $(wildcard shared-core/*.h) $(wildcard shared-algorithms/*.h)
OBJECTS = $(SOURCES:.m=.o)

# Default target
all: $(TARGET)

# Build the main executable
$(TARGET): $(OBJECTS)
	$(CC) $(OBJCFLAGS) -o $@ $^

# Compile Objective-C source files
%.o: %.m $(HEADERS)
	$(CC) $(CFLAGS) $(OBJCFLAGS) -c $< -o $@

# Install target
install: $(TARGET)
	cp $(TARGET) /usr/local/bin/

# Clean build artifacts
clean:
	rm -f $(OBJECTS) $(TARGET)

# Run tests
test: $(TARGET)
	@echo "Running tests..."
	# Add test commands here

# Build benchmark
benchmark: pdf21md-benchmark

pdf21md-benchmark: $(SRCDIR)/CLI/pdf21md-benchmark.m $(filter-out $(SRCDIR)/CLI/main.o,$(OBJECTS))
	$(CC) $(OBJCFLAGS) -o $@ $^

# Phony targets
.PHONY: all clean install test benchmark

# Debug build
debug: CFLAGS += -g -DDEBUG
debug: $(TARGET)

# Print variables for debugging
print-%:
	@echo $* = $($*)
</file>

<file path="pdf21md/README.md">
# pdf21md

A blazingly fast PDF to Markdown converter for macOS, built with Objective-C and optimized for performance using Grand Central Dispatch (GCD).

## Features

- **High-Speed Conversion**: Uses all available CPU cores to process PDF pages concurrently
- **Intelligent Heading Detection**: Analyzes font sizes and usage frequency to automatically format titles and headings
- **Asset Extraction**: Saves raster and vector images into a specified assets folder and links them correctly in the Markdown file
- **Smart Image Formatting**: Automatically chooses between JPEG (for photos) and PNG (for graphics with transparency)
- **Flexible I/O**: Reads from a PDF file or `stdin` and writes to a Markdown file or `stdout`
- **Customizable Rasterization**: Allows setting a custom DPI for converting vector graphics to bitmaps

## Building

### Using Make
```bash
# Build the project
make

# Build with debug symbols
make debug

# Build benchmark tool
make benchmark

# Install to /usr/local/bin
sudo make install

# Clean build artifacts
make clean
```

### Manual Build
```bash
# Compile manually
clang -fobjc-arc -framework Foundation -framework CoreGraphics -framework PDFKit -framework ImageIO \
  src/CLI/*.m src/Core/*.m src/Models/*.m src/Services/*.m shared-core/*.m shared-algorithms/*.m \
  -o pdf21md
```

## Installation

```bash
# Build and install
make
sudo make install
```

## Usage

```bash
# Convert a PDF file
./pdf21md -i document.pdf -o document.md

# Extract images to assets folder
./pdf21md -i report.pdf -o report.md -a ./assets

# Customize DPI for vector graphics
./pdf21md -i large.pdf -o large.md -d 300

# Use with pipes
cat document.pdf | ./pdf21md > document.md
```

### Command Line Options

```
Usage: pdf21md [-i input.pdf] [-o output.md] [-a assets_folder] [-d dpi]
  Converts PDF documents to Markdown format
  -i <path>: Input PDF file (default: stdin)
  -o <path>: Output Markdown file (default: stdout)
  -a <path>: Assets folder for extracted images
  -d <dpi>: DPI for rasterizing vector graphics (default: 144)
```

## Architecture

The Objective-C implementation is organized into several key components:

### Core Components
- **PDF21MDConverter**: Main conversion coordinator
- **PDF21MDPageProcessor**: Handles individual page processing
- **PDF21MDFontAnalyzer**: Analyzes font usage for heading detection
- **PDF21MDAssetManager**: Manages image extraction and saving
- **PDF21MDMarkdownGenerator**: Generates final Markdown output

### Models
- **PDF21MDContentElement**: Base protocol for content elements
- **PDF21MDTextElement**: Represents text content with formatting
- **PDF21MDImageElement**: Represents image content

### Shared Components
- **PDF21MDConstants**: Shared constants and configuration
- **PDF21MDFileSystemUtils**: File system utilities
- **PDF21MDImageFormatDetection**: Image format detection algorithms

## Testing

```bash
# Run basic tests (requires implementation)
make test

# Run benchmark
make benchmark
./pdf21md-benchmark
```

## Performance

- Utilizes Grand Central Dispatch for concurrent page processing
- Memory-efficient processing with proper resource management
- Optimized image format detection and conversion
- Smart caching of font analysis results

## Requirements

- macOS 10.12 or later
- Xcode Command Line Tools
- Foundation, CoreGraphics, PDFKit, and ImageIO frameworks

## License

MIT License - see LICENSE file in the root directory
</file>

<file path="test_both.sh">
#!/bin/bash
# Test both Objective-C and Swift implementations
# Change to script directory

set -e

if [ $# -ne 1 ]; then
    PDF="testdata/test.pdf"
else
    PDF=$(realpath $1)
fi

cd "$(dirname "$0")"

PDF_DIR=$(dirname $PDF)
PDF_NAME=$(basename $PDF .pdf)
MD_DIR_OC="$PDF_DIR/$PDF_NAME-oc"
MD_DIR_SW="$PDF_DIR/$PDF_NAME-sw"

# Build both versions first
./build.sh

# Run Objective-C version
echo "oc"
CG_PDF_VERBOSE=True time ./pdf21md/pdf21md \
    -i "$PDF" \
    -o "$MD_DIR_OC.md" \
    -a "$MD_DIR_OC"

# Run Swift version
echo "sw"
CG_PDF_VERBOSE=True time ./pdf22md/.build/release/pdf22md \
    -i "$PDF" \
    -o "$MD_DIR_SW.md" \
    -a "$MD_DIR_SW"
</file>

<file path="AGENTS.md">
# pdf22md

A blazingly fast PDF to Markdown converter for macOS.

`pdf22md` is a command-line tool that extracts all text and image content from a PDF file and converts it into a clean Markdown document. It uses Grand Central Dispatch (GCD) to process pages and save images in parallel, making it exceptionally fast for multi-page documents.

### Key Features

  * **High-Speed Conversion**: Uses all available CPU cores to process PDF pages concurrently.
  * **Intelligent Heading Detection**: Analyzes font sizes and usage frequency to automatically format titles and headings (`#`, `##`, etc.).
  * **Asset Extraction**: Saves raster and vector images into a specified assets folder and links them correctly in the Markdown file.
  * **Smart Image Formatting**: Automatically chooses between JPEG (for photos) and PNG (for graphics with transparency) to optimize file size and quality.
  * **Flexible I/O**: Reads from a PDF file or `stdin` and writes to a Markdown file or `stdout`.
  * **Customizable Rasterization**: Allows setting a custom DPI for converting vector graphics to bitmaps.

### Installation

Once the Homebrew tap is set up (see plan below), installation is simple:

```bash
brew install <your-username>/pdf22md/pdf22md
```

### Building from Source

To build the project manually, you need Xcode Command Line Tools installed.

```bash
# Clone the repository (once it's public)
git clone https://github.com/<your-username>/pdf22md.git
cd pdf22md

# Compile the tool
make

# Install it to /usr/local/bin
sudo make install
```

### Usage

```
Usage: pdf22md [-i input.pdf] [-o output.md] [-a assets_folder] [-d dpi]
  Converts PDF documents to Markdown format
  -i <path>: Input PDF file (default: stdin)
  -o <path>: Output Markdown file (default: stdout)
  -a <path>: Assets folder for extracted images
  -d <dpi>: DPI for rasterizing vector graphics (default: 144)
```

**Example:**

```bash
# Convert a local PDF file and save images to an 'assets' folder
pdf22md -i report.pdf -o report.md -a ./assets
```

---


# main-overview

## Development Guidelines

- Only modify code directly relevant to the specific request. Avoid changing unrelated functionality.
- Never replace code with placeholders like `# ... rest of the processing ...`. Always include complete code.
- Break problems into smaller steps. Think through each step separately before implementing.
- Always provide a complete PLAN with REASONING based on evidence from code and logs before making changes.
- Explain your OBSERVATIONS clearly, then provide REASONING to identify the exact issue. Add console logs when needed to gather more information.


pdf22md is a PDF to Markdown converter that transforms PDF documents while preserving their semantic structure and content relationships.

Core Business Components:

1. Document Structure Analysis (Importance: 95)
- Hierarchical heading detection using font statistics
- Document structure preservation through positional element sorting
- Automated heading level assignment (H1-H6) based on font usage patterns

2. Content Classification System (Importance: 85)
- TextElement: Handles formatted text with style attributes
- ImageElement: Manages both raster and vector graphics
- Content relationship tracking between elements

3. Asset Processing Pipeline (Importance: 80)
- Intelligent format selection between PNG/JPEG based on:
  * Transparency detection
  * Color complexity analysis
  * Dimension-based optimization
- Asset extraction with maintained document references

4. PDF Content Processing (Importance: 90)
- Text styling and formatting context preservation
- Vector graphics path construction tracking
- Coordinate system transformation management
- Element bounds calculation for layout fidelity

Key Integration Points:

1. Content Extraction Layer
- Connects PDF parsing with markdown generation
- Maintains element relationships and hierarchy
- Preserves formatting context across transformations

2. Asset Management Layer
- Links extracted images with markdown references
- Maintains asset organization structure
- Handles format conversions while preserving quality

The system organizes business logic around content transformation pipelines while maintaining document semantic structure throughout the conversion process.

‚Äî‚Äî When you‚Äôre done with a round of updates, update CHANGELOG.md with the changes, remove done things from TODO.md, identify new things that need to be done and add them to TODO.md. Then build the app or run ./release.sh and then continue updates.
</file>

<file path="CLAUDE.md">
# pdf22md

A blazingly fast PDF to Markdown converter for macOS, available in two implementations: `pdf21md` (Objective-C) and `pdf22md` (Swift).

`pdf21md` and `pdf22md` are command-line tools that extract all text and image content from a PDF file and convert it into a clean Markdown document. The Objective-C version (`pdf21md`) uses Grand Central Dispatch (GCD) while the Swift version (`pdf22md`) uses modern async/await for parallel processing, making both exceptionally fast for multi-page documents.

### Key Features

  * **High-Speed Conversion**: Uses all available CPU cores to process PDF pages concurrently.
  * **Intelligent Heading Detection**: Analyzes font sizes and usage frequency to automatically format titles and headings (`#`, `##`, etc.).
  * **Asset Extraction**: Saves raster and vector images into a specified assets folder and links them correctly in the Markdown file.
  * **Smart Image Formatting**: Automatically chooses between JPEG (for photos) and PNG (for graphics with transparency) to optimize file size and quality.
  * **Flexible I/O**: Reads from a PDF file or `stdin` and writes to a Markdown file or `stdout`.
  * **Customizable Rasterization**: Allows setting a custom DPI for converting vector graphics to bitmaps.

### Installation

Once the Homebrew tap is set up (see plan below), installation is simple:

```bash
brew install <your-username>/pdf22md/pdf22md
```

### Building from Source

To build the project manually, you need Xcode Command Line Tools installed.

```bash
# Clone the repository (once it's public)
git clone https://github.com/<your-username>/pdf22md.git
cd pdf22md

# For Objective-C version (pdf21md)
cd pdf21md
make
sudo make install

# For Swift version (pdf22md)
cd ../pdf22md
swift build -c release
sudo cp .build/release/pdf22md /usr/local/bin/
```

### Usage

```
Usage: pdf22md [-i input.pdf] [-o output.md] [-a assets_folder] [-d dpi]
  Converts PDF documents to Markdown format
  -i <path>: Input PDF file (default: stdin)
  -o <path>: Output Markdown file (default: stdout)
  -a <path>: Assets folder for extracted images
  -d <dpi>: DPI for rasterizing vector graphics (default: 144)
```

**Example:**

```bash
# Convert using Objective-C version
pdf21md -i report.pdf -o report.md -a ./assets

# Or using Swift version
pdf22md -i report.pdf -o report.md -a ./assets
```

---


# main-overview

## Development Guidelines

- Only modify code directly relevant to the specific request. Avoid changing unrelated functionality.
- Never replace code with placeholders like `# ... rest of the processing ...`. Always include complete code.
- Break problems into smaller steps. Think through each step separately before implementing.
- Always provide a complete PLAN with REASONING based on evidence from code and logs before making changes.
- Explain your OBSERVATIONS clearly, then provide REASONING to identify the exact issue. Add console logs when needed to gather more information.


pdf22md is a PDF to Markdown converter that transforms PDF documents while preserving their semantic structure and content relationships.

Core Business Components:

1. Document Structure Analysis (Importance: 95)
- Hierarchical heading detection using font statistics
- Document structure preservation through positional element sorting
- Automated heading level assignment (H1-H6) based on font usage patterns

2. Content Classification System (Importance: 85)
- TextElement: Handles formatted text with style attributes
- ImageElement: Manages both raster and vector graphics
- Content relationship tracking between elements

3. Asset Processing Pipeline (Importance: 80)
- Intelligent format selection between PNG/JPEG based on:
  * Transparency detection
  * Color complexity analysis
  * Dimension-based optimization
- Asset extraction with maintained document references

4. PDF Content Processing (Importance: 90)
- Text styling and formatting context preservation
- Vector graphics path construction tracking
- Coordinate system transformation management
- Element bounds calculation for layout fidelity

Key Integration Points:

1. Content Extraction Layer
- Connects PDF parsing with markdown generation
- Maintains element relationships and hierarchy
- Preserves formatting context across transformations

2. Asset Management Layer
- Links extracted images with markdown references
- Maintains asset organization structure
- Handles format conversions while preserving quality

The system organizes business logic around content transformation pipelines while maintaining document semantic structure throughout the conversion process.

‚Äî‚Äî When you‚Äôre done with a round of updates, update CHANGELOG.md with the changes, remove done things from TODO.md, identify new things that need to be done and add them to TODO.md. Then build the app or run ./release.sh and then continue updates.
</file>

<file path=".gitignore">
_private/
!AGENTS.md
!CHANGELOG.md
!CLAUDE.md
!default.mode1v3
!default.mode2v3
!default.pbxuser
!default.perspectivev3
!docs/*.md
!README.md
!TODO.md
._*
.AppleDouble
.build/
.cursorindexingignore
.DS_Store
.idea/
.LSOverride
.specstory/
.Spotlight-V100
.Trashes
.vscode/
*.a
*.dmg
*.dSYM/
*.dylib
*.gcda
*.gcno
*.gcov
*.mode1v3
*.mode2v3
*.moved-aside
*.o
*.pbxuser
*.pdf
*.perspectivev3
*.swo
*.swp
*.tar.gz
*.xccheckout
*.xcodeproj/
*.xcscmblueprint
*.xcworkspace
*.zip
*~
build/
cmake_install.cmake
CMakeCache.txt
CMakeFiles/
coverage/
debug-assets/
DerivedData/
dist/
docs/_build/
issues/
Makefile.cmake
pdf22md/.build
test-results/
test/out/
testdata/test.pdf-oc/.test*
xcuserdata/
</file>

<file path="build.sh">
#!/bin/bash
# Build script for pdf22md (both Objective-C and Swift versions)

set -e # Exit on any error

npx repomix -o llms.txt .

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Print colored output
print_status() {
    echo -e "${BLUE}==>${NC} $1"
}

print_success() {
    echo -e "${GREEN}‚úì${NC} $1"
}

print_error() {
    echo -e "${RED}‚úó${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}‚ö†${NC} $1"
}

# Check if we're in the right directory
if [ ! -d "pdf21md" ] || [ ! -d "pdf22md" ]; then
    print_error "This script must be run from the pdf22md root directory"
    exit 1
fi

# Parse command line arguments
BUILD_OBJC=true
BUILD_SWIFT=true
CLEAN=false
INSTALL=false
BUILD_TYPE="release"

while [[ $# -gt 0 ]]; do
    case $1 in
    --objc-only)
        BUILD_SWIFT=false
        shift
        ;;
    --swift-only)
        BUILD_OBJC=false
        shift
        ;;
    --clean)
        CLEAN=true
        shift
        ;;
    --install)
        INSTALL=true
        shift
        ;;
    --debug)
        BUILD_TYPE="debug"
        shift
        ;;
    -h | --help)
        echo "Usage: $0 [options]"
        echo "Options:"
        echo "  --objc-only      Build only the Objective-C version"
        echo "  --swift-only     Build only the Swift version"
        echo "  --clean          Clean build artifacts before building"
        echo "  --install        Install binaries to /usr/local/bin after building"
        echo "  --debug          Build in debug mode"
        echo "  -h, --help       Show this help message"
        exit 0
        ;;
    *)
        print_error "Unknown option: $1"
        exit 1
        ;;
    esac
done

# Clean if requested
if [ "$CLEAN" = true ]; then
    print_status "Cleaning build artifacts"

    if [ "$BUILD_OBJC" = true ]; then
        cd pdf21md
        make clean >/dev/null 2>&1 || true
        cd ..
        print_success "Cleaned Objective-C build artifacts"
    fi

    if [ "$BUILD_SWIFT" = true ]; then
        cd pdf22md
        swift package clean >/dev/null 2>&1 || true
        rm -rf .build >/dev/null 2>&1 || true
        cd ..
        print_success "Cleaned Swift build artifacts"
    fi
fi

# Build Objective-C version
if [ "$BUILD_OBJC" = true ]; then
    print_status "Building Objective-C version"
    cd pdf21md

    if [ "$BUILD_TYPE" = "debug" ]; then
        make debug
    else
        make
    fi

    if [ $? -eq 0 ]; then
        print_success "Objective-C build completed successfully"
        if [ -f "pdf21md" ]; then
            print_success "Binary created: pdf21md/pdf21md"
        fi
    else
        print_error "Objective-C build failed"
        exit 1
    fi

    cd ..
fi

# Build Swift version
if [ "$BUILD_SWIFT" = true ]; then
    print_status "Building Swift version"
    cd pdf22md

    if [ "$BUILD_TYPE" = "debug" ]; then
        swift build
    else
        swift build -c release
    fi

    if [ $? -eq 0 ]; then
        print_success "Swift build completed successfully"

        # Create a convenience symlink to the Swift binary
        if [ "$BUILD_TYPE" = "debug" ]; then
            SWIFT_BINARY=".build/debug/pdf22md"
        else
            SWIFT_BINARY=".build/release/pdf22md"
        fi

        if [ -f "$SWIFT_BINARY" ]; then
            ln -sf "$SWIFT_BINARY" pdf22md
            print_success "Binary created: pdf22md/pdf22md"
        fi
    else
        print_error "Swift build failed"
        exit 1
    fi

    cd ..
fi

# Install if requested
if [ "$INSTALL" = true ]; then
    print_status "Installing binaries"

    if [ "$BUILD_OBJC" = true ] && [ -f "pdf21md/pdf21md" ]; then
        sudo cp pdf21md/pdf21md /usr/local/bin/pdf21md
        print_success "Installed pdf21md to /usr/local/bin/"
    fi

    if [ "$BUILD_SWIFT" = true ]; then
        if [ "$BUILD_TYPE" = "debug" ]; then
            SWIFT_BINARY="pdf22md/.build/debug/pdf22md"
        else
            SWIFT_BINARY="pdf22md/.build/release/pdf22md"
        fi

        if [ -f "$SWIFT_BINARY" ]; then
            sudo cp "$SWIFT_BINARY" /usr/local/bin/pdf22md
            print_success "Installed pdf22md to /usr/local/bin/"
        fi
    fi

    print_warning "Note: Both versions are now installed:"
    print_warning "  pdf21md - Objective-C implementation"
    print_warning "  pdf22md - Swift implementation"
fi

print_success "Build completed successfully!"

# Show summary
echo
print_status "Build Summary:"
if [ "$BUILD_OBJC" = true ] && [ -f "pdf21md/pdf21md" ]; then
    echo "  ‚Ä¢ Objective-C binary: pdf21md/pdf21md"
fi
if [ "$BUILD_SWIFT" = true ]; then
    if [ "$BUILD_TYPE" = "debug" ]; then
        echo "  ‚Ä¢ Swift binary: pdf22md/.build/debug/pdf22md"
    else
        echo "  ‚Ä¢ Swift binary: pdf22md/.build/release/pdf22md"
    fi
    if [ -L "pdf22md/pdf22md" ]; then
        echo "  ‚Ä¢ Swift symlink: pdf22md/pdf22md"
    fi
fi
</file>

<file path="README.md">
# pdf22md: Your Fast PDF to Markdown Converter

Tired of manually copying text and images from PDFs? `pdf22md` is a powerful tool that automatically converts your PDF documents into clean, readable Markdown files. It's designed for speed and accuracy, making it perfect for researchers, developers, and anyone who needs to repurpose content from PDFs.

## What Does It Do?

`pdf22md` takes your PDF files and transforms them into Markdown, a simple formatting language that's easy to read and convert into other formats like HTML or Word documents. It intelligently extracts:

-   **Text**: All readable text from your PDF.
-   **Headings**: Automatically detects titles and headings (like `## Section Title`) based on font sizes.
-   **Images**: Extracts images and saves them to a separate folder, linking them correctly in your Markdown file. It even chooses the best image format (JPEG for photos, PNG for graphics) to keep file sizes small.

## Why Use pdf22md?

-   **Blazing Fast**: `pdf22md` uses all available processing power to convert even large PDFs quickly.
-   **Accurate**: It's smart about how it extracts content, preserving the structure and readability of your document.
-   **Easy to Use**: Simple commands get your PDFs converted in no time.
-   **Flexible**: Works with both single files and multiple documents, and you can even pipe content directly into it.

## How It Works (A Little Technical Detail)

`pdf22md` is unique because it offers two highly optimized versions:

-   **Objective-C Version (`pdf21md`)**: A mature, robust implementation built for maximum performance on macOS.
-   **Swift Version (`pdf22md`)**: A modern, type-safe implementation using the latest Swift features, designed for future development and integration into other Swift projects.

Both versions share the same core goal: to give you the fastest, most accurate PDF to Markdown conversion possible.

## Get Started Quickly

### Installation

Currently, you can build `pdf22md` from its source code. Homebrew installation will be available soon for easier setup!

#### Build from Source (Recommended)

1.  **Clone the repository**:
    ```bash
    git clone https://github.com/twardoch/pdf22md.git
    cd pdf22md
    ```
2.  **Run the build script**: This script will build both the Objective-C and Swift versions.
    ```bash
    ./build.sh
    ```
    After a successful build, you'll find the executables in `pdf21md/pdf21md` (Objective-C) and `pdf22md/.build/release/pdf22md` (Swift).

### Basic Usage

Once installed, you can use `pdf22md` from your terminal:

```bash
# Convert a PDF file and save the Markdown output
pdf22md -i your_document.pdf -o output.md

# Extract images to a subfolder named 'assets'
pdf22md -i your_document.pdf -o output.md -a ./assets

# Convert a PDF and pipe the output directly to your screen
cat your_document.pdf | pdf22md
```

#### Command Line Options:

```
Usage: pdf22md [-i input.pdf] [-o output.md] [-a assets_folder] [-d dpi]
  Converts PDF documents to Markdown format.
  -i <path>: Input PDF file (default: stdin)
  -o <path>: Output Markdown file (default: stdout)
  -a <path>: Assets folder for extracted images (optional)
  -d <dpi>: DPI for rasterizing vector graphics (default: 144, optional)
```

## Requirements

-   macOS 10.12 or later
-   Xcode Command Line Tools (for building from source)
-   For Swift version: macOS 12.0+ and Swift 5.7+

## Performance

`pdf22md` is engineered for speed:

-   **Parallel Processing**: It uses all available CPU cores to process PDF pages simultaneously.
-   **Efficient Memory Use**: Designed to handle large documents without hogging your system's memory.
-   **Smart Optimizations**: Includes intelligent algorithms for font analysis and image handling.

## Need More Details?

-   **For Developers**: Check out `CONTRIBUTING.md` (coming soon) for in-depth technical explanations and contribution guidelines.
-   **Specific Implementations**:
    -   [Objective-C Version Details](./pdf21md/README.md)
    -   [Swift Version Details](./pdf22md/README.md)
-   **Parallel Processing**: Learn more about how `pdf22md` achieves its speed in [PARALLEL_PROCESSING.md](./docs/PARALLEL_PROCESSING.md).

## License

`pdf22md` is released under the MIT License. See the [LICENSE](LICENSE) file for details.
</file>

<file path="CHANGELOG.md">
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Changed
- **IMPLEMENTATION RENAMING**: 
  - Renamed Objective-C implementation from `pdf22md-objc` to `pdf21md` (directory and binary)
  - Renamed Swift implementation binary from `pdf22md` to `pdf22md`
  - Updated all class prefixes from `PDF22MD` to `PDF21MD` in Objective-C implementation
  - Updated all build scripts and documentation to reflect new naming
- **MAJOR CODEBASE RESTRUCTURING**: Complete reorganization into two self-contained implementations
- **Dual Implementation Architecture**: 
  - `pdf21md/`: Production-ready Objective-C implementation with full functionality
  - `pdf22md/`: Modern Swift library foundation with Swift Package Manager
- **Shared Component Integration**: Moved shared components to implementation-specific directories:
  - `pdf21md/shared-core/`: FileSystemUtils, Constants, ErrorFactory, ConcurrencyManager
  - `pdf21md/shared-algorithms/`: ImageFormatDetection
- **Build System Consolidation**: 
  - Created self-contained Makefile for Objective-C implementation
  - Simplified Swift Package Manager manifest for Swift implementation
  - Removed redundant root-level build scripts
- **Import Path Updates**: Fixed all import statements to reference new shared component locations
- **Documentation Overhaul**: 
  - Updated main README.md to showcase dual implementation approach
  - Created comprehensive README.md for each implementation
  - Updated project structure to reflect new organization

### Added
- **Self-Contained Implementations**: Both implementations now include their own:
  - Build systems (Makefile for ObjC, Package.swift for Swift)
  - Test resources and test suites
  - Documentation and usage examples
  - Shared components integrated locally
- **Production-Ready Objective-C**: Fully functional `pdf21md` executable with:
  - Complete PDF-to-Markdown conversion
  - Parallel processing with GCD
  - Smart image extraction and format detection
  - Command-line interface with proper argument parsing
- **Modern Swift Foundation**: Swift Package Manager library with:
  - Proper module structure for programmatic usage
  - Test framework foundation
  - Modern Swift patterns ready for implementation

### Removed
- **Eliminated Directory Redundancy**: 
  - Removed obsolete `swift/`, `shared/`, `build/`, `test/` directories
  - Consolidated all functionality into two main implementation folders
- **Cleaned Up Build Artifacts**:
  - Removed root-level Makefile, build.sh, pdf22md executable
  - Eliminated duplicate test resources and documentation
- **Streamlined Structure**: Removed intermediate directories and scattered files

### Fixed
- **Build System Issues**: 
  - Resolved module cache issues in Swift build.
  - Resolved duplicate main symbol errors in Objective-C build
  - Fixed import path references for shared components
  - Corrected Swift Package Manager manifest syntax errors
- **File System Organization**: 
  - Fixed relative path issues in shared component imports
  - Resolved compilation errors from directory restructuring
  - Ensured both implementations build and test successfully

### Added
- **PDF22MDFileSystemUtils**: Unified file system operations consolidating scattered NSFileManager patterns
- **PDF22MDConstants**: Centralized configuration constants eliminating magic numbers across 15+ files
- Enhanced error handling with new file system error codes (InvalidPath, DirectoryNotFound, PermissionDenied)
- Comprehensive codebase analysis using repomix (72,530 tokens, 52 files) for streamlining optimization
- Detailed PLAN.md for systematic code streamlining approach
- Updated TODO.md with final 3% streamlining tasks to reach 100% excellence
- Comprehensive streamlining plan (PLAN.md) for codebase optimization
- Unified build system using single Makefile and build.sh script
- Shared component library (shared/ directory) for common algorithms
- PDF22MDImageFormatDetection utility for optimal image format selection
- Unified test resource directory (shared/test-resources/) for all implementations
- **PDF22MDErrorFactory**: Unified error creation factory eliminating error handling duplication across 9+ files with specialized methods for configuration, file system, and processing errors
- **PDF22MDConcurrencyManager**: Standardized GCD patterns and queue management for consistent concurrency across implementations with shared queues and parallel processing utilities
- **Complete Modern Objective-C Implementation**: Full feature-parity rewrite in modern Objective-C with nullability annotations, lightweight generics, and proper designated initializers
- **Complete Swift Implementation**: Modern Swift implementation with async/await, actors, and Swift Package Manager support
- **Multi-Implementation Architecture**: Three implementations (C/ObjC, Modern ObjC, Swift) for different use cases and platform requirements
- **Advanced Error Handling**: Custom error domains and comprehensive error reporting across all implementations
- **Thread-Safe Asset Management**: Concurrent image processing with proper synchronization
- **Modern Build Infrastructure**: Support for both Makefile and Xcode/SPM build systems
- TROUBLESHOOTING.md documentation for common build and runtime issues
- Enhanced Swift toolchain detection in build scripts
- Better error messages for SWBBuildService.framework missing issue
- pdf22md-benchmark utility for performance testing
- Builder pattern for PDF22MDConversionOptions configuration
- Verbose logging options for PDF loading and conversion processes
- Timeout handling for conversion process to prevent hangs
- Comprehensive test data with sample PDFs and expected output
- Semantic versioning support based on git tags
- Version display option (-v, -V) in the command-line tool
- Release automation script (release.sh) for macOS
- GitHub Actions workflow for automated releases
- Package installer (.pkg) generation for macOS

### Changed
- Restructured project with separate directories for each implementation (pdf21md, pdf22md)
- Moved test files and resources to implementation-specific directories
- Updated object file compilation commands in build scripts

### Improved
- Build scripts now provide clearer guidance when Swift toolchain is corrupted
- Swift build failures are handled more gracefully with specific remediation steps
- Build process for pdf21md to resolve duplicate symbol errors
- Error reporting now includes process IDs for easier debugging
- Conversion feedback with detailed status messages during operations

### Fixed
- Duplicate symbol errors in pdf21md build process
- Build script compatibility issues with object file handling
- PDF processing hang issue with timeout implementation
- Memory leaks in asset management

### Removed
- Legacy archived-old-implementation directory (2,000+ lines of obsolete code)
- Duplicate build scripts (pdf21md/build.sh, release.sh, run-tests.sh)
- Duplicate README files and documentation
- Duplicate PARALLEL_PROCESSING.md files across implementations
- Resolved issue files (102, 201) after fixing Swift toolchain problems
- Obsolete pdf22md-benchmark binary file from version control
- **210+ duplicate test images** across 3 implementations (58MB saved)
- **Duplicate PDF test files** across implementations
- **Duplicate man pages** from implementation directories
- **Duplicate Swift build scripts** (pdf22md/build.sh, release.sh)

### Streamlined
- **File system operations**: Consolidated NSFileManager patterns from 4+ files into PDF22MDFileSystemUtils (~150 lines eliminated)
- **Configuration constants**: Centralized all magic numbers (144.0 DPI, 2.0 threshold, etc.) from 15+ files into PDF22MDConstants
- **Asset management**: Updated PDF22MDAssetManager to use shared file utilities and constants
- **Validation logic**: Unified path validation and directory operations across implementations
- Consolidated build system into single authoritative Makefile and build.sh
- Unified documentation in single root README.md
- Removed code duplication between root and implementation directories
- Extracted image format detection algorithm into shared utility (~100 lines deduplicated)
- Build system automatically compiles shared components with proper dependencies
- **Error handling patterns**: Replaced manual NSError creation with standardized factory methods across all validation and processing code (40-60% reduction in error handling boilerplate)
- **Concurrency patterns**: Unified GCD usage with shared queue management and standardized parallel processing patterns (eliminated duplicate queue creation across 4+ files)
- **Shared component architecture**: Established professional foundation with Core/ directory containing ErrorFactory, ConcurrencyManager, FileSystemUtils, and Constants
- **Test resource consolidation**: Single shared/test-resources/ directory (58MB space saved)
- **Documentation consolidation**: Single man page source (docs/pdf22md.1)
- **Build script unification**: No implementation-specific build scripts
- Universal binary support (Intel and Apple Silicon)
- Man page generation in release packages
- MIT License file for open-source compliance
- GitHub issue templates for bug reports and feature requests
- Comprehensive .gitignore file with proper exclusions
- Build directory structure to separate source from build artifacts
- CHANGELOG.md to track version history
- Professional project documentation standards

### Changed
- **Architectural Modernization**: Complete rewrite of core components using modern Objective-C and Swift patterns
- **Enhanced Font Analysis**: Improved heading detection algorithm with configurable thresholds
- **Robust Asset Processing**: Smart image format selection with transparency detection and quality optimization
- **Memory Management**: Enhanced memory efficiency with proper autorelease pool usage and actor-based resource management (Swift)
- Makefile now supports VERSION variable for build-time versioning
- Makefile now uses a dedicated `build/` directory for object files
- .gitignore updated to properly exclude build artifacts and editor files
- GitHub Actions workflow fixed to use correct binary name
- Project structure reorganized following professional standards

### Fixed
- **Critical Build Issues**: Resolved all compilation errors in modern Objective-C implementation including:
  - Fixed designated initializer chain issues
  - Resolved private instance variable access violations  
  - Fixed NSValue CGRect compatibility issues using NSData approach
  - Corrected deprecated UTType constant usage
  - Fixed method signature mismatches and unused variable warnings
- **Memory Safety**: All CGImageRef memory leaks resolved with proper resource management
- **Concurrency Issues**: Thread-safe operations with proper GCD usage and Swift actor patterns
- Build artifacts (.o files) no longer pollute the repository root
- GitHub Actions workflow now correctly references the pdf22md binary
- Make variable in .gitignore replaced with actual filename
- Removed all DEBUG logging statements from production code
- Fixed CLI deadlock caused by main-queue dispatch in `PDFMarkdownConverter`; completions now called directly
- Fixed hanging issue on certain malformed PDFs by replacing low-level CGPDFScanner-based extraction with PDFKit high-level API (see `PDFPageProcessor`)
- Removed unused CGPDFScanner operator callback functions and PDFScannerState struct that were part of the deprecated implementation
- Fixed segmentation fault during asset extraction (Phase 1a): removed premature CGImageRelease calls in `PDFPageProcessor` that deallocated images still in use
- **Build Script Compatibility**: Fixed bash incompatibility in build.sh by replacing `declare -A` associative arrays with simple variables for broader shell compatibility
- **Swift Build Resilience**: Enhanced build.sh with Swift toolchain health checks and graceful fallback handling when Swift toolchain is corrupted
- **Comprehensive Testing Infrastructure**: Implemented complete test framework with unit tests, integration tests, and working test runner for MVP 1.0 readiness
  - Created PDF22MDConverterTests.m for core conversion logic validation
  - Created PDF22MDAssetManagerTests.m for image extraction and management testing
  - Created PDF22MDFontAnalyzerTests.m for heading detection algorithm validation
  - Created EndToEndConversionTests.m for complete pipeline testing
  - Created SimpleConverterTest.m working test executable proving framework functionality
- **Enhanced Error Handling System**: Expanded error definitions with user-friendly messages and actionable suggestions
  - Added 8 specific error codes including encrypted PDF, memory pressure, and processing timeout
  - Implemented PDF22MDErrorHelper with comprehensive user-friendly error messages
  - Added actionable recovery suggestions for all error conditions (e.g., "Try opening in another PDF viewer to verify it's not corrupted")
  - Fixed API compatibility issues in error method naming

### Removed
- Object files from repository root (moved to build directory)

## [1.0.0] - 2024-01-01

### Added
- Initial release of pdf22md
- PDF to Markdown conversion with parallel processing
- Intelligent heading detection based on font size analysis
- Asset extraction with smart image format selection (JPEG/PNG)
- Support for both file and stdin/stdout I/O
- Customizable DPI for vector graphics rasterization
- Grand Central Dispatch (GCD) for multi-core performance
- Comprehensive documentation
</file>

<file path="TODO.md">
# TODO - Linearized Implementation Plan

## üö® PRIORITY 1: Implementation Renaming (pdf21md / pdf22md)

### Phase 1: Directory Renaming
- [x] Rename `pdf22md-objc/` directory to `pdf21md/`
- [ ] Keep `pdf22md/` directory as is

### Phase 2: Objective-C Updates (pdf21md)
#### Makefile
- [ ] Change target name from `pdf22md` to `pdf21md`
- [ ] Update `BINARY_NAME = pdf21md`
- [ ] Update installation path references

#### Source Code Renaming
- [ ] Change class prefix `PDF22MD` to `PDF21MD` in `src/CLI/` (all .h/.m files)
- [ ] Change class prefix `PDF22MD` to `PDF21MD` in `src/Core/` (all .h/.m files)
- [ ] Change class prefix `PDF22MD` to `PDF21MD` in `src/Models/` (all .h/.m files)
- [ ] Change class prefix `PDF22MD` to `PDF21MD` in `src/Services/` (all .h/.m files)
- [ ] Change class prefix `PDF22MD` to `PDF21MD` in `shared-core/` (all utility classes)
- [ ] Change class prefix `PDF22MD` to `PDF21MD` in `shared-algorithms/` (all algorithm classes)
- [ ] Change class prefix `PDF22MD` to `PDF21MD` in `Tests/` (all test files)
- [ ] Update all `#import` statements to use new class names
- [ ] Update all `@class` forward declarations

### Phase 3: Swift Updates (pdf22md)
- [ ] Update Package.swift: Change executable product name from `pdf22md` to `pdf22md`
- [ ] Update main.swift: Change `commandName` from `pdf22md` to `pdf22md`

### Phase 4: Build Scripts
- [ ] Update build.sh: Replace all `pdf22md-objc` with `pdf21md`
- [ ] Update build.sh: Ensure both binaries are installed: `pdf21md` and `pdf22md`
- [ ] Update test_both.sh: Update all directory references
- [ ] Update test_both.sh: Update binary execution paths
- [ ] Update release.sh if it exists

### Phase 5: Documentation Updates
- [ ] Update README.md with new binary names
- [ ] Update CHANGELOG.md with renaming entry
- [x] Update CLAUDE.md project description
- [ ] Update pdf21md/README.md (formerly pdf22md-objc/README.md)
- [ ] Update pdf22md/README.md
- [ ] Create/update man pages for pdf21md and pdf22md

## üö® PRIORITY 2: Fix Markdown Output Generation

### Objective-C (pdf21md) Debugging
#### CLI Enhancement (`src/CLI/main.m`)
- [ ] Add debug flag (`-v/--verbose`) to show conversion progress
- [ ] Log markdown string length and first 100 chars before file write
- [ ] Add detailed error reporting for file write operations
- [ ] Verify output path permissions and parent directory existence
- [ ] Add fallback to stdout when file write fails

#### Markdown Generator (`src/Services/PDF21MDMarkdownGenerator.m`)
- [ ] Add element count validation (log how many elements processed)
- [ ] Log markdown generation stages (frontmatter, content, links)
- [ ] Validate non-empty output before returning
- [ ] Add error propagation for generation failures
- [ ] Add null/empty string checks

#### Converter Pipeline (`src/Core/PDF21MDConverter.m`)
- [ ] Log element extraction results per page
- [ ] Validate font analysis results (heading detection working)
- [ ] Monitor parallel processing completion
- [ ] Add timeout handling for stuck operations

### Swift (pdf22md) Debugging
#### Error Handling Enhancement
- [ ] Add comprehensive try-catch blocks around file operations
- [ ] Log conversion pipeline progress and intermediate results
- [ ] Validate markdown content length before writing
- [ ] Add permission and path validation
- [ ] Implement debug output mode

#### File Writing Robustness
- [ ] Add file write validation and retry logic
- [ ] Check parent directory existence and permissions
- [ ] Add atomic write operations with backup
- [ ] Implement fallback to stdout on file write failure

### Testing & Validation
- [ ] Test with `_private/jlm.pdf` to reproduce exact failure
- [ ] Add minimal test PDF with predictable content
- [ ] Verify conversion pipeline with simple document
- [ ] Create debug mode showing element extraction details
- [ ] Add validation scripts to verify markdown output quality

## Priority 3: Fix CMap Warnings
- [ ] Research PDF font encoding requirements
- [ ] Check if warnings affect text extraction quality
- [ ] Implement proper CMap handling or suppress if benign
- [ ] Test with various PDFs to ensure text extraction works

## Priority 4: Code Quality Fixes
- [ ] Remove unused `fontName` variable in PDFPageProcessorOptimized.swift:70
- [ ] Add comprehensive error messages throughout codebase
- [ ] Implement progress reporting for long conversions
- [ ] Add user-friendly error messages

## Phase 5: Testing & Integration
- [ ] End-to-end conversion validation with multiple PDFs
- [ ] Asset and markdown coordination testing
- [ ] Error recovery testing with simulated failures
- [ ] Performance regression testing
- [ ] Cross-implementation output comparison

## Phase 6: Release Preparation
- [ ] Ensure both `pdf21md` and `pdf22md` work correctly
- [ ] Update all documentation with correct binary names
- [ ] Create Homebrew formulas for both tools
- [ ] Set up GitHub Actions CI/CD
- [ ] Prepare release notes and announcement

## Success Criteria
- [x] PLAN.md updated with renaming strategy
- [ ] Both implementations renamed correctly
- [ ] Both tools generate Markdown files successfully
- [ ] Image extraction continues to work
- [ ] No critical warnings or errors
- [ ] Documentation is accurate
- [ ] Ready for public release
</file>

</files>
