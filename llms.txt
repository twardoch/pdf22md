This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    build-release.yml
    release.yml
docs/
  PARALLEL_PROCESSING.md
  pdf22md.1
issues/
  issue102-resolution.txt
pdf22md-objc/
  src/
    CLI/
      main.m
      pdf22md-benchmark.m
    Core/
      PDF22MDConversionOptions.h
      PDF22MDConversionOptions.m
      PDF22MDConverter.h
      PDF22MDConverter.m
      PDF22MDError.h
      PDF22MDError.m
      PDF22MDFontAnalyzer.h
      PDF22MDFontAnalyzer.m
      PDF22MDPageProcessor.h
      PDF22MDPageProcessor.m
    Models/
      PDF22MDContentElement.h
      PDF22MDImageElement.h
      PDF22MDImageElement.m
      PDF22MDTextElement.h
      PDF22MDTextElement.m
    Services/
      PDF22MDAssetManager.h
      PDF22MDAssetManager.m
      PDF22MDMarkdownGenerator.h
      PDF22MDMarkdownGenerator.m
  Tests/
    Integration/
      EndToEndConversionTests.m
    Unit/
      AssetExtractorTests.m
      ContentElementTests.m
      PDF22MDAssetManagerTests.m
      PDF22MDConverterTests.m
      PDF22MDFontAnalyzerTests.m
      PDFMarkdownConverterTests.m
      SimpleConverterTest.m
pdf22md-swift/
  Tests/
    PDF22MDTests/
      PDF22MDTests.swift
  Package.swift
  README.md
shared/
  Algorithms/
    PDF22MDImageFormatDetection.h
    PDF22MDImageFormatDetection.m
  Core/
    PDF22MDConcurrencyManager.h
    PDF22MDConcurrencyManager.m
    PDF22MDErrorFactory.h
    PDF22MDErrorFactory.m
  test-resources/
    expected-outputs/
      README.md
.gitignore
AGENTS.md
build.sh
CHANGELOG.md
CLAUDE.md
LICENSE
Makefile
README.md
TODO.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/release.yml">
name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  build-and-release:
    runs-on: macos-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Full history for version tags
    
    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable
    
    - name: Get version from tag
      id: version
      run: |
        VERSION=${GITHUB_REF#refs/tags/v}
        echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
        echo "TAG=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
    
    - name: Build universal binary
      run: |
        # Build for Intel
        make clean
        make VERSION="${{ steps.version.outputs.VERSION }}" CFLAGS="-Wall -Wextra -O2 -fobjc-arc -arch x86_64"
        mv pdf22md pdf22md-x86_64
        
        # Build for Apple Silicon
        make clean
        make VERSION="${{ steps.version.outputs.VERSION }}" CFLAGS="-Wall -Wextra -O2 -fobjc-arc -arch arm64"
        mv pdf22md pdf22md-arm64
        
        # Create universal binary
        lipo -create -output pdf22md pdf22md-x86_64 pdf22md-arm64
        chmod +x pdf22md
        
        # Verify universal binary
        lipo -info pdf22md
        ./pdf22md -v
    
    - name: Create distribution package
      run: |
        # Create directory structure
        mkdir -p dist/usr/local/bin
        mkdir -p dist/usr/local/share/man/man1
        mkdir -p dist/usr/local/share/doc/pdf22md
        
        # Copy files
        cp pdf22md dist/usr/local/bin/
        cp LICENSE dist/usr/local/share/doc/pdf22md/
        cp README.md dist/usr/local/share/doc/pdf22md/
        cp docs/PARALLEL_PROCESSING.md dist/usr/local/share/doc/pdf22md/ || true
        
        # Create man page
        cat > dist/usr/local/share/man/man1/pdf22md.1 << EOF
        .TH PDF22MD 1 "$(date +'%B %Y')" "pdf22md ${{ steps.version.outputs.VERSION }}" "User Commands"
        .SH NAME
        pdf22md \- Convert PDF documents to Markdown format
        .SH SYNOPSIS
        .B pdf22md
        [\fB\-i\fR \fIinput.pdf\fR]
        [\fB\-o\fR \fIoutput.md\fR]
        [\fB\-a\fR \fIassets_folder\fR]
        [\fB\-d\fR \fIdpi\fR]
        [\fB\-v\fR]
        [\fB\-h\fR]
        .SH DESCRIPTION
        .B pdf22md
        is a high-performance PDF to Markdown converter for macOS that uses Grand Central Dispatch (GCD) for parallel processing.
        .SH OPTIONS
        .TP
        .BR \-i " " \fIpath\fR
        Input PDF file (default: stdin)
        .TP
        .BR \-o " " \fIpath\fR
        Output Markdown file (default: stdout)
        .TP
        .BR \-a " " \fIpath\fR
        Assets folder for extracted images
        .TP
        .BR \-d " " \fIdpi\fR
        DPI for rasterizing vector graphics (default: 144)
        .TP
        .BR \-v
        Display version information
        .TP
        .BR \-h
        Display help message
        .SH EXAMPLES
        .TP
        Convert a PDF file to Markdown:
        .B pdf22md -i document.pdf -o document.md
        .TP
        Convert with images saved to an assets folder:
        .B pdf22md -i report.pdf -o report.md -a ./assets
        .TP
        Use with pipes:
        .B cat document.pdf | pdf22md > document.md
        .SH AUTHOR
        Adam Twardoch
        .SH LICENSE
        MIT License
        EOF
    
    - name: Create installer package
      run: |
        # Create package info
        mkdir -p package_resources
        
        # Create postinstall script
        cat > package_resources/postinstall << 'EOF'
        #!/bin/bash
        # Update man database
        if command -v makewhatis >/dev/null 2>&1; then
            makewhatis /usr/local/share/man
        fi
        exit 0
        EOF
        chmod +x package_resources/postinstall
        
        # Build the package
        pkgbuild --root dist \
                 --identifier com.twardoch.pdf22md \
                 --version "${{ steps.version.outputs.VERSION }}" \
                 --scripts package_resources \
                 --ownership recommended \
                 pdf22md-${{ steps.version.outputs.VERSION }}.pkg
        
        # Create a distribution XML for productbuild (optional, for more control)
        cat > distribution.xml << EOF
        <?xml version="1.0" encoding="utf-8" standalone="yes"?>
        <installer-gui-script minSpecVersion="2.0">
            <title>pdf22md ${{ steps.version.outputs.VERSION }}</title>
            <organization>com.twardoch</organization>
            <domains enable_localSystem="true"/>
            <options customize="never" require-scripts="true" rootVolumeOnly="true"/>
            <pkg-ref id="com.twardoch.pdf22md">
                <bundle-version>
                    <bundle CFBundleVersion="${{ steps.version.outputs.VERSION }}" id="com.twardoch.pdf22md" path="pdf22md"/>
                </bundle-version>
            </pkg-ref>
            <choices-outline>
                <line choice="default">
                    <line choice="com.twardoch.pdf22md"/>
                </line>
            </choices-outline>
            <choice id="default" title="pdf22md" description="PDF to Markdown converter"/>
            <choice id="com.twardoch.pdf22md" visible="false">
                <pkg-ref id="com.twardoch.pdf22md"/>
            </choice>
            <pkg-ref id="com.twardoch.pdf22md" version="${{ steps.version.outputs.VERSION }}" onConclusion="none">pdf22md-${{ steps.version.outputs.VERSION }}.pkg</pkg-ref>
        </installer-gui-script>
        EOF
        
        # Sign the package if certificates are available
        if security find-identity -p basic -v | grep -q "Developer ID Installer"; then
            INSTALLER_CERT=$(security find-identity -p basic -v | grep "Developer ID Installer" | head -1 | awk '{print $2}')
            productsign --sign "$INSTALLER_CERT" \
                        pdf22md-${{ steps.version.outputs.VERSION }}.pkg \
                        pdf22md-${{ steps.version.outputs.VERSION }}-signed.pkg
            mv pdf22md-${{ steps.version.outputs.VERSION }}-signed.pkg pdf22md-${{ steps.version.outputs.VERSION }}.pkg
        fi
    
    - name: Create release archives
      run: |
        # Create tarball with binary and docs
        mkdir -p pdf22md-${{ steps.version.outputs.VERSION }}
        cp pdf22md pdf22md-${{ steps.version.outputs.VERSION }}/
        cp README.md LICENSE pdf22md-${{ steps.version.outputs.VERSION }}/
        cp -r docs pdf22md-${{ steps.version.outputs.VERSION }}/ || true
        tar -czf pdf22md-${{ steps.version.outputs.VERSION }}-macos.tar.gz pdf22md-${{ steps.version.outputs.VERSION }}
        
        # Create zip for those who prefer it
        zip -r pdf22md-${{ steps.version.outputs.VERSION }}-macos.zip pdf22md-${{ steps.version.outputs.VERSION }}
    
    - name: Generate release notes
      id: release_notes
      run: |
        # Get previous tag
        PREVIOUS_TAG=$(git tag -l 'v*' | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -2 | head -1)
        
        # Generate changelog
        if [ -n "$PREVIOUS_TAG" ]; then
          echo "## What's Changed" > release_notes.md
          echo "" >> release_notes.md
          git log --pretty=format:"* %s (%h)" ${PREVIOUS_TAG}..HEAD >> release_notes.md
        else
          echo "## Initial Release" > release_notes.md
          echo "" >> release_notes.md
          echo "First release of pdf22md!" >> release_notes.md
        fi
        
        echo "" >> release_notes.md
        echo "## Installation" >> release_notes.md
        echo "" >> release_notes.md
        echo "### Using the installer package (recommended):" >> release_notes.md
        echo '```bash' >> release_notes.md
        echo "curl -LO https://github.com/twardoch/pdf22md/releases/download/${{ steps.version.outputs.TAG }}/pdf22md-${{ steps.version.outputs.VERSION }}.pkg" >> release_notes.md
        echo "sudo installer -pkg pdf22md-${{ steps.version.outputs.VERSION }}.pkg -target /" >> release_notes.md
        echo '```' >> release_notes.md
        echo "" >> release_notes.md
        echo "### Manual installation:" >> release_notes.md
        echo '```bash' >> release_notes.md
        echo "curl -LO https://github.com/twardoch/pdf22md/releases/download/${{ steps.version.outputs.TAG }}/pdf22md-${{ steps.version.outputs.VERSION }}-macos.tar.gz" >> release_notes.md
        echo "tar -xzf pdf22md-${{ steps.version.outputs.VERSION }}-macos.tar.gz" >> release_notes.md
        echo "sudo cp pdf22md-${{ steps.version.outputs.VERSION }}/pdf22md /usr/local/bin/" >> release_notes.md
        echo '```' >> release_notes.md
    
    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        name: pdf22md ${{ steps.version.outputs.VERSION }}
        body_path: release_notes.md
        files: |
          pdf22md-${{ steps.version.outputs.VERSION }}.pkg
          pdf22md-${{ steps.version.outputs.VERSION }}-macos.tar.gz
          pdf22md-${{ steps.version.outputs.VERSION }}-macos.zip
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Update Homebrew formula
      run: |
        # This would typically update a homebrew tap repository
        # For now, we'll just output what should be done
        echo "To update Homebrew formula:"
        echo "1. Update the url to: https://github.com/twardoch/pdf22md/archive/refs/tags/${{ steps.version.outputs.TAG }}.tar.gz"
        echo "2. Update the sha256 hash"
        echo "3. Update the version in the formula"
</file>

<file path="docs/PARALLEL_PROCESSING.md">
# Parallel Processing in `pdf22md`

This document outlines the implementation of parallel processing in the `pdf22md` command-line tool for converting PDF documents to Markdown format.

## 1. Objective

The goal was to accelerate the conversion of multi-page PDF documents by processing multiple pages concurrently and saving extracted images in parallel.

## 2. Technology: Grand Central Dispatch (GCD)

Similar to `pdfupng`, we utilized Apple's **Grand Central Dispatch (GCD)** framework with the `dispatch_apply` function for parallel execution.

## 3. Implementation Details

### 3.1. Parallel Page Processing

The core changes were made within the `convertWithAssetsFolderPath:rasterizedDPI:completion:` method in `PDFMarkdownConverter.m`.

#### From Sequential to Concurrent

The original implementation used a sequential `for` loop:

```objc
for (NSInteger pageIndex = 0; pageIndex < pageCount; pageIndex++) {
    PDFPage *page = [self.pdfDocument pageAtIndex:pageIndex];
    // ... process page ...
}
```

This was replaced with:

```objc
dispatch_apply(pageCount, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t pageIndex) {
    @autoreleasepool {
        PDFPage *page = [self.pdfDocument pageAtIndex:pageIndex];
        // ... process page ...
    }
});
```

### 3.2. Thread Safety Measures

1. **Temporary Storage Arrays**: Instead of directly modifying shared arrays (`allElements`, `fontStats`), we create temporary per-page storage:

```objc
NSMutableArray<NSMutableArray<id<ContentElement>> *> *pageElementsArray = [NSMutableArray arrayWithCapacity:pageCount];
NSMutableArray<NSMutableDictionary *> *pageFontStatsArray = [NSMutableArray arrayWithCapacity:pageCount];
```

2. **Error Handling**: A shared boolean flag with synchronized access:

```objc
__block BOOL processingFailed = NO;
NSObject *lock = [[NSObject alloc] init];

// Inside parallel block
@synchronized(lock) {
    if (processingFailed) return;
}
```

3. **Result Merging**: After parallel processing completes, results are merged sequentially:

```objc
for (NSInteger i = 0; i < pageCount; i++) {
    [self.allElements addObjectsFromArray:pageElementsArray[i]];
    // Merge font statistics...
}
```

### 3.3. Parallel Image Saving

Image saving was also parallelized:

```objc
dispatch_apply(imageCount, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t index) {
    @autoreleasepool {
        ImageElement *imageElement = imageElements[index];
        NSString *savedPath = [assetExtractor saveImage:imageElement.image ...];
        if (savedPath) {
            @synchronized(imageElement) {
                imageElement.assetRelativePath = savedPath;
            }
        }
    }
});
```

### 3.4. Memory Management

Each parallel operation is wrapped in `@autoreleasepool` to ensure prompt deallocation of temporary objects and prevent memory spikes.

## 4. Performance Benefits

- **Multi-core Utilization**: Pages are processed on multiple CPU cores simultaneously
- **Reduced Total Time**: For PDFs with many pages, the speedup is nearly linear with the number of cores
- **Efficient Memory Usage**: Autoreleasepool prevents memory accumulation
- **Scalability**: The implementation automatically adapts to the available hardware

## 5. Considerations

- **Thread Safety**: All shared resources are protected with appropriate synchronization
- **Memory Overhead**: Each parallel task has its own memory footprint, but autoreleasepool keeps it manageable
- **I/O Bottlenecks**: Image saving may be limited by disk I/O speed rather than CPU
</file>

<file path="docs/pdf22md.1">
.TH PDF22MD 1 "June 2025" "pdf22md v1.0" "User Commands"
.SH NAME
pdf22md \- high-performance PDF to Markdown converter
.SH SYNOPSIS
.B pdf22md
[\fB\-i\fR \fIinput.pdf\fR]
[\fB\-o\fR \fIoutput.md\fR]
[\fB\-a\fR \fIassets_folder\fR]
[\fB\-d\fR \fIdpi\fR]
[\fB\-v\fR]
[\fB\-h\fR]
.SH DESCRIPTION
.B pdf22md
is a blazingly fast PDF to Markdown converter that extracts text and images from PDF documents and converts them into clean, structured Markdown format. It uses parallel processing to achieve high performance on multi-page documents.

The tool automatically detects heading hierarchy based on font size analysis, extracts images with intelligent format optimization (PNG/JPEG), and generates YAML frontmatter with document metadata.

.SH OPTIONS
.TP
\fB\-i\fR \fIinput.pdf\fR
Specify the input PDF file to convert. If not provided, pdf22md reads from standard input (stdin).
.TP
\fB\-o\fR \fIoutput.md\fR
Specify the output Markdown file. If not provided, pdf22md writes to standard output (stdout).
.TP
\fB\-a\fR \fIassets_folder\fR
Specify the folder where extracted images will be saved. The folder will be created if it doesn't exist. Images are automatically referenced in the generated Markdown with relative paths.
.TP
\fB\-d\fR \fIdpi\fR
Set the DPI (dots per inch) for rasterizing vector graphics. Default is 144. Higher values produce better quality but larger file sizes. Common values: 72 (screen), 144 (default), 300 (print quality).
.TP
\fB\-v\fR, \fB\-\-version\fR
Display version information and exit.
.TP
\fB\-h\fR, \fB\-\-help\fR
Display usage information and exit.

.SH EXAMPLES
.TP
Convert a PDF file to Markdown:
.B pdf22md \-i document.pdf \-o document.md

.TP
Extract images to an assets folder:
.B pdf22md \-i document.pdf \-o document.md \-a ./assets

.TP
Use higher DPI for better image quality:
.B pdf22md \-i document.pdf \-o document.md \-a ./assets \-d 300

.TP
Convert using pipes (stdin/stdout):
.B cat document.pdf | pdf22md > document.md

.TP
Process a document with custom settings:
.B pdf22md \-i report.pdf \-o report.md \-a ./images \-d 200

.SH INPUT/OUTPUT
.SS Input Sources
.B pdf22md
accepts PDF input from:
.IP • 2
File path specified with \fB\-i\fR flag
.IP • 2
Standard input (stdin) when no \fB\-i\fR flag is provided

.SS Output Destinations
Markdown output is written to:
.IP • 2
File path specified with \fB\-o\fR flag
.IP • 2
Standard output (stdout) when no \fB\-o\fR flag is provided

.SS Image Assets
When the \fB\-a\fR flag is used:
.IP • 2
Images are extracted and saved to the specified folder
.IP • 2
Filenames follow the pattern: image_001.png, image_002.jpg, etc.
.IP • 2
Format selection is automatic (PNG for graphics, JPEG for photos)
.IP • 2
Markdown contains relative references to the images

.SH FEATURES
.SS Intelligent Content Processing
.IP • 2
\fBHeading Detection\fR: Automatically identifies headings (H1-H6) based on font size analysis
.IP • 2
\fBText Extraction\fR: Preserves text formatting and structure
.IP • 2
\fBImage Processing\fR: Extracts both raster and vector graphics
.IP • 2
\fBSmart Formatting\fR: Maintains document hierarchy and readability

.SS Performance Optimizations
.IP • 2
\fBParallel Processing\fR: Uses all available CPU cores for maximum speed
.IP • 2
\fBMemory Efficiency\fR: Processes large documents without excessive memory usage
.IP • 2
\fBFormat Optimization\fR: Automatic PNG/JPEG selection based on image content

.SS Output Features
.IP • 2
\fBYAML Frontmatter\fR: Includes document metadata (title, author, creation date)
.IP • 2
\fBClean Markdown\fR: Well-structured output compatible with all Markdown processors
.IP • 2
\fBAsset Management\fR: Organized image extraction with proper linking

.SH FILE FORMATS
.SS Supported Input
.IP • 2
PDF files (version 1.4 and higher)
.IP • 2
Unencrypted PDFs (password-protected PDFs are not supported)
.IP • 2
PDFs with text, images, and vector graphics
.IP • 2
Multi-page documents of any size

.SS Generated Output
.IP • 2
\fBMarkdown (.md)\fR: GitHub Flavored Markdown compatible
.IP • 2
\fBImages (.png/.jpg)\fR: Extracted graphics in optimal formats
.IP • 2
\fBYAML Frontmatter\fR: Document metadata in standard format

.SH PERFORMANCE
Typical conversion speeds on modern hardware:
.IP • 2
Simple text documents: <1 second per page
.IP • 2
Complex documents with images: 2-5 seconds per page
.IP • 2
Large documents (100+ pages): Scales linearly with parallel processing

Memory usage is optimized for documents up to 1000 pages. Very large documents may require additional system memory.

.SH ERROR HANDLING
.B pdf22md
provides detailed error messages with suggestions for common issues:

.SS Common Errors and Solutions
.TP
\fBInvalid PDF file\fR
.IP • 2
Verify the file exists and is a valid PDF
.IP • 2
Check if the file is corrupted
.IP • 2
Ensure you have read permissions

.TP
\fBCannot create assets folder\fR
.IP • 2
Check if the parent directory exists
.IP • 2
Verify you have write permissions
.IP • 2
Ensure sufficient disk space

.TP
\fBPassword-protected PDF\fR
.IP • 2
Remove password protection using another tool first
.IP • 2
Use: qpdf \-\-decrypt input.pdf output.pdf

.TP
\fBMemory pressure\fR
.IP • 2
Close other applications to free memory
.IP • 2
Try using a lower DPI setting (\-d 72)
.IP • 2
Process smaller sections of large documents

.SH EXIT STATUS
.TP
.B 0
Successful conversion
.TP
.B 1
Error occurred (invalid input, processing failure, I/O error)

.SH ENVIRONMENT
No special environment variables are required. The tool uses standard macOS frameworks (PDFKit, CoreGraphics) and runs on macOS 10.15 and later.

.SH LIMITATIONS
.IP • 2
Password-protected PDFs are not supported
.IP • 2
Scanned PDFs without OCR text layer will only extract images
.IP • 2
Complex table layouts may not convert perfectly
.IP • 2
Some advanced PDF features (forms, annotations) are not preserved

.SH COMPATIBILITY
.SS Platform Support
.IP • 2
macOS 10.15 (Catalina) and later
.IP • 2
Intel and Apple Silicon processors
.IP • 2
Universal binary for optimal performance

.SS Markdown Compatibility
Output is compatible with:
.IP • 2
GitHub Flavored Markdown
.IP • 2
CommonMark specification
.IP • 2
Popular Markdown processors (pandoc, Jekyll, etc.)
.IP • 2
Static site generators (Hugo, Jekyll, Gatsby)

.SH FILES
.TP
.I ~/.pdf22md/
User configuration directory (future use)
.TP
.I /usr/local/bin/pdf22md
Default installation location
.TP
.I /usr/local/share/man/man1/pdf22md.1
This manual page

.SH EXAMPLES WORKFLOW
.SS Basic Document Conversion
.nf
# Convert a simple document
pdf22md \-i report.pdf \-o report.md

# Result: clean Markdown with YAML frontmatter
# Output includes: title, headings, body text, metadata
.fi

.SS Academic Paper with Images
.nf
# Convert research paper with figure extraction
pdf22md \-i paper.pdf \-o paper.md \-a figures \-d 300

# Result: 
# - paper.md with structured content
# - figures/ folder with high-quality images
# - Proper cross-references to figures
.fi

.SS Batch Processing
.nf
# Process multiple documents
for pdf in *.pdf; do
    pdf22md \-i "$pdf" \-o "${pdf%.pdf}.md" \-a "assets_${pdf%.pdf}"
done
.fi

.SS Integration with Other Tools
.nf
# Combine with pandoc for further processing
pdf22md \-i document.pdf | pandoc \-f markdown \-t html \-o document.html

# Use with static site generators
pdf22md \-i post.pdf \-o content/posts/post.md \-a static/images
.fi

.SH TROUBLESHOOTING
.SS Performance Issues
If conversion is slow:
.IP • 2
Check available memory and CPU usage
.IP • 2
Close unnecessary applications
.IP • 2
Try lower DPI setting for faster processing
.IP • 2
Process documents in smaller batches

.SS Quality Issues
If output quality is poor:
.IP • 2
Increase DPI setting (\-d 300) for better images
.IP • 2
Verify the source PDF has good quality text
.IP • 2
Check if the PDF has a proper text layer (not just scanned images)

.SS Memory Errors
For large documents:
.IP • 2
Ensure sufficient RAM (8GB+ recommended for large PDFs)
.IP • 2
Close other memory-intensive applications
.IP • 2
Split very large PDFs into smaller parts first

.SH REPORTING BUGS
Report bugs and feature requests at:
.UR https://github.com/twardoch/pdf22md/issues
.UE

Include in your report:
.IP • 2
pdf22md version (\fBpdf22md \-v\fR)
.IP • 2
macOS version
.IP • 2
Sample PDF file (if possible)
.IP • 2
Complete error message
.IP • 2
Steps to reproduce the issue

.SH AUTHORS
Written by Adam Twardoch and contributors.

.SH LICENSE
MIT License. See the LICENSE file for details.

.SH SEE ALSO
.BR pandoc (1),
.BR qpdf (1),
.BR pdftotext (1),
.BR markdown (7)

Project homepage: 
.UR https://github.com/twardoch/pdf22md
.UE
</file>

<file path="pdf22md-objc/src/CLI/main.m">
#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>
#import "../Core/PDF22MDConverter.h"
#import "../Core/PDF22MDConversionOptions.h"

#ifndef VERSION
#define VERSION "1.0.0"
#endif

void printUsage(const char *programName) {
    fprintf(stderr, "Usage: %s [-i input.pdf] [-o output.md] [-a assets_folder] [-d dpi] [-v] [-h]\n", programName);
    fprintf(stderr, "  Converts PDF documents to Markdown format\n");
    fprintf(stderr, "  -i <path>: Input PDF file (default: stdin)\n");
    fprintf(stderr, "  -o <path>: Output Markdown file (default: stdout)\n");
    fprintf(stderr, "  -a <path>: Assets folder for extracted images\n");
    fprintf(stderr, "  -d <dpi>: DPI for rasterizing vector graphics (default: 144)\n");
    fprintf(stderr, "  -v: Display version information\n");
    fprintf(stderr, "  -h: Display this help message\n");
}

void printVersion() {
    printf("pdf22md version %s\n", VERSION);
}

int main(int argc, const char *argv[]) {
    @autoreleasepool {
        NSString *inputPath = nil;
        NSString *outputPath = nil;
        NSString *assetsPath = nil;
        CGFloat dpi = 144.0;
        
        // Parse command line arguments
        int opt;
        while ((opt = getopt(argc, (char * const *)argv, "i:o:a:d:hvV")) != -1) {
            switch (opt) {
                case 'i':
                    inputPath = [NSString stringWithUTF8String:optarg];
                    break;
                case 'o':
                    outputPath = [NSString stringWithUTF8String:optarg];
                    break;
                case 'a':
                    assetsPath = [NSString stringWithUTF8String:optarg];
                    break;
                case 'd':
                    dpi = atof(optarg);
                    if (dpi <= 0) {
                        fprintf(stderr, "Invalid DPI value: %s\n", optarg);
                        return 1;
                    }
                    break;
                case 'h':
                    printUsage(argv[0]);
                    return 0;
                case 'v':
                case 'V':
                    printVersion();
                    return 0;
                default:
                    printUsage(argv[0]);
                    return 1;
            }
        }
        
        // Initialize converter
        PDF22MDConverter *converter = nil;
        
        if (inputPath) {
            // Read from file
            NSURL *pdfURL = [NSURL fileURLWithPath:inputPath];
            converter = [[PDF22MDConverter alloc] initWithPDFURL:pdfURL];
            if (!converter) {
                fprintf(stderr, "Failed to load PDF from: %s\n", [inputPath UTF8String]);
                return 1;
            }
        } else {
            // Read from stdin
            NSFileHandle *stdinHandle = [NSFileHandle fileHandleWithStandardInput];
            NSData *pdfData = [stdinHandle readDataToEndOfFile];
            
            if (!pdfData || [pdfData length] == 0) {
                fprintf(stderr, "No PDF data received from stdin\n");
                return 1;
            }
            
            converter = [[PDF22MDConverter alloc] initWithPDFData:pdfData];
            if (!converter) {
                fprintf(stderr, "Failed to create PDF document from stdin data\n");
                return 1;
            }
        }
        
        // Create conversion options
        PDF22MDConversionOptionsBuilder *builder = [[PDF22MDConversionOptionsBuilder alloc] init];
        builder.assetsFolderPath = assetsPath;
        builder.rasterizationDPI = dpi;
        builder.extractImages = (assetsPath != nil);
        
        // Add progress handler for interactive terminals
        if (isatty(STDERR_FILENO)) {
            builder.progressHandler = ^(NSInteger currentPage, NSInteger totalPages) {
                fprintf(stderr, "\rProcessing page %ld of %ld...", (long)currentPage, (long)totalPages);
                fflush(stderr);
            };
        }
        
        PDF22MDConversionOptions *options = [builder build];
        
        // Perform conversion
        __block NSString *markdown = nil;
        __block NSError *conversionError = nil;
        
        dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
        
        [converter convertWithOptions:options
                           completion:^(NSString *result, NSError *error) {
            markdown = result;
            conversionError = error;
            dispatch_semaphore_signal(semaphore);
        }];
        
        // Wait for completion
        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
        
        if (isatty(STDERR_FILENO) && options.progressHandler) {
            fprintf(stderr, "\n"); // Clear progress line
        }
        
        if (conversionError) {
            fprintf(stderr, "Conversion failed: %s\n", 
                    [[conversionError localizedDescription] UTF8String]);
            return 1;
        }
        
        // Write output
        if (outputPath) {
            // Write to file
            NSError *writeError = nil;
            BOOL success = [markdown writeToFile:outputPath
                                      atomically:YES
                                        encoding:NSUTF8StringEncoding
                                           error:&writeError];
            if (!success) {
                fprintf(stderr, "Failed to write output file: %s\n",
                        [[writeError localizedDescription] UTF8String]);
                return 1;
            }
        } else {
            // Write to stdout
            NSFileHandle *stdoutHandle = [NSFileHandle fileHandleWithStandardOutput];
            NSData *markdownData = [markdown dataUsingEncoding:NSUTF8StringEncoding];
            [stdoutHandle writeData:markdownData];
            
            // Add newline if not present
            if (![markdown hasSuffix:@"\n"]) {
                [stdoutHandle writeData:[@"\n" dataUsingEncoding:NSUTF8StringEncoding]];
            }
        }
        
        return 0;
    }
}
</file>

<file path="pdf22md-objc/src/Core/PDF22MDConversionOptions.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

/**
 * Configuration options for PDF to Markdown conversion.
 * This class uses the builder pattern for convenient configuration.
 */
@interface PDF22MDConversionOptions : NSObject <NSCopying>

/**
 * Path to the folder where extracted assets (images) should be saved.
 * If nil, images will not be extracted.
 */
@property (nonatomic, copy, nullable) NSString *assetsFolderPath;

/**
 * DPI for rasterizing vector graphics.
 * Default is 144.0
 */
@property (nonatomic, assign) CGFloat rasterizationDPI;

/**
 * Maximum number of concurrent page processing operations.
 * Default is NSProcessInfo.processInfo.processorCount
 */
@property (nonatomic, assign) NSInteger maxConcurrentPages;

/**
 * Whether to include YAML frontmatter with metadata.
 * Default is YES
 */
@property (nonatomic, assign) BOOL includeMetadata;

/**
 * Whether to extract images from the PDF.
 * Default is YES (if assetsFolderPath is set)
 */
@property (nonatomic, assign) BOOL extractImages;

/**
 * Whether to preserve the PDF outline/bookmarks structure.
 * Default is YES
 */
@property (nonatomic, assign) BOOL preserveOutline;

/**
 * Minimum font size difference to consider for heading detection.
 * Default is 2.0 points
 */
@property (nonatomic, assign) CGFloat headingFontSizeThreshold;

/**
 * Maximum heading level to detect (1-6).
 * Default is 6
 */
@property (nonatomic, assign) NSInteger maxHeadingLevel;

/**
 * Progress handler called during conversion.
 * The handler receives the current page index and total page count.
 */
@property (nonatomic, copy, nullable) void (^progressHandler)(NSInteger currentPage, NSInteger totalPages);

/**
 * Creates default conversion options.
 */
+ (instancetype)defaultOptions;

/**
 * Validates the current options configuration.
 * @param error Set if validation fails
 * @return YES if valid, NO otherwise
 */
- (BOOL)validateWithError:(NSError * _Nullable * _Nullable)error;

@end

/**
 * Builder class for creating PDF22MDConversionOptions instances.
 */
@interface PDF22MDConversionOptionsBuilder : NSObject

@property (nonatomic, copy, nullable) NSString *assetsFolderPath;
@property (nonatomic, assign) CGFloat rasterizationDPI;
@property (nonatomic, assign) NSInteger maxConcurrentPages;
@property (nonatomic, assign) BOOL includeMetadata;
@property (nonatomic, assign) BOOL extractImages;
@property (nonatomic, assign) BOOL preserveOutline;
@property (nonatomic, assign) CGFloat headingFontSizeThreshold;
@property (nonatomic, assign) NSInteger maxHeadingLevel;
@property (nonatomic, copy, nullable) void (^progressHandler)(NSInteger currentPage, NSInteger totalPages);

- (PDF22MDConversionOptions *)build;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/Core/PDF22MDConverter.h">
#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>

NS_ASSUME_NONNULL_BEGIN

@class PDF22MDConversionOptions;

/**
 * Main converter class that coordinates the PDF to Markdown conversion process.
 * This class manages the entire conversion pipeline including parallel processing,
 * content extraction, and markdown generation.
 */
@interface PDF22MDConverter : NSObject

/**
 * The PDF document being converted.
 */
@property (nonatomic, strong, readonly) PDFDocument *document;

/**
 * Progress object for tracking conversion progress.
 */
@property (nonatomic, strong, readonly) NSProgress *progress;

/**
 * Initializes a converter with PDF data.
 *
 * @param pdfData The PDF data to convert
 * @return A new converter instance, or nil if the PDF is invalid
 */
- (nullable instancetype)initWithPDFData:(NSData *)pdfData;

/**
 * Initializes a converter with a PDF file URL.
 *
 * @param pdfURL The URL of the PDF file to convert
 * @return A new converter instance, or nil if the PDF is invalid
 */
- (nullable instancetype)initWithPDFURL:(NSURL *)pdfURL;

/**
 * Designated initializer that creates a converter with both URL and document.
 * This is the real designated initializer that other initializers should call.
 *
 * @param pdfURL The URL of the PDF file (may be nil for data-based PDFs)
 * @param document The PDF document instance
 * @return A new converter instance, or nil if invalid
 */
- (nullable instancetype)initWithPDFURL:(nullable NSURL *)pdfURL document:(PDFDocument *)document NS_DESIGNATED_INITIALIZER;

- (instancetype)init NS_UNAVAILABLE;

/**
 * Converts the PDF to Markdown with the given options.
 * This method performs the conversion asynchronously on a background queue.
 *
 * @param options Conversion options (uses defaults if nil)
 * @param completion Completion handler called with the result or error
 */
- (void)convertWithOptions:(nullable PDF22MDConversionOptions *)options
                completion:(void (^)(NSString * _Nullable markdown, NSError * _Nullable error))completion;

/**
 * Cancels an ongoing conversion.
 * The completion handler will be called with a cancellation error.
 */
- (void)cancelConversion;

/**
 * Validates that the PDF can be converted.
 *
 * @param error Set if validation fails
 * @return YES if the PDF is valid for conversion, NO otherwise
 */
- (BOOL)validateDocumentWithError:(NSError * _Nullable * _Nullable)error;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/Core/PDF22MDFontAnalyzer.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

@protocol PDF22MDContentElement;
@class PDF22MDTextElement;

/**
 * Font statistics for a particular font and size combination.
 */
@interface PDF22MDFontStatistics : NSObject
@property (nonatomic, copy, readonly) NSString *fontKey;
@property (nonatomic, copy, readonly) NSString *fontName;
@property (nonatomic, assign, readonly) CGFloat fontSize;
@property (nonatomic, assign, readonly) NSUInteger occurrenceCount;
@property (nonatomic, assign) NSInteger assignedHeadingLevel; // 0 for body text, 1-6 for headings

- (instancetype)initWithFontKey:(NSString *)fontKey
                       fontName:(NSString *)fontName
                       fontSize:(CGFloat)fontSize;

- (void)incrementOccurrenceCount;
- (void)addOccurrenceCount:(NSUInteger)count;

@end

/**
 * Analyzes font usage in PDF documents to detect heading hierarchy.
 */
@interface PDF22MDFontAnalyzer : NSObject

/**
 * The font size threshold for detecting headings.
 * Text with font size differences greater than this value may be considered headings.
 */
@property (nonatomic, assign) CGFloat fontSizeThreshold;

/**
 * Maximum heading level to assign (1-6).
 */
@property (nonatomic, assign) NSInteger maxHeadingLevel;

/**
 * Dictionary of font statistics keyed by font identifier.
 */
@property (nonatomic, strong, readonly) NSDictionary<NSString *, PDF22MDFontStatistics *> *fontStatistics;

/**
 * Initializes the analyzer with default settings.
 */
- (instancetype)init;

/**
 * Analyzes an array of content elements to build font statistics.
 * This should be called before assignHeadingLevels.
 *
 * @param elements Array of content elements to analyze
 */
- (void)analyzeElements:(NSArray<id<PDF22MDContentElement>> *)elements;

/**
 * Assigns heading levels to text elements based on font analysis.
 * Call this after analyzeElements.
 *
 * @param elements Array of content elements to process
 */
- (void)assignHeadingLevels:(NSArray<id<PDF22MDContentElement>> *)elements;

/**
 * Merges font statistics from another analyzer.
 * Useful for combining statistics from multiple pages.
 *
 * @param otherAnalyzer The analyzer to merge from
 */
- (void)mergeFontStatisticsFromAnalyzer:(PDF22MDFontAnalyzer *)otherAnalyzer;

/**
 * Resets all collected statistics.
 */
- (void)reset;

/**
 * Gets a sorted array of font statistics by size (largest first).
 */
- (NSArray<PDF22MDFontStatistics *> *)sortedFontStatistics;

/**
 * Creates a font key identifier from font properties.
 */
+ (NSString *)fontKeyForFontName:(nullable NSString *)fontName fontSize:(CGFloat)fontSize;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/Core/PDF22MDFontAnalyzer.m">
#import "PDF22MDFontAnalyzer.h"
#import "../Models/PDF22MDContentElement.h"
#import "../Models/PDF22MDTextElement.h"

@implementation PDF22MDFontStatistics

- (instancetype)initWithFontKey:(NSString *)fontKey
                       fontName:(NSString *)fontName
                       fontSize:(CGFloat)fontSize {
    self = [super init];
    if (self) {
        _fontKey = [fontKey copy];
        _fontName = [fontName copy];
        _fontSize = fontSize;
        _occurrenceCount = 0;
        _assignedHeadingLevel = 0;
    }
    return self;
}

- (void)incrementOccurrenceCount {
    _occurrenceCount++;
}

- (void)addOccurrenceCount:(NSUInteger)count {
    _occurrenceCount += count;
}

- (NSString *)description {
    return [NSString stringWithFormat:@"<FontStats: %@ size=%.1f count=%lu level=%ld>",
            self.fontName, self.fontSize, (unsigned long)self.occurrenceCount, (long)self.assignedHeadingLevel];
}

@end

@interface PDF22MDFontAnalyzer ()
@property (nonatomic, strong) NSMutableDictionary<NSString *, PDF22MDFontStatistics *> *mutableFontStatistics;
@end

@implementation PDF22MDFontAnalyzer

#pragma mark - Initialization

- (instancetype)init {
    self = [super init];
    if (self) {
        _fontSizeThreshold = 2.0;
        _maxHeadingLevel = 6;
        _mutableFontStatistics = [NSMutableDictionary dictionary];
    }
    return self;
}

#pragma mark - Public Methods

- (void)analyzeElements:(NSArray<id<PDF22MDContentElement>> *)elements {
    for (id<PDF22MDContentElement> element in elements) {
        if ([element isKindOfClass:[PDF22MDTextElement class]]) {
            PDF22MDTextElement *textElement = (PDF22MDTextElement *)element;
            [self addTextElementToStatistics:textElement];
        }
    }
}

- (void)assignHeadingLevels:(NSArray<id<PDF22MDContentElement>> *)elements {
    // Get sorted font statistics
    NSArray<PDF22MDFontStatistics *> *sortedStats = [self sortedFontStatistics];
    
    if (sortedStats.count == 0) {
        return;
    }
    
    // Find the most common font size (likely body text)
    PDF22MDFontStatistics *mostCommonFont = nil;
    NSUInteger highestCount = 0;
    
    for (PDF22MDFontStatistics *stats in sortedStats) {
        if (stats.occurrenceCount > highestCount) {
            highestCount = stats.occurrenceCount;
            mostCommonFont = stats;
        }
    }
    
    CGFloat bodyFontSize = mostCommonFont ? mostCommonFont.fontSize : 12.0;
    
    // Assign heading levels based on size hierarchy
    NSInteger currentHeadingLevel = 1;
    CGFloat lastHeadingSize = CGFLOAT_MAX;
    
    for (PDF22MDFontStatistics *stats in sortedStats) {
        // Skip if this is likely body text
        if (stats == mostCommonFont) {
            stats.assignedHeadingLevel = 0;
            continue;
        }
        
        // Check if this font is significantly larger than body text
        CGFloat sizeDifference = stats.fontSize - bodyFontSize;
        
        if (sizeDifference >= self.fontSizeThreshold) {
            // This is a potential heading
            // Check if it's significantly different from the last heading size
            if (lastHeadingSize - stats.fontSize >= self.fontSizeThreshold) {
                currentHeadingLevel++;
            }
            
            if (currentHeadingLevel <= self.maxHeadingLevel) {
                stats.assignedHeadingLevel = currentHeadingLevel;
                lastHeadingSize = stats.fontSize;
            } else {
                // Too many heading levels, treat as body text
                stats.assignedHeadingLevel = 0;
            }
        } else {
            // Not large enough to be a heading
            stats.assignedHeadingLevel = 0;
        }
        
        // Additional heuristic: if occurrence count is very high, it's probably not a heading
        if (stats.occurrenceCount > highestCount * 0.5) {
            stats.assignedHeadingLevel = 0;
        }
    }
    
    // Apply heading levels to text elements
    for (id<PDF22MDContentElement> element in elements) {
        if ([element isKindOfClass:[PDF22MDTextElement class]]) {
            PDF22MDTextElement *textElement = (PDF22MDTextElement *)element;
            NSString *fontKey = [[self class] fontKeyForFontName:textElement.fontName 
                                                        fontSize:textElement.fontSize];
            PDF22MDFontStatistics *stats = self.mutableFontStatistics[fontKey];
            if (stats) {
                textElement.headingLevel = stats.assignedHeadingLevel;
            }
        }
    }
}

- (void)mergeFontStatisticsFromAnalyzer:(PDF22MDFontAnalyzer *)otherAnalyzer {
    [otherAnalyzer.fontStatistics enumerateKeysAndObjectsUsingBlock:^(NSString *key, PDF22MDFontStatistics *otherStats, BOOL * __unused stop) {
        PDF22MDFontStatistics *existingStats = self.mutableFontStatistics[key];
        
        if (existingStats) {
            // Merge occurrence counts
            [existingStats addOccurrenceCount:otherStats.occurrenceCount];
        } else {
            // Add new statistics
            PDF22MDFontStatistics *newStats = [[PDF22MDFontStatistics alloc] initWithFontKey:otherStats.fontKey
                                                                                    fontName:otherStats.fontName
                                                                                    fontSize:otherStats.fontSize];
            [newStats addOccurrenceCount:otherStats.occurrenceCount];
            self.mutableFontStatistics[key] = newStats;
        }
    }];
}

- (void)reset {
    [self.mutableFontStatistics removeAllObjects];
}

- (NSArray<PDF22MDFontStatistics *> *)sortedFontStatistics {
    NSArray<PDF22MDFontStatistics *> *allStats = [self.mutableFontStatistics allValues];
    
    // Sort by font size in descending order
    return [allStats sortedArrayUsingComparator:^NSComparisonResult(PDF22MDFontStatistics *obj1, PDF22MDFontStatistics *obj2) {
        if (obj1.fontSize > obj2.fontSize) {
            return NSOrderedAscending;
        } else if (obj1.fontSize < obj2.fontSize) {
            return NSOrderedDescending;
        } else {
            // Same size, sort by occurrence count
            if (obj1.occurrenceCount > obj2.occurrenceCount) {
                return NSOrderedAscending;
            } else if (obj1.occurrenceCount < obj2.occurrenceCount) {
                return NSOrderedDescending;
            }
            return NSOrderedSame;
        }
    }];
}

+ (NSString *)fontKeyForFontName:(nullable NSString *)fontName fontSize:(CGFloat)fontSize {
    NSString *name = fontName ?: @"Unknown";
    return [NSString stringWithFormat:@"%.1f-%@", fontSize, name];
}

#pragma mark - Properties

- (NSDictionary<NSString *, PDF22MDFontStatistics *> *)fontStatistics {
    return [self.mutableFontStatistics copy];
}

#pragma mark - Private Methods

- (void)addTextElementToStatistics:(PDF22MDTextElement *)textElement {
    // Skip empty text
    NSString *trimmedText = [textElement.text stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    if (trimmedText.length == 0) {
        return;
    }
    
    NSString *fontKey = [[self class] fontKeyForFontName:textElement.fontName fontSize:textElement.fontSize];
    
    PDF22MDFontStatistics *stats = self.mutableFontStatistics[fontKey];
    if (!stats) {
        stats = [[PDF22MDFontStatistics alloc] initWithFontKey:fontKey
                                                      fontName:textElement.fontName ?: @"Unknown"
                                                      fontSize:textElement.fontSize];
        self.mutableFontStatistics[fontKey] = stats;
    }
    
    [stats incrementOccurrenceCount];
}

@end
</file>

<file path="pdf22md-objc/src/Core/PDF22MDPageProcessor.h">
#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

@protocol PDF22MDContentElement;
@class PDF22MDFontAnalyzer;

/**
 * Processes individual PDF pages to extract content elements.
 * Uses PDFKit's high-level API for safe and reliable content extraction.
 */
@interface PDF22MDPageProcessor : NSObject

/**
 * The PDF page being processed.
 */
@property (nonatomic, strong, readonly) PDFPage *pdfPage;

/**
 * The zero-based index of the page.
 */
@property (nonatomic, assign, readonly) NSInteger pageIndex;

/**
 * DPI for rasterizing vector graphics.
 */
@property (nonatomic, assign, readonly) CGFloat dpi;

/**
 * Font analyzer for this page (optional).
 */
@property (nonatomic, strong, nullable) PDF22MDFontAnalyzer *fontAnalyzer;

/**
 * Initializes a page processor for the given PDF page.
 *
 * @param pdfPage The PDF page to process
 * @param pageIndex The zero-based page index
 * @param dpi DPI for rasterization (default: 144)
 * @return A new page processor instance
 */
- (instancetype)initWithPDFPage:(PDFPage *)pdfPage
                      pageIndex:(NSInteger)pageIndex
                            dpi:(CGFloat)dpi NS_DESIGNATED_INITIALIZER;

- (instancetype)init NS_UNAVAILABLE;

/**
 * Extracts all content elements from the page.
 * This includes text and images.
 *
 * @return Array of content elements in reading order
 */
- (NSArray<id<PDF22MDContentElement>> *)extractContentElements;

/**
 * Extracts only text elements from the page.
 *
 * @return Array of text elements
 */
- (NSArray<id<PDF22MDContentElement>> *)extractTextElements;

/**
 * Extracts only image elements from the page.
 *
 * @return Array of image elements
 */
- (NSArray<id<PDF22MDContentElement>> *)extractImageElements;

/**
 * Captures vector graphics in the specified bounds as a rasterized image.
 *
 * @param bounds The area to capture
 * @param elements Array to add the captured image element to
 */
- (void)captureVectorGraphicsInBounds:(CGRect)bounds
                         withElements:(NSMutableArray<id<PDF22MDContentElement>> *)elements;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/Core/PDF22MDPageProcessor.m">
#import "PDF22MDPageProcessor.h"
#import "../Models/PDF22MDTextElement.h"
#import "../Models/PDF22MDImageElement.h"
#import "PDF22MDFontAnalyzer.h"
#import <CoreGraphics/CoreGraphics.h>

#if TARGET_OS_MAC && !TARGET_OS_IPHONE
#import <AppKit/AppKit.h>
#else
#import <UIKit/UIKit.h>
#endif

@interface PDF22MDPageProcessor ()
@property (nonatomic, assign) CGPDFPageRef cgPdfPage;
@end

@implementation PDF22MDPageProcessor

#pragma mark - Initialization

- (instancetype)initWithPDFPage:(PDFPage *)pdfPage
                      pageIndex:(NSInteger)pageIndex
                            dpi:(CGFloat)dpi {
    self = [super init];
    if (self) {
        _pdfPage = pdfPage;
        _pageIndex = pageIndex;
        _dpi = dpi;
        _cgPdfPage = [pdfPage pageRef];
    }
    return self;
}

#pragma mark - Public Methods

- (NSArray<id<PDF22MDContentElement>> *)extractContentElements {
    NSMutableArray<id<PDF22MDContentElement>> *elements = [NSMutableArray array];
    
    // Extract text elements
    NSArray *textElements = [self extractTextElements];
    [elements addObjectsFromArray:textElements];
    
    // Extract image elements
    NSArray *imageElements = [self extractImageElements];
    [elements addObjectsFromArray:imageElements];
    
    // Sort elements by position
    [self sortElementsByPosition:elements];
    
    return elements;
}

- (NSArray<id<PDF22MDContentElement>> *)extractTextElements {
    NSMutableArray<id<PDF22MDContentElement>> *elements = [NSMutableArray array];
    
    // Extract text using PDFKit's high-level API
    NSString *pageText = [self.pdfPage string];
    if (!pageText || pageText.length == 0) {
        return elements;
    }
    
    // Get page bounds for positioning
    CGRect pageRect = [self.pdfPage boundsForBox:kPDFDisplayBoxMediaBox];
    CGFloat pageHeight = CGRectGetHeight(pageRect);
    
    // Split into paragraphs while preserving structure
    NSArray<NSString *> *paragraphs = [self extractParagraphsFromPageText:pageText];
    
    // Create text elements with approximate positioning
    CGFloat cursorY = pageHeight - 20; // Start near top with margin
    CGFloat lineHeight = 14.0; // Default line height
    CGFloat paragraphSpacing = lineHeight * 0.5;
    
    for (NSString *paragraph in paragraphs) {
        NSString *trimmed = [paragraph stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
        if (trimmed.length == 0) {
            cursorY -= paragraphSpacing;
            continue;
        }
        
        // Try to extract font information from PDF selections
        PDFSelection *selection = [self.pdfPage selectionForRange:NSMakeRange(0, trimmed.length)];
        NSDictionary *fontInfo = [self extractFontInfoFromSelection:selection];
        
        PDF22MDTextElement *element = [[PDF22MDTextElement alloc] initWithText:trimmed
                                                                        bounds:CGRectMake(20, cursorY - lineHeight, pageRect.size.width - 40, lineHeight)
                                                                     pageIndex:self.pageIndex
                                                                      fontName:fontInfo[@"fontName"]
                                                                      fontSize:[fontInfo[@"fontSize"] doubleValue]
                                                                        isBold:[fontInfo[@"isBold"] boolValue]
                                                                      isItalic:[fontInfo[@"isItalic"] boolValue]];
        
        [elements addObject:element];
        
        // Update cursor position
        NSInteger lineCount = [self estimateLineCountForText:trimmed inWidth:pageRect.size.width - 40];
        cursorY -= (lineHeight * lineCount + paragraphSpacing);
    }
    
    return elements;
}

- (NSArray<id<PDF22MDContentElement>> *)extractImageElements {
    NSMutableArray<id<PDF22MDContentElement>> *elements = [NSMutableArray array];
    
    // Method 1: Extract images from annotations
    NSArray<PDFAnnotation *> *annotations = [self.pdfPage annotations];
    
    for (PDFAnnotation *annotation in annotations) {
        // Check if annotation might contain an image
        if ([self annotationMayContainImage:annotation]) {
            CGImageRef image = [self imageFromAnnotation:annotation];
            if (image) {
                PDF22MDImageElement *element = [[PDF22MDImageElement alloc] initWithImage:image
                                                                                   bounds:[annotation bounds]
                                                                                pageIndex:self.pageIndex
                                                                           isVectorSource:NO];
                [elements addObject:element];
                CGImageRelease(image);
            }
        }
    }
    
    // Method 2: Detect image regions by analyzing page content
    NSArray *imageRegions = [self detectImageRegionsInPage];
    for (NSData *regionData in imageRegions) {
        CGRect region;
        [regionData getBytes:&region length:sizeof(CGRect)];
        [self captureVectorGraphicsInBounds:region withElements:elements];
    }
    
    return elements;
}

- (void)captureVectorGraphicsInBounds:(CGRect)bounds
                         withElements:(NSMutableArray<id<PDF22MDContentElement>> *)elements {
    // Expand bounds slightly to ensure we capture everything
    bounds = CGRectInset(bounds, -5, -5);
    
    // Calculate size at specified DPI
    CGFloat scale = self.dpi / 72.0;
    size_t width = (size_t)(CGRectGetWidth(bounds) * scale);
    size_t height = (size_t)(CGRectGetHeight(bounds) * scale);
    
    if (width == 0 || height == 0 || width > 4096 || height > 4096) {
        return;
    }
    
    // Create bitmap context
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, colorSpace,
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        return;
    }
    
    // Set white background
    CGContextSetRGBFillColor(context, 1.0, 1.0, 1.0, 1.0);
    CGContextFillRect(context, CGRectMake(0, 0, width, height));
    
    // Set up transformation to render just the bounds area
    CGContextSaveGState(context);
    CGContextScaleCTM(context, scale, scale);
    CGContextTranslateCTM(context, -bounds.origin.x, -bounds.origin.y);
    
    // Draw the PDF page
    CGContextDrawPDFPage(context, self.cgPdfPage);
    
    CGContextRestoreGState(context);
    
    // Create image
    CGImageRef image = CGBitmapContextCreateImage(context);
    CGContextRelease(context);
    
    if (image) {
        PDF22MDImageElement *element = [[PDF22MDImageElement alloc] initWithImage:image
                                                                           bounds:bounds
                                                                        pageIndex:self.pageIndex
                                                                   isVectorSource:YES];
        [elements addObject:element];
        CGImageRelease(image);
    }
}

#pragma mark - Private Methods

- (NSArray<NSString *> *)extractParagraphsFromPageText:(NSString *)pageText {
    // Split by multiple newlines to get paragraphs
    NSArray *components = [pageText componentsSeparatedByString:@"\n\n"];
    NSMutableArray *paragraphs = [NSMutableArray array];
    
    for (NSString *component in components) {
        // Further split by single newlines but join short lines
        NSArray *lines = [component componentsSeparatedByString:@"\n"];
        NSMutableString *paragraph = [NSMutableString string];
        
        for (NSString *line in lines) {
            NSString *trimmedLine = [line stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
            if (trimmedLine.length > 0) {
                if (paragraph.length > 0) {
                    // Add space between lines
                    [paragraph appendString:@" "];
                }
                [paragraph appendString:trimmedLine];
            }
        }
        
        if (paragraph.length > 0) {
            [paragraphs addObject:[paragraph copy]];
        }
    }
    
    return paragraphs;
}

- (NSDictionary *)extractFontInfoFromSelection:(PDFSelection *)selection {
    // Default font info
    NSMutableDictionary *fontInfo = [@{
        @"fontName": @"Helvetica",
        @"fontSize": @(12.0),
        @"isBold": @(NO),
        @"isItalic": @(NO)
    } mutableCopy];
    
    // PDFKit doesn't provide direct access to font information
    // This would require lower-level Core Graphics analysis
    // For now, we'll use heuristics based on the text content
    
    NSString *text = [selection string];
    if (text) {
        // Simple heuristic: all caps might indicate a heading
        if ([text isEqualToString:[text uppercaseString]] && text.length > 3) {
            fontInfo[@"fontSize"] = @(14.0);
            fontInfo[@"isBold"] = @(YES);
        }
    }
    
    return fontInfo;
}

- (BOOL)annotationMayContainImage:(PDFAnnotation *)annotation {
    // Check annotation type and bounds
    CGRect bounds = [annotation bounds];
    
    // Images typically have reasonable dimensions
    if (CGRectIsEmpty(bounds) || bounds.size.width < 10 || bounds.size.height < 10) {
        return NO;
    }
    
    // Check if it's not a text annotation
    NSString *contents = [annotation contents];
    if (contents && contents.length > 0) {
        return NO;
    }
    
    return YES;
}

- (CGImageRef)imageFromAnnotation:(PDFAnnotation *)annotation {
    CGRect bounds = [annotation bounds];
    
    // Create a bitmap context to render the annotation
    CGFloat scale = self.dpi / 72.0;
    size_t width = (size_t)(bounds.size.width * scale);
    size_t height = (size_t)(bounds.size.height * scale);
    
    if (width == 0 || height == 0 || width > 4096 || height > 4096) {
        return NULL;
    }
    
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, colorSpace,
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        return NULL;
    }
    
    // Set white background
    CGContextSetRGBFillColor(context, 1.0, 1.0, 1.0, 1.0);
    CGContextFillRect(context, CGRectMake(0, 0, width, height));
    
    // Transform context to match annotation bounds
    CGContextSaveGState(context);
    CGContextScaleCTM(context, scale, scale);
    
    // Draw just the annotation area from the page
    CGContextClipToRect(context, CGRectMake(0, 0, bounds.size.width, bounds.size.height));
    CGContextTranslateCTM(context, -bounds.origin.x, -bounds.origin.y);
    CGContextDrawPDFPage(context, self.cgPdfPage);
    
    CGContextRestoreGState(context);
    
    // Create image
    CGImageRef image = CGBitmapContextCreateImage(context);
    CGContextRelease(context);
    
    return image;
}

- (NSArray *)detectImageRegionsInPage {
    NSMutableArray *regions = [NSMutableArray array];
    
    // Simple heuristic: divide page into grid and check for non-text regions
    CGRect pageRect = [self.pdfPage boundsForBox:kPDFDisplayBoxMediaBox];
    CGFloat gridSize = 100.0;
    
    NSInteger gridX = (NSInteger)ceil(pageRect.size.width / gridSize);
    NSInteger gridY = (NSInteger)ceil(pageRect.size.height / gridSize);
    
    for (NSInteger x = 0; x < gridX; x++) {
        for (NSInteger y = 0; y < gridY; y++) {
            CGRect gridRect = CGRectMake(x * gridSize, y * gridSize, gridSize, gridSize);
            gridRect = CGRectIntersection(gridRect, pageRect);
            
            if (CGRectIsEmpty(gridRect) || gridRect.size.width < 20 || gridRect.size.height < 20) {
                continue;
            }
            
            // Check if this region contains primarily non-text content
            PDFSelection *selection = [self.pdfPage selectionForRect:gridRect];
            NSString *regionText = [[selection string] stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
            
            // If very little text, might be an image region
            if (regionText.length < 10) {
                NSData *rectData = [NSData dataWithBytes:&gridRect length:sizeof(CGRect)];
                [regions addObject:rectData];
            }
        }
    }
    
    // Merge adjacent regions
    return [self mergeAdjacentRegions:regions];
}

- (NSArray *)mergeAdjacentRegions:(NSArray *)regions {
    if (regions.count <= 1) {
        return regions;
    }
    
    NSMutableArray *mergedRegions = [NSMutableArray array];
    NSMutableSet *processedIndices = [NSMutableSet set];
    
    for (NSUInteger i = 0; i < regions.count; i++) {
        if ([processedIndices containsObject:@(i)]) {
            continue;
        }
        
        CGRect currentRect;
        [regions[i] getBytes:&currentRect length:sizeof(CGRect)];
        [processedIndices addObject:@(i)];
        
        // Try to merge with adjacent regions
        BOOL merged = YES;
        while (merged) {
            merged = NO;
            
            for (NSUInteger j = 0; j < regions.count; j++) {
                if ([processedIndices containsObject:@(j)]) {
                    continue;
                }
                
                CGRect otherRect;
                [regions[j] getBytes:&otherRect length:sizeof(CGRect)];
                
                // Check if rectangles are adjacent
                if (CGRectIntersectsRect(CGRectInset(currentRect, -10, -10), otherRect)) {
                    currentRect = CGRectUnion(currentRect, otherRect);
                    [processedIndices addObject:@(j)];
                    merged = YES;
                }
            }
        }
        
        NSData *rectData = [NSData dataWithBytes:&currentRect length:sizeof(CGRect)];
        [mergedRegions addObject:rectData];
    }
    
    return mergedRegions;
}

- (NSInteger)estimateLineCountForText:(NSString *)text inWidth:(CGFloat)width {
    // Simple estimation based on average character width
    CGFloat avgCharWidth = 7.0; // Approximate for 12pt font
    NSInteger charsPerLine = (NSInteger)(width / avgCharWidth);
    
    if (charsPerLine <= 0) {
        return 1;
    }
    
    return MAX(1, (text.length + charsPerLine - 1) / charsPerLine);
}

- (void)sortElementsByPosition:(NSMutableArray<id<PDF22MDContentElement>> *)elements {
    [elements sortUsingComparator:^NSComparisonResult(id<PDF22MDContentElement> obj1, id<PDF22MDContentElement> obj2) {
        // Sort by vertical position (top to bottom)
        CGFloat y1 = CGRectGetMaxY(obj1.bounds);
        CGFloat y2 = CGRectGetMaxY(obj2.bounds);
        
        if (fabs(y1 - y2) > 5.0) { // Tolerance for same line
            return y1 > y2 ? NSOrderedAscending : NSOrderedDescending;
        }
        
        // Same line, sort by horizontal position (left to right)
        CGFloat x1 = CGRectGetMinX(obj1.bounds);
        CGFloat x2 = CGRectGetMinX(obj2.bounds);
        
        return x1 < x2 ? NSOrderedAscending : NSOrderedDescending;
    }];
}

@end
</file>

<file path="pdf22md-objc/src/Models/PDF22MDContentElement.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

/**
 * Protocol defining the interface for all content elements extracted from a PDF.
 * This includes text elements, image elements, and potentially other content types.
 */
@protocol PDF22MDContentElement <NSObject>

@required
/**
 * The bounding rectangle of this element in PDF coordinate space.
 */
@property (nonatomic, readonly) CGRect bounds;

/**
 * The zero-based index of the page this element was extracted from.
 */
@property (nonatomic, readonly) NSInteger pageIndex;

/**
 * Generates the Markdown representation of this element.
 * @return A string containing the Markdown formatted content, or nil if the element has no valid representation.
 */
- (nullable NSString *)markdownRepresentation;

@optional
/**
 * Additional metadata associated with this element.
 * The dictionary keys and values are element-type specific.
 */
- (NSDictionary<NSString *, id> *)metadata;

/**
 * The original extraction context for debugging purposes.
 */
- (NSString *)debugDescription;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/Models/PDF22MDImageElement.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>
#import "PDF22MDContentElement.h"

NS_ASSUME_NONNULL_BEGIN

/**
 * Represents an image element extracted from a PDF page.
 * Handles both raster and vector graphics.
 */
@interface PDF22MDImageElement : NSObject <PDF22MDContentElement>

/**
 * The extracted image. Ownership is transferred to this object.
 */
@property (nonatomic, readonly) CGImageRef image;

/**
 * The bounding rectangle of this image in the PDF.
 */
@property (nonatomic, assign, readonly) CGRect bounds;

/**
 * The page index where this image was found.
 */
@property (nonatomic, assign, readonly) NSInteger pageIndex;

/**
 * Indicates whether this image was originally vector graphics.
 */
@property (nonatomic, assign, readonly) BOOL isVectorSource;

/**
 * The relative path to the saved asset file, if any.
 * This is set after the image has been extracted and saved.
 */
@property (nonatomic, copy, nullable) NSString *assetRelativePath;

/**
 * Designated initializer for creating an image element.
 *
 * @param image The CGImage (ownership is transferred)
 * @param bounds The bounding rectangle
 * @param pageIndex The page index
 * @param isVectorSource Whether this was originally vector graphics
 * @return A new image element instance
 */
- (instancetype)initWithImage:(CGImageRef)image
                       bounds:(CGRect)bounds
                    pageIndex:(NSInteger)pageIndex
               isVectorSource:(BOOL)isVectorSource NS_DESIGNATED_INITIALIZER;

- (instancetype)init NS_UNAVAILABLE;

/**
 * Analyzes the image to determine if JPEG compression would be suitable.
 * @return YES if JPEG is recommended, NO for PNG
 */
- (BOOL)shouldUseJPEGCompression;

/**
 * Gets the dimensions of the image.
 * @return The size in pixels
 */
- (CGSize)imageDimensions;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/Models/PDF22MDImageElement.m">
#import "PDF22MDImageElement.h"

@implementation PDF22MDImageElement

#pragma mark - Initialization

- (instancetype)initWithImage:(CGImageRef)image
                       bounds:(CGRect)bounds
                    pageIndex:(NSInteger)pageIndex
               isVectorSource:(BOOL)isVectorSource {
    self = [super init];
    if (self) {
        _image = CGImageRetain(image);
        _bounds = bounds;
        _pageIndex = pageIndex;
        _isVectorSource = isVectorSource;
    }
    return self;
}

- (void)dealloc {
    if (_image) {
        CGImageRelease(_image);
    }
}

#pragma mark - PDF22MDContentElement Protocol

- (nullable NSString *)markdownRepresentation {
    if (!self.assetRelativePath) {
        return @"![Image](image-not-saved)";
    }
    
    return [NSString stringWithFormat:@"![Image](%@)", self.assetRelativePath];
}

- (NSDictionary<NSString *, id> *)metadata {
    CGSize dimensions = [self imageDimensions];
    
    return @{
        @"width": @(dimensions.width),
        @"height": @(dimensions.height),
        @"isVectorSource": @(self.isVectorSource),
        @"hasAlpha": @([self imageHasAlpha]),
        @"shouldUseJPEG": @([self shouldUseJPEGCompression])
    };
}

#pragma mark - Public Methods

- (CGSize)imageDimensions {
    if (!self.image) {
        return CGSizeZero;
    }
    
    return CGSizeMake(CGImageGetWidth(self.image), CGImageGetHeight(self.image));
}

- (BOOL)shouldUseJPEGCompression {
    if (!self.image) {
        return NO;
    }
    
    // If image has alpha channel, use PNG
    if ([self imageHasAlpha]) {
        return NO;
    }
    
    // For small images, use PNG
    CGSize dimensions = [self imageDimensions];
    if (dimensions.width * dimensions.height < 10000) { // Less than 100x100
        return NO;
    }
    
    // For vector sources, prefer PNG to maintain quality
    if (self.isVectorSource) {
        return NO;
    }
    
    // Analyze color complexity
    NSUInteger uniqueColors = [self estimateUniqueColorCount];
    
    // If we have many unique colors, it's likely a photograph - use JPEG
    return uniqueColors > 256;
}

#pragma mark - Private Methods

- (BOOL)imageHasAlpha {
    if (!self.image) {
        return NO;
    }
    
    CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(self.image);
    
    return alphaInfo != kCGImageAlphaNone &&
           alphaInfo != kCGImageAlphaNoneSkipFirst &&
           alphaInfo != kCGImageAlphaNoneSkipLast;
}

- (NSUInteger)estimateUniqueColorCount {
    if (!self.image) {
        return 0;
    }
    
    size_t width = CGImageGetWidth(self.image);
    size_t height = CGImageGetHeight(self.image);
    
    // Sample a subset of pixels for performance
    size_t sampleWidth = MIN(width, 100);
    size_t sampleHeight = MIN(height, 100);
    size_t __unused stepX = MAX(1, width / sampleWidth);
    size_t __unused stepY = MAX(1, height / sampleHeight);
    
    // Create a small bitmap context for sampling
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    size_t bytesPerRow = sampleWidth * 4;
    unsigned char *pixelData = calloc(sampleHeight * bytesPerRow, sizeof(unsigned char));
    
    if (!pixelData) {
        CGColorSpaceRelease(colorSpace);
        return 256; // Default to medium complexity
    }
    
    CGContextRef context = CGBitmapContextCreate(pixelData, sampleWidth, sampleHeight, 8, bytesPerRow, colorSpace,
                                                kCGImageAlphaNoneSkipLast | kCGBitmapByteOrder32Big);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        free(pixelData);
        return 256;
    }
    
    // Draw scaled image
    CGContextDrawImage(context, CGRectMake(0, 0, sampleWidth, sampleHeight), self.image);
    CGContextRelease(context);
    
    // Count unique colors
    NSMutableSet *uniqueColors = [NSMutableSet set];
    
    for (size_t y = 0; y < sampleHeight; y++) {
        for (size_t x = 0; x < sampleWidth; x++) {
            size_t offset = (y * bytesPerRow) + (x * 4);
            uint32_t color = (pixelData[offset] << 24) | 
                           (pixelData[offset + 1] << 16) | 
                           (pixelData[offset + 2] << 8) | 
                           pixelData[offset + 3];
            [uniqueColors addObject:@(color)];
            
            // Early exit if we already have many colors
            if (uniqueColors.count > 1000) {
                free(pixelData);
                return uniqueColors.count;
            }
        }
    }
    
    free(pixelData);
    return uniqueColors.count;
}

#pragma mark - NSObject

- (NSString *)description {
    CGSize dimensions = [self imageDimensions];
    return [NSString stringWithFormat:@"<%@: %p, size=%.0fx%.0f, bounds=%@, page=%ld>",
            NSStringFromClass([self class]),
            self,
            dimensions.width,
            dimensions.height,
            [NSString stringWithFormat:@"{{%.1f,%.1f},{%.1f,%.1f}}", self.bounds.origin.x, self.bounds.origin.y, self.bounds.size.width, self.bounds.size.height],
            (long)self.pageIndex];
}

- (NSString *)debugDescription {
    CGSize dimensions = [self imageDimensions];
    return [NSString stringWithFormat:@"<%@: %p> {\n  dimensions: %.0fx%.0f\n  bounds: %@\n  page: %ld\n  vector: %@\n  alpha: %@\n  path: %@\n}",
            NSStringFromClass([self class]),
            self,
            dimensions.width,
            dimensions.height,
            [NSString stringWithFormat:@"{{%.1f,%.1f},{%.1f,%.1f}}", self.bounds.origin.x, self.bounds.origin.y, self.bounds.size.width, self.bounds.size.height],
            (long)self.pageIndex,
            self.isVectorSource ? @"YES" : @"NO",
            [self imageHasAlpha] ? @"YES" : @"NO",
            self.assetRelativePath ?: @"<not saved>"];
}

- (BOOL)isEqual:(id)object {
    if (self == object) {
        return YES;
    }
    
    if (![object isKindOfClass:[PDF22MDImageElement class]]) {
        return NO;
    }
    
    PDF22MDImageElement *other = (PDF22MDImageElement *)object;
    
    return CGRectEqualToRect(self.bounds, other.bounds) &&
           self.pageIndex == other.pageIndex &&
           self.isVectorSource == other.isVectorSource &&
           (self.assetRelativePath == other.assetRelativePath || 
            [self.assetRelativePath isEqualToString:other.assetRelativePath]);
}

- (NSUInteger)hash {
    NSUInteger prime = 31;
    NSUInteger result = 1;
    
    result = prime * result + (NSUInteger)(self.bounds.origin.x + self.bounds.origin.y + self.bounds.size.width + self.bounds.size.height);
    result = prime * result + self.pageIndex;
    result = prime * result + (self.isVectorSource ? 1 : 0);
    result = prime * result + [self.assetRelativePath hash];
    
    return result;
}

@end
</file>

<file path="pdf22md-objc/src/Models/PDF22MDTextElement.h">
#import <Foundation/Foundation.h>
#import "PDF22MDContentElement.h"

NS_ASSUME_NONNULL_BEGIN

/**
 * Represents a text element extracted from a PDF page.
 * Includes text content and associated styling information.
 */
@interface PDF22MDTextElement : NSObject <PDF22MDContentElement>

/**
 * The extracted text content. Never nil, but may be empty.
 */
@property (nonatomic, copy, readonly) NSString *text;

/**
 * The bounding rectangle of this text element.
 */
@property (nonatomic, assign, readonly) CGRect bounds;

/**
 * The page index where this text was found.
 */
@property (nonatomic, assign, readonly) NSInteger pageIndex;

/**
 * The font name used for this text, if available.
 */
@property (nonatomic, copy, nullable, readonly) NSString *fontName;

/**
 * The font size in points.
 */
@property (nonatomic, assign, readonly) CGFloat fontSize;

/**
 * Indicates if the text appears to be bold.
 */
@property (nonatomic, assign, readonly) BOOL isBold;

/**
 * Indicates if the text appears to be italic.
 */
@property (nonatomic, assign, readonly) BOOL isItalic;

/**
 * The detected heading level (0 for body text, 1-6 for headings).
 */
@property (nonatomic, assign) NSInteger headingLevel;

/**
 * Designated initializer for creating a text element.
 *
 * @param text The text content (required)
 * @param bounds The bounding rectangle
 * @param pageIndex The page index
 * @return A new text element instance
 */
- (instancetype)initWithText:(NSString *)text
                      bounds:(CGRect)bounds
                   pageIndex:(NSInteger)pageIndex;

/**
 * Convenience initializer with full styling information.
 *
 * @param text The text content
 * @param bounds The bounding rectangle
 * @param pageIndex The page index
 * @param fontName The font name (optional)
 * @param fontSize The font size
 * @param isBold Bold style flag
 * @param isItalic Italic style flag
 * @return A new text element instance
 */
- (instancetype)initWithText:(NSString *)text
                      bounds:(CGRect)bounds
                   pageIndex:(NSInteger)pageIndex
                    fontName:(nullable NSString *)fontName
                    fontSize:(CGFloat)fontSize
                      isBold:(BOOL)isBold
                    isItalic:(BOOL)isItalic NS_DESIGNATED_INITIALIZER;

- (instancetype)init NS_UNAVAILABLE;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/Models/PDF22MDTextElement.m">
#import "PDF22MDTextElement.h"

@implementation PDF22MDTextElement

#pragma mark - Initialization

- (instancetype)initWithText:(NSString *)text
                      bounds:(CGRect)bounds
                   pageIndex:(NSInteger)pageIndex {
    return [self initWithText:text
                       bounds:bounds
                    pageIndex:pageIndex
                     fontName:nil
                     fontSize:12.0
                       isBold:NO
                     isItalic:NO];
}

- (instancetype)initWithText:(NSString *)text
                      bounds:(CGRect)bounds
                   pageIndex:(NSInteger)pageIndex
                    fontName:(nullable NSString *)fontName
                    fontSize:(CGFloat)fontSize
                      isBold:(BOOL)isBold
                    isItalic:(BOOL)isItalic {
    self = [super init];
    if (self) {
        _text = [text copy];
        _bounds = bounds;
        _pageIndex = pageIndex;
        _fontName = [fontName copy];
        _fontSize = fontSize;
        _isBold = isBold;
        _isItalic = isItalic;
        _headingLevel = 0; // Default to body text
    }
    return self;
}

#pragma mark - PDF22MDContentElement Protocol

- (nullable NSString *)markdownRepresentation {
    if (!self.text || self.text.length == 0) {
        return nil;
    }
    
    NSString *trimmedText = [self.text stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    if (trimmedText.length == 0) {
        return nil;
    }
    
    // Apply heading formatting
    if (self.headingLevel > 0 && self.headingLevel <= 6) {
        NSMutableString *heading = [NSMutableString string];
        for (NSInteger i = 0; i < self.headingLevel; i++) {
            [heading appendString:@"#"];
        }
        [heading appendString:@" "];
        [heading appendString:trimmedText];
        return heading;
    }
    
    // Apply bold/italic formatting
    NSString *formattedText = trimmedText;
    
    if (self.isBold && self.isItalic) {
        formattedText = [NSString stringWithFormat:@"***%@***", formattedText];
    } else if (self.isBold) {
        formattedText = [NSString stringWithFormat:@"**%@**", formattedText];
    } else if (self.isItalic) {
        formattedText = [NSString stringWithFormat:@"*%@*", formattedText];
    }
    
    return formattedText;
}

- (NSDictionary<NSString *, id> *)metadata {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    if (self.fontName) {
        metadata[@"fontName"] = self.fontName;
    }
    metadata[@"fontSize"] = @(self.fontSize);
    metadata[@"isBold"] = @(self.isBold);
    metadata[@"isItalic"] = @(self.isItalic);
    metadata[@"headingLevel"] = @(self.headingLevel);
    
    return [metadata copy];
}

#pragma mark - NSObject

- (NSString *)description {
    return [NSString stringWithFormat:@"<%@: %p, text='%@', bounds=%@, page=%ld>",
            NSStringFromClass([self class]),
            self,
            [self.text length] > 50 ? [[self.text substringToIndex:50] stringByAppendingString:@"..."] : self.text,
            [NSString stringWithFormat:@"{{%.1f,%.1f},{%.1f,%.1f}}", self.bounds.origin.x, self.bounds.origin.y, self.bounds.size.width, self.bounds.size.height],
            (long)self.pageIndex];
}

- (NSString *)debugDescription {
    return [NSString stringWithFormat:@"<%@: %p> {\n  text: '%@'\n  bounds: %@\n  page: %ld\n  font: %@\n  size: %.1f\n  bold: %@\n  italic: %@\n  heading: %ld\n}",
            NSStringFromClass([self class]),
            self,
            self.text,
            [NSString stringWithFormat:@"{{%.1f,%.1f},{%.1f,%.1f}}", self.bounds.origin.x, self.bounds.origin.y, self.bounds.size.width, self.bounds.size.height],
            (long)self.pageIndex,
            self.fontName ?: @"<unknown>",
            self.fontSize,
            self.isBold ? @"YES" : @"NO",
            self.isItalic ? @"YES" : @"NO",
            (long)self.headingLevel];
}

- (BOOL)isEqual:(id)object {
    if (self == object) {
        return YES;
    }
    
    if (![object isKindOfClass:[PDF22MDTextElement class]]) {
        return NO;
    }
    
    PDF22MDTextElement *other = (PDF22MDTextElement *)object;
    
    return [self.text isEqualToString:other.text] &&
           CGRectEqualToRect(self.bounds, other.bounds) &&
           self.pageIndex == other.pageIndex &&
           (self.fontName == other.fontName || [self.fontName isEqualToString:other.fontName]) &&
           self.fontSize == other.fontSize &&
           self.isBold == other.isBold &&
           self.isItalic == other.isItalic &&
           self.headingLevel == other.headingLevel;
}

- (NSUInteger)hash {
    NSUInteger prime = 31;
    NSUInteger result = 1;
    
    result = prime * result + [self.text hash];
    result = prime * result + (NSUInteger)(self.bounds.origin.x + self.bounds.origin.y + self.bounds.size.width + self.bounds.size.height);
    result = prime * result + self.pageIndex;
    result = prime * result + [self.fontName hash];
    result = prime * result + (NSUInteger)self.fontSize;
    result = prime * result + (self.isBold ? 1 : 0);
    result = prime * result + (self.isItalic ? 1 : 0);
    result = prime * result + self.headingLevel;
    
    return result;
}

@end
</file>

<file path="pdf22md-objc/src/Services/PDF22MDMarkdownGenerator.h">
#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>

NS_ASSUME_NONNULL_BEGIN

@protocol PDF22MDContentElement;
@class PDF22MDConversionOptions;

/**
 * Metadata structure for YAML frontmatter generation.
 */
@interface PDF22MDDocumentMetadata : NSObject
@property (nonatomic, copy, nullable) NSString *title;
@property (nonatomic, copy, nullable) NSString *author;
@property (nonatomic, copy, nullable) NSString *subject;
@property (nonatomic, copy, nullable) NSArray<NSString *> *keywords;
@property (nonatomic, copy, nullable) NSString *creator;
@property (nonatomic, copy, nullable) NSString *producer;
@property (nonatomic, strong, nullable) NSDate *creationDate;
@property (nonatomic, strong, nullable) NSDate *modificationDate;
@property (nonatomic, assign) NSInteger pageCount;
@property (nonatomic, copy, nullable) NSString *pdfVersion;
@property (nonatomic, strong, nullable) PDFOutline *outline;
@end

/**
 * Generates Markdown output from PDF content elements.
 */
@interface PDF22MDMarkdownGenerator : NSObject

/**
 * Conversion options affecting markdown generation.
 */
@property (nonatomic, strong, readonly) PDF22MDConversionOptions *options;

/**
 * Initializes the generator with conversion options.
 *
 * @param options The conversion options to use
 * @return A new generator instance
 */
- (instancetype)initWithOptions:(PDF22MDConversionOptions *)options NS_DESIGNATED_INITIALIZER;

- (instancetype)init NS_UNAVAILABLE;

/**
 * Generates a complete markdown document from content elements.
 *
 * @param elements Array of content elements in reading order
 * @param metadata Document metadata for frontmatter
 * @return The generated markdown string
 */
- (NSString *)generateMarkdownFromElements:(NSArray<id<PDF22MDContentElement>> *)elements
                              withMetadata:(nullable PDF22MDDocumentMetadata *)metadata;

/**
 * Generates YAML frontmatter from document metadata.
 *
 * @param metadata The document metadata
 * @return YAML frontmatter string, or nil if includeMetadata is NO
 */
- (nullable NSString *)generateYAMLFrontmatter:(PDF22MDDocumentMetadata *)metadata;

/**
 * Generates markdown content from elements without frontmatter.
 *
 * @param elements Array of content elements
 * @return The markdown content
 */
- (NSString *)generateMarkdownContent:(NSArray<id<PDF22MDContentElement>> *)elements;

/**
 * Extracts metadata from a PDF document.
 *
 * @param document The PDF document
 * @return Populated metadata object
 */
+ (PDF22MDDocumentMetadata *)extractMetadataFromDocument:(PDFDocument *)document;

/**
 * Escapes a string for safe inclusion in YAML.
 *
 * @param string The string to escape
 * @return The escaped string
 */
+ (NSString *)escapeYAMLString:(NSString *)string;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/Services/PDF22MDMarkdownGenerator.m">
#import "PDF22MDMarkdownGenerator.h"
#import "../Core/PDF22MDConversionOptions.h"
#import "../Models/PDF22MDContentElement.h"
#import "../Models/PDF22MDTextElement.h"

// Version string - should match the compiled version
#ifndef PDF22MD_VERSION
#define PDF22MD_VERSION "1.0.0"
#endif

@implementation PDF22MDDocumentMetadata
@end

@implementation PDF22MDMarkdownGenerator

#pragma mark - Initialization

- (instancetype)initWithOptions:(PDF22MDConversionOptions *)options {
    self = [super init];
    if (self) {
        _options = options;
    }
    return self;
}

#pragma mark - Public Methods

- (NSString *)generateMarkdownFromElements:(NSArray<id<PDF22MDContentElement>> *)elements
                              withMetadata:(nullable PDF22MDDocumentMetadata *)metadata {
    NSMutableString *markdown = [NSMutableString string];
    
    // Add YAML frontmatter if enabled
    if (self.options.includeMetadata && metadata) {
        NSString *frontmatter = [self generateYAMLFrontmatter:metadata];
        if (frontmatter) {
            [markdown appendString:frontmatter];
            [markdown appendString:@"\n"];
        }
    }
    
    // Generate content
    NSString *content = [self generateMarkdownContent:elements];
    [markdown appendString:content];
    
    // Clean up extra newlines
    NSString *finalMarkdown = [markdown stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    
    return finalMarkdown;
}

- (nullable NSString *)generateYAMLFrontmatter:(PDF22MDDocumentMetadata *)metadata {
    if (!self.options.includeMetadata) {
        return nil;
    }
    
    NSMutableString *yaml = [NSMutableString string];
    [yaml appendString:@"---\n"];
    
    // Basic metadata
    if (metadata.title && metadata.title.length > 0) {
        [yaml appendFormat:@"title: \"%@\"\n", [[self class] escapeYAMLString:metadata.title]];
    }
    
    if (metadata.author && metadata.author.length > 0) {
        [yaml appendFormat:@"author: \"%@\"\n", [[self class] escapeYAMLString:metadata.author]];
    }
    
    if (metadata.subject && metadata.subject.length > 0) {
        [yaml appendFormat:@"subject: \"%@\"\n", [[self class] escapeYAMLString:metadata.subject]];
    }
    
    // Keywords
    if (metadata.keywords && metadata.keywords.count > 0) {
        [yaml appendString:@"keywords:\n"];
        for (NSString *keyword in metadata.keywords) {
            [yaml appendFormat:@"  - \"%@\"\n", [[self class] escapeYAMLString:keyword]];
        }
    }
    
    // Creator and producer
    if (metadata.creator && metadata.creator.length > 0) {
        [yaml appendFormat:@"creator: \"%@\"\n", [[self class] escapeYAMLString:metadata.creator]];
    }
    
    if (metadata.producer && metadata.producer.length > 0) {
        [yaml appendFormat:@"producer: \"%@\"\n", [[self class] escapeYAMLString:metadata.producer]];
    }
    
    // Dates
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateFormat:@"yyyy-MM-dd'T'HH:mm:ssZZZZZ"];
    [formatter setLocale:[NSLocale localeWithLocaleIdentifier:@"en_US_POSIX"]];
    
    if (metadata.creationDate) {
        [yaml appendFormat:@"created: %@\n", [formatter stringFromDate:metadata.creationDate]];
    }
    
    if (metadata.modificationDate) {
        [yaml appendFormat:@"modified: %@\n", [formatter stringFromDate:metadata.modificationDate]];
    }
    
    // PDF specific metadata
    [yaml appendString:@"pdf_metadata:\n"];
    [yaml appendFormat:@"  page_count: %ld\n", (long)metadata.pageCount];
    
    if (metadata.pdfVersion && metadata.pdfVersion.length > 0) {
        [yaml appendFormat:@"  version: \"%@\"\n", metadata.pdfVersion];
    }
    
    // Outline/bookmarks
    if (self.options.preserveOutline && metadata.outline && [metadata.outline numberOfChildren] > 0) {
        [yaml appendString:@"  outline:\n"];
        [self appendOutlineToYAML:yaml outline:metadata.outline indent:@"    "];
    }
    
    // Conversion metadata
    [yaml appendString:@"conversion:\n"];
    [yaml appendString:@"  tool: \"pdf22md\"\n"];
    [yaml appendFormat:@"  version: \"%s\"\n", PDF22MD_VERSION];
    [yaml appendFormat:@"  date: %@\n", [formatter stringFromDate:[NSDate date]]];
    
    [yaml appendString:@"---\n"];
    
    return yaml;
}

- (NSString *)generateMarkdownContent:(NSArray<id<PDF22MDContentElement>> *)elements {
    NSMutableString *content = [NSMutableString string];
    
    id<PDF22MDContentElement> previousElement = nil;
    
    for (id<PDF22MDContentElement> element in elements) {
        NSString *elementMarkdown = [element markdownRepresentation];
        
        if (elementMarkdown && elementMarkdown.length > 0) {
            // Add appropriate spacing between elements
            if (previousElement) {
                // Check if we need extra spacing (e.g., between paragraphs)
                if ([self shouldAddExtraSpacingBetween:previousElement and:element]) {
                    [content appendString:@"\n\n"];
                } else {
                    [content appendString:@"\n"];
                }
            }
            
            [content appendString:elementMarkdown];
            previousElement = element;
        }
    }
    
    return content;
}

+ (PDF22MDDocumentMetadata *)extractMetadataFromDocument:(PDFDocument *)document {
    PDF22MDDocumentMetadata *metadata = [[PDF22MDDocumentMetadata alloc] init];
    
    // Get document attributes
    NSDictionary *attributes = [document documentAttributes];
    
    metadata.title = attributes[PDFDocumentTitleAttribute];
    metadata.author = attributes[PDFDocumentAuthorAttribute];
    metadata.subject = attributes[PDFDocumentSubjectAttribute];
    metadata.keywords = attributes[PDFDocumentKeywordsAttribute];
    metadata.creator = attributes[PDFDocumentCreatorAttribute];
    metadata.producer = attributes[PDFDocumentProducerAttribute];
    metadata.creationDate = attributes[PDFDocumentCreationDateAttribute];
    metadata.modificationDate = attributes[PDFDocumentModificationDateAttribute];
    
    metadata.pageCount = [document pageCount];
    metadata.outline = [document outlineRoot];
    
    // Try to extract PDF version
    metadata.pdfVersion = [self extractPDFVersionFromAttributes:attributes];
    
    return metadata;
}

+ (NSString *)escapeYAMLString:(NSString *)string {
    // Escape quotes and backslashes for YAML
    NSString *escaped = [string stringByReplacingOccurrencesOfString:@"\\" withString:@"\\\\"];
    escaped = [escaped stringByReplacingOccurrencesOfString:@"\"" withString:@"\\\""];
    escaped = [escaped stringByReplacingOccurrencesOfString:@"\n" withString:@"\\n"];
    escaped = [escaped stringByReplacingOccurrencesOfString:@"\r" withString:@"\\r"];
    escaped = [escaped stringByReplacingOccurrencesOfString:@"\t" withString:@"\\t"];
    return escaped;
}

#pragma mark - Private Methods

- (void)appendOutlineToYAML:(NSMutableString *)yaml outline:(PDFOutline *)outline indent:(NSString *)indent {
    for (NSUInteger i = 0; i < [outline numberOfChildren]; i++) {
        PDFOutline *child = [outline childAtIndex:i];
        NSString *label = [child label];
        
        if (label && label.length > 0) {
            [yaml appendFormat:@"%@- title: \"%@\"\n", indent, [[self class] escapeYAMLString:label]];
            
            PDFDestination *destination = [child destination];
            if (destination) {
                PDFPage *page = [destination page];
                if (page) {
                    // Note: We need the document to get page index, so this is an approximation
                    [yaml appendFormat:@"%@  page: %ld\n", indent, (long)1];
                }
            }
            
            if ([child numberOfChildren] > 0) {
                [yaml appendFormat:@"%@  children:\n", indent];
                NSString *newIndent = [indent stringByAppendingString:@"    "];
                [self appendOutlineToYAML:yaml outline:child indent:newIndent];
            }
        }
    }
}

+ (NSString *)extractPDFVersionFromAttributes:(NSDictionary *)attributes {
    // Look for PDF version in various attribute keys
    for (NSString *key in attributes) {
        id value = attributes[key];
        if ([value isKindOfClass:[NSString class]]) {
            NSString *stringValue = (NSString *)value;
            
            // Look for PDF version patterns
            NSRange pdfRange = [stringValue rangeOfString:@"PDF-" options:NSCaseInsensitiveSearch];
            if (pdfRange.location != NSNotFound) {
                // Extract version number after "PDF-"
                NSString *versionPart = [stringValue substringFromIndex:pdfRange.location];
                NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"PDF-?(\\d+\\.\\d+)"
                                                                                       options:NSRegularExpressionCaseInsensitive
                                                                                         error:nil];
                NSTextCheckingResult *match = [regex firstMatchInString:versionPart
                                                               options:0
                                                                 range:NSMakeRange(0, versionPart.length)];
                if (match && match.numberOfRanges > 1) {
                    return [versionPart substringWithRange:[match rangeAtIndex:1]];
                }
            }
        }
    }
    
    return nil;
}

- (BOOL)shouldAddExtraSpacingBetween:(id<PDF22MDContentElement>)element1 
                                 and:(id<PDF22MDContentElement>)element2 {
    // Add extra spacing between different element types
    if ([element1 class] != [element2 class]) {
        return YES;
    }
    
    // Add extra spacing after headings
    if ([element1 isKindOfClass:[PDF22MDTextElement class]]) {
        PDF22MDTextElement *textElement = (PDF22MDTextElement *)element1;
        if (textElement.headingLevel > 0) {
            return YES;
        }
    }
    
    // Add extra spacing between elements on different pages
    if (element1.pageIndex != element2.pageIndex) {
        return YES;
    }
    
    // Check vertical distance between elements
    CGFloat verticalDistance = fabs(CGRectGetMinY(element1.bounds) - CGRectGetMaxY(element2.bounds));
    if (verticalDistance > 20.0) { // Significant gap
        return YES;
    }
    
    return NO;
}

@end
</file>

<file path="pdf22md-objc/Tests/Integration/EndToEndConversionTests.m">
//
//  EndToEndConversionTests.m
//  pdf22md-objc
//
//  Integration tests for complete PDF to Markdown conversion pipeline
//

#import <XCTest/XCTest.h>
#import "PDF22MDConverter.h"
#import "PDF22MDConversionOptions.h"
#import "PDF22MDError.h"

@interface EndToEndConversionTests : XCTestCase
@property (nonatomic, strong) PDF22MDConverter *converter;
@property (nonatomic, strong) NSString *testResourcesPath;
@property (nonatomic, strong) NSString *tempOutputPath;
@end

@implementation EndToEndConversionTests

- (void)setUp {
    [super setUp];
    self.converter = [[PDF22MDConverter alloc] init];
    
    // Set up test resources path
    NSBundle *bundle = [NSBundle bundleForClass:[self class]];
    self.testResourcesPath = [bundle.resourcePath stringByAppendingPathComponent:@"Tests/Resources"];
    
    // Create temporary output directory
    self.tempOutputPath = [NSTemporaryDirectory() stringByAppendingPathComponent:@"pdf22md-test-output"];
    [[NSFileManager defaultManager] createDirectoryAtPath:self.tempOutputPath 
                              withIntermediateDirectories:YES 
                                               attributes:nil 
                                                    error:nil];
}

- (void)tearDown {
    // Clean up temporary directory
    [[NSFileManager defaultManager] removeItemAtPath:self.tempOutputPath error:nil];
    self.converter = nil;
    [super tearDown];
}

#pragma mark - Complete Workflow Tests

- (void)testSimpleTextDocumentConversion {
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"simple-text.pdf"];
    
    // Skip test if resource file doesn't exist
    if (![self fileExistsAtPath:testPDFPath]) {
        NSLog(@"Test PDF 'simple-text.pdf' not found, skipping test");
        return;
    }
    
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    options.assetsPath = [self.tempOutputPath stringByAppendingPathComponent:@"assets"];
    
    NSError *error = nil;
    NSString *markdown = [self.converter convertPDFAtPath:testPDFPath 
                                              withOptions:options 
                                                    error:&error];
    
    XCTAssertNotNil(markdown, @"Should successfully convert simple text PDF");
    XCTAssertNil(error, @"Should not return error for valid PDF conversion");
    
    // Validate markdown structure
    [self validateBasicMarkdownStructure:markdown];
    
    // Check that assets directory was created (even if empty)
    BOOL isDirectory;
    BOOL assetsExist = [[NSFileManager defaultManager] fileExistsAtPath:options.assetsPath 
                                                            isDirectory:&isDirectory];
    XCTAssertTrue(assetsExist && isDirectory, @"Assets directory should be created");
}

- (void)testComplexDocumentWithImages {
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"complex-with-images.pdf"];
    
    if (![self fileExistsAtPath:testPDFPath]) {
        NSLog(@"Test PDF 'complex-with-images.pdf' not found, skipping test");
        return;
    }
    
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    options.assetsPath = [self.tempOutputPath stringByAppendingPathComponent:@"assets"];
    options.dpi = 200; // Higher DPI for quality
    
    NSError *error = nil;
    NSString *markdown = [self.converter convertPDFAtPath:testPDFPath 
                                              withOptions:options 
                                                    error:&error];
    
    XCTAssertNotNil(markdown, @"Should successfully convert complex PDF with images");
    XCTAssertNil(error, @"Should not return error for valid PDF conversion");
    
    // Validate markdown structure
    [self validateBasicMarkdownStructure:markdown];
    
    // Check for image references in markdown
    XCTAssertTrue([markdown containsString:@"!["], @"Should contain image references");
    XCTAssertTrue([markdown containsString:@"assets/"], @"Should reference assets directory");
    
    // Verify that image files were actually created
    NSArray *assetFiles = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:options.assetsPath error:nil];
    XCTAssertTrue(assetFiles.count > 0, @"Should extract at least one asset file");
    
    // Verify image file formats
    for (NSString *filename in assetFiles) {
        XCTAssertTrue([filename hasSuffix:@".png"] || [filename hasSuffix:@".jpg"], 
                      @"Asset files should be PNG or JPG format");
    }
}

- (void)testLargeDocumentPerformance {
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"large-document.pdf"];
    
    if (![self fileExistsAtPath:testPDFPath]) {
        NSLog(@"Test PDF 'large-document.pdf' not found, skipping test");
        return;
    }
    
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    options.assetsPath = [self.tempOutputPath stringByAppendingPathComponent:@"assets"];
    
    NSDate *startTime = [NSDate date];
    
    NSError *error = nil;
    NSString *markdown = [self.converter convertPDFAtPath:testPDFPath 
                                              withOptions:options 
                                                    error:&error];
    
    NSTimeInterval elapsed = [[NSDate date] timeIntervalSinceDate:startTime];
    
    XCTAssertNotNil(markdown, @"Should successfully convert large PDF");
    XCTAssertNil(error, @"Should not return error for valid large PDF");
    XCTAssertLessThan(elapsed, 30.0, @"Large document conversion should complete within 30 seconds");
    
    NSLog(@"Large document conversion time: %.2f seconds", elapsed);
}

#pragma mark - Error Handling Integration Tests

- (void)testMalformedPDFHandling {
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"malformed.pdf"];
    
    if (![self fileExistsAtPath:testPDFPath]) {
        NSLog(@"Test PDF 'malformed.pdf' not found, skipping test");
        return;
    }
    
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    
    NSError *error = nil;
    NSString *markdown = [self.converter convertPDFAtPath:testPDFPath 
                                              withOptions:options 
                                                    error:&error];
    
    // Should either succeed with partial content or fail gracefully
    if (markdown) {
        XCTAssertNil(error, @"If conversion succeeds, should not return error");
        XCTAssertTrue(markdown.length > 0, @"If conversion succeeds, should return content");
    } else {
        XCTAssertNotNil(error, @"If conversion fails, should return meaningful error");
        XCTAssertNotEqual(error.code, 0, @"Error should have meaningful error code");
        XCTAssertTrue(error.localizedDescription.length > 0, @"Error should have description");
    }
}

- (void)testEncryptedPDFHandling {
    // This test would require an encrypted PDF sample
    // For now, we'll test the expected behavior
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"encrypted.pdf"];
    
    if (![self fileExistsAtPath:testPDFPath]) {
        NSLog(@"Test PDF 'encrypted.pdf' not found, skipping test");
        return;
    }
    
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    
    NSError *error = nil;
    NSString *markdown = [self.converter convertPDFAtPath:testPDFPath 
                                              withOptions:options 
                                                    error:&error];
    
    XCTAssertNil(markdown, @"Should not convert encrypted PDF without password");
    XCTAssertNotNil(error, @"Should return error for encrypted PDF");
    XCTAssertEqual(error.code, PDF22MDErrorEncryptedPDF, @"Should return encrypted PDF error code");
}

#pragma mark - Memory Stress Tests

- (void)testMemoryStabilityUnderLoad {
    // Test multiple conversions to ensure memory stability
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    options.assetsPath = [self.tempOutputPath stringByAppendingPathComponent:@"stress-assets"];
    
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"simple-text.pdf"];
    
    if (![self fileExistsAtPath:testPDFPath]) {
        NSLog(@"Test PDF not found, creating minimal test for memory stability");
        return;
    }
    
    // Run multiple conversions
    for (int i = 0; i < 5; i++) {
        @autoreleasepool {
            NSError *error = nil;
            NSString *markdown = [self.converter convertPDFAtPath:testPDFPath 
                                                      withOptions:options 
                                                            error:&error];
            
            XCTAssertNotNil(markdown, @"Conversion %d should succeed", i + 1);
            XCTAssertNil(error, @"Conversion %d should not return error", i + 1);
        }
    }
}

#pragma mark - Output Validation Tests

- (void)testMarkdownOutputQuality {
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"simple-text.pdf"];
    
    if (![self fileExistsAtPath:testPDFPath]) {
        NSLog(@"Test PDF not found, skipping output quality test");
        return;
    }
    
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    
    NSError *error = nil;
    NSString *markdown = [self.converter convertPDFAtPath:testPDFPath 
                                              withOptions:options 
                                                    error:&error];
    
    XCTAssertNotNil(markdown, @"Should produce markdown output");
    
    if (markdown) {
        [self validateAdvancedMarkdownStructure:markdown];
    }
}

- (void)testExpectedOutputComparison {
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"simple-text.pdf"];
    NSString *expectedPath = [self.testResourcesPath stringByAppendingPathComponent:@"expected-outputs/simple-text.md"];
    
    if (![self fileExistsAtPath:testPDFPath] || ![self fileExistsAtPath:expectedPath]) {
        NSLog(@"Test files not found, skipping expected output comparison");
        return;
    }
    
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    
    NSError *error = nil;
    NSString *actualMarkdown = [self.converter convertPDFAtPath:testPDFPath 
                                                    withOptions:options 
                                                          error:&error];
    
    NSString *expectedMarkdown = [NSString stringWithContentsOfFile:expectedPath 
                                                           encoding:NSUTF8StringEncoding 
                                                              error:nil];
    
    XCTAssertNotNil(actualMarkdown, @"Should produce actual markdown");
    XCTAssertNotNil(expectedMarkdown, @"Should load expected markdown");
    
    if (actualMarkdown && expectedMarkdown) {
        // Normalize whitespace for comparison
        NSString *normalizedActual = [self normalizeWhitespace:actualMarkdown];
        NSString *normalizedExpected = [self normalizeWhitespace:expectedMarkdown];
        
        XCTAssertEqualObjects(normalizedActual, normalizedExpected, 
                              @"Actual output should match expected output");
    }
}

#pragma mark - Helper Methods

- (BOOL)fileExistsAtPath:(NSString *)path {
    return [[NSFileManager defaultManager] fileExistsAtPath:path];
}

- (void)validateBasicMarkdownStructure:(NSString *)markdown {
    XCTAssertTrue(markdown.length > 0, @"Markdown should not be empty");
    
    // Should not contain raw PDF artifacts
    XCTAssertFalse([markdown containsString:@"%%PDF"], @"Should not contain PDF header");
    XCTAssertFalse([markdown containsString:@"endobj"], @"Should not contain PDF objects");
    
    // Should be valid UTF-8
    NSData *data = [markdown dataUsingEncoding:NSUTF8StringEncoding];
    XCTAssertNotNil(data, @"Markdown should be valid UTF-8");
}

- (void)validateAdvancedMarkdownStructure:(NSString *)markdown {
    [self validateBasicMarkdownStructure:markdown];
    
    // Check for proper markdown formatting
    NSArray *lines = [markdown componentsSeparatedByString:@"\n"];
    
    BOOL hasHeadings = NO;
    BOOL hasContent = NO;
    
    for (NSString *line in lines) {
        NSString *trimmed = [line stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
        
        if ([trimmed hasPrefix:@"#"]) {
            hasHeadings = YES;
            // Validate heading format
            XCTAssertTrue([trimmed rangeOfString:@"# "].location != NSNotFound ||
                         [trimmed rangeOfString:@"## "].location != NSNotFound ||
                         [trimmed rangeOfString:@"### "].location != NSNotFound,
                         @"Headings should have proper spacing");
        }
        
        if (trimmed.length > 0 && ![trimmed hasPrefix:@"#"] && ![trimmed hasPrefix:@"!"]) {
            hasContent = YES;
        }
    }
    
    // Don't require headings for all documents, but if present, they should be formatted correctly
    if (hasHeadings) {
        XCTAssertTrue(hasContent, @"Document with headings should also have content");
    }
}

- (NSString *)normalizeWhitespace:(NSString *)text {
    // Normalize line endings and excessive whitespace for comparison
    NSString *normalized = [text stringByReplacingOccurrencesOfString:@"\r\n" withString:@"\n"];
    normalized = [normalized stringByReplacingOccurrencesOfString:@"\r" withString:@"\n"];
    
    // Remove trailing whitespace from lines
    NSMutableArray *lines = [[normalized componentsSeparatedByString:@"\n"] mutableCopy];
    for (NSInteger i = 0; i < lines.count; i++) {
        lines[i] = [lines[i] stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
    }
    
    return [lines componentsJoinedByString:@"\n"];
}

@end
</file>

<file path="pdf22md-objc/Tests/Unit/AssetExtractorTests.m">
//
//  AssetExtractorTests.m
//  pdf22md
//
//  Unit tests for asset extraction and image processing functionality
//

#import <XCTest/XCTest.h>
#import <CoreGraphics/CoreGraphics.h>
#import <ImageIO/ImageIO.h>
#import "../../src/AssetExtractor.h"

@interface AssetExtractorTests : XCTestCase
@property (nonatomic, strong) AssetExtractor *extractor;
@property (nonatomic, strong) NSString *testAssetsPath;
@end

@implementation AssetExtractorTests

- (void)setUp {
    [super setUp];
    self.extractor = [[AssetExtractor alloc] init];
    
    // Create temporary test assets directory
    NSString *tempDir = NSTemporaryDirectory();
    self.testAssetsPath = [tempDir stringByAppendingPathComponent:@"pdf22md-test-assets"];
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    [fileManager createDirectoryAtPath:self.testAssetsPath 
           withIntermediateDirectories:YES 
                            attributes:nil 
                                 error:nil];
}

- (void)tearDown {
    // Clean up test assets directory
    NSFileManager *fileManager = [NSFileManager defaultManager];
    [fileManager removeItemAtPath:self.testAssetsPath error:nil];
    
    self.extractor = nil;
    self.testAssetsPath = nil;
    [super tearDown];
}

#pragma mark - Basic Functionality Tests

- (void)testExtractorInitialization {
    XCTAssertNotNil(self.extractor, @"AssetExtractor should initialize successfully");
}

- (void)testSetAssetsFolderPath {
    NSString *testPath = @"/tmp/test-assets";
    [self.extractor setAssetsFolderPath:testPath];
    
    // Note: We can't directly test the private property, but we can test that the method doesn't crash
    // and that subsequent operations work as expected
    XCTAssertTrue(YES, @"setAssetsFolderPath should complete without crashing");
}

#pragma mark - Image Format Detection Tests

- (void)testFormatOptimizationLogic {
    // Test the format optimization logic with synthetic images
    
    // Create a simple test image
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, 100, 100, 8, 0, colorSpace, 
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (context) {
        // Fill with a simple color
        CGContextSetRGBFillColor(context, 1.0, 0.0, 0.0, 1.0);
        CGContextFillRect(context, CGRectMake(0, 0, 100, 100));
        
        CGImageRef testImage = CGBitmapContextCreateImage(context);
        CGContextRelease(context);
        
        if (testImage) {
            // Test format decision logic
            BOOL shouldUseJPEG = [self.extractor shouldUseJPEGForImage:testImage];
            
            // For a simple solid color image, PNG should be preferred
            // (though the exact logic depends on implementation)
            XCTAssertTrue(shouldUseJPEG == YES || shouldUseJPEG == NO, 
                         @"shouldUseJPEGForImage should return a boolean value");
            
            CGImageRelease(testImage);
        }
    }
}

- (void)testImageSaving {
    // Test image saving functionality
    
    // Create a minimal test image
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, 50, 50, 8, 0, colorSpace, 
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (context) {
        // Create a gradient pattern for testing
        CGContextSetRGBFillColor(context, 0.5, 0.5, 1.0, 1.0);
        CGContextFillRect(context, CGRectMake(0, 0, 50, 50));
        
        CGImageRef testImage = CGBitmapContextCreateImage(context);
        CGContextRelease(context);
        
        if (testImage) {
            [self.extractor setAssetsFolderPath:self.testAssetsPath];
            
            NSString *savedPath = [self.extractor saveImage:testImage withBaseName:@"test_image"];
            
            if (savedPath) {
                // Verify the file was created
                NSString *fullPath = [self.testAssetsPath stringByAppendingPathComponent:savedPath];
                NSFileManager *fileManager = [NSFileManager defaultManager];
                XCTAssertTrue([fileManager fileExistsAtPath:fullPath], 
                             @"Saved image file should exist at path: %@", fullPath);
                
                // Verify it's a valid image file
                NSData *imageData = [NSData dataWithContentsOfFile:fullPath];
                XCTAssertNotNil(imageData, @"Should be able to read saved image data");
                XCTAssertTrue(imageData.length > 0, @"Saved image should have non-zero size");
            } else {
                XCTFail(@"saveImage should return a non-nil path");
            }
            
            CGImageRelease(testImage);
        }
    }
}

#pragma mark - File Naming Tests

- (void)testUniqueFileNaming {
    // Test that the extractor generates unique filenames
    [self.extractor setAssetsFolderPath:self.testAssetsPath];
    
    // Create multiple test images and verify unique naming
    for (int i = 0; i < 3; i++) {
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        CGContextRef context = CGBitmapContextCreate(NULL, 20, 20, 8, 0, colorSpace, 
                                                    kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
        CGColorSpaceRelease(colorSpace);
        
        if (context) {
            // Use different colors for each image
            CGFloat red = (i == 0) ? 1.0 : 0.0;
            CGFloat green = (i == 1) ? 1.0 : 0.0;
            CGFloat blue = (i == 2) ? 1.0 : 0.0;
            
            CGContextSetRGBFillColor(context, red, green, blue, 1.0);
            CGContextFillRect(context, CGRectMake(0, 0, 20, 20));
            
            CGImageRef testImage = CGBitmapContextCreateImage(context);
            CGContextRelease(context);
            
            if (testImage) {
                NSString *savedPath = [self.extractor saveImage:testImage withBaseName:@"test"];
                XCTAssertNotNil(savedPath, @"Should get a valid filename for image %d", i);
                
                CGImageRelease(testImage);
            }
        }
    }
    
    // Verify multiple files were created
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSArray *contents = [fileManager contentsOfDirectoryAtPath:self.testAssetsPath error:nil];
    XCTAssertTrue(contents.count >= 1, @"Should have created at least one image file");
}

#pragma mark - Error Handling Tests

- (void)testNilImageHandling {
    [self.extractor setAssetsFolderPath:self.testAssetsPath];
    
    NSString *result = [self.extractor saveImage:NULL withBaseName:@"test"];
    XCTAssertNil(result, @"Should return nil for NULL image");
}

- (void)testInvalidAssetsFolderHandling {
    // Test with invalid assets folder path
    NSString *invalidPath = @"/invalid/path/that/cannot/be/created";
    [self.extractor setAssetsFolderPath:invalidPath];
    
    // Create a test image
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, 10, 10, 8, 0, colorSpace, 
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (context) {
        CGContextSetRGBFillColor(context, 1.0, 1.0, 1.0, 1.0);
        CGContextFillRect(context, CGRectMake(0, 0, 10, 10));
        
        CGImageRef testImage = CGBitmapContextCreateImage(context);
        CGContextRelease(context);
        
        if (testImage) {
            NSString *result = [self.extractor saveImage:testImage withBaseName:@"test"];
            // Should handle the error gracefully (exact behavior depends on implementation)
            // At minimum, should not crash
            
            CGImageRelease(testImage);
        }
    }
}

#pragma mark - Performance Tests

- (void)testImageSavingPerformance {
    [self.extractor setAssetsFolderPath:self.testAssetsPath];
    
    [self measureBlock:^{
        // Create and save a test image
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        CGContextRef context = CGBitmapContextCreate(NULL, 100, 100, 8, 0, colorSpace, 
                                                    kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
        CGColorSpaceRelease(colorSpace);
        
        if (context) {
            CGContextSetRGBFillColor(context, 0.5, 0.5, 0.5, 1.0);
            CGContextFillRect(context, CGRectMake(0, 0, 100, 100));
            
            CGImageRef testImage = CGBitmapContextCreateImage(context);
            CGContextRelease(context);
            
            if (testImage) {
                [self.extractor saveImage:testImage withBaseName:@"perf_test"];
                CGImageRelease(testImage);
            }
        }
    }];
}

#pragma mark - Memory Management Tests

- (void)testMemoryManagement {
    // Test that multiple image operations don't cause memory issues
    [self.extractor setAssetsFolderPath:self.testAssetsPath];
    
    for (int i = 0; i < 10; i++) {
        @autoreleasepool {
            CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
            CGContextRef context = CGBitmapContextCreate(NULL, 50, 50, 8, 0, colorSpace, 
                                                        kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
            CGColorSpaceRelease(colorSpace);
            
            if (context) {
                CGContextSetRGBFillColor(context, (i % 3) / 3.0, ((i + 1) % 3) / 3.0, ((i + 2) % 3) / 3.0, 1.0);
                CGContextFillRect(context, CGRectMake(0, 0, 50, 50));
                
                CGImageRef testImage = CGBitmapContextCreateImage(context);
                CGContextRelease(context);
                
                if (testImage) {
                    NSString *baseName = [NSString stringWithFormat:@"memory_test_%d", i];
                    [self.extractor saveImage:testImage withBaseName:baseName];
                    CGImageRelease(testImage);
                }
            }
        }
    }
    
    // Verify files were created
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSArray *contents = [fileManager contentsOfDirectoryAtPath:self.testAssetsPath error:nil];
    XCTAssertTrue(contents.count > 0, @"Should have created image files during memory test");
}

@end
</file>

<file path="pdf22md-objc/Tests/Unit/ContentElementTests.m">
//
//  ContentElementTests.m
//  pdf22md
//
//  Unit tests for ContentElement model and text/image element functionality
//

#import <XCTest/XCTest.h>
#import <CoreGraphics/CoreGraphics.h>
#import "../../src/ContentElement.h"

@interface ContentElementTests : XCTestCase
@end

@implementation ContentElementTests

- (void)setUp {
    [super setUp];
}

- (void)tearDown {
    [super tearDown];
}

#pragma mark - ContentElement Protocol Tests

- (void)testContentElementProtocolExists {
    // Verify that the ContentElement protocol exists and can be referenced
    Protocol *contentElementProtocol = @protocol(ContentElement);
    XCTAssertNotNil(contentElementProtocol, @"ContentElement protocol should exist");
}

#pragma mark - Text Element Tests

- (void)testTextElementCreation {
    // Test creation of text elements
    NSString *testText = @"Sample text content";
    CGRect testBounds = CGRectMake(10, 20, 200, 30);
    NSInteger testPage = 1;
    
    // Check if TextElement class exists and can be instantiated
    Class textElementClass = NSClassFromString(@"TextElement");
    if (textElementClass) {
        // Test basic instantiation
        id textElement = [[textElementClass alloc] init];
        XCTAssertNotNil(textElement, @"TextElement should be instantiable");
        
        // Test that it conforms to ContentElement protocol
        XCTAssertTrue([textElement conformsToProtocol:@protocol(ContentElement)], 
                     @"TextElement should conform to ContentElement protocol");
    } else {
        XCTFail(@"TextElement class should be available");
    }
}

- (void)testTextElementProperties {
    Class textElementClass = NSClassFromString(@"TextElement");
    if (textElementClass) {
        id textElement = [[textElementClass alloc] init];
        
        // Test basic property access (using KVC since we don't have direct access to the interface)
        NSString *testText = @"Test content";
        
        // Check if text property exists and can be set/get
        if ([textElement respondsToSelector:@selector(setText:)]) {
            [textElement performSelector:@selector(setText:) withObject:testText];
            
            if ([textElement respondsToSelector:@selector(text)]) {
                NSString *retrievedText = [textElement performSelector:@selector(text)];
                XCTAssertEqualObjects(retrievedText, testText, @"Text property should store and retrieve correctly");
            }
        }
        
        // Test bounds property if available
        if ([textElement respondsToSelector:@selector(setBounds:)]) {
            CGRect testBounds = CGRectMake(5, 10, 100, 20);
            NSValue *boundsValue = [NSValue valueWithCGRect:testBounds];
            [textElement performSelector:@selector(setBounds:) withObject:boundsValue];
            
            if ([textElement respondsToSelector:@selector(bounds)]) {
                NSValue *retrievedBounds = [textElement performSelector:@selector(bounds)];
                CGRect retrievedRect = [retrievedBounds CGRectValue];
                XCTAssertTrue(CGRectEqualToRect(retrievedRect, testBounds), 
                             @"Bounds property should store and retrieve correctly");
            }
        }
    }
}

#pragma mark - Image Element Tests

- (void)testImageElementCreation {
    Class imageElementClass = NSClassFromString(@"ImageElement");
    if (imageElementClass) {
        // Test basic instantiation
        id imageElement = [[imageElementClass alloc] init];
        XCTAssertNotNil(imageElement, @"ImageElement should be instantiable");
        
        // Test that it conforms to ContentElement protocol
        XCTAssertTrue([imageElement conformsToProtocol:@protocol(ContentElement)], 
                     @"ImageElement should conform to ContentElement protocol");
    } else {
        XCTFail(@"ImageElement class should be available");
    }
}

- (void)testImageElementWithCGImage {
    Class imageElementClass = NSClassFromString(@"ImageElement");
    if (imageElementClass) {
        // Create a test CGImage
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        CGContextRef context = CGBitmapContextCreate(NULL, 50, 50, 8, 0, colorSpace, 
                                                    kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
        CGColorSpaceRelease(colorSpace);
        
        if (context) {
            CGContextSetRGBFillColor(context, 1.0, 0.0, 0.0, 1.0);
            CGContextFillRect(context, CGRectMake(0, 0, 50, 50));
            
            CGImageRef testImage = CGBitmapContextCreateImage(context);
            CGContextRelease(context);
            
            if (testImage) {
                id imageElement = [[imageElementClass alloc] init];
                
                // Test image property if available
                if ([imageElement respondsToSelector:@selector(setImage:)]) {
                    // Note: CGImageRef is not an object, so we need to handle it appropriately
                    // This test may need adjustment based on the actual implementation
                    XCTAssertTrue(YES, @"Image element should be able to handle CGImageRef");
                }
                
                CGImageRelease(testImage);
            }
        }
    }
}

#pragma mark - Markdown Generation Tests

- (void)testMarkdownGeneration {
    // Test that elements can generate markdown representation
    Class textElementClass = NSClassFromString(@"TextElement");
    if (textElementClass) {
        id textElement = [[textElementClass alloc] init];
        
        if ([textElement respondsToSelector:@selector(markdownRepresentation)]) {
            NSString *markdown = [textElement performSelector:@selector(markdownRepresentation)];
            XCTAssertTrue([markdown isKindOfClass:[NSString class]], 
                         @"markdownRepresentation should return an NSString");
        } else {
            XCTFail(@"TextElement should implement markdownRepresentation method");
        }
    }
}

#pragma mark - Bounds and Positioning Tests

- (void)testBoundsHandling {
    // Test bounds property across different element types
    NSArray *elementClassNames = @[@"TextElement", @"ImageElement"];
    
    for (NSString *className in elementClassNames) {
        Class elementClass = NSClassFromString(className);
        if (elementClass) {
            id element = [[elementClass alloc] init];
            
            // Test bounds property
            if ([element respondsToSelector:@selector(bounds)]) {
                // Default bounds should be valid
                CGRect bounds = CGRectZero;
                if ([element respondsToSelector:@selector(bounds)]) {
                    NSValue *boundsValue = [element performSelector:@selector(bounds)];
                    if (boundsValue) {
                        bounds = [boundsValue CGRectValue];
                    }
                }
                
                // Bounds should be a valid rectangle (finite values)
                XCTAssertTrue(isfinite(bounds.origin.x) && isfinite(bounds.origin.y) && 
                             isfinite(bounds.size.width) && isfinite(bounds.size.height),
                             @"%@ bounds should have finite values", className);
            }
        }
    }
}

#pragma mark - Page Index Tests

- (void)testPageIndexProperty {
    // Test page index property across element types
    NSArray *elementClassNames = @[@"TextElement", @"ImageElement"];
    
    for (NSString *className in elementClassNames) {
        Class elementClass = NSClassFromString(className);
        if (elementClass) {
            id element = [[elementClass alloc] init];
            
            if ([element respondsToSelector:@selector(pageIndex)]) {
                NSInteger pageIndex = [[element performSelector:@selector(pageIndex)] integerValue];
                XCTAssertTrue(pageIndex >= 0, @"%@ pageIndex should be non-negative", className);
            }
            
            // Test setting page index if setter exists
            if ([element respondsToSelector:@selector(setPageIndex:)]) {
                NSInteger testPageIndex = 5;
                [element performSelector:@selector(setPageIndex:) withObject:@(testPageIndex)];
                
                if ([element respondsToSelector:@selector(pageIndex)]) {
                    NSInteger retrievedIndex = [[element performSelector:@selector(pageIndex)] integerValue];
                    XCTAssertEqual(retrievedIndex, testPageIndex, 
                                  @"%@ should store and retrieve pageIndex correctly", className);
                }
            }
        }
    }
}

#pragma mark - Memory Management Tests

- (void)testElementMemoryManagement {
    // Test that elements can be created and destroyed without memory issues
    for (int i = 0; i < 100; i++) {
        @autoreleasepool {
            Class textElementClass = NSClassFromString(@"TextElement");
            if (textElementClass) {
                id textElement = [[textElementClass alloc] init];
                
                // Set some properties to test memory handling
                if ([textElement respondsToSelector:@selector(setText:)]) {
                    NSString *testText = [NSString stringWithFormat:@"Test text %d", i];
                    [textElement performSelector:@selector(setText:) withObject:testText];
                }
                
                textElement = nil;
            }
            
            Class imageElementClass = NSClassFromString(@"ImageElement");
            if (imageElementClass) {
                id imageElement = [[imageElementClass alloc] init];
                imageElement = nil;
            }
        }
    }
    
    XCTAssertTrue(YES, @"Memory management test completed without crashes");
}

#pragma mark - Performance Tests

- (void)testElementCreationPerformance {
    [self measureBlock:^{
        for (int i = 0; i < 1000; i++) {
            @autoreleasepool {
                Class textElementClass = NSClassFromString(@"TextElement");
                if (textElementClass) {
                    id textElement = [[textElementClass alloc] init];
                    textElement = nil;
                }
            }
        }
    }];
}

- (void)testMarkdownGenerationPerformance {
    Class textElementClass = NSClassFromString(@"TextElement");
    if (textElementClass) {
        id textElement = [[textElementClass alloc] init];
        
        if ([textElement respondsToSelector:@selector(setText:)]) {
            [textElement performSelector:@selector(setText:) withObject:@"Sample text for performance testing"];
        }
        
        [self measureBlock:^{
            for (int i = 0; i < 1000; i++) {
                if ([textElement respondsToSelector:@selector(markdownRepresentation)]) {
                    [textElement performSelector:@selector(markdownRepresentation)];
                }
            }
        }];
    }
}

@end
</file>

<file path="pdf22md-objc/Tests/Unit/PDF22MDAssetManagerTests.m">
//
//  PDF22MDAssetManagerTests.m
//  pdf22md-objc
//
//  Unit tests for PDF22MDAssetManager image extraction and management
//

#import <XCTest/XCTest.h>
#import "PDF22MDAssetManager.h"
#import "PDF22MDImageElement.h"
#import "PDF22MDError.h"

@interface PDF22MDAssetManagerTests : XCTestCase
@property (nonatomic, strong) PDF22MDAssetManager *assetManager;
@property (nonatomic, strong) NSString *tempAssetsPath;
@end

@implementation PDF22MDAssetManagerTests

- (void)setUp {
    [super setUp];
    
    // Create temporary assets directory
    self.tempAssetsPath = [NSTemporaryDirectory() stringByAppendingPathComponent:@"test-assets"];
    [[NSFileManager defaultManager] createDirectoryAtPath:self.tempAssetsPath 
                              withIntermediateDirectories:YES 
                                               attributes:nil 
                                                    error:nil];
    
    self.assetManager = [[PDF22MDAssetManager alloc] initWithAssetsPath:self.tempAssetsPath];
}

- (void)tearDown {
    // Clean up temporary directory
    [[NSFileManager defaultManager] removeItemAtPath:self.tempAssetsPath error:nil];
    self.assetManager = nil;
    [super tearDown];
}

#pragma mark - Initialization Tests

- (void)testAssetManagerInitialization {
    XCTAssertNotNil(self.assetManager, @"Asset manager should initialize successfully");
}

- (void)testInitializationWithNilPath {
    PDF22MDAssetManager *manager = [[PDF22MDAssetManager alloc] initWithAssetsPath:nil];
    XCTAssertNotNil(manager, @"Asset manager should handle nil assets path");
}

- (void)testAssetsDirectoryCreation {
    NSString *newPath = [NSTemporaryDirectory() stringByAppendingPathComponent:@"new-assets"];
    PDF22MDAssetManager *manager = [[PDF22MDAssetManager alloc] initWithAssetsPath:newPath];
    
    NSError *error = nil;
    BOOL success = [manager ensureAssetsDirectoryExists:&error];
    
    XCTAssertTrue(success, @"Should successfully create assets directory");
    XCTAssertNil(error, @"Should not return error when creating valid directory");
    
    BOOL isDirectory;
    BOOL exists = [[NSFileManager defaultManager] fileExistsAtPath:newPath isDirectory:&isDirectory];
    XCTAssertTrue(exists && isDirectory, @"Assets directory should exist and be a directory");
    
    // Clean up
    [[NSFileManager defaultManager] removeItemAtPath:newPath error:nil];
}

#pragma mark - Image Processing Tests

- (void)testImageElementCreation {
    // Create a simple test image (1x1 pixel)
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, 1, 1, 8, 4, colorSpace, kCGImageAlphaZero);
    CGImageRef cgImage = CGBitmapContextCreateImage(context);
    
    PDF22MDImageElement *element = [[PDF22MDImageElement alloc] initWithImage:cgImage 
                                                                        bounds:CGRectMake(0, 0, 100, 100) 
                                                                    pageNumber:1];
    
    XCTAssertNotNil(element, @"Should create image element successfully");
    XCTAssertEqual(element.pageNumber, 1, @"Page number should be set correctly");
    XCTAssertEqualWithAccuracy(element.bounds.size.width, 100.0, 0.1, @"Width should be set correctly");
    
    // Clean up
    CGImageRelease(cgImage);
    CGContextRelease(context);
    CGColorSpaceRelease(colorSpace);
}

- (void)testImageFormatSelection {
    // Test PNG selection for images with transparency
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, 10, 10, 8, 40, colorSpace, kCGImageAlphaFirst);
    CGImageRef transparentImage = CGBitmapContextCreateImage(context);
    
    NSString *format = [self.assetManager preferredFormatForImage:transparentImage];
    XCTAssertEqualObjects(format, @"png", @"Should prefer PNG for images with transparency");
    
    CGImageRelease(transparentImage);
    CGContextRelease(context);
    CGColorSpaceRelease(colorSpace);
}

- (void)testImageFilenameGeneration {
    NSString *filename1 = [self.assetManager generateFilenameForImageAtIndex:0 withFormat:@"png"];
    NSString *filename2 = [self.assetManager generateFilenameForImageAtIndex:1 withFormat:@"jpg"];
    NSString *filename3 = [self.assetManager generateFilenameForImageAtIndex:99 withFormat:@"png"];
    
    XCTAssertEqualObjects(filename1, @"image_001.png", @"Should generate correct filename for index 0");
    XCTAssertEqualObjects(filename2, @"image_002.jpg", @"Should generate correct filename for index 1");
    XCTAssertEqualObjects(filename3, @"image_100.png", @"Should generate correct filename for index 99");
}

#pragma mark - File Path Tests

- (void)testRelativePathGeneration {
    NSString *filename = @"image_001.png";
    NSString *relativePath = [self.assetManager relativePathForFilename:filename];
    
    NSString *expectedPath = [@"test-assets" stringByAppendingPathComponent:filename];
    XCTAssertEqualObjects(relativePath, expectedPath, @"Should generate correct relative path");
}

- (void)testAbsolutePathGeneration {
    NSString *filename = @"image_001.png";
    NSString *absolutePath = [self.assetManager absolutePathForFilename:filename];
    
    NSString *expectedPath = [self.tempAssetsPath stringByAppendingPathComponent:filename];
    XCTAssertEqualObjects(absolutePath, expectedPath, @"Should generate correct absolute path");
}

#pragma mark - Error Handling Tests

- (void)testInvalidAssetsPathHandling {
    // Try to create assets directory in a location that requires root access
    NSString *invalidPath = @"/usr/bin/invalid-assets";
    PDF22MDAssetManager *manager = [[PDF22MDAssetManager alloc] initWithAssetsPath:invalidPath];
    
    NSError *error = nil;
    BOOL success = [manager ensureAssetsDirectoryExists:&error];
    
    XCTAssertFalse(success, @"Should fail to create directory in invalid location");
    XCTAssertNotNil(error, @"Should return error for invalid directory creation");
    XCTAssertEqual(error.code, PDF22MDErrorAssetFolderCreation, @"Should return appropriate error code");
}

- (void)testNilImageHandling {
    NSString *result = [self.assetManager preferredFormatForImage:NULL];
    XCTAssertEqualObjects(result, @"png", @"Should default to PNG for nil image");
}

#pragma mark - Integration Tests

- (void)testCompleteImageSaveWorkflow {
    // Create a test image
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, 50, 50, 8, 200, colorSpace, kCGImageAlphaZero);
    
    // Draw something simple
    CGContextSetRGBFillColor(context, 1.0, 0.0, 0.0, 1.0);
    CGContextFillRect(context, CGRectMake(0, 0, 50, 50));
    
    CGImageRef testImage = CGBitmapContextCreateImage(context);
    
    // Test the save workflow
    NSError *error = nil;
    BOOL directoryCreated = [self.assetManager ensureAssetsDirectoryExists:&error];
    XCTAssertTrue(directoryCreated, @"Should create assets directory");
    
    NSString *filename = [self.assetManager generateFilenameForImageAtIndex:0 withFormat:@"png"];
    NSString *absolutePath = [self.assetManager absolutePathForFilename:filename];
    
    // Save image (this would normally be done by the asset manager)
    NSData *imageData = (__bridge_transfer NSData *)CGImagePNGRepresentation(testImage);
    BOOL saved = [imageData writeToFile:absolutePath atomically:YES];
    XCTAssertTrue(saved, @"Should save image successfully");
    
    // Verify file exists
    BOOL fileExists = [[NSFileManager defaultManager] fileExistsAtPath:absolutePath];
    XCTAssertTrue(fileExists, @"Saved image file should exist");
    
    // Clean up
    CGImageRelease(testImage);
    CGContextRelease(context);
    CGColorSpaceRelease(colorSpace);
}

#pragma mark - Performance Tests

- (void)testMultipleImageHandling {
    NSMutableArray *images = [NSMutableArray array];
    
    // Create multiple test images
    for (int i = 0; i < 10; i++) {
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        CGContextRef context = CGBitmapContextCreate(NULL, 10, 10, 8, 40, colorSpace, kCGImageAlphaZero);
        CGImageRef image = CGBitmapContextCreateImage(context);
        
        [images addObject:(__bridge id)image];
        
        CGContextRelease(context);
        CGColorSpaceRelease(colorSpace);
    }
    
    NSDate *startTime = [NSDate date];
    
    // Test filename generation for all images
    for (int i = 0; i < images.count; i++) {
        NSString *filename = [self.assetManager generateFilenameForImageAtIndex:i withFormat:@"png"];
        XCTAssertNotNil(filename, @"Should generate filename for image %d", i);
    }
    
    NSTimeInterval elapsed = [[NSDate date] timeIntervalSinceDate:startTime];
    XCTAssertLessThan(elapsed, 1.0, @"Should handle multiple images quickly");
    
    // Clean up images
    for (id image in images) {
        CGImageRelease((__bridge CGImageRef)image);
    }
}

// Helper function for PNG representation (normally would be in asset manager)
CFDataRef CGImagePNGRepresentation(CGImageRef image) {
    CFMutableDataRef data = CFDataCreateMutable(NULL, 0);
    CGImageDestinationRef destination = CGImageDestinationCreateWithData(data, kUTTypePNG, 1, NULL);
    
    if (destination) {
        CGImageDestinationAddImage(destination, image, NULL);
        CGImageDestinationFinalize(destination);
        CFRelease(destination);
    }
    
    return data;
}

@end
</file>

<file path="pdf22md-objc/Tests/Unit/PDF22MDFontAnalyzerTests.m">
//
//  PDF22MDFontAnalyzerTests.m
//  pdf22md-objc
//
//  Unit tests for PDF22MDFontAnalyzer heading detection logic
//

#import <XCTest/XCTest.h>
#import "PDF22MDFontAnalyzer.h"

@interface PDF22MDFontAnalyzerTests : XCTestCase
@property (nonatomic, strong) PDF22MDFontAnalyzer *analyzer;
@end

@implementation PDF22MDFontAnalyzerTests

- (void)setUp {
    [super setUp];
    self.analyzer = [[PDF22MDFontAnalyzer alloc] init];
}

- (void)tearDown {
    self.analyzer = nil;
    [super tearDown];
}

#pragma mark - Initialization Tests

- (void)testAnalyzerInitialization {
    XCTAssertNotNil(self.analyzer, @"Font analyzer should initialize successfully");
}

#pragma mark - Font Size Analysis Tests

- (void)testBasicFontSizeAnalysis {
    // Test the core font size analysis functionality
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    
    // Simulate typical document font usage
    fontSizes[@"12.0"] = @100;  // Body text - most frequent
    fontSizes[@"18.0"] = @5;    // Major heading
    fontSizes[@"16.0"] = @8;    // Minor heading
    fontSizes[@"14.0"] = @12;   // Subheading
    
    [self.analyzer analyzeFontSizes:fontSizes];
    
    // Test heading level assignment
    NSInteger h1Level = [self.analyzer headingLevelForFontSize:18.0];
    NSInteger h2Level = [self.analyzer headingLevelForFontSize:16.0];
    NSInteger h3Level = [self.analyzer headingLevelForFontSize:14.0];
    NSInteger bodyLevel = [self.analyzer headingLevelForFontSize:12.0];
    
    XCTAssertEqual(h1Level, 1, @"Largest non-body font should be H1");
    XCTAssertEqual(h2Level, 2, @"Second largest font should be H2");
    XCTAssertEqual(h3Level, 3, @"Third largest font should be H3");
    XCTAssertEqual(bodyLevel, 0, @"Most frequent font should be body text (level 0)");
}

- (void)testSingleFontSizeDocument {
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    fontSizes[@"12.0"] = @100;  // Only one font size
    
    [self.analyzer analyzeFontSizes:fontSizes];
    
    NSInteger level = [self.analyzer headingLevelForFontSize:12.0];
    XCTAssertEqual(level, 0, @"Single font size should be treated as body text");
}

- (void)testEmptyFontAnalysis {
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    
    [self.analyzer analyzeFontSizes:fontSizes];
    
    NSInteger level = [self.analyzer headingLevelForFontSize:12.0];
    XCTAssertEqual(level, 0, @"Unknown font size should default to body text");
}

#pragma mark - Edge Case Tests

- (void)testVerySmallFontSizes {
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    fontSizes[@"8.0"] = @50;    // Small body text
    fontSizes[@"10.0"] = @5;    // Slightly larger
    
    [self.analyzer analyzeFontSizes:fontSizes];
    
    NSInteger smallLevel = [self.analyzer headingLevelForFontSize:8.0];
    NSInteger largerLevel = [self.analyzer headingLevelForFontSize:10.0];
    
    XCTAssertEqual(smallLevel, 0, @"Most frequent small font should be body text");
    XCTAssertEqual(largerLevel, 1, @"Less frequent larger font should be heading");
}

- (void)testVeryLargeFontSizes {
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    fontSizes[@"12.0"] = @100;  // Body text
    fontSizes[@"72.0"] = @1;    // Very large title
    fontSizes[@"48.0"] = @2;    // Large heading
    fontSizes[@"36.0"] = @3;    // Medium heading
    
    [self.analyzer analyzeFontSizes:fontSizes];
    
    NSInteger titleLevel = [self.analyzer headingLevelForFontSize:72.0];
    NSInteger h1Level = [self.analyzer headingLevelForFontSize:48.0];
    NSInteger h2Level = [self.analyzer headingLevelForFontSize:36.0];
    
    XCTAssertEqual(titleLevel, 1, @"Largest font should be H1");
    XCTAssertEqual(h1Level, 2, @"Second largest should be H2");
    XCTAssertEqual(h2Level, 3, @"Third largest should be H3");
}

#pragma mark - Frequency Analysis Tests

- (void)testFrequencyBasedBodyTextDetection {
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    fontSizes[@"12.0"] = @200;  // Very frequent - clearly body text
    fontSizes[@"14.0"] = @150;  // Also frequent - might be body text too
    fontSizes[@"18.0"] = @5;    // Infrequent - heading
    
    [self.analyzer analyzeFontSizes:fontSizes];
    
    NSInteger mostFrequentLevel = [self.analyzer headingLevelForFontSize:12.0];
    NSInteger secondFrequentLevel = [self.analyzer headingLevelForFontSize:14.0];
    NSInteger infrequentLevel = [self.analyzer headingLevelForFontSize:18.0];
    
    XCTAssertEqual(mostFrequentLevel, 0, @"Most frequent font should be body text");
    // The second most frequent could be body or heading depending on algorithm
    XCTAssertTrue(infrequentLevel > 0, @"Infrequent large font should be a heading");
}

#pragma mark - Heading Level Limits Tests

- (void)testMaximumHeadingLevels {
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    fontSizes[@"12.0"] = @100;  // Body
    
    // Add many different heading sizes
    for (int i = 1; i <= 10; i++) {
        fontSizes[[NSString stringWithFormat:@"%.1f", 12.0 + i * 2]] = @(10 - i);
    }
    
    [self.analyzer analyzeFontSizes:fontSizes];
    
    // Check that we don't exceed H6 (level 6)
    NSInteger maxLevel = 0;
    for (NSString *sizeStr in fontSizes.allKeys) {
        CGFloat size = [sizeStr floatValue];
        NSInteger level = [self.analyzer headingLevelForFontSize:size];
        if (level > maxLevel) {
            maxLevel = level;
        }
    }
    
    XCTAssertLessThanOrEqual(maxLevel, 6, @"Should not exceed H6 (level 6)");
}

#pragma mark - Performance Tests

- (void)testLargeFontSetPerformance {
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    
    // Create a large set of font sizes to test performance
    for (int i = 8; i <= 72; i++) {
        fontSizes[[NSString stringWithFormat:@"%.1f", (CGFloat)i]] = @(arc4random() % 100 + 1);
    }
    
    NSDate *startTime = [NSDate date];
    [self.analyzer analyzeFontSizes:fontSizes];
    NSTimeInterval elapsed = [[NSDate date] timeIntervalSinceDate:startTime];
    
    XCTAssertLessThan(elapsed, 1.0, @"Font analysis should complete within 1 second for large font set");
}

#pragma mark - Algorithm Consistency Tests

- (void)testConsistentResults {
    NSMutableDictionary *fontSizes = [NSMutableDictionary dictionary];
    fontSizes[@"12.0"] = @100;
    fontSizes[@"16.0"] = @10;
    fontSizes[@"20.0"] = @5;
    
    // Run analysis multiple times
    [self.analyzer analyzeFontSizes:fontSizes];
    NSInteger firstRun16 = [self.analyzer headingLevelForFontSize:16.0];
    NSInteger firstRun20 = [self.analyzer headingLevelForFontSize:20.0];
    
    [self.analyzer analyzeFontSizes:fontSizes];
    NSInteger secondRun16 = [self.analyzer headingLevelForFontSize:16.0];
    NSInteger secondRun20 = [self.analyzer headingLevelForFontSize:20.0];
    
    XCTAssertEqual(firstRun16, secondRun16, @"Font analysis should be consistent across runs");
    XCTAssertEqual(firstRun20, secondRun20, @"Font analysis should be consistent across runs");
}

@end
</file>

<file path="pdf22md-objc/Tests/Unit/PDFMarkdownConverterTests.m">
//
//  PDFMarkdownConverterTests.m
//  pdf22md
//
//  Unit tests for core PDF to Markdown conversion functionality
//

#import <XCTest/XCTest.h>
#import "../../src/PDFMarkdownConverter.h"
#import "../../src/AssetExtractor.h"
#import "../../src/ContentElement.h"

@interface PDFMarkdownConverterTests : XCTestCase
@property (nonatomic, strong) PDFMarkdownConverter *converter;
@property (nonatomic, strong) NSString *testResourcesPath;
@end

@implementation PDFMarkdownConverterTests

- (void)setUp {
    [super setUp];
    self.converter = [[PDFMarkdownConverter alloc] init];
    
    // Set up test resources path
    NSBundle *testBundle = [NSBundle bundleForClass:[self class]];
    self.testResourcesPath = [testBundle.bundlePath stringByAppendingPathComponent:@"Resources"];
    
    // Ensure test resources directory exists
    NSFileManager *fileManager = [NSFileManager defaultManager];
    if (![fileManager fileExistsAtPath:self.testResourcesPath]) {
        [fileManager createDirectoryAtPath:self.testResourcesPath 
               withIntermediateDirectories:YES 
                                attributes:nil 
                                     error:nil];
    }
}

- (void)tearDown {
    self.converter = nil;
    self.testResourcesPath = nil;
    [super tearDown];
}

#pragma mark - Basic Functionality Tests

- (void)testConverterInitialization {
    XCTAssertNotNil(self.converter, @"PDFMarkdownConverter should initialize successfully");
}

- (void)testInvalidPDFHandling {
    // Test with nil input
    NSString *result = [self.converter convertPDFAtPath:nil 
                                          assetsFolderPath:nil 
                                                       dpi:144];
    XCTAssertNil(result, @"Converter should return nil for nil input path");
    
    // Test with non-existent file
    NSString *nonExistentPath = @"/path/that/does/not/exist.pdf";
    result = [self.converter convertPDFAtPath:nonExistentPath 
                               assetsFolderPath:nil 
                                            dpi:144];
    XCTAssertNil(result, @"Converter should return nil for non-existent file");
}

- (void)testEmptyStringHandling {
    // Test with empty string
    NSString *result = [self.converter convertPDFAtPath:@"" 
                                          assetsFolderPath:nil 
                                                       dpi:144];
    XCTAssertNil(result, @"Converter should return nil for empty string path");
}

- (void)testDPIParameterValidation {
    // Create a minimal test PDF path (we'll use an existing test file)
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"simple-test.pdf"];
    
    // Test with invalid DPI values
    NSString *result = [self.converter convertPDFAtPath:testPDFPath 
                                          assetsFolderPath:nil 
                                                       dpi:0];
    // Should still work with fallback DPI or return error gracefully
    // The exact behavior depends on implementation, but should not crash
    
    result = [self.converter convertPDFAtPath:testPDFPath 
                               assetsFolderPath:nil 
                                            dpi:-144];
    // Should handle negative DPI gracefully
}

#pragma mark - Asset Folder Tests

- (void)testAssetFolderCreation {
    NSString *tempDir = NSTemporaryDirectory();
    NSString *testAssetsFolder = [tempDir stringByAppendingPathComponent:@"test-assets"];
    
    // Clean up any existing test folder
    NSFileManager *fileManager = [NSFileManager defaultManager];
    [fileManager removeItemAtPath:testAssetsFolder error:nil];
    
    // Verify folder doesn't exist initially
    XCTAssertFalse([fileManager fileExistsAtPath:testAssetsFolder], 
                   @"Test assets folder should not exist initially");
    
    // Test folder creation during conversion (with a valid PDF)
    // For now, just test that the method accepts the parameter
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"simple-test.pdf"];
    [self.converter convertPDFAtPath:testPDFPath 
                      assetsFolderPath:testAssetsFolder 
                                   dpi:144];
    
    // Clean up
    [fileManager removeItemAtPath:testAssetsFolder error:nil];
}

#pragma mark - Memory Management Tests

- (void)testMemoryManagement {
    // Test that converter handles multiple conversions without memory issues
    for (int i = 0; i < 10; i++) {
        @autoreleasepool {
            PDFMarkdownConverter *tempConverter = [[PDFMarkdownConverter alloc] init];
            
            // Test with nil path to avoid actual file I/O
            NSString *result = [tempConverter convertPDFAtPath:nil 
                                               assetsFolderPath:nil 
                                                            dpi:144];
            XCTAssertNil(result, @"Should handle nil input gracefully");
            
            tempConverter = nil;
        }
    }
}

#pragma mark - Performance Tests

- (void)testPerformanceBaseline {
    // Simple performance test to establish baseline
    [self measureBlock:^{
        // Test basic object creation and method call
        PDFMarkdownConverter *converter = [[PDFMarkdownConverter alloc] init];
        [converter convertPDFAtPath:nil assetsFolderPath:nil dpi:144];
    }];
}

#pragma mark - Error Handling Tests

- (void)testErrorConditions {
    // Test various error conditions that should be handled gracefully
    NSArray *invalidPaths = @[
        @"",
        @"not-a-pdf.txt",
        @"/dev/null",
        @"~/nonexistent/path/file.pdf"
    ];
    
    for (NSString *invalidPath in invalidPaths) {
        NSString *result = [self.converter convertPDFAtPath:invalidPath 
                                            assetsFolderPath:nil 
                                                         dpi:144];
        XCTAssertNil(result, @"Should handle invalid path gracefully: %@", invalidPath);
    }
}

#pragma mark - Integration Points Tests

- (void)testAssetExtractorIntegration {
    // Test that converter properly integrates with AssetExtractor
    // This is a basic smoke test for the integration
    AssetExtractor *extractor = [[AssetExtractor alloc] init];
    XCTAssertNotNil(extractor, @"AssetExtractor should initialize for integration testing");
}

- (void)testContentElementIntegration {
    // Test that converter properly works with ContentElement classes
    // This verifies the model layer integration
    XCTAssertTrue([NSClassFromString(@"ContentElement") conformsToProtocol:@protocol(NSObject)], 
                  @"ContentElement should be available for integration");
}

@end
</file>

<file path="pdf22md-objc/Tests/Unit/SimpleConverterTest.m">
//
//  SimpleConverterTest.m
//  pdf22md-objc
//
//  Simple test without XCTest framework dependency
//

#import <Foundation/Foundation.h>
#import "Core/PDF22MDConverter.h"
#import "Core/PDF22MDConversionOptions.h"
#import "Core/PDF22MDError.h"

// Simple assertion macro for non-XCTest testing
#define ASSERT(condition, message) \
    if (!(condition)) { \
        printf("❌ ASSERT FAILED: %s - %s\n", #condition, message); \
        return 1; \
    } else { \
        printf("✅ ASSERT PASSED: %s\n", #condition); \
    }

int main(int argc, char *argv[]) {
    @autoreleasepool {
        printf("🧪 Running Simple Converter Tests\n");
        printf("==================================\n");
        
        // Test 1: Options initialization
        PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
        ASSERT(options != nil, "Options should initialize successfully");
        ASSERT(options.rasterizationDPI == 144.0, "Default DPI should be 144");
        
        // Test 2: Default options creation
        PDF22MDConversionOptions *defaultOptions = [PDF22MDConversionOptions defaultOptions];
        ASSERT(defaultOptions != nil, "Default options should initialize successfully");
        
        // Test 3: Error handling for nil URL
        PDF22MDConverter *converter = [[PDF22MDConverter alloc] initWithPDFURL:nil];
        ASSERT(converter == nil, "Should return nil for nil URL");
        
        // Test 4: Error handling for non-existent file  
        NSURL *nonExistentURL = [NSURL fileURLWithPath:@"/nonexistent/file.pdf"];
        converter = [[PDF22MDConverter alloc] initWithPDFURL:nonExistentURL];
        ASSERT(converter == nil, "Should return nil for non-existent file");
        
        // Test 5: Error helper methods
        NSError *testError = [PDF22MDErrorHelper invalidPDFError];
        ASSERT(testError != nil, "Error helper should create error");
        ASSERT(testError.localizedDescription != nil, "Error should have localized description");
        ASSERT(testError.localizedDescription.length > 0, "Error description should not be empty");
        
        // Test 6: File not found error
        NSError *fileError = [PDF22MDErrorHelper fileNotFoundErrorWithPath:@"/test/path"];
        ASSERT(fileError != nil, "Should create file not found error");
        ASSERT(fileError.code == PDF22MDErrorFileNotFound, "Should have correct error code");
        
        printf("\n🎉 All simple tests passed!\n");
        return 0;
    }
}
</file>

<file path="pdf22md-swift/Tests/PDF22MDTests/PDF22MDTests.swift">
import XCTest
@testable import PDF22MD

final class PDF22MDTests: XCTestCase {
    
    // MARK: - TextElement Tests
    
    func testTextElementCreation() {
        let element = TextElement(
            text: "Hello, World!",
            bounds: CGRect(x: 0, y: 0, width: 100, height: 20),
            pageIndex: 0
        )
        
        XCTAssertEqual(element.text, "Hello, World!")
        XCTAssertEqual(element.pageIndex, 0)
        XCTAssertEqual(element.headingLevel, 0)
        XCTAssertFalse(element.isBold)
        XCTAssertFalse(element.isItalic)
    }
    
    func testTextElementMarkdownGeneration() {
        // Test regular text
        let regularText = TextElement(
            text: "Regular paragraph text",
            bounds: CGRect.zero,
            pageIndex: 0
        )
        XCTAssertEqual(regularText.markdownRepresentation(), "Regular paragraph text")
        
        // Test heading
        var heading = TextElement(
            text: "Chapter Title",
            bounds: CGRect.zero,
            pageIndex: 0
        )
        heading.headingLevel = 1
        XCTAssertEqual(heading.markdownRepresentation(), "# Chapter Title")
        
        // Test bold text
        let boldText = TextElement(
            text: "Bold text",
            bounds: CGRect.zero,
            pageIndex: 0,
            fontName: "Arial-Bold",
            fontSize: 12.0,
            isBold: true,
            isItalic: false
        )
        XCTAssertEqual(boldText.markdownRepresentation(), "**Bold text**")
        
        // Test italic text
        let italicText = TextElement(
            text: "Italic text",
            bounds: CGRect.zero,
            pageIndex: 0,
            fontName: "Arial-Italic",
            fontSize: 12.0,
            isBold: false,
            isItalic: true
        )
        XCTAssertEqual(italicText.markdownRepresentation(), "*Italic text*")
        
        // Test bold italic text
        let boldItalicText = TextElement(
            text: "Bold italic text",
            bounds: CGRect.zero,
            pageIndex: 0,
            fontName: "Arial-BoldItalic",
            fontSize: 12.0,
            isBold: true,
            isItalic: true
        )
        XCTAssertEqual(boldItalicText.markdownRepresentation(), "***Bold italic text***")
    }
    
    func testTextElementEquality() {
        let element1 = TextElement(
            text: "Test text",
            bounds: CGRect(x: 0, y: 0, width: 100, height: 20),
            pageIndex: 0
        )
        
        let element2 = TextElement(
            text: "Test text",
            bounds: CGRect(x: 0, y: 0, width: 100, height: 20),
            pageIndex: 0
        )
        
        XCTAssertEqual(element1, element2)
    }
    
    // MARK: - ConversionOptions Tests
    
    func testConversionOptionsDefaults() {
        let options = ConversionOptions()
        
        XCTAssertNil(options.assetsFolderPath)
        XCTAssertEqual(options.rasterizationDPI, 144.0)
        XCTAssertTrue(options.includeMetadata)
        XCTAssertTrue(options.extractImages)
        XCTAssertTrue(options.preserveOutline)
        XCTAssertEqual(options.headingFontSizeThreshold, 2.0)
        XCTAssertEqual(options.maxHeadingLevel, 6)
    }
    
    func testConversionOptionsValidation() {
        var options = ConversionOptions()
        
        // Valid options should not throw
        XCTAssertNoThrow(try options.validate())
        
        // Invalid DPI should throw
        options.rasterizationDPI = -1
        XCTAssertThrowsError(try options.validate()) { error in
            XCTAssertTrue(error is PDFError)
            if case .invalidConfiguration = error as! PDFError {
                // Expected error type
            } else {
                XCTFail("Expected invalidConfiguration error")
            }
        }
        
        // Reset to valid value
        options.rasterizationDPI = 144.0
        
        // Invalid max heading level should throw
        options.maxHeadingLevel = 0
        XCTAssertThrowsError(try options.validate())
        
        options.maxHeadingLevel = 7
        XCTAssertThrowsError(try options.validate())
    }
    
    func testConversionOptionsBuilder() {
        let options = ConversionOptionsBuilder()
            .assetsFolderPath("/tmp/assets")
            .rasterizationDPI(300.0)
            .includeMetadata(false)
            .extractImages(true)
            .maxHeadingLevel(3)
            .build()
        
        XCTAssertEqual(options.assetsFolderPath, "/tmp/assets")
        XCTAssertEqual(options.rasterizationDPI, 300.0)
        XCTAssertFalse(options.includeMetadata)
        XCTAssertTrue(options.extractImages)
        XCTAssertEqual(options.maxHeadingLevel, 3)
    }
    
    // MARK: - FontAnalyzer Tests
    
    func testFontKeyGeneration() {
        let key1 = FontAnalyzer.fontKey(forFontName: "Arial", fontSize: 12.0)
        let key2 = FontAnalyzer.fontKey(forFontName: "Arial", fontSize: 12.0)
        let key3 = FontAnalyzer.fontKey(forFontName: "Arial", fontSize: 14.0)
        let key4 = FontAnalyzer.fontKey(forFontName: nil, fontSize: 12.0)
        
        XCTAssertEqual(key1, key2)
        XCTAssertNotEqual(key1, key3)
        XCTAssertEqual(key4, "12.0-Unknown")
    }
    
    func testFontAnalyzerBasicFunctionality() {
        let analyzer = FontAnalyzer()
        
        let elements: [ContentElement] = [
            TextElement(
                text: "Body text",
                bounds: CGRect.zero,
                pageIndex: 0,
                fontName: "Arial",
                fontSize: 12.0,
                isBold: false,
                isItalic: false
            ),
            TextElement(
                text: "Heading",
                bounds: CGRect.zero,
                pageIndex: 0,
                fontName: "Arial-Bold",
                fontSize: 18.0,
                isBold: true,
                isItalic: false
            )
        ]
        
        analyzer.analyzeElements(elements)
        let stats = analyzer.getSortedFontStatistics()
        
        XCTAssertEqual(stats.count, 2)
        // Should be sorted by font size (largest first)
        XCTAssertEqual(stats[0].fontSize, 18.0)
        XCTAssertEqual(stats[1].fontSize, 12.0)
    }
    
    // MARK: - PDFError Tests
    
    func testPDFErrorMessages() {
        let invalidPDFError = PDFError.invalidPDF(reason: "Corrupted file")
        XCTAssertEqual(invalidPDFError.errorDescription, "Invalid or corrupted PDF file: Corrupted file")
        
        let assetError = PDFError.assetCreationFailed(path: "/tmp/test", reason: "No permission")
        XCTAssertEqual(assetError.errorDescription, "Failed to create or save asset at /tmp/test: No permission")
        
        let pageError = PDFError.pageProcessingFailed(page: 5, reason: "Malformed content")
        XCTAssertEqual(pageError.errorDescription, "Failed to process page 6: Malformed content")
        
        let cancelledError = PDFError.cancelled
        XCTAssertEqual(cancelledError.errorDescription, "Operation was cancelled")
    }
    
    // MARK: - MarkdownGenerator Tests
    
    func testMarkdownGeneratorBasic() {
        let options = ConversionOptions()
        let generator = MarkdownGenerator(options: options)
        
        let elements: [ContentElement] = [
            TextElement(text: "First paragraph", bounds: CGRect.zero, pageIndex: 0),
            TextElement(text: "Second paragraph", bounds: CGRect.zero, pageIndex: 0)
        ]
        
        let markdown = generator.generateMarkdownContent(from: elements)
        XCTAssertTrue(markdown.contains("First paragraph"))
        XCTAssertTrue(markdown.contains("Second paragraph"))
    }
    
    func testYAMLEscaping() {
        let options = ConversionOptions()
        let generator = MarkdownGenerator(options: options)
        
        // Test string escaping
        let testString = "Test \"quotes\" and\nnewlines"
        let escaped = generator.generateYAMLFrontmatter(DocumentMetadata(pageCount: 1))
        
        // Basic YAML structure should be present
        XCTAssertTrue(escaped?.contains("---") == true)
        XCTAssertTrue(escaped?.contains("pdf_metadata:") == true)
        XCTAssertTrue(escaped?.contains("page_count: 1") == true)
    }
    
    // MARK: - Performance Tests
    
    func testTextElementPerformance() {
        measure {
            for i in 0..<1000 {
                let element = TextElement(
                    text: "Performance test text \(i)",
                    bounds: CGRect(x: 0, y: CGFloat(i), width: 100, height: 20),
                    pageIndex: i % 10
                )
                _ = element.markdownRepresentation()
            }
        }
    }
    
    func testFontAnalyzerPerformance() {
        let analyzer = FontAnalyzer()
        let elements = (0..<1000).map { i in
            TextElement(
                text: "Text \(i)",
                bounds: CGRect.zero,
                pageIndex: 0,
                fontName: "Arial",
                fontSize: CGFloat(12 + (i % 6)),
                isBold: i % 2 == 0,
                isItalic: i % 3 == 0
            )
        }
        
        measure {
            analyzer.analyzeElements(elements)
            _ = analyzer.getSortedFontStatistics()
        }
    }
}
</file>

<file path="pdf22md-swift/Package.swift">
// swift-tools-version: 5.7
// The swift-tools-version declares the minimum version of Swift required to build this package.

import PackageDescription

let package = Package(
    name: "pdf22md",
    platforms: [
        .macOS(.v12) // Required for async/await
    ],
    products: [
        // Library product for programmatic usage
        .library(
            name: "PDF22MD",
            targets: ["PDF22MD"]
        ),
        // Executable product for CLI
        .executable(
            name: "pdf22md",
            targets: ["pdf22md"]
        )
    ],
    dependencies: [
        // Swift Argument Parser for CLI
        .package(url: "https://github.com/apple/swift-argument-parser", from: "1.2.0")
    ],
    targets: [
        // Main library target
        .target(
            name: "PDF22MD",
            dependencies: [],
            swiftSettings: [
                .define("VERSION", to: "\"1.0.0\"")
            ]
        ),
        // CLI executable target
        .executableTarget(
            name: "pdf22md",
            dependencies: [
                "PDF22MD",
                .product(name: "ArgumentParser", package: "swift-argument-parser")
            ]
        ),
        // Test target
        .testTarget(
            name: "PDF22MDTests",
            dependencies: ["PDF22MD"],
            resources: [
                .process("Resources")
            ]
        )
    ]
)
</file>

<file path="shared/Algorithms/PDF22MDImageFormatDetection.h">
//
//  PDF22MDImageFormatDetection.h
//  pdf22md - Shared Components
//
//  Shared utility for determining optimal image format (JPEG vs PNG)
//  based on image characteristics and source type.
//

#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

/**
 * Shared utility class for image format detection and optimization.
 * Determines whether to use JPEG or PNG format based on image characteristics.
 */
@interface PDF22MDImageFormatDetection : NSObject

/**
 * Determines whether JPEG format should be used for an image.
 * 
 * @param image The CGImageRef to analyze
 * @param isVectorSource Whether the image originates from a vector source
 * @return YES if JPEG is recommended, NO if PNG is recommended
 */
+ (BOOL)shouldUseJPEGForImage:(CGImageRef)image 
               isVectorSource:(BOOL)isVectorSource;

/**
 * Estimates the number of unique colors in an image through sampling.
 * Used to determine color complexity for format selection.
 * 
 * @param image The CGImageRef to analyze
 * @return Estimated number of unique colors (capped at practical limits)
 */
+ (NSUInteger)estimateUniqueColorCountForImage:(CGImageRef)image;

/**
 * Returns the recommended file extension for an image.
 * 
 * @param image The CGImageRef to analyze
 * @param isVectorSource Whether the image originates from a vector source
 * @return "jpg" or "png" based on analysis
 */
+ (NSString *)recommendedExtensionForImage:(CGImageRef)image 
                            isVectorSource:(BOOL)isVectorSource;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="shared/Algorithms/PDF22MDImageFormatDetection.m">
//
//  PDF22MDImageFormatDetection.m
//  pdf22md - Shared Components
//
//  Shared utility for determining optimal image format (JPEG vs PNG)
//  based on image characteristics and source type.
//

#import "PDF22MDImageFormatDetection.h"

@implementation PDF22MDImageFormatDetection

+ (BOOL)shouldUseJPEGForImage:(CGImageRef)image 
               isVectorSource:(BOOL)isVectorSource {
    if (!image) {
        return NO;
    }
    
    // Get image properties
    size_t width = CGImageGetWidth(image);
    size_t height = CGImageGetHeight(image);
    CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(image);
    
    // If image has alpha channel, use PNG
    if (alphaInfo != kCGImageAlphaNone &&
        alphaInfo != kCGImageAlphaNoneSkipFirst &&
        alphaInfo != kCGImageAlphaNoneSkipLast) {
        return NO;
    }
    
    // For small images, use PNG
    if (width * height < 10000) { // Less than 100x100
        return NO;
    }
    
    // For vector sources, prefer PNG to maintain quality
    if (isVectorSource) {
        return NO;
    }
    
    // Analyze color complexity
    NSUInteger uniqueColors = [self estimateUniqueColorCountForImage:image];
    
    // If we have many unique colors, it's likely a photograph - use JPEG
    return uniqueColors > 256;
}

+ (NSUInteger)estimateUniqueColorCountForImage:(CGImageRef)image {
    if (!image) {
        return 0;
    }
    
    size_t width = CGImageGetWidth(image);
    size_t height = CGImageGetHeight(image);
    
    // Don't analyze extremely large images - assume they're complex
    if (width * height > 4000000) { // Larger than ~2000x2000
        return 10000; // Assume high complexity
    }
    
    // Create a bitmap context for pixel analysis
    uint32_t *pixelData = malloc(sizeof(uint32_t));
    if (!pixelData) {
        return 0;
    }
    
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(pixelData, 1, 1, 8, 4,
                                               colorSpace,
                                               kCGImageAlphaPremultipliedLast |
                                               kCGBitmapByteOrder32Big);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        free(pixelData);
        return 0;
    }
    
    // Sample the image at regular intervals
    size_t stepX = MAX(1, width / 100);   // Sample ~100 points horizontally
    size_t stepY = MAX(1, height / 100);  // Sample ~100 points vertically
    
    // Count unique colors by sampling
    NSMutableSet *uniqueColors = [NSMutableSet set];
    
    for (size_t y = 0; y < height; y += stepY) {
        for (size_t x = 0; x < width; x += stepX) {
            // Draw a single pixel
            CGContextClearRect(context, CGRectMake(0, 0, 1, 1));
            CGContextDrawImage(context, CGRectMake(-x, -y, width, height), image);
            
            uint32_t color = pixelData[0];
            [uniqueColors addObject:@(color)];
            
            // Early exit if we already have many colors
            if (uniqueColors.count > 1000) {
                break;
            }
        }
        
        if (uniqueColors.count > 1000) {
            break;
        }
    }
    
    CGContextRelease(context);
    free(pixelData);
    
    return uniqueColors.count;
}

+ (NSString *)recommendedExtensionForImage:(CGImageRef)image 
                            isVectorSource:(BOOL)isVectorSource {
    return [self shouldUseJPEGForImage:image isVectorSource:isVectorSource] ? @"jpg" : @"png";
}

@end
</file>

<file path="shared/Core/PDF22MDConcurrencyManager.h">
//
//  PDF22MDConcurrencyManager.h
//  pdf22md - Shared Components
//
//  Standardized concurrency patterns and queue management
//  for consistent GCD usage across all implementations.
//

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

/**
 * Standardized concurrency manager providing unified GCD patterns
 * and queue management across all PDF22MD implementations.
 */
@interface PDF22MDConcurrencyManager : NSObject

#pragma mark - Shared Queue Access

/**
 * Shared concurrent queue for CPU-intensive operations.
 * Optimized for parallel processing tasks like page conversion.
 */
+ (dispatch_queue_t)sharedConcurrentQueue;

/**
 * Shared serial queue for file system operations.
 * Ensures thread-safe file access and prevents race conditions.
 */
+ (dispatch_queue_t)sharedFileAccessQueue;

/**
 * Shared serial queue for converter operations.
 * Manages conversion workflow and state consistency.
 */
+ (dispatch_queue_t)sharedConverterQueue;

/**
 * Shared global queue for background processing.
 * Standard system queue for general background tasks.
 */
+ (dispatch_queue_t)sharedBackgroundQueue;

#pragma mark - Concurrency Utilities

/**
 * Creates a dispatch group for coordinating multiple operations.
 */
+ (dispatch_group_t)createProcessingGroup;

/**
 * Creates a semaphore with specified concurrent operation limit.
 */
+ (dispatch_semaphore_t)createConcurrencySemaphoreWithLimit:(NSInteger)limit;

/**
 * Executes operation on concurrent queue with completion on main queue.
 */
+ (void)performConcurrentOperation:(void(^)(void))operation
                        completion:(nullable void(^)(void))completion;

/**
 * Executes operation on serial file access queue.
 */
+ (void)performFileOperation:(void(^)(void))operation
                  completion:(nullable void(^)(void))completion;

/**
 * Executes operation on converter queue.
 */
+ (void)performConverterOperation:(void(^)(void))operation
                       completion:(nullable void(^)(void))completion;

#pragma mark - Parallel Processing Patterns

/**
 * Processes array items in parallel with concurrency limit.
 * Uses dispatch groups and semaphores for optimal performance.
 */
+ (void)processItemsInParallel:(NSArray *)items
               concurrencyLimit:(NSInteger)limit
                      processor:(void(^)(id item, NSInteger index))processor
                     completion:(void(^)(void))completion;

/**
 * Processes array items in parallel with progress reporting.
 */
+ (void)processItemsInParallel:(NSArray *)items
               concurrencyLimit:(NSInteger)limit
                      processor:(void(^)(id item, NSInteger index))processor
                progressHandler:(nullable void(^)(NSInteger completedCount, NSInteger totalCount))progressHandler
                     completion:(void(^)(void))completion;

#pragma mark - Synchronization Utilities

/**
 * Waits for dispatch group with timeout.
 * Returns YES if completed within timeout, NO if timed out.
 */
+ (BOOL)waitForGroup:(dispatch_group_t)group
             timeout:(NSTimeInterval)timeoutSeconds;

/**
 * Waits for semaphore with timeout.
 * Returns YES if acquired within timeout, NO if timed out.
 */
+ (BOOL)waitForSemaphore:(dispatch_semaphore_t)semaphore
                 timeout:(NSTimeInterval)timeoutSeconds;

/**
 * Executes block on main queue, handling both main and background thread calls.
 */
+ (void)executeOnMainQueue:(void(^)(void))block;

/**
 * Executes block on main queue synchronously if on background thread,
 * immediately if already on main thread.
 */
+ (void)executeOnMainQueueSync:(void(^)(void))block;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="shared/Core/PDF22MDConcurrencyManager.m">
//
//  PDF22MDConcurrencyManager.m
//  pdf22md - Shared Components
//
//  Standardized concurrency patterns and queue management
//  for consistent GCD usage across all implementations.
//

#import "PDF22MDConcurrencyManager.h"

@implementation PDF22MDConcurrencyManager

#pragma mark - Shared Queue Access

+ (dispatch_queue_t)sharedConcurrentQueue {
    static dispatch_queue_t sharedQueue;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        sharedQueue = dispatch_queue_create("com.twardoch.pdf22md.concurrent", 
                                          DISPATCH_QUEUE_CONCURRENT);
    });
    return sharedQueue;
}

+ (dispatch_queue_t)sharedFileAccessQueue {
    static dispatch_queue_t sharedQueue;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        sharedQueue = dispatch_queue_create("com.twardoch.pdf22md.fileaccess", 
                                          DISPATCH_QUEUE_SERIAL);
    });
    return sharedQueue;
}

+ (dispatch_queue_t)sharedConverterQueue {
    static dispatch_queue_t sharedQueue;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        sharedQueue = dispatch_queue_create("com.twardoch.pdf22md.converter", 
                                          DISPATCH_QUEUE_SERIAL);
    });
    return sharedQueue;
}

+ (dispatch_queue_t)sharedBackgroundQueue {
    return dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
}

#pragma mark - Concurrency Utilities

+ (dispatch_group_t)createProcessingGroup {
    return dispatch_group_create();
}

+ (dispatch_semaphore_t)createConcurrencySemaphoreWithLimit:(NSInteger)limit {
    return dispatch_semaphore_create(limit);
}

+ (void)performConcurrentOperation:(void(^)(void))operation
                        completion:(nullable void(^)(void))completion {
    dispatch_async([self sharedConcurrentQueue], ^{
        operation();
        
        if (completion) {
            [self executeOnMainQueue:completion];
        }
    });
}

+ (void)performFileOperation:(void(^)(void))operation
                  completion:(nullable void(^)(void))completion {
    dispatch_async([self sharedFileAccessQueue], ^{
        operation();
        
        if (completion) {
            [self executeOnMainQueue:completion];
        }
    });
}

+ (void)performConverterOperation:(void(^)(void))operation
                       completion:(nullable void(^)(void))completion {
    dispatch_async([self sharedConverterQueue], ^{
        operation();
        
        if (completion) {
            [self executeOnMainQueue:completion];
        }
    });
}

#pragma mark - Parallel Processing Patterns

+ (void)processItemsInParallel:(NSArray *)items
               concurrencyLimit:(NSInteger)limit
                      processor:(void(^)(id item, NSInteger index))processor
                     completion:(void(^)(void))completion {
    [self processItemsInParallel:items
                 concurrencyLimit:limit
                        processor:processor
                  progressHandler:nil
                       completion:completion];
}

+ (void)processItemsInParallel:(NSArray *)items
               concurrencyLimit:(NSInteger)limit
                      processor:(void(^)(id item, NSInteger index))processor
                progressHandler:(nullable void(^)(NSInteger completedCount, NSInteger totalCount))progressHandler
                     completion:(void(^)(void))completion {
    if (items.count == 0) {
        [self executeOnMainQueue:completion];
        return;
    }
    
    dispatch_group_t processingGroup = [self createProcessingGroup];
    dispatch_semaphore_t concurrencySemaphore = [self createConcurrencySemaphoreWithLimit:limit];
    
    __block NSInteger completedCount = 0;
    NSInteger totalCount = items.count;
    
    for (NSInteger i = 0; i < totalCount; i++) {
        id item = items[i];
        
        dispatch_group_async(processingGroup, [self sharedBackgroundQueue], ^{
            dispatch_semaphore_wait(concurrencySemaphore, DISPATCH_TIME_FOREVER);
            
            processor(item, i);
            
            // Update progress if handler provided
            if (progressHandler) {
                @synchronized(self) {
                    completedCount++;
                    NSInteger currentCompleted = completedCount;
                    
                    [self executeOnMainQueue:^{
                        progressHandler(currentCompleted, totalCount);
                    }];
                }
            }
            
            dispatch_semaphore_signal(concurrencySemaphore);
        });
    }
    
    dispatch_group_notify(processingGroup, [self sharedBackgroundQueue], ^{
        [self executeOnMainQueue:completion];
    });
}

#pragma mark - Synchronization Utilities

+ (BOOL)waitForGroup:(dispatch_group_t)group
             timeout:(NSTimeInterval)timeoutSeconds {
    dispatch_time_t timeout = dispatch_time(DISPATCH_TIME_NOW, 
                                          (int64_t)(timeoutSeconds * NSEC_PER_SEC));
    return dispatch_group_wait(group, timeout) == 0;
}

+ (BOOL)waitForSemaphore:(dispatch_semaphore_t)semaphore
                 timeout:(NSTimeInterval)timeoutSeconds {
    dispatch_time_t timeout = dispatch_time(DISPATCH_TIME_NOW, 
                                          (int64_t)(timeoutSeconds * NSEC_PER_SEC));
    return dispatch_semaphore_wait(semaphore, timeout) == 0;
}

+ (void)executeOnMainQueue:(void(^)(void))block {
    if ([NSThread isMainThread]) {
        block();
    } else {
        dispatch_async(dispatch_get_main_queue(), block);
    }
}

+ (void)executeOnMainQueueSync:(void(^)(void))block {
    if ([NSThread isMainThread]) {
        block();
    } else {
        dispatch_sync(dispatch_get_main_queue(), block);
    }
}

@end
</file>

<file path="shared/Core/PDF22MDErrorFactory.h">
//
//  PDF22MDErrorFactory.h
//  pdf22md - Shared Components
//
//  Unified error creation factory for consistent error handling
//  across all implementations and components.
//

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

// Forward declaration - error constants defined in implementation-specific headers
typedef NS_ENUM(NSInteger, PDF22MDError);

/**
 * Unified error factory for creating consistent, user-friendly error objects
 * across all PDF22MD implementations and components.
 */
@interface PDF22MDErrorFactory : NSObject

#pragma mark - Core Factory Methods

/**
 * Creates a user-friendly error with code, description, and actionable suggestion.
 */
+ (NSError *)createErrorForDomain:(NSErrorDomain)domain
                             code:(NSInteger)code
                      description:(NSString *)description
                       suggestion:(nullable NSString *)suggestion
                  underlyingError:(nullable NSError *)underlyingError;

#pragma mark - Configuration Error Factory Methods

/**
 * Creates an error for invalid configuration with specific validation details.
 */
+ (NSError *)invalidConfigurationErrorWithField:(NSString *)fieldName
                                         reason:(NSString *)reason
                                     suggestion:(NSString *)suggestion;

/**
 * Creates an error for invalid DPI value.
 */
+ (NSError *)invalidDPIErrorWithValue:(CGFloat)dpiValue;

/**
 * Creates an error for invalid concurrent pages value.
 */
+ (NSError *)invalidConcurrentPagesErrorWithValue:(NSInteger)pageCount;

/**
 * Creates an error for invalid heading level value.
 */
+ (NSError *)invalidHeadingLevelErrorWithValue:(NSInteger)headingLevel;

/**
 * Creates an error for invalid font size threshold.
 */
+ (NSError *)invalidFontSizeThresholdErrorWithValue:(CGFloat)threshold;

#pragma mark - File System Error Factory Methods

/**
 * Creates an error for invalid PDF input.
 */
+ (NSError *)invalidPDFErrorWithPath:(NSString *)path
                     underlyingError:(nullable NSError *)underlyingError;

/**
 * Creates an error for file not found.
 */
+ (NSError *)fileNotFoundErrorWithPath:(NSString *)path;

/**
 * Creates an error for invalid input parameters.
 */
+ (NSError *)invalidInputErrorWithReason:(NSString *)reason;

/**
 * Creates an error for asset folder creation failure.
 */
+ (NSError *)assetCreationErrorWithPath:(NSString *)path
                                 reason:(NSString *)reason;

#pragma mark - Processing Error Factory Methods

/**
 * Creates an error for memory pressure.
 */
+ (NSError *)memoryPressureErrorWithContext:(NSString *)context;

/**
 * Creates an error for processing timeout.
 */
+ (NSError *)processingTimeoutErrorWithDuration:(NSTimeInterval)duration;

/**
 * Creates an error for encrypted PDF.
 */
+ (NSError *)encryptedPDFError;

/**
 * Creates an error for empty document.
 */
+ (NSError *)emptyDocumentError;

/**
 * Creates an error for page processing failure.
 */
+ (NSError *)pageProcessingFailedErrorForPage:(NSInteger)pageIndex 
                                       reason:(nullable NSString *)reason
                              underlyingError:(nullable NSError *)underlyingError;

/**
 * Creates an error for general processing failure.
 */
+ (NSError *)processingFailedErrorWithReason:(NSString *)reason 
                             underlyingError:(nullable NSError *)underlyingError;

/**
 * Creates an error for I/O failure.
 */
+ (NSError *)ioFailureErrorWithPath:(nullable NSString *)path 
                             reason:(NSString *)reason
                    underlyingError:(nullable NSError *)underlyingError;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="shared/Core/PDF22MDErrorFactory.m">
//
//  PDF22MDErrorFactory.m
//  pdf22md - Shared Components
//
//  Unified error creation factory for consistent error handling
//  across all implementations and components.
//

#import "PDF22MDErrorFactory.h"

// Import error constants from implementation-specific header
// This ensures we use the same error domain and codes consistently
extern NSErrorDomain const PDF22MDErrorDomain;

// Error codes - using constants to avoid redefinition
#define PDF22MDErrorInvalidConfiguration 1004
#define PDF22MDErrorInvalidPDF 1000
#define PDF22MDErrorFileNotFound 1012
#define PDF22MDErrorInvalidInput 1011
#define PDF22MDErrorAssetFolderCreation 1001
#define PDF22MDErrorMemoryPressure 1006
#define PDF22MDErrorProcessingTimeout 1008
#define PDF22MDErrorEncryptedPDF 1009
#define PDF22MDErrorEmptyDocument 1010
#define PDF22MDErrorPageProcessingFailed 1003
#define PDF22MDErrorProcessingFailed 1002
#define PDF22MDErrorIOFailure 1005

// Error keys
extern NSString * const PDF22MDErrorPageIndexKey;
extern NSString * const PDF22MDErrorFilePathKey;
extern NSString * const PDF22MDErrorUnderlyingErrorKey;

@implementation PDF22MDErrorFactory

#pragma mark - Core Factory Methods

+ (NSError *)createErrorForDomain:(NSErrorDomain)domain
                             code:(NSInteger)code
                      description:(NSString *)description
                       suggestion:(nullable NSString *)suggestion
                  underlyingError:(nullable NSError *)underlyingError {
    NSMutableDictionary *userInfo = [@{
        NSLocalizedDescriptionKey: description,
        NSLocalizedFailureReasonErrorKey: description
    } mutableCopy];
    
    if (suggestion) {
        userInfo[NSLocalizedRecoverySuggestionErrorKey] = suggestion;
    }
    
    if (underlyingError) {
        userInfo[NSUnderlyingErrorKey] = underlyingError;
        userInfo[PDF22MDErrorUnderlyingErrorKey] = underlyingError;
    }
    
    return [NSError errorWithDomain:domain
                               code:code
                           userInfo:userInfo];
}

#pragma mark - Configuration Error Factory Methods

+ (NSError *)invalidConfigurationErrorWithField:(NSString *)fieldName
                                         reason:(NSString *)reason
                                     suggestion:(NSString *)suggestion {
    NSString *description = [NSString stringWithFormat:@"Invalid %@: %@", fieldName, reason];
    
    return [self createErrorForDomain:PDF22MDErrorDomain
                                 code:PDF22MDErrorInvalidConfiguration
                          description:description
                           suggestion:suggestion
                      underlyingError:nil];
}

+ (NSError *)invalidDPIErrorWithValue:(CGFloat)dpiValue {
    NSString *reason = [NSString stringWithFormat:@"DPI value %.1f is invalid", dpiValue];
    NSString *suggestion = @"DPI must be between 1 and 600";
    
    return [self invalidConfigurationErrorWithField:@"rasterization DPI"
                                              reason:reason
                                          suggestion:suggestion];
}

+ (NSError *)invalidConcurrentPagesErrorWithValue:(NSInteger)pageCount {
    NSString *reason = [NSString stringWithFormat:@"concurrent pages value %ld is invalid", (long)pageCount];
    NSString *suggestion = @"Value must be between 1 and 64";
    
    return [self invalidConfigurationErrorWithField:@"max concurrent pages"
                                              reason:reason
                                          suggestion:suggestion];
}

+ (NSError *)invalidHeadingLevelErrorWithValue:(NSInteger)headingLevel {
    NSString *reason = [NSString stringWithFormat:@"heading level %ld is invalid", (long)headingLevel];
    NSString *suggestion = @"Heading level must be between 1 and 6";
    
    return [self invalidConfigurationErrorWithField:@"max heading level"
                                              reason:reason
                                          suggestion:suggestion];
}

+ (NSError *)invalidFontSizeThresholdErrorWithValue:(CGFloat)threshold {
    NSString *reason = [NSString stringWithFormat:@"font size threshold %.1f is invalid", threshold];
    NSString *suggestion = @"Threshold must be between 0.5 and 10.0 points";
    
    return [self invalidConfigurationErrorWithField:@"heading font size threshold"
                                              reason:reason
                                          suggestion:suggestion];
}

#pragma mark - File System Error Factory Methods

+ (NSError *)invalidPDFErrorWithPath:(NSString *)path
                     underlyingError:(nullable NSError *)underlyingError {
    NSString *description = [NSString stringWithFormat:@"The PDF file appears to be corrupted or invalid: %@", path];
    NSString *suggestion = @"Ensure the file is a valid PDF document. Try opening it in another PDF viewer to verify it's not corrupted.";
    
    NSError *error = [self createErrorForDomain:PDF22MDErrorDomain
                                           code:PDF22MDErrorInvalidPDF
                                    description:description
                                     suggestion:suggestion
                                underlyingError:underlyingError];
    
    NSMutableDictionary *userInfo = [error.userInfo mutableCopy];
    userInfo[PDF22MDErrorFilePathKey] = path;
    
    return [NSError errorWithDomain:PDF22MDErrorDomain
                               code:PDF22MDErrorInvalidPDF
                           userInfo:userInfo];
}

+ (NSError *)fileNotFoundErrorWithPath:(NSString *)path {
    NSString *description = [NSString stringWithFormat:@"File not found: %@", path];
    NSString *suggestion = @"Check that the file path is correct and the file exists.";
    
    NSError *error = [self createErrorForDomain:PDF22MDErrorDomain
                                           code:PDF22MDErrorFileNotFound
                                    description:description
                                     suggestion:suggestion
                                underlyingError:nil];
    
    NSMutableDictionary *userInfo = [error.userInfo mutableCopy];
    userInfo[PDF22MDErrorFilePathKey] = path;
    
    return [NSError errorWithDomain:PDF22MDErrorDomain
                               code:PDF22MDErrorFileNotFound
                           userInfo:userInfo];
}

+ (NSError *)invalidInputErrorWithReason:(NSString *)reason {
    NSString *description = [NSString stringWithFormat:@"Invalid input: %@", reason];
    NSString *suggestion = @"Check the command line arguments and ensure all required parameters are provided correctly.";
    
    return [self createErrorForDomain:PDF22MDErrorDomain
                                 code:PDF22MDErrorInvalidInput
                          description:description
                           suggestion:suggestion
                      underlyingError:nil];
}

+ (NSError *)assetCreationErrorWithPath:(NSString *)path
                                 reason:(NSString *)reason {
    NSString *description = [NSString stringWithFormat:@"Could not create assets folder at %@: %@", path, reason];
    NSString *suggestion = @"Ensure you have write permissions to the target directory and sufficient disk space.";
    
    NSError *error = [self createErrorForDomain:PDF22MDErrorDomain
                                           code:PDF22MDErrorAssetFolderCreation
                                    description:description
                                     suggestion:suggestion
                                underlyingError:nil];
    
    NSMutableDictionary *userInfo = [error.userInfo mutableCopy];
    userInfo[PDF22MDErrorFilePathKey] = path;
    
    return [NSError errorWithDomain:PDF22MDErrorDomain
                               code:PDF22MDErrorAssetFolderCreation
                           userInfo:userInfo];
}

#pragma mark - Processing Error Factory Methods

+ (NSError *)memoryPressureErrorWithContext:(NSString *)context {
    NSString *description = [NSString stringWithFormat:@"Insufficient memory to process PDF during %@", context];
    NSString *suggestion = @"Try processing a smaller PDF or close other applications to free up memory. For very large documents, consider splitting them into smaller files.";
    
    return [self createErrorForDomain:PDF22MDErrorDomain
                                 code:PDF22MDErrorMemoryPressure
                          description:description
                           suggestion:suggestion
                      underlyingError:nil];
}

+ (NSError *)processingTimeoutErrorWithDuration:(NSTimeInterval)duration {
    NSString *description = [NSString stringWithFormat:@"PDF processing timed out after %.1f seconds (document too complex)", duration];
    NSString *suggestion = @"The PDF may be extremely large or complex. Try processing smaller sections or contact support if this persists.";
    
    return [self createErrorForDomain:PDF22MDErrorDomain
                                 code:PDF22MDErrorProcessingTimeout
                          description:description
                           suggestion:suggestion
                      underlyingError:nil];
}

+ (NSError *)encryptedPDFError {
    NSString *description = @"Password-protected PDFs are not currently supported";
    NSString *suggestion = @"Please remove the password protection from the PDF using another tool before conversion.";
    
    return [self createErrorForDomain:PDF22MDErrorDomain
                                 code:PDF22MDErrorEncryptedPDF
                          description:description
                           suggestion:suggestion
                      underlyingError:nil];
}

+ (NSError *)emptyDocumentError {
    NSString *description = @"The PDF contains no readable content";
    NSString *suggestion = @"The PDF may be empty, contain only images without text, or have text in an unsupported format.";
    
    return [self createErrorForDomain:PDF22MDErrorDomain
                                 code:PDF22MDErrorEmptyDocument
                          description:description
                           suggestion:suggestion
                      underlyingError:nil];
}

+ (NSError *)pageProcessingFailedErrorForPage:(NSInteger)pageIndex 
                                       reason:(nullable NSString *)reason
                              underlyingError:(nullable NSError *)underlyingError {
    NSString *description = [NSString stringWithFormat:@"Failed to process page %ld", (long)(pageIndex + 1)];
    NSString *failureReason = reason ?: @"An error occurred while extracting content from the page";
    
    NSMutableDictionary *userInfo = [@{
        NSLocalizedDescriptionKey: description,
        NSLocalizedFailureReasonErrorKey: failureReason,
        NSLocalizedRecoverySuggestionErrorKey: @"The page may contain unsupported content or be corrupted",
        PDF22MDErrorPageIndexKey: @(pageIndex)
    } mutableCopy];
    
    if (underlyingError) {
        userInfo[NSUnderlyingErrorKey] = underlyingError;
        userInfo[PDF22MDErrorUnderlyingErrorKey] = underlyingError;
    }
    
    return [NSError errorWithDomain:PDF22MDErrorDomain
                               code:PDF22MDErrorPageProcessingFailed
                           userInfo:userInfo];
}

+ (NSError *)processingFailedErrorWithReason:(NSString *)reason 
                             underlyingError:(nullable NSError *)underlyingError {
    NSString *description = @"PDF processing failed";
    
    NSMutableDictionary *userInfo = [@{
        NSLocalizedDescriptionKey: description,
        NSLocalizedFailureReasonErrorKey: reason,
        NSLocalizedRecoverySuggestionErrorKey: @"Check the input file and try again"
    } mutableCopy];
    
    if (underlyingError) {
        userInfo[NSUnderlyingErrorKey] = underlyingError;
        userInfo[PDF22MDErrorUnderlyingErrorKey] = underlyingError;
    }
    
    return [NSError errorWithDomain:PDF22MDErrorDomain
                               code:PDF22MDErrorProcessingFailed
                           userInfo:userInfo];
}

+ (NSError *)ioFailureErrorWithPath:(nullable NSString *)path 
                             reason:(NSString *)reason
                    underlyingError:(nullable NSError *)underlyingError {
    NSString *description = @"File I/O operation failed";
    
    NSMutableDictionary *userInfo = [@{
        NSLocalizedDescriptionKey: description,
        NSLocalizedFailureReasonErrorKey: reason,
        NSLocalizedRecoverySuggestionErrorKey: @"Check file permissions and available disk space"
    } mutableCopy];
    
    if (path) {
        userInfo[PDF22MDErrorFilePathKey] = path;
    }
    
    if (underlyingError) {
        userInfo[NSUnderlyingErrorKey] = underlyingError;
        userInfo[PDF22MDErrorUnderlyingErrorKey] = underlyingError;
    }
    
    return [NSError errorWithDomain:PDF22MDErrorDomain
                               code:PDF22MDErrorIOFailure
                           userInfo:userInfo];
}

@end
</file>

<file path="shared/test-resources/expected-outputs/README.md">
---
title: "README.md"
creator: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36 Edg/137.0.0.0"
producer: "Skia/PDF m137"
created: 2025-06-23T01:33:53+02:00
modified: 2025-06-23T01:33:53+02:00
pdf_metadata:
  page_count: 2
conversion:
  tool: "pdf22md"
  version: "v1.1.0-dirty"
  date: 2025-06-23T02:28:31+02:00
---

23/06/2025, 01:33 README.md

![Image](image_000.png)

![Image](image_001.png)

pdf22md

MIT

License MIT

License

10.15+

![Image](image_002.png)

![Image](image_003.png)

macOS 10.15+

macOS

Build and Release Build and Release passing passing

A blazingly fast PDF to Markdown converter for macOS.

pdf22md is a command-line tool that extracts all text and image content from a PDF file and converts it into a

![Image](image_004.png)

![Image](image_005.png)

![Image](image_006.png)

clean Markdown document. It uses Grand Central Dispatch (GCD) to process pages and save images in

parallel, making it exceptionally fast for multi-page documents.

Key Features

High-Speed Conversion: Uses all available CPU cores to process PDF pages concurrently

Intelligent Heading Detection: Analyzes font sizes and usage frequency to automatically format titles

![Image](image_007.png)

![Image](image_008.png)

![Image](image_009.png)

and headings ( # , ## , etc.)

Asset Extraction: Saves raster and vector images into a specified assets folder and links them correctly

in the Markdown file

Smart Image Formatting: Automatically chooses between JPEG (for photos) and PNG (for graphics with

transparency) to optimize file size and quality

Flexible I/O: Reads from a PDF file or stdin and writes to a Markdown file or stdout

![Image](image_010.png)

![Image](image_011.png)

![Image](image_012.png)

Customizable Rasterization: Allows setting a custom DPI for converting vector graphics to bitmaps

Installation

Using Homebrew (Coming Soon)

brew tap twardoch/pdf22md

brew install pdf22md

![Image](image_013.png)

![Image](image_014.png)

Building from Source

To build the project manually, you need Xcode Command Line Tools installed.

# Clone the repository

git clone https://github.com/twardoch/pdf22md.git

cd pdf22md

# Compile the tool

make

# Install it to /usr/local/bin (optional)

sudo make install

Download Pre-built Binary

Pre-built binaries are available from the Releases page.

Usage

Usage: pdf22md [-i input.pdf] [-o output.md] [-a assets

_

folder] [-d dpi]

Converts PDF documents to Markdown format

-i <path>: Input PDF file (default: stdin)

-o <path>: Output Markdown file (default: stdout)

-a <path>: Assets folder for extracted images

-d <dpi>: DPI for rasterizing vector graphics (default: 144)

Examples

# Convert a PDF file to Markdown

pdf22md -i document.pdf -o document.md

# Convert with images saved to an 'assets' folder

pdf22md -i report.pdf -o report.md -a ./assets

# Convert with custom DPI for vector graphics

pdf22md -i presentation.pdf -o presentation.md -a ./images -d 300

# Use with pipes

cat document.pdf | pdf22md > document.md

# Convert and view in less

pdf22md -i manual.pdf | less

Requirements

macOS 10.15 (Catalina) or later

Xcode Command Line Tools (for building from source)

Project Structure

pdf22md/

├── src/ # Source code

│ ├── main.m # Entry point

│ ├── PDFMarkdownConverter.* # Main conversion logic

│ ├── PDFPageProcessor.* # PDF page processing

│ ├── ContentElement.* # Content element definitions

│ └── AssetExtractor.* # Image extraction logic

├── docs/ # Additional documentation

├── test/ # Test files

file:///Users/adam/Developer/vcs/github.twardoch/pub/pdf22md/README.md 1/2

23/06/2025, 01:33 README.md

![Image](image_015.png)

![Image](image_016.png)

├── LICENSE # MIT License

├── Makefile # Build configuration

└── README.md # This file

Contributing

Contributions are welcome! Please feel free to submit a Pull Request. For major changes, please open an

![Image](image_017.png)

![Image](image_018.png)

![Image](image_019.png)

issue first to discuss what you

would like to change.

1. Fork the repository

2. Create your feature branch ( git checkout -b feature/AmazingFeature )

3. Commit your changes ( git commit -m 'Add some AmazingFeature' )

![Image](image_020.png)

![Image](image_021.png)

![Image](image_022.png)

4. Push to the branch ( git push origin feature/AmazingFeature )

5. Open a Pull Request

License

This project is licensed under the MIT License - see the LICENSE file for details.

Acknowledgments

![Image](image_023.png)

![Image](image_024.png)

![Image](image_025.png)

![Image](image_026.png)

![Image](image_027.png)

Built with Apple’s PDFKit and Core Graphics frameworks

Parallel processing powered by Grand Central Dispatch (GCD)

Inspired by the need for fast, accurate PDF to Markdown conversion

Related Projects

pdfplumber - Python library for PDF processing

![Image](image_028.png)

pdf2md - Another PDF to Markdown converter

![Image](image_029.png)

![Image](image_030.png)

![Image](image_031.png)

![Image](image_032.png)

pandoc - Universal document converter

Changelog

See CHANGELOG.md for a list of changes in each version.

Support

If you encounter any issues or have questions, please open an issue on GitHub.

![Image](image_033.png)

![Image](image_034.png)

file:///Users/adam/Developer/vcs/github.twardoch/pub/pdf22md/README.md 2/2
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2024 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path=".github/workflows/build-release.yml">
name: Build and Release

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  release:
    types: [ created ]

jobs:
  build:
    runs-on: macos-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Build the tool
      run: make

    - name: Run a basic check
      run: ./pdf22md -h

  create-release:
    if: github.event_name == 'release'
    runs-on: macos-latest
    needs: build

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Build the binary
      run: make

    - name: Create Tarball Archive
      run: |
        tar -czvf pdf22md-macos-x86_64.tar.gz pdf22md

    - name: Upload Release Asset
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ github.event.release.upload_url }}
        asset_path: ./pdf22md-macos-x86_64.tar.gz
        asset_name: pdf22md-macos-x86_64.tar.gz
        asset_content_type: application/gzip
</file>

<file path="issues/issue102-resolution.txt">
ISSUE 102 & 201 RESOLUTION
===================

Problem:
--------
Two build script issues were preventing successful builds:

1. `declare -A` bash incompatibility error
   - Error: "declare: -A: invalid option"
   - Root cause: Bash 3.x doesn't support associative arrays

2. SWBBuildService framework loading issue in Swift build
   - Error: "Library not loaded: @rpath/SWBBuildService.framework"
   - Root cause: Corrupted or incomplete Swift toolchain installation

Solutions Implemented:
---------------------

1. Fixed bash incompatibility:
   - Replaced associative array `declare -A build_results` with simple variables
   - Changed from `build_results["objc"]` to `build_results_objc`
   - Updated all references throughout build.sh

2. Enhanced Swift build resilience:
   - Added Swift toolchain health check before attempting build
   - Implemented graceful fallback when Swift toolchain is corrupted
   - Added informative error messages with recovery instructions
   - Modified build.sh to continue with Objective-C when Swift fails

Results:
--------
- Objective-C build: ✓ WORKING
- Swift build: ✗ BLOCKED (system Swift toolchain issue)
- Build script: ✓ ROBUST (handles mixed success gracefully)

The build script now:
- Detects and reports Swift toolchain issues clearly
- Provides recovery instructions (xcode-select --install)
- Continues with successful builds when one implementation fails
- Gives clear status reporting for both implementations

Note: The Swift toolchain issue requires system-level resolution by the user:
`xcode-select --install` or reinstalling Xcode Command Line Tools.
</file>

<file path="pdf22md-objc/src/Core/PDF22MDError.h">
#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

/**
 * Error domain for all PDF22MD errors.
 */
extern NSErrorDomain const PDF22MDErrorDomain;

/**
 * Error codes used throughout the PDF22MD framework.
 */
typedef NS_ERROR_ENUM(PDF22MDErrorDomain, PDF22MDError) {
    /**
     * The provided PDF file or data is invalid or corrupted.
     */
    PDF22MDErrorInvalidPDF = 1000,
    
    /**
     * Failed to create the assets folder or save extracted images.
     */
    PDF22MDErrorAssetFolderCreation = 1001,
    
    /**
     * General processing failure during conversion.
     */
    PDF22MDErrorProcessingFailed = 1002,
    
    /**
     * One or more pages failed to process.
     */
    PDF22MDErrorPageProcessingFailed = 1003,
    
    /**
     * Invalid or missing configuration options.
     */
    PDF22MDErrorInvalidConfiguration = 1004,
    
    /**
     * I/O error reading or writing files.
     */
    PDF22MDErrorIOFailure = 1005,
    
    /**
     * Memory allocation failure or insufficient memory to process PDF.
     */
    PDF22MDErrorMemoryPressure = 1006,
    
    /**
     * Operation was cancelled.
     */
    PDF22MDErrorCancelled = 1007,
    
    /**
     * PDF processing timed out (document too complex).
     */
    PDF22MDErrorProcessingTimeout = 1008,
    
    /**
     * Password-protected PDFs are not currently supported.
     */
    PDF22MDErrorEncryptedPDF = 1009,
    
    /**
     * The PDF contains no readable content.
     */
    PDF22MDErrorEmptyDocument = 1010,
    
    /**
     * Invalid input parameters provided.
     */
    PDF22MDErrorInvalidInput = 1011,
    
    /**
     * File not found at specified path.
     */
    PDF22MDErrorFileNotFound = 1012
};

/**
 * Keys for additional information in error's userInfo dictionary.
 */
extern NSString * const PDF22MDErrorPageIndexKey;      // NSNumber containing the failed page index
extern NSString * const PDF22MDErrorFilePathKey;       // NSString containing the problematic file path
extern NSString * const PDF22MDErrorUnderlyingErrorKey; // Original NSError that caused this error

/**
 * Helper class for creating consistent, user-friendly error objects.
 */
@interface PDF22MDErrorHelper : NSObject

/**
 * Creates a user-friendly error with code, description, and actionable suggestion.
 */
+ (NSError *)userFriendlyErrorWithCode:(PDF22MDError)code 
                           description:(NSString *)description
                            suggestion:(nullable NSString *)suggestion
                       underlyingError:(nullable NSError *)underlyingError;

/**
 * Creates an error for invalid PDF input.
 */
+ (NSError *)invalidPDFError;

/**
 * Creates an error for invalid PDF input with additional details.
 */
+ (NSError *)invalidPDFErrorWithReason:(nullable NSString *)reason;

/**
 * Creates an error for file not found.
 */
+ (NSError *)fileNotFoundErrorWithPath:(NSString *)path;

/**
 * Creates an error for invalid input parameters.
 */
+ (NSError *)invalidInputErrorWithReason:(NSString *)reason;

/**
 * Creates an error for asset folder creation failure.
 */
+ (NSError *)assetFolderCreationErrorWithPath:(NSString *)path 
                                       reason:(nullable NSString *)reason;

/**
 * Creates an error for memory pressure.
 */
+ (NSError *)memoryPressureError;

/**
 * Creates an error for processing timeout.
 */
+ (NSError *)processingTimeoutError;

/**
 * Creates an error for encrypted PDF.
 */
+ (NSError *)encryptedPDFError;

/**
 * Creates an error for empty document.
 */
+ (NSError *)emptyDocumentError;

/**
 * Creates an error for page processing failure.
 */
+ (NSError *)pageProcessingFailedErrorForPage:(NSInteger)pageIndex 
                                        reason:(nullable NSString *)reason
                               underlyingError:(nullable NSError *)underlyingError;

/**
 * Creates an error for general processing failure.
 */
+ (NSError *)processingFailedErrorWithReason:(NSString *)reason 
                              underlyingError:(nullable NSError *)underlyingError;

/**
 * Creates an error for I/O failure.
 */
+ (NSError *)ioFailureErrorWithPath:(nullable NSString *)path 
                              reason:(NSString *)reason
                     underlyingError:(nullable NSError *)underlyingError;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/Core/PDF22MDError.m">
#import "PDF22MDError.h"

NSErrorDomain const PDF22MDErrorDomain = @"com.twardoch.pdf22md.ErrorDomain";

NSString * const PDF22MDErrorPageIndexKey = @"PDF22MDErrorPageIndex";
NSString * const PDF22MDErrorFilePathKey = @"PDF22MDErrorFilePath";
NSString * const PDF22MDErrorUnderlyingErrorKey = @"PDF22MDErrorUnderlyingError";

@implementation PDF22MDErrorHelper

+ (NSError *)userFriendlyErrorWithCode:(PDF22MDError)code 
                           description:(NSString *)description
                            suggestion:(nullable NSString *)suggestion
                       underlyingError:(nullable NSError *)underlyingError {
    NSMutableDictionary *userInfo = [@{
        NSLocalizedDescriptionKey: description,
        NSLocalizedFailureReasonErrorKey: description
    } mutableCopy];
    
    if (suggestion) {
        userInfo[NSLocalizedRecoverySuggestionErrorKey] = suggestion;
    }
    
    if (underlyingError) {
        userInfo[NSUnderlyingErrorKey] = underlyingError;
        userInfo[PDF22MDErrorUnderlyingErrorKey] = underlyingError;
    }
    
    return [NSError errorWithDomain:PDF22MDErrorDomain
                               code:code
                           userInfo:userInfo];
}

+ (NSError *)invalidPDFError {
    return [self invalidPDFErrorWithReason:nil];
}

+ (NSError *)invalidPDFErrorWithReason:(nullable NSString *)reason {
    NSString *description = reason ?: @"The PDF file appears to be corrupted or invalid";
    NSString *suggestion = @"Ensure the file is a valid PDF document. Try opening it in another PDF viewer to verify it's not corrupted.";
    
    return [self userFriendlyErrorWithCode:PDF22MDErrorInvalidPDF
                               description:description
                                suggestion:suggestion
                           underlyingError:nil];
}

+ (NSError *)fileNotFoundErrorWithPath:(NSString *)path {
    NSString *description = [NSString stringWithFormat:@"File not found: %@", path];
    NSString *suggestion = @"Check that the file path is correct and the file exists.";
    
    NSError *error = [self userFriendlyErrorWithCode:PDF22MDErrorFileNotFound
                                         description:description
                                          suggestion:suggestion
                                     underlyingError:nil];
    
    NSMutableDictionary *userInfo = [error.userInfo mutableCopy];
    userInfo[PDF22MDErrorFilePathKey] = path;
    
    return [NSError errorWithDomain:PDF22MDErrorDomain
                               code:PDF22MDErrorFileNotFound
                           userInfo:userInfo];
}

+ (NSError *)invalidInputErrorWithReason:(NSString *)reason {
    NSString *description = [NSString stringWithFormat:@"Invalid input: %@", reason];
    NSString *suggestion = @"Check the command line arguments and ensure all required parameters are provided correctly.";
    
    return [self userFriendlyErrorWithCode:PDF22MDErrorInvalidInput
                               description:description
                                suggestion:suggestion
                           underlyingError:nil];
}

+ (NSError *)assetFolderCreationErrorWithPath:(NSString *)path 
                                       reason:(nullable NSString *)reason {
    NSString *description = reason ?: @"Could not create assets folder at specified path";
    NSString *suggestion = @"Ensure you have write permissions to the target directory and sufficient disk space.";
    
    NSError *error = [self userFriendlyErrorWithCode:PDF22MDErrorAssetFolderCreation
                                         description:description
                                          suggestion:suggestion
                                     underlyingError:nil];
    
    NSMutableDictionary *userInfo = [error.userInfo mutableCopy];
    userInfo[PDF22MDErrorFilePathKey] = path;
    
    return [NSError errorWithDomain:PDF22MDErrorDomain
                               code:PDF22MDErrorAssetFolderCreation
                           userInfo:userInfo];
}

+ (NSError *)memoryPressureError {
    NSString *description = @"Insufficient memory to process this PDF";
    NSString *suggestion = @"Try processing a smaller PDF or close other applications to free up memory. For very large documents, consider splitting them into smaller files.";
    
    return [self userFriendlyErrorWithCode:PDF22MDErrorMemoryPressure
                               description:description
                                suggestion:suggestion
                           underlyingError:nil];
}

+ (NSError *)processingTimeoutError {
    NSString *description = @"PDF processing timed out (document too complex)";
    NSString *suggestion = @"The PDF may be extremely large or complex. Try processing smaller sections or contact support if this persists.";
    
    return [self userFriendlyErrorWithCode:PDF22MDErrorProcessingTimeout
                               description:description
                                suggestion:suggestion
                           underlyingError:nil];
}

+ (NSError *)encryptedPDFError {
    NSString *description = @"Password-protected PDFs are not currently supported";
    NSString *suggestion = @"Please remove the password protection from the PDF using another tool before conversion.";
    
    return [self userFriendlyErrorWithCode:PDF22MDErrorEncryptedPDF
                               description:description
                                suggestion:suggestion
                           underlyingError:nil];
}

+ (NSError *)emptyDocumentError {
    NSString *description = @"The PDF contains no readable content";
    NSString *suggestion = @"The PDF may be empty, contain only images without text, or have text in an unsupported format.";
    
    return [self userFriendlyErrorWithCode:PDF22MDErrorEmptyDocument
                               description:description
                                suggestion:suggestion
                           underlyingError:nil];
}

+ (NSError *)assetCreationFailedErrorWithPath:(NSString *)path 
                                         reason:(nullable NSString *)reason {
    // This method is deprecated in favor of assetFolderCreationErrorWithPath:reason:
    return [self assetFolderCreationErrorWithPath:path reason:reason];
}

+ (NSError *)pageProcessingFailedErrorForPage:(NSInteger)pageIndex 
                                        reason:(nullable NSString *)reason
                               underlyingError:(nullable NSError *)underlyingError {
    NSString *description = [NSString stringWithFormat:@"Failed to process page %ld", (long)(pageIndex + 1)];
    NSString *failureReason = reason ?: @"An error occurred while extracting content from the page";
    
    NSMutableDictionary *userInfo = [@{
        NSLocalizedDescriptionKey: description,
        NSLocalizedFailureReasonErrorKey: failureReason,
        NSLocalizedRecoverySuggestionErrorKey: @"The page may contain unsupported content or be corrupted",
        PDF22MDErrorPageIndexKey: @(pageIndex)
    } mutableCopy];
    
    if (underlyingError) {
        userInfo[NSUnderlyingErrorKey] = underlyingError;
        userInfo[PDF22MDErrorUnderlyingErrorKey] = underlyingError;
    }
    
    return [NSError errorWithDomain:PDF22MDErrorDomain
                               code:PDF22MDErrorPageProcessingFailed
                           userInfo:userInfo];
}

+ (NSError *)processingFailedErrorWithReason:(NSString *)reason 
                              underlyingError:(nullable NSError *)underlyingError {
    NSString *description = @"PDF processing failed";
    
    NSMutableDictionary *userInfo = [@{
        NSLocalizedDescriptionKey: description,
        NSLocalizedFailureReasonErrorKey: reason,
        NSLocalizedRecoverySuggestionErrorKey: @"Check the input file and try again"
    } mutableCopy];
    
    if (underlyingError) {
        userInfo[NSUnderlyingErrorKey] = underlyingError;
        userInfo[PDF22MDErrorUnderlyingErrorKey] = underlyingError;
    }
    
    return [NSError errorWithDomain:PDF22MDErrorDomain
                               code:PDF22MDErrorProcessingFailed
                           userInfo:userInfo];
}

+ (NSError *)ioFailureErrorWithPath:(nullable NSString *)path 
                              reason:(NSString *)reason
                     underlyingError:(nullable NSError *)underlyingError {
    NSString *description = @"File I/O operation failed";
    
    NSMutableDictionary *userInfo = [@{
        NSLocalizedDescriptionKey: description,
        NSLocalizedFailureReasonErrorKey: reason,
        NSLocalizedRecoverySuggestionErrorKey: @"Check file permissions and available disk space"
    } mutableCopy];
    
    if (path) {
        userInfo[PDF22MDErrorFilePathKey] = path;
    }
    
    if (underlyingError) {
        userInfo[NSUnderlyingErrorKey] = underlyingError;
        userInfo[PDF22MDErrorUnderlyingErrorKey] = underlyingError;
    }
    
    return [NSError errorWithDomain:PDF22MDErrorDomain
                               code:PDF22MDErrorIOFailure
                           userInfo:userInfo];
}

@end
</file>

<file path="pdf22md-objc/src/Services/PDF22MDAssetManager.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

@class PDF22MDImageElement;

/**
 * Manages the extraction and saving of assets (images) from PDF documents.
 * Thread-safe for concurrent image saving operations.
 */
@interface PDF22MDAssetManager : NSObject

/**
 * The base folder path where assets will be saved.
 */
@property (nonatomic, copy, readonly) NSString *assetsFolderPath;

/**
 * Initializes the asset manager with a folder path.
 * Creates the folder if it doesn't exist.
 *
 * @param folderPath The path where assets will be saved
 * @return A new instance, or nil if folder creation fails
 */
- (nullable instancetype)initWithAssetFolder:(NSString *)folderPath NS_DESIGNATED_INITIALIZER;

- (instancetype)init NS_UNAVAILABLE;

/**
 * Saves an image to the assets folder with automatic format selection.
 *
 * @param image The CGImage to save
 * @param isVectorSource Whether this image originated from vector graphics
 * @param baseName The base filename (without extension)
 * @return The relative path to the saved file, or nil on failure
 */
- (nullable NSString *)saveImage:(CGImageRef)image
                  isVectorSource:(BOOL)isVectorSource
                    withBaseName:(NSString *)baseName;

/**
 * Saves an image element to the assets folder.
 * Updates the element's assetRelativePath property on success.
 *
 * @param imageElement The image element to save
 * @param baseName The base filename (without extension)
 * @return The relative path to the saved file, or nil on failure
 */
- (nullable NSString *)saveImageElement:(PDF22MDImageElement *)imageElement
                           withBaseName:(NSString *)baseName;


/**
 * Gets the next available filename for the given base name.
 * Handles conflicts by appending numbers.
 *
 * @param baseName The desired base filename
 * @param extension The file extension (without dot)
 * @return A unique filename
 */
- (NSString *)uniqueFilenameForBaseName:(NSString *)baseName
                          withExtension:(NSString *)extension;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/Tests/Unit/PDF22MDConverterTests.m">
//
//  PDF22MDConverterTests.m
//  pdf22md-objc
//
//  Unit tests for PDF22MDConverter core functionality
//

#import <XCTest/XCTest.h>
#import "PDF22MDConverter.h"
#import "PDF22MDConversionOptions.h"
#import "PDF22MDError.h"
#import "../../../shared/Core/PDF22MDErrorFactory.h"

@interface PDF22MDConverterTests : XCTestCase
@property (nonatomic, strong) PDF22MDConverter *converter;
@property (nonatomic, strong) PDF22MDConversionOptions *defaultOptions;
@property (nonatomic, strong) NSString *testResourcesPath;
@end

@implementation PDF22MDConverterTests

- (void)setUp {
    [super setUp];
    self.converter = [[PDF22MDConverter alloc] init];
    self.defaultOptions = [[PDF22MDConversionOptions alloc] init];
    
    // Set up test resources path
    NSBundle *bundle = [NSBundle bundleForClass:[self class]];
    self.testResourcesPath = [bundle.resourcePath stringByAppendingPathComponent:@"Tests/Resources"];
}

- (void)tearDown {
    self.converter = nil;
    self.defaultOptions = nil;
    [super tearDown];
}

#pragma mark - Initialization Tests

- (void)testConverterInitialization {
    XCTAssertNotNil(self.converter, @"Converter should initialize successfully");
}

- (void)testDefaultOptionsInitialization {
    XCTAssertNotNil(self.defaultOptions, @"Default options should initialize successfully");
    XCTAssertEqual(self.defaultOptions.dpi, 144, @"Default DPI should be 144");
    XCTAssertNil(self.defaultOptions.assetsPath, @"Default assets path should be nil");
}

#pragma mark - Input Validation Tests

- (void)testNilInputPathHandling {
    NSError *error = nil;
    NSString *result = [self.converter convertPDFAtPath:nil 
                                            withOptions:self.defaultOptions 
                                                  error:&error];
    
    XCTAssertNil(result, @"Should return nil for nil input path");
    XCTAssertNotNil(error, @"Should provide error for nil input path");
    XCTAssertEqual(error.code, PDF22MDErrorInvalidInput, @"Should return invalid input error");
}

- (void)testNonExistentFileHandling {
    NSError *error = nil;
    NSString *nonExistentPath = @"/tmp/nonexistent_file.pdf";
    NSString *result = [self.converter convertPDFAtPath:nonExistentPath 
                                            withOptions:self.defaultOptions 
                                                  error:&error];
    
    XCTAssertNil(result, @"Should return nil for nonexistent file");
    XCTAssertNotNil(error, @"Should provide error for nonexistent file");
    XCTAssertEqual(error.code, PDF22MDErrorFileNotFound, @"Should return file not found error");
}

- (void)testNonPDFFileHandling {
    NSError *error = nil;
    
    // Create a temporary text file
    NSString *tempPath = [NSTemporaryDirectory() stringByAppendingPathComponent:@"test.txt"];
    [@"This is not a PDF" writeToFile:tempPath 
                           atomically:YES 
                             encoding:NSUTF8StringEncoding 
                                error:nil];
    
    NSString *result = [self.converter convertPDFAtPath:tempPath 
                                            withOptions:self.defaultOptions 
                                                  error:&error];
    
    XCTAssertNil(result, @"Should return nil for non-PDF file");
    XCTAssertNotNil(error, @"Should provide error for non-PDF file");
    XCTAssertEqual(error.code, PDF22MDErrorInvalidPDF, @"Should return invalid PDF error");
    
    // Clean up
    [[NSFileManager defaultManager] removeItemAtPath:tempPath error:nil];
}

#pragma mark - Basic Conversion Tests

- (void)testBasicTextConversion {
    // This test would require a simple test PDF file
    // For now, we'll create a placeholder that demonstrates the expected behavior
    
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"simple-text.pdf"];
    
    // Skip test if resource file doesn't exist (expected during initial setup)
    if (![[NSFileManager defaultManager] fileExistsAtPath:testPDFPath]) {
        NSLog(@"Test PDF not found at %@, skipping test", testPDFPath);
        return;
    }
    
    NSError *error = nil;
    NSString *result = [self.converter convertPDFAtPath:testPDFPath 
                                            withOptions:self.defaultOptions 
                                                  error:&error];
    
    XCTAssertNotNil(result, @"Should successfully convert simple text PDF");
    XCTAssertNil(error, @"Should not return error for valid PDF");
    XCTAssertTrue([result containsString:@"#"], @"Should contain markdown headers");
    XCTAssertTrue(result.length > 0, @"Should return non-empty markdown");
}

#pragma mark - Options Validation Tests

- (void)testCustomDPIOption {
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    options.dpi = 300;
    
    XCTAssertEqual(options.dpi, 300, @"Should accept custom DPI value");
}

- (void)testAssetsPathOption {
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    options.assetsPath = @"/tmp/assets";
    
    XCTAssertEqualObjects(options.assetsPath, @"/tmp/assets", @"Should accept custom assets path");
}

#pragma mark - Memory Management Tests

- (void)testMemoryManagement {
    // Test that repeated conversions don't cause memory leaks
    for (int i = 0; i < 10; i++) {
        @autoreleasepool {
            PDF22MDConverter *tempConverter = [[PDF22MDConverter alloc] init];
            PDF22MDConversionOptions *tempOptions = [[PDF22MDConversionOptions alloc] init];
            
            XCTAssertNotNil(tempConverter, @"Converter should initialize in loop iteration %d", i);
            XCTAssertNotNil(tempOptions, @"Options should initialize in loop iteration %d", i);
        }
    }
}

#pragma mark - Error Handling Tests

- (void)testErrorMessageQuality {
    NSError *error = nil;
    NSString *result = [self.converter convertPDFAtPath:@"/nonexistent/path.pdf" 
                                            withOptions:self.defaultOptions 
                                                  error:&error];
    
    XCTAssertNil(result, @"Should return nil for invalid path");
    XCTAssertNotNil(error, @"Should provide error");
    XCTAssertNotNil(error.localizedDescription, @"Error should have localized description");
    XCTAssertTrue(error.localizedDescription.length > 0, @"Error description should not be empty");
    XCTAssertFalse([error.localizedDescription containsString:@"nil"], @"Error description should not contain 'nil'");
}

@end
</file>

<file path="pdf22md-swift/README.md">
# pdf22md - Modern Swift Implementation

A high-performance PDF to Markdown converter built with modern Swift features including async/await, actors, and structured concurrency.

## Features

- **Modern Swift**: Uses Swift 5.7+ features including async/await, actors, and result builders
- **Structured Concurrency**: Concurrent page processing with TaskGroup and proper cancellation
- **Memory Safe**: Automatic memory management with value types where appropriate
- **Type Safe**: Strong typing with enums, associated types, and generic constraints
- **Actor-Based Assets**: Thread-safe image processing with actors
- **Progress Streaming**: Real-time progress updates with AsyncSequence

## Architecture

```
pdf22md-swift/
├── Sources/
│   ├── PDF22MD/                 # Library module
│   │   ├── Core/                # Core conversion logic
│   │   │   ├── PDFConverter     # Main coordinator
│   │   │   ├── PDFPageProcessor # Page content extraction
│   │   │   ├── FontAnalyzer     # Heading detection
│   │   │   ├── PDFError         # Error handling
│   │   │   └── ConversionOptions # Configuration
│   │   ├── Models/              # Data models
│   │   │   ├── ContentElement   # Protocol definition
│   │   │   ├── TextElement      # Text content (struct)
│   │   │   └── ImageElement     # Image content (class)
│   │   └── Services/            # Business logic services
│   │       ├── AssetManager     # Image extraction (actor)
│   │       └── MarkdownGenerator # Markdown generation
│   └── pdf22md/                 # CLI executable
│       └── main.swift
├── Tests/
│   └── PDF22MDTests/
├── Package.swift
└── README.md
```

## Building

### Using the Build Script (Recommended)
```bash
# Build the project
./build.sh

# Build and run tests
./build.sh --test

# Build and install to /usr/local/bin
./build.sh --install

# Build, test, and install
./build.sh --test --install

# Create release archive
./release.sh
```

### Using Swift Package Manager Directly
```bash
# Build with Swift Package Manager
swift build

# Build optimized release
swift build -c release

# Run tests
swift test

# Generate documentation
swift package generate-documentation
```

## Installation

### Swift Package Manager

Add to your `Package.swift`:

```swift
dependencies: [
    .package(url: "https://github.com/twardoch/pdf22md-swift", from: "1.0.0")
]
```

### Executable

```bash
# Build executable
swift build -c release

# Copy to PATH
cp .build/release/pdf22md /usr/local/bin/
```

## Usage

### Command Line

```bash
# Convert a PDF file
pdf22md -i document.pdf -o document.md

# Extract images to assets folder
pdf22md -i report.pdf -o report.md -a ./assets

# Customize DPI and concurrency
pdf22md -i large.pdf -o large.md -d 300 --max-concurrency 8

# Use with pipes
cat document.pdf | pdf22md > document.md

# Verbose output with progress
pdf22md -i document.pdf -o document.md --verbose
```

### Programmatic Usage

```swift
import PDF22MD

// Simple conversion
let converter = try PDFConverter(url: inputURL)
let markdown = try await converter.convert()

// With custom options
let options = ConversionOptions(
    assetsFolderPath: "./assets",
    rasterizationDPI: 300.0,
    includeMetadata: true
)

let markdown = try await converter.convert(options: options)

// Using builder pattern
let options = ConversionOptionsBuilder()
    .assetsFolderPath("./images")
    .rasterizationDPI(300)
    .maxConcurrentPages(4)
    .progressHandler { page, total in
        print("Processing \(page)/\(total)")
    }
    .build()

// Convenience method
try await PDFConverter.convert(
    inputURL: inputURL,
    outputURL: outputURL,
    options: options
)
```

## Key Swift Features Used

### 1. Async/Await
```swift
public func convert(options: ConversionOptions = .default) async throws -> String {
    return try await withThrowingTaskGroup(of: (Int, [ContentElement]).self) { group in
        // Process pages concurrently
    }
}
```

### 2. Actors for Thread Safety
```swift
public actor AssetManager {
    private var usedFilenames: Set<String> = []
    
    public func saveImage(_ image: CGImage) async throws -> String {
        // Thread-safe image saving
    }
}
```

### 3. Result Types
```swift
public enum PDFError: LocalizedError {
    case invalidPDF(reason: String?)
    case processingFailed(reason: String, underlyingError: Error?)
    // ...
}
```

### 4. Value Types
```swift
public struct TextElement: ContentElement, Equatable, Hashable {
    public let text: String
    public let bounds: CGRect
    // Immutable by default
}
```

### 5. Protocol Extensions
```swift
public extension ContentElement {
    func isOnSameLine(as other: ContentElement) -> Bool {
        // Default implementation
    }
}
```

### 6. Structured Concurrency
```swift
return try await withThrowingTaskGroup(of: (Int, [ContentElement]).self) { group in
    for pageIndex in 0..<pageCount {
        group.addTask {
            // Process page concurrently
        }
    }
    // Collect results
}
```

## Testing

```bash
# Run all tests
swift test

# Run specific test
swift test --filter PDF22MDTests.testTextElementCreation

# Run tests with coverage
swift test --enable-code-coverage

# Performance tests
swift test --filter Performance
```

## Performance

- Utilizes all available CPU cores with structured concurrency
- Actor-based asset management for thread-safe operations
- Memory-efficient with proper value/reference type usage
- Cancellation support for long-running operations
- Streaming progress updates

## Error Handling

```swift
do {
    let markdown = try await converter.convert()
} catch PDFError.invalidPDF(let reason) {
    print("Invalid PDF: \(reason ?? "Unknown error")")
} catch PDFError.processingFailed(let reason, let underlying) {
    print("Processing failed: \(reason)")
    if let underlying = underlying {
        print("Underlying error: \(underlying)")
    }
} catch {
    print("Unexpected error: \(error)")
}
```

## Requirements

- macOS 12.0 or later (for async/await)
- Swift 5.7 or later
- Xcode 14.0 or later

## Documentation

Generate documentation with:

```bash
swift package generate-documentation
```

View documentation:

```bash
swift package preview-documentation
```

## License

MIT License - see LICENSE file in the root directory
</file>

<file path=".gitignore">
# Build products
build/
*.o
pdf22md

# macOS
.DS_Store
.AppleDouble
.LSOverride

# Thumbnails
._*

# Files that might appear on external disk
.Spotlight-V100
.Trashes

# Editor-specific
.vscode/
*.swp
.idea/
*.xcodeproj/
*.xcworkspace/

# Cursor and other AI assistants
.cursor/
.cursorrules
.cursorindexingignore
.giga/
.specstory/

# Test artifacts
test/out/
*.md
!README.md
!TODO.md
!CLAUDE.md
!AGENTS.md
!CHANGELOG.md
!docs/*.md
</file>

<file path="CLAUDE.md">
# pdf22md

A blazingly fast PDF to Markdown converter for macOS.

`pdf22md` is a command-line tool that extracts all text and image content from a PDF file and converts it into a clean Markdown document. It uses Grand Central Dispatch (GCD) to process pages and save images in parallel, making it exceptionally fast for multi-page documents.

### Key Features

  * **High-Speed Conversion**: Uses all available CPU cores to process PDF pages concurrently.
  * **Intelligent Heading Detection**: Analyzes font sizes and usage frequency to automatically format titles and headings (`#`, `##`, etc.).
  * **Asset Extraction**: Saves raster and vector images into a specified assets folder and links them correctly in the Markdown file.
  * **Smart Image Formatting**: Automatically chooses between JPEG (for photos) and PNG (for graphics with transparency) to optimize file size and quality.
  * **Flexible I/O**: Reads from a PDF file or `stdin` and writes to a Markdown file or `stdout`.
  * **Customizable Rasterization**: Allows setting a custom DPI for converting vector graphics to bitmaps.

### Installation

Once the Homebrew tap is set up (see plan below), installation is simple:

```bash
brew install <your-username>/pdf22md/pdf22md
```

### Building from Source

To build the project manually, you need Xcode Command Line Tools installed.

```bash
# Clone the repository (once it's public)
git clone https://github.com/<your-username>/pdf22md.git
cd pdf22md

# Compile the tool
make

# Install it to /usr/local/bin
sudo make install
```

### Usage

```
Usage: pdf22md [-i input.pdf] [-o output.md] [-a assets_folder] [-d dpi]
  Converts PDF documents to Markdown format
  -i <path>: Input PDF file (default: stdin)
  -o <path>: Output Markdown file (default: stdout)
  -a <path>: Assets folder for extracted images
  -d <dpi>: DPI for rasterizing vector graphics (default: 144)
```

**Example:**

```bash
# Convert a local PDF file and save images to an 'assets' folder
pdf22md -i report.pdf -o report.md -a ./assets
```

---


# main-overview

## Development Guidelines

- Only modify code directly relevant to the specific request. Avoid changing unrelated functionality.
- Never replace code with placeholders like `# ... rest of the processing ...`. Always include complete code.
- Break problems into smaller steps. Think through each step separately before implementing.
- Always provide a complete PLAN with REASONING based on evidence from code and logs before making changes.
- Explain your OBSERVATIONS clearly, then provide REASONING to identify the exact issue. Add console logs when needed to gather more information.


pdf22md is a PDF to Markdown converter that transforms PDF documents while preserving their semantic structure and content relationships.

Core Business Components:

1. Document Structure Analysis (Importance: 95)
- Hierarchical heading detection using font statistics
- Document structure preservation through positional element sorting
- Automated heading level assignment (H1-H6) based on font usage patterns

2. Content Classification System (Importance: 85)
- TextElement: Handles formatted text with style attributes
- ImageElement: Manages both raster and vector graphics
- Content relationship tracking between elements

3. Asset Processing Pipeline (Importance: 80)
- Intelligent format selection between PNG/JPEG based on:
  * Transparency detection
  * Color complexity analysis
  * Dimension-based optimization
- Asset extraction with maintained document references

4. PDF Content Processing (Importance: 90)
- Text styling and formatting context preservation
- Vector graphics path construction tracking
- Coordinate system transformation management
- Element bounds calculation for layout fidelity

Key Integration Points:

1. Content Extraction Layer
- Connects PDF parsing with markdown generation
- Maintains element relationships and hierarchy
- Preserves formatting context across transformations

2. Asset Management Layer
- Links extracted images with markdown references
- Maintains asset organization structure
- Handles format conversions while preserving quality

The system organizes business logic around content transformation pipelines while maintaining document semantic structure throughout the conversion process.

—— When you’re done with a round of updates, update CHANGELOG.md with the changes, remove done things from TODO.md, identify new things that need to be done and add them to TODO.md. Then build the app or run ./release.sh and then continue updates.
</file>

<file path="pdf22md-objc/src/CLI/pdf22md-benchmark.m">
//
//  pdf22md-benchmark.m
//  pdf22md Performance Benchmarking Tool
//
//  Comprehensive performance validation and benchmarking for pdf22md
//

#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>
#import <mach/mach.h>
#import <mach/mach_time.h>
#import "../Core/PDF22MDConverter.h"
#import "../Core/PDF22MDConversionOptions.h"
#import "../Core/PDF22MDError.h"

#ifndef VERSION
#define VERSION "1.0.0"
#endif

// ANSI color codes for output
#define COLOR_RESET   "\033[0m"
#define COLOR_RED     "\033[31m"
#define COLOR_GREEN   "\033[32m"
#define COLOR_YELLOW  "\033[33m"
#define COLOR_BLUE    "\033[34m"
#define COLOR_MAGENTA "\033[35m"
#define COLOR_CYAN    "\033[36m"

typedef struct {
    NSTimeInterval totalTime;
    NSTimeInterval conversionTime;
    NSTimeInterval markdownTime;
    NSTimeInterval assetTime;
    NSUInteger pageCount;
    NSUInteger imageCount;
    NSUInteger fileSize;
    NSUInteger outputSize;
    NSUInteger peakMemory;
    double pagesPerSecond;
    double mbPerSecond;
} BenchmarkResult;

@interface PDF22MDBenchmark : NSObject

@property (nonatomic, strong) NSMutableArray<NSValue *> *results;
@property (nonatomic, strong) NSString *corpusPath;
@property (nonatomic, strong) NSString *outputPath;
@property (nonatomic, assign) BOOL verbose;
@property (nonatomic, assign) BOOL compareMode;
@property (nonatomic, assign) BOOL memoryProfile;
@property (nonatomic, assign) NSInteger iterations;

- (void)runBenchmarks;
- (void)printResults;
- (void)saveResultsToJSON:(NSString *)path;
- (BenchmarkResult)benchmarkPDF:(NSString *)pdfPath;
- (NSUInteger)getCurrentMemoryUsage;
- (void)compareWithBaseline:(NSString *)baselinePath;

@end

@implementation PDF22MDBenchmark

- (instancetype)init {
    self = [super init];
    if (self) {
        _results = [NSMutableArray array];
        _iterations = 1;
        _verbose = NO;
        _compareMode = NO;
        _memoryProfile = NO;
    }
    return self;
}

- (void)runBenchmarks {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSArray<NSString *> *pdfFiles = nil;
    
    if (self.corpusPath) {
        BOOL isDirectory;
        if ([fileManager fileExistsAtPath:self.corpusPath isDirectory:&isDirectory]) {
            if (isDirectory) {
                // Benchmark all PDFs in corpus directory
                NSError *error = nil;
                NSArray *files = [fileManager contentsOfDirectoryAtPath:self.corpusPath error:&error];
                if (error) {
                    fprintf(stderr, "%sError reading corpus directory: %s%s\n", 
                            COLOR_RED, error.localizedDescription.UTF8String, COLOR_RESET);
                    return;
                }
                
                NSPredicate *pdfPredicate = [NSPredicate predicateWithFormat:@"SELF ENDSWITH '.pdf'"];
                pdfFiles = [[files filteredArrayUsingPredicate:pdfPredicate] 
                            sortedArrayUsingSelector:@selector(localizedStandardCompare:)];
                
                printf("%s📊 Benchmarking %lu PDFs from corpus%s\n", 
                       COLOR_CYAN, (unsigned long)pdfFiles.count, COLOR_RESET);
            } else {
                // Single file provided via corpus path
                pdfFiles = @[[self.corpusPath lastPathComponent]];
                self.corpusPath = [self.corpusPath stringByDeletingLastPathComponent];
                if (self.corpusPath.length == 0) {
                    self.corpusPath = @".";
                }
            }
        } else {
            fprintf(stderr, "%sError: Path not found: %s%s\n", 
                    COLOR_RED, self.corpusPath.UTF8String, COLOR_RESET);
            return;
        }
    } else {
        // Single file benchmark
        pdfFiles = @[@"test.pdf"];
    }
    
    printf("%s════════════════════════════════════════════════════════════════%s\n",
           COLOR_BLUE, COLOR_RESET);
    
    for (NSString *pdfFile in pdfFiles) {
        NSString *fullPath = self.corpusPath ? 
            [self.corpusPath stringByAppendingPathComponent:pdfFile] : pdfFile;
        
        if (![fileManager fileExistsAtPath:fullPath]) {
            fprintf(stderr, "%s⚠️  Skipping non-existent file: %s%s\n", 
                    COLOR_YELLOW, fullPath.UTF8String, COLOR_RESET);
            continue;
        }
        
        printf("\n%sBenchmarking: %s%s\n", COLOR_MAGENTA, pdfFile.UTF8String, COLOR_RESET);
        
        // Run multiple iterations for averaging
        BenchmarkResult avgResult = {0};
        NSMutableArray *iterationResults = [NSMutableArray array];
        
        for (NSInteger i = 0; i < self.iterations; i++) {
            if (self.iterations > 1) {
                printf("  Iteration %ld/%ld...\n", (long)(i + 1), (long)self.iterations);
            }
            
            BenchmarkResult result = [self benchmarkPDF:fullPath];
            [iterationResults addObject:[NSValue valueWithBytes:&result 
                                                        objCType:@encode(BenchmarkResult)]];
            
            // Accumulate for averaging
            avgResult.totalTime += result.totalTime;
            avgResult.conversionTime += result.conversionTime;
            avgResult.markdownTime += result.markdownTime;
            avgResult.assetTime += result.assetTime;
            avgResult.pageCount = result.pageCount;
            avgResult.imageCount = result.imageCount;
            avgResult.fileSize = result.fileSize;
            avgResult.outputSize += result.outputSize;
            avgResult.peakMemory = MAX(avgResult.peakMemory, result.peakMemory);
            
            // Cool down between iterations
            if (i < self.iterations - 1) {
                [NSThread sleepForTimeInterval:0.5];
            }
        }
        
        // Calculate averages
        avgResult.totalTime /= self.iterations;
        avgResult.conversionTime /= self.iterations;
        avgResult.markdownTime /= self.iterations;
        avgResult.assetTime /= self.iterations;
        avgResult.outputSize /= self.iterations;
        avgResult.pagesPerSecond = avgResult.pageCount / avgResult.totalTime;
        avgResult.mbPerSecond = (avgResult.fileSize / 1024.0 / 1024.0) / avgResult.totalTime;
        
        [self.results addObject:[NSValue valueWithBytes:&avgResult 
                                              objCType:@encode(BenchmarkResult)]];
        
        // Print immediate results
        [self printResult:avgResult forFile:pdfFile];
    }
    
    printf("%s════════════════════════════════════════════════════════════════%s\n\n",
           COLOR_BLUE, COLOR_RESET);
}

- (BenchmarkResult)benchmarkPDF:(NSString *)pdfPath {
    BenchmarkResult result = {0};
    
    // Get file size
    NSError *error = nil;
    NSDictionary *attrs = [[NSFileManager defaultManager] attributesOfItemAtPath:pdfPath error:&error];
    result.fileSize = [attrs[NSFileSize] unsignedIntegerValue];
    
    // Memory baseline
    NSUInteger memStart = [self getCurrentMemoryUsage];
    
    // Start total timing
    NSDate *startTime = [NSDate date];
    mach_timebase_info_data_t timebase;
    mach_timebase_info(&timebase);
    
    // Load PDF
    if (self.verbose) {
        printf("  Loading PDF from: %s\n", pdfPath.UTF8String);
    }
    
    NSURL *pdfURL = [NSURL fileURLWithPath:pdfPath];
    PDF22MDConverter *converter = [[PDF22MDConverter alloc] initWithPDFURL:pdfURL];
    
    if (!converter) {
        fprintf(stderr, "%sError: Failed to load PDF from %s%s\n", COLOR_RED, pdfPath.UTF8String, COLOR_RESET);
        return result;
    }
    
    result.pageCount = converter.document.pageCount;
    
    // Configure options using builder
    PDF22MDConversionOptionsBuilder *builder = [[PDF22MDConversionOptionsBuilder alloc] init];
    if (self.outputPath) {
        NSString *assetDir = [[self.outputPath stringByDeletingLastPathComponent] 
                              stringByAppendingPathComponent:@"benchmark-assets"];
        builder.assetsFolderPath = assetDir;
        builder.extractImages = YES;
    }
    builder.rasterizationDPI = 144.0;
    
    PDF22MDConversionOptions *options = [builder build];
    
    // Conversion timing
    uint64_t convStart = mach_absolute_time();
    __block NSString *markdown = nil;
    __block NSError *convError = nil;
    
    if (self.verbose) {
        printf("  Starting conversion with %lu pages...\n", (unsigned long)result.pageCount);
    }
    
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
    
    [converter convertWithOptions:options completion:^(NSString *output, NSError *error) {
        if (self.verbose) {
            if (error) {
                printf("  Conversion completed with error: %s\n", error.localizedDescription.UTF8String);
            } else {
                printf("  Conversion completed successfully, output length: %lu\n", (unsigned long)output.length);
            }
        }
        markdown = output;
        convError = error;
        dispatch_semaphore_signal(semaphore);
    }];
    
    // Wait with timeout
    dispatch_time_t timeout = dispatch_time(DISPATCH_TIME_NOW, 30 * NSEC_PER_SEC);
    if (dispatch_semaphore_wait(semaphore, timeout) != 0) {
        fprintf(stderr, "%sError: Conversion timed out after 30 seconds%s\n", COLOR_RED, COLOR_RESET);
        return result;
    }
    
    uint64_t convEnd = mach_absolute_time();
    
    // Calculate times
    result.conversionTime = (double)(convEnd - convStart) * timebase.numer / timebase.denom / 1e9;
    
    if (convError) {
        fprintf(stderr, "%sConversion error: %s%s\n", 
                COLOR_RED, convError.localizedDescription.UTF8String, COLOR_RESET);
        return result;
    }
    
    // Output size
    result.outputSize = [markdown lengthOfBytesUsingEncoding:NSUTF8StringEncoding];
    
    // Peak memory
    result.peakMemory = [self getCurrentMemoryUsage] - memStart;
    
    // Total time
    result.totalTime = -[startTime timeIntervalSinceNow];
    result.pagesPerSecond = result.pageCount / result.totalTime;
    result.mbPerSecond = (result.fileSize / 1024.0 / 1024.0) / result.totalTime;
    
    // Count images if assets were extracted
    if (options.assetsFolderPath) {
        NSArray *assets = [[NSFileManager defaultManager] 
                           contentsOfDirectoryAtPath:options.assetsFolderPath error:nil];
        result.imageCount = assets.count;
    }
    
    // Save output if requested
    if (self.outputPath && markdown) {
        [markdown writeToFile:self.outputPath 
                   atomically:YES 
                     encoding:NSUTF8StringEncoding 
                        error:nil];
    }
    
    return result;
}

- (void)printResult:(BenchmarkResult)result forFile:(NSString *)filename {
    printf("\n%s📄 %s%s\n", COLOR_GREEN, filename.UTF8String, COLOR_RESET);
    printf("  Pages:        %lu\n", (unsigned long)result.pageCount);
    printf("  File size:    %.2f MB\n", result.fileSize / 1024.0 / 1024.0);
    printf("  Output size:  %.2f KB\n", result.outputSize / 1024.0);
    printf("  Images:       %lu\n", (unsigned long)result.imageCount);
    printf("\n");
    printf("  %s⏱  Performance:%s\n", COLOR_CYAN, COLOR_RESET);
    printf("  Total time:   %.3f seconds\n", result.totalTime);
    printf("  Conversion:   %.3f seconds (%.1f%%)\n", 
           result.conversionTime, (result.conversionTime / result.totalTime) * 100);
    printf("  Pages/sec:    %.1f\n", result.pagesPerSecond);
    printf("  MB/sec:       %.2f\n", result.mbPerSecond);
    
    if (result.peakMemory > 0) {
        printf("\n  %s💾 Memory:%s\n", COLOR_CYAN, COLOR_RESET);
        printf("  Peak usage:   %.1f MB\n", result.peakMemory / 1024.0 / 1024.0);
    }
}

- (NSUInteger)getCurrentMemoryUsage {
    struct task_basic_info info;
    mach_msg_type_number_t size = TASK_BASIC_INFO_COUNT;
    kern_return_t kerr = task_info(mach_task_self(),
                                   TASK_BASIC_INFO,
                                   (task_info_t)&info,
                                   &size);
    return (kerr == KERN_SUCCESS) ? info.resident_size : 0;
}

- (void)printResults {
    if (self.results.count == 0) return;
    
    printf("\n%s📊 BENCHMARK SUMMARY%s\n", COLOR_CYAN, COLOR_RESET);
    printf("%s════════════════════════════════════════════════════════════════%s\n",
           COLOR_BLUE, COLOR_RESET);
    
    // Calculate aggregates
    double totalPages = 0;
    double totalTime = 0;
    double totalSize = 0;
    double avgPagesPerSec = 0;
    double avgMBPerSec = 0;
    NSUInteger maxMemory = 0;
    
    for (NSValue *value in self.results) {
        BenchmarkResult result;
        [value getValue:&result];
        
        totalPages += result.pageCount;
        totalTime += result.totalTime;
        totalSize += result.fileSize;
        avgPagesPerSec += result.pagesPerSecond;
        avgMBPerSec += result.mbPerSecond;
        maxMemory = MAX(maxMemory, result.peakMemory);
    }
    
    NSUInteger count = self.results.count;
    avgPagesPerSec /= count;
    avgMBPerSec /= count;
    
    printf("\n%sDocuments processed: %lu%s\n", COLOR_GREEN, (unsigned long)count, COLOR_RESET);
    printf("Total pages:         %.0f\n", totalPages);
    printf("Total size:          %.1f MB\n", totalSize / 1024.0 / 1024.0);
    printf("Total time:          %.2f seconds\n", totalTime);
    printf("\n");
    printf("%sAverage performance:%s\n", COLOR_MAGENTA, COLOR_RESET);
    printf("Pages per second:    %.1f\n", avgPagesPerSec);
    printf("MB per second:       %.2f\n", avgMBPerSec);
    printf("Peak memory usage:   %.1f MB\n", maxMemory / 1024.0 / 1024.0);
    
    // Performance rating
    printf("\n%sPerformance Rating: ", COLOR_YELLOW);
    if (avgPagesPerSec >= 50) {
        printf("⚡️ BLAZINGLY FAST");
    } else if (avgPagesPerSec >= 20) {
        printf("🚀 VERY FAST");
    } else if (avgPagesPerSec >= 10) {
        printf("✅ FAST");
    } else if (avgPagesPerSec >= 5) {
        printf("👍 GOOD");
    } else {
        printf("🐌 NEEDS OPTIMIZATION");
    }
    printf("%s\n\n", COLOR_RESET);
}

- (void)saveResultsToJSON:(NSString *)path {
    NSMutableDictionary *output = [NSMutableDictionary dictionary];
    output[@"timestamp"] = [NSDate date];
    output[@"version"] = @(VERSION);
    output[@"platform"] = @{
        @"os": [[NSProcessInfo processInfo] operatingSystemVersionString],
        @"processors": @([[NSProcessInfo processInfo] processorCount]),
        @"memory": @([[NSProcessInfo processInfo] physicalMemory])
    };
    
    NSMutableArray *results = [NSMutableArray array];
    for (NSValue *value in self.results) {
        BenchmarkResult result;
        [value getValue:&result];
        
        [results addObject:@{
            @"pageCount": @(result.pageCount),
            @"fileSize": @(result.fileSize),
            @"outputSize": @(result.outputSize),
            @"imageCount": @(result.imageCount),
            @"totalTime": @(result.totalTime),
            @"conversionTime": @(result.conversionTime),
            @"pagesPerSecond": @(result.pagesPerSecond),
            @"mbPerSecond": @(result.mbPerSecond),
            @"peakMemory": @(result.peakMemory)
        }];
    }
    
    output[@"results"] = results;
    
    NSError *error = nil;
    NSData *jsonData = [NSJSONSerialization dataWithJSONObject:output 
                                                       options:NSJSONWritingPrettyPrinted 
                                                         error:&error];
    if (!error) {
        [jsonData writeToFile:path atomically:YES];
        printf("%sSaved results to: %s%s\n", COLOR_GREEN, path.UTF8String, COLOR_RESET);
    } else {
        fprintf(stderr, "%sError saving results: %s%s\n", 
                COLOR_RED, error.localizedDescription.UTF8String, COLOR_RESET);
    }
}

- (void)compareWithBaseline:(NSString *)baselinePath {
    // Implementation for comparing with baseline results
    printf("%sComparison with baseline not yet implemented%s\n", COLOR_YELLOW, COLOR_RESET);
}

@end

// Main function
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        PDF22MDBenchmark *benchmark = [[PDF22MDBenchmark alloc] init];
        
        // Parse command line arguments
        NSString *corpusPath = nil;
        NSString *outputPath = nil;
        NSString *jsonPath = nil;
        NSString *comparePath = nil;
        
        for (int i = 1; i < argc; i++) {
            NSString *arg = [NSString stringWithUTF8String:argv[i]];
            
            if ([arg isEqualToString:@"--corpus"] && i + 1 < argc) {
                corpusPath = [NSString stringWithUTF8String:argv[++i]];
                benchmark.corpusPath = corpusPath;
            } else if ([arg isEqualToString:@"--output"] && i + 1 < argc) {
                outputPath = [NSString stringWithUTF8String:argv[++i]];
                benchmark.outputPath = outputPath;
            } else if ([arg isEqualToString:@"--json"] && i + 1 < argc) {
                jsonPath = [NSString stringWithUTF8String:argv[++i]];
            } else if ([arg isEqualToString:@"--compare"] && i + 1 < argc) {
                comparePath = [NSString stringWithUTF8String:argv[++i]];
                benchmark.compareMode = YES;
            } else if ([arg isEqualToString:@"--iterations"] && i + 1 < argc) {
                benchmark.iterations = atoi(argv[++i]);
            } else if ([arg isEqualToString:@"--memory-profile"]) {
                benchmark.memoryProfile = YES;
            } else if ([arg isEqualToString:@"--verbose"]) {
                benchmark.verbose = YES;
            } else if ([arg isEqualToString:@"--help"]) {
                printf("pdf22md-benchmark - Performance benchmarking tool for pdf22md\n\n");
                printf("Usage: pdf22md-benchmark [OPTIONS] [PDF_FILE]\n\n");
                printf("Options:\n");
                printf("  --corpus PATH         Benchmark all PDFs in directory\n");
                printf("  --output PATH         Save converted markdown output\n");
                printf("  --json PATH          Save results to JSON file\n");
                printf("  --compare PATH       Compare with baseline JSON\n");
                printf("  --iterations N       Number of iterations (default: 1)\n");
                printf("  --memory-profile     Enable detailed memory profiling\n");
                printf("  --verbose            Verbose output\n");
                printf("  --help               Show this help\n\n");
                printf("Examples:\n");
                printf("  pdf22md-benchmark test.pdf\n");
                printf("  pdf22md-benchmark --corpus ./test-pdfs/ --json results.json\n");
                printf("  pdf22md-benchmark --compare baseline.json current.json\n");
                return 0;
            } else if (!corpusPath && ![arg hasPrefix:@"-"]) {
                // Argument is the PDF file
                corpusPath = arg;
            }
        }
        
        if (!corpusPath && !comparePath) {
            fprintf(stderr, "Error: Please specify a PDF file or use --corpus\n");
            fprintf(stderr, "Use --help for usage information\n");
            return 1;
        }
        
        // Set corpus path if single file provided
        if (corpusPath && !benchmark.corpusPath) {
            benchmark.corpusPath = corpusPath;
        }
        
        printf("%s🚀 pdf22md Performance Benchmark v%s%s\n", COLOR_CYAN, VERSION, COLOR_RESET);
        printf("%s════════════════════════════════════════════════════════════════%s\n",
               COLOR_BLUE, COLOR_RESET);
        
        if (comparePath) {
            [benchmark compareWithBaseline:comparePath];
        } else {
            [benchmark runBenchmarks];
            [benchmark printResults];
            
            if (jsonPath) {
                [benchmark saveResultsToJSON:jsonPath];
            }
        }
        
        return 0;
    }
}
</file>

<file path="pdf22md-objc/src/Core/PDF22MDConversionOptions.m">
#import "PDF22MDConversionOptions.h"
#import "PDF22MDError.h"
#import "../../shared/Core/PDF22MDErrorFactory.h"

@implementation PDF22MDConversionOptions

#pragma mark - Initialization

- (instancetype)init {
    self = [super init];
    if (self) {
        // Set default values
        _rasterizationDPI = 144.0;
        _maxConcurrentPages = [[NSProcessInfo processInfo] processorCount];
        _includeMetadata = YES;
        _extractImages = YES;
        _preserveOutline = YES;
        _headingFontSizeThreshold = 2.0;
        _maxHeadingLevel = 6;
    }
    return self;
}

+ (instancetype)defaultOptions {
    return [[self alloc] init];
}

#pragma mark - NSCopying

- (id)copyWithZone:(nullable NSZone *)zone {
    PDF22MDConversionOptions *copy = [[PDF22MDConversionOptions allocWithZone:zone] init];
    
    copy.assetsFolderPath = self.assetsFolderPath;
    copy.rasterizationDPI = self.rasterizationDPI;
    copy.maxConcurrentPages = self.maxConcurrentPages;
    copy.includeMetadata = self.includeMetadata;
    copy.extractImages = self.extractImages;
    copy.preserveOutline = self.preserveOutline;
    copy.headingFontSizeThreshold = self.headingFontSizeThreshold;
    copy.maxHeadingLevel = self.maxHeadingLevel;
    copy.progressHandler = self.progressHandler;
    
    return copy;
}

#pragma mark - Validation

- (BOOL)validateWithError:(NSError * _Nullable * _Nullable)error {
    // Validate DPI
    if (self.rasterizationDPI <= 0 || self.rasterizationDPI > 600) {
        if (error) {
            *error = [PDF22MDErrorFactory invalidDPIErrorWithValue:self.rasterizationDPI];
        }
        return NO;
    }
    
    // Validate concurrent pages
    if (self.maxConcurrentPages < 1 || self.maxConcurrentPages > 64) {
        if (error) {
            *error = [PDF22MDErrorFactory invalidConcurrentPagesErrorWithValue:self.maxConcurrentPages];
        }
        return NO;
    }
    
    // Validate heading level
    if (self.maxHeadingLevel < 1 || self.maxHeadingLevel > 6) {
        if (error) {
            *error = [PDF22MDErrorFactory invalidHeadingLevelErrorWithValue:self.maxHeadingLevel];
        }
        return NO;
    }
    
    // Validate font size threshold
    if (self.headingFontSizeThreshold < 0.5 || self.headingFontSizeThreshold > 10.0) {
        if (error) {
            *error = [PDF22MDErrorFactory invalidFontSizeThresholdErrorWithValue:self.headingFontSizeThreshold];
        }
        return NO;
    }
    
    // Validate assets path if image extraction is enabled
    if (self.extractImages && self.assetsFolderPath) {
        NSFileManager *fileManager = [NSFileManager defaultManager];
        BOOL isDirectory = NO;
        BOOL exists = [fileManager fileExistsAtPath:self.assetsFolderPath isDirectory:&isDirectory];
        
        if (exists && !isDirectory) {
            if (error) {
                *error = [PDF22MDErrorFactory assetCreationErrorWithPath:self.assetsFolderPath
                                                                   reason:@"Path exists but is not a directory"];
            }
            return NO;
        }
    }
    
    return YES;
}

#pragma mark - Description

- (NSString *)description {
    return [NSString stringWithFormat:@"<%@: %p, assets=%@, dpi=%.0f, concurrent=%ld>",
            NSStringFromClass([self class]),
            self,
            self.assetsFolderPath ?: @"<none>",
            self.rasterizationDPI,
            (long)self.maxConcurrentPages];
}

@end

#pragma mark - Builder Implementation

@implementation PDF22MDConversionOptionsBuilder

- (instancetype)init {
    self = [super init];
    if (self) {
        // Initialize with default values
        PDF22MDConversionOptions *defaults = [PDF22MDConversionOptions defaultOptions];
        _rasterizationDPI = defaults.rasterizationDPI;
        _maxConcurrentPages = defaults.maxConcurrentPages;
        _includeMetadata = defaults.includeMetadata;
        _extractImages = defaults.extractImages;
        _preserveOutline = defaults.preserveOutline;
        _headingFontSizeThreshold = defaults.headingFontSizeThreshold;
        _maxHeadingLevel = defaults.maxHeadingLevel;
    }
    return self;
}

- (PDF22MDConversionOptions *)build {
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    
    options.assetsFolderPath = self.assetsFolderPath;
    options.rasterizationDPI = self.rasterizationDPI;
    options.maxConcurrentPages = self.maxConcurrentPages;
    options.includeMetadata = self.includeMetadata;
    options.extractImages = self.extractImages;
    options.preserveOutline = self.preserveOutline;
    options.headingFontSizeThreshold = self.headingFontSizeThreshold;
    options.maxHeadingLevel = self.maxHeadingLevel;
    options.progressHandler = self.progressHandler;
    
    return options;
}

@end
</file>

<file path="pdf22md-objc/src/Core/PDF22MDConverter.m">
#import "PDF22MDConverter.h"
#import "PDF22MDConversionOptions.h"
#import "PDF22MDPageProcessor.h"
#import "../Models/PDF22MDContentElement.h"
#import "../Models/PDF22MDImageElement.h"
#import "../Services/PDF22MDAssetManager.h"
#import "../Services/PDF22MDMarkdownGenerator.h"
#import "PDF22MDFontAnalyzer.h"
#import "PDF22MDError.h"
#import "../../shared/Core/PDF22MDConcurrencyManager.h"

@interface PDF22MDConverter ()
@property (nonatomic, strong) dispatch_queue_t conversionQueue;
@property (nonatomic, strong) NSMutableArray<id<PDF22MDContentElement>> *allElements;
@property (nonatomic, strong) PDF22MDFontAnalyzer *fontAnalyzer;
@property (nonatomic, assign) BOOL isCancelled;
@end

@implementation PDF22MDConverter

#pragma mark - Initialization

- (nullable instancetype)initWithPDFData:(NSData *)pdfData {
    if (!pdfData || pdfData.length == 0) {
        return nil;
    }
    
    PDFDocument *document = [[PDFDocument alloc] initWithData:pdfData];
    if (!document) {
        return nil;
    }
    
    NSURL *tempURL = [NSURL URLWithString:@"data:application/pdf"];
    return [self initWithPDFURL:tempURL document:document];
}

- (nullable instancetype)initWithPDFURL:(NSURL *)pdfURL {
    if (!pdfURL) {
        return nil;
    }
    
    PDFDocument *document = [[PDFDocument alloc] initWithURL:pdfURL];
    if (!document) {
        return nil;
    }
    
    return [self initWithPDFURL:pdfURL document:document];
}

- (nullable instancetype)initWithPDFURL:(nullable NSURL *)pdfURL document:(PDFDocument *)document {
    if (!document) {
        return nil;
    }
    
    self = [super init];
    if (self) {
        _document = document;
        _conversionQueue = [PDF22MDConcurrencyManager sharedConverterQueue];
        _allElements = [NSMutableArray array];
        _fontAnalyzer = [[PDF22MDFontAnalyzer alloc] init];
        _progress = [NSProgress progressWithTotalUnitCount:[document pageCount]];
        _isCancelled = NO;
    }
    return self;
}

#pragma mark - Public Methods

- (void)convertWithOptions:(nullable PDF22MDConversionOptions *)options
                completion:(void (^)(NSString * _Nullable markdown, NSError * _Nullable error))completion {
    // Use default options if none provided
    if (!options) {
        options = [PDF22MDConversionOptions defaultOptions];
    }
    
    // Validate options
    NSError *validationError = nil;
    if (![options validateWithError:&validationError]) {
        completion(nil, validationError);
        return;
    }
    
    // Reset state
    self.isCancelled = NO;
    [self.allElements removeAllObjects];
    [self.fontAnalyzer reset];
    self.progress.completedUnitCount = 0;
    
    // Configure font analyzer
    self.fontAnalyzer.fontSizeThreshold = options.headingFontSizeThreshold;
    self.fontAnalyzer.maxHeadingLevel = options.maxHeadingLevel;
    
    // Perform conversion using shared concurrency manager
    [PDF22MDConcurrencyManager performConverterOperation:^{
        @autoreleasepool {
            NSError *error = nil;
            NSString *markdown = [self performConversionWithOptions:options error:&error];
            
            // Call completion on main queue
            [PDF22MDConcurrencyManager executeOnMainQueue:^{
                completion(markdown, error);
            }];
        }
    } completion:nil];
}

- (void)cancelConversion {
    self.isCancelled = YES;
    [self.progress cancel];
}

- (BOOL)validateDocumentWithError:(NSError * _Nullable * _Nullable)error {
    if (!self.document) {
        if (error) {
            *error = [PDF22MDErrorHelper invalidPDFErrorWithReason:@"Document is nil"];
        }
        return NO;
    }
    
    if ([self.document pageCount] == 0) {
        if (error) {
            *error = [PDF22MDErrorHelper invalidPDFErrorWithReason:@"Document has no pages"];
        }
        return NO;
    }
    
    if ([self.document isLocked]) {
        if (error) {
            *error = [PDF22MDErrorHelper invalidPDFErrorWithReason:@"Document is password protected"];
        }
        return NO;
    }
    
    return YES;
}

#pragma mark - Private Methods

- (nullable NSString *)performConversionWithOptions:(PDF22MDConversionOptions *)options
                                              error:(NSError * _Nullable * _Nullable)error {
    // Validate document
    if (![self validateDocumentWithError:error]) {
        return nil;
    }
    
    NSInteger pageCount = [self.document pageCount];
    
    // Create asset manager if needed
    PDF22MDAssetManager *assetManager = nil;
    if (options.extractImages && options.assetsFolderPath) {
        assetManager = [[PDF22MDAssetManager alloc] initWithAssetFolder:options.assetsFolderPath];
        if (!assetManager) {
            if (error) {
                *error = [PDF22MDErrorHelper assetFolderCreationErrorWithPath:options.assetsFolderPath
                                                                          reason:@"Failed to create asset manager"];
            }
            return nil;
        }
    }
    
    // Process pages in parallel
    NSMutableArray<NSMutableArray<id<PDF22MDContentElement>> *> *pageElementsArray = [NSMutableArray arrayWithCapacity:pageCount];
    NSMutableArray<PDF22MDFontAnalyzer *> *pageFontAnalyzers = [NSMutableArray arrayWithCapacity:pageCount];
    
    for (NSInteger i = 0; i < pageCount; i++) {
        [pageElementsArray addObject:[NSMutableArray array]];
        [pageFontAnalyzers addObject:[[PDF22MDFontAnalyzer alloc] init]];
    }
    
    // Create dispatch group for parallel processing
    dispatch_group_t processingGroup = dispatch_group_create();
    __block BOOL processingFailed = NO;
    __block NSError *processingError = nil;
    
    // Limit concurrency based on options
    dispatch_semaphore_t concurrencySemaphore = dispatch_semaphore_create(options.maxConcurrentPages);
    
    for (NSInteger pageIndex = 0; pageIndex < pageCount; pageIndex++) {
        if (self.isCancelled) {
            if (error) {
                *error = [NSError errorWithDomain:PDF22MDErrorDomain
                                             code:PDF22MDErrorCancelled
                                         userInfo:@{NSLocalizedDescriptionKey: @"Conversion was cancelled"}];
            }
            return nil;
        }
        
        dispatch_group_async(processingGroup, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            dispatch_semaphore_wait(concurrencySemaphore, DISPATCH_TIME_FOREVER);
            
            @autoreleasepool {
                if (!processingFailed && !self.isCancelled) {
                    PDFPage *page = [self.document pageAtIndex:pageIndex];
                    if (!page) {
                        processingFailed = YES;
                        processingError = [PDF22MDErrorHelper pageProcessingFailedErrorForPage:pageIndex
                                                                                        reason:@"Failed to get page"
                                                                               underlyingError:nil];
                    } else {
                        // Process page
                        PDF22MDPageProcessor *processor = [[PDF22MDPageProcessor alloc] initWithPDFPage:page
                                                                                             pageIndex:pageIndex
                                                                                                   dpi:options.rasterizationDPI];
                        processor.fontAnalyzer = pageFontAnalyzers[pageIndex];
                        
                        NSArray<id<PDF22MDContentElement>> *pageElements = [processor extractContentElements];
                        [pageElementsArray[pageIndex] addObjectsFromArray:pageElements];
                        
                        // Analyze fonts for this page
                        [pageFontAnalyzers[pageIndex] analyzeElements:pageElements];
                        
                        // Update progress
                        dispatch_async(dispatch_get_main_queue(), ^{
                            self.progress.completedUnitCount = pageIndex + 1;
                            if (options.progressHandler) {
                                options.progressHandler(pageIndex + 1, pageCount);
                            }
                        });
                    }
                }
            }
            
            dispatch_semaphore_signal(concurrencySemaphore);
        });
    }
    
    // Wait for all pages to complete
    dispatch_group_wait(processingGroup, DISPATCH_TIME_FOREVER);
    
    if (processingFailed) {
        if (error) {
            *error = processingError ?: [PDF22MDErrorHelper processingFailedErrorWithReason:@"Unknown processing error"
                                                                              underlyingError:nil];
        }
        return nil;
    }
    
    if (self.isCancelled) {
        if (error) {
            *error = [NSError errorWithDomain:PDF22MDErrorDomain
                                         code:PDF22MDErrorCancelled
                                     userInfo:@{NSLocalizedDescriptionKey: @"Conversion was cancelled"}];
        }
        return nil;
    }
    
    // Merge results from all pages
    for (NSInteger i = 0; i < pageCount; i++) {
        [self.allElements addObjectsFromArray:pageElementsArray[i]];
        [self.fontAnalyzer mergeFontStatisticsFromAnalyzer:pageFontAnalyzers[i]];
    }
    
    // Analyze font hierarchy and assign heading levels
    [self.fontAnalyzer analyzeElements:self.allElements];
    [self.fontAnalyzer assignHeadingLevels:self.allElements];
    
    // Sort elements by page and position
    [self sortElements];
    
    // Extract and save images if needed
    if (assetManager) {
        [self extractImagesWithAssetManager:assetManager];
    }
    
    // Generate markdown
    PDF22MDMarkdownGenerator *generator = [[PDF22MDMarkdownGenerator alloc] initWithOptions:options];
    PDF22MDDocumentMetadata *metadata = [PDF22MDMarkdownGenerator extractMetadataFromDocument:self.document];
    
    NSString *markdown = [generator generateMarkdownFromElements:self.allElements withMetadata:metadata];
    
    return markdown;
}

- (void)sortElements {
    [self.allElements sortUsingComparator:^NSComparisonResult(id<PDF22MDContentElement> obj1, id<PDF22MDContentElement> obj2) {
        // First sort by page
        if (obj1.pageIndex != obj2.pageIndex) {
            return obj1.pageIndex < obj2.pageIndex ? NSOrderedAscending : NSOrderedDescending;
        }
        
        // Then sort by vertical position (top to bottom)
        CGFloat y1 = CGRectGetMaxY(obj1.bounds);
        CGFloat y2 = CGRectGetMaxY(obj2.bounds);
        
        if (fabs(y1 - y2) > 5.0) { // Tolerance for same line
            return y1 > y2 ? NSOrderedAscending : NSOrderedDescending;
        }
        
        // Finally sort by horizontal position (left to right)
        CGFloat x1 = CGRectGetMinX(obj1.bounds);
        CGFloat x2 = CGRectGetMinX(obj2.bounds);
        
        return x1 < x2 ? NSOrderedAscending : NSOrderedDescending;
    }];
}

- (void)extractImagesWithAssetManager:(PDF22MDAssetManager *)assetManager {
    NSMutableArray<PDF22MDImageElement *> *imageElements = [NSMutableArray array];
    
    for (id<PDF22MDContentElement> element in self.allElements) {
        if ([element isKindOfClass:[PDF22MDImageElement class]]) {
            [imageElements addObject:(PDF22MDImageElement *)element];
        }
    }
    
    if (imageElements.count == 0) {
        return;
    }
    
    // Save images in parallel
    dispatch_group_t imageGroup = dispatch_group_create();
    dispatch_queue_t imageQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    
    [imageElements enumerateObjectsUsingBlock:^(PDF22MDImageElement *imageElement, NSUInteger idx, BOOL * __unused stop) {
        dispatch_group_async(imageGroup, imageQueue, ^{
            @autoreleasepool {
                NSString *baseName = [NSString stringWithFormat:@"image_%03lu", (unsigned long)idx];
                [assetManager saveImageElement:imageElement withBaseName:baseName];
            }
        });
    }];
    
    dispatch_group_wait(imageGroup, DISPATCH_TIME_FOREVER);
}

@end
</file>

<file path="pdf22md-objc/src/Services/PDF22MDAssetManager.m">
#import "PDF22MDAssetManager.h"
#import "../Models/PDF22MDImageElement.h"
#import "../../shared/Algorithms/PDF22MDImageFormatDetection.h"
#import "../../shared/Core/PDF22MDConcurrencyManager.h"
#import <ImageIO/ImageIO.h>

@interface PDF22MDAssetManager ()
@property (nonatomic, strong) NSFileManager *fileManager;
@property (nonatomic, strong) dispatch_queue_t fileAccessQueue;
@property (nonatomic, strong) NSMutableSet<NSString *> *usedFilenames;
@end

@implementation PDF22MDAssetManager

#pragma mark - Initialization

- (nullable instancetype)initWithAssetFolder:(NSString *)folderPath {
    self = [super init];
    if (self) {
        _assetsFolderPath = [folderPath copy];
        _fileManager = [[NSFileManager alloc] init];
        _fileAccessQueue = [PDF22MDConcurrencyManager sharedFileAccessQueue];
        _usedFilenames = [NSMutableSet set];
        
        // Create assets folder if it doesn't exist
        NSError *error = nil;
        BOOL isDirectory = NO;
        BOOL exists = [_fileManager fileExistsAtPath:folderPath isDirectory:&isDirectory];
        
        if (exists && !isDirectory) {
            NSLog(@"Asset path exists but is not a directory: %@", folderPath);
            return nil;
        }
        
        if (!exists) {
            if (![_fileManager createDirectoryAtPath:folderPath
                         withIntermediateDirectories:YES
                                          attributes:nil
                                               error:&error]) {
                NSLog(@"Failed to create assets folder: %@", error);
                return nil;
            }
        }
    }
    return self;
}

#pragma mark - Public Methods

- (nullable NSString *)saveImage:(CGImageRef)image
                  isVectorSource:(BOOL)isVectorSource
                    withBaseName:(NSString *)baseName {
    if (!image) {
        return nil;
    }
    
    // Determine optimal format
    BOOL shouldUseJPEG = [PDF22MDImageFormatDetection shouldUseJPEGForImage:image isVectorSource:isVectorSource];
    
    NSString *extension = shouldUseJPEG ? @"jpg" : @"png";
    NSString *fileName = [self uniqueFilenameForBaseName:baseName withExtension:extension];
    NSString *fullPath = [self.assetsFolderPath stringByAppendingPathComponent:fileName];
    
    // Create destination
    NSURL *fileURL = [NSURL fileURLWithPath:fullPath];
    CGImageDestinationRef destination = CGImageDestinationCreateWithURL(
        (__bridge CFURLRef)fileURL,
        shouldUseJPEG ? (__bridge CFStringRef)@"public.jpeg" : (__bridge CFStringRef)@"public.png",
        1,
        NULL
    );
    
    if (!destination) {
        NSLog(@"Failed to create image destination for %@", fullPath);
        return nil;
    }
    
    // Set compression options
    NSDictionary *properties = nil;
    if (shouldUseJPEG) {
        properties = @{(__bridge NSString *)kCGImageDestinationLossyCompressionQuality: @(0.85)};
    } else {
        // For PNG, we can set compression level
        properties = @{(__bridge NSString *)kCGImagePropertyPNGCompressionFilter: @(1)}; // Best compression
    }
    
    // Add image to destination
    CGImageDestinationAddImage(destination, image, (__bridge CFDictionaryRef)properties);
    
    // Finalize
    BOOL success = CGImageDestinationFinalize(destination);
    CFRelease(destination);
    
    if (!success) {
        NSLog(@"Failed to save image to %@", fullPath);
        return nil;
    }
    
    // Return relative path (just the filename since it's in the assets folder)
    return fileName;
}

- (nullable NSString *)saveImageElement:(PDF22MDImageElement *)imageElement
                           withBaseName:(NSString *)baseName {
    NSString *savedPath = [self saveImage:imageElement.image
                           isVectorSource:imageElement.isVectorSource
                             withBaseName:baseName];
    
    if (savedPath) {
        imageElement.assetRelativePath = savedPath;
    }
    
    return savedPath;
}


- (NSString *)uniqueFilenameForBaseName:(NSString *)baseName
                          withExtension:(NSString *)extension {
    __block NSString *filename = nil;
    
    dispatch_sync(self.fileAccessQueue, ^{
        NSString *candidate = [NSString stringWithFormat:@"%@.%@", baseName, extension];
        NSInteger counter = 1;
        
        // Check if filename is already used
        while ([self.usedFilenames containsObject:candidate] ||
               [self.fileManager fileExistsAtPath:[self.assetsFolderPath stringByAppendingPathComponent:candidate]]) {
            candidate = [NSString stringWithFormat:@"%@_%03ld.%@", baseName, (long)counter, extension];
            counter++;
        }
        
        [self.usedFilenames addObject:candidate];
        filename = candidate;
    });
    
    return filename;
}


@end
</file>

<file path="AGENTS.md">
# pdf22md

A blazingly fast PDF to Markdown converter for macOS.

`pdf22md` is a command-line tool that extracts all text and image content from a PDF file and converts it into a clean Markdown document. It uses Grand Central Dispatch (GCD) to process pages and save images in parallel, making it exceptionally fast for multi-page documents.

### Key Features

  * **High-Speed Conversion**: Uses all available CPU cores to process PDF pages concurrently.
  * **Intelligent Heading Detection**: Analyzes font sizes and usage frequency to automatically format titles and headings (`#`, `##`, etc.).
  * **Asset Extraction**: Saves raster and vector images into a specified assets folder and links them correctly in the Markdown file.
  * **Smart Image Formatting**: Automatically chooses between JPEG (for photos) and PNG (for graphics with transparency) to optimize file size and quality.
  * **Flexible I/O**: Reads from a PDF file or `stdin` and writes to a Markdown file or `stdout`.
  * **Customizable Rasterization**: Allows setting a custom DPI for converting vector graphics to bitmaps.

### Installation

Once the Homebrew tap is set up (see plan below), installation is simple:

```bash
brew install <your-username>/pdf22md/pdf22md
```

### Building from Source

To build the project manually, you need Xcode Command Line Tools installed.

```bash
# Clone the repository (once it's public)
git clone https://github.com/<your-username>/pdf22md.git
cd pdf22md

# Compile the tool
make

# Install it to /usr/local/bin
sudo make install
```

### Usage

```
Usage: pdf22md [-i input.pdf] [-o output.md] [-a assets_folder] [-d dpi]
  Converts PDF documents to Markdown format
  -i <path>: Input PDF file (default: stdin)
  -o <path>: Output Markdown file (default: stdout)
  -a <path>: Assets folder for extracted images
  -d <dpi>: DPI for rasterizing vector graphics (default: 144)
```

**Example:**

```bash
# Convert a local PDF file and save images to an 'assets' folder
pdf22md -i report.pdf -o report.md -a ./assets
```

---


# main-overview

## Development Guidelines

- Only modify code directly relevant to the specific request. Avoid changing unrelated functionality.
- Never replace code with placeholders like `# ... rest of the processing ...`. Always include complete code.
- Break problems into smaller steps. Think through each step separately before implementing.
- Always provide a complete PLAN with REASONING based on evidence from code and logs before making changes.
- Explain your OBSERVATIONS clearly, then provide REASONING to identify the exact issue. Add console logs when needed to gather more information.


pdf22md is a PDF to Markdown converter that transforms PDF documents while preserving their semantic structure and content relationships.

Core Business Components:

1. Document Structure Analysis (Importance: 95)
- Hierarchical heading detection using font statistics
- Document structure preservation through positional element sorting
- Automated heading level assignment (H1-H6) based on font usage patterns

2. Content Classification System (Importance: 85)
- TextElement: Handles formatted text with style attributes
- ImageElement: Manages both raster and vector graphics
- Content relationship tracking between elements

3. Asset Processing Pipeline (Importance: 80)
- Intelligent format selection between PNG/JPEG based on:
  * Transparency detection
  * Color complexity analysis
  * Dimension-based optimization
- Asset extraction with maintained document references

4. PDF Content Processing (Importance: 90)
- Text styling and formatting context preservation
- Vector graphics path construction tracking
- Coordinate system transformation management
- Element bounds calculation for layout fidelity

Key Integration Points:

1. Content Extraction Layer
- Connects PDF parsing with markdown generation
- Maintains element relationships and hierarchy
- Preserves formatting context across transformations

2. Asset Management Layer
- Links extracted images with markdown references
- Maintains asset organization structure
- Handles format conversions while preserving quality

The system organizes business logic around content transformation pipelines while maintaining document semantic structure throughout the conversion process.

—— When you’re done with a round of updates, update CHANGELOG.md with the changes, remove done things from TODO.md, identify new things that need to be done and add them to TODO.md. Then build the app or run ./release.sh and then continue updates.
</file>

<file path="build.sh">
#!/bin/bash

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Print functions
print_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
print_warning() { echo -e "${YELLOW}[WARN]${NC} $1"; }
print_error() { echo -e "${RED}[ERROR]${NC} $1"; }
print_header() { echo -e "${BLUE}[BUILD]${NC} $1"; }

# Track build results
build_results_objc=0
build_results_swift=0

# Check for required tools
check_requirements() {
    local missing_tools=()

    if ! command -v clang &>/dev/null; then
        missing_tools+=("clang")
    fi

    if ! command -v swift &>/dev/null; then
        missing_tools+=("swift")
    fi

    if ! command -v make &>/dev/null; then
        missing_tools+=("make")
    fi

    if [ ${#missing_tools[@]} -ne 0 ]; then
        print_error "Missing required tools: ${missing_tools[*]}"
        print_info "Please install Xcode Command Line Tools:"
        print_info "xcode-select --install"
        exit 1
    fi
}

# Build pdf22md-objc
build_objc() {
    print_header "Building pdf22md-objc..."
    
    if [ ! -d "pdf22md-objc" ]; then
        print_error "pdf22md-objc directory not found"
        build_results_objc=1
        return 1
    fi
    
    # Build using unified Makefile
    if make clean && make; then
        print_info "✓ pdf22md-objc built successfully"
        build_results_objc=0
        
        # Run tests if requested
        if [ "$RUN_TESTS" = "true" ]; then
            if make test; then
                print_info "✓ Tests passed"
            else
                print_warning "Tests failed, but build completed"
            fi
        fi
        
        # Install if requested
        if [ "$INSTALL_BINARIES" = "true" ]; then
            if sudo make install; then
                print_info "✓ Installation completed"
            else
                print_error "Installation failed"
                build_results_objc=1
            fi
        fi
    else
        print_error "✗ pdf22md-objc build failed"
        build_results_objc=1
    fi
    return $build_results_objc
}

# Build pdf22md-swift
build_swift() {
    print_header "Building pdf22md-swift..."
    
    if [ ! -d "pdf22md-swift" ]; then
        print_error "pdf22md-swift directory not found"
        build_results_swift=1
        return 1
    fi
    
    # Check if Swift toolchain is functional before attempting build
    if ! swift --version >/dev/null 2>&1; then
        print_error "Swift toolchain appears to be corrupted or missing"
        print_warning "Skipping Swift build. Install/repair Xcode Command Line Tools:"
        print_info "  xcode-select --install"
        build_results_swift=1
        return 1
    fi
    
    # Check for Swift Package Manager functionality
    if ! swift package --version >/dev/null 2>&1; then
        print_error "Swift Package Manager is not functional"
        print_warning "This is often due to missing SWBBuildService.framework"
        print_info "Possible solutions:"
        print_info "  1. Run: xcode-select --install"
        print_info "  2. If you have Xcode installed: sudo xcode-select -s /Applications/Xcode.app"
        print_info "  3. Reinstall Command Line Tools completely:"
        print_info "     sudo rm -rf /Library/Developer/CommandLineTools"
        print_info "     xcode-select --install"
        build_results_swift=1
        return 1
    fi
    
    cd pdf22md-swift
    
    # Build with options
    local build_cmd="./build.sh"
    if [ "$RUN_TESTS" = "true" ]; then
        build_cmd="$build_cmd --test"
    fi
    if [ "$INSTALL_BINARIES" = "true" ]; then
        build_cmd="$build_cmd --install"
    fi
    
    if $build_cmd; then
        print_info "✓ pdf22md-swift built successfully"
        build_results_swift=0
    else
        print_error "✗ pdf22md-swift build failed"
        print_warning "Swift toolchain may be corrupted. Try:"
        print_info "  xcode-select --install"
        build_results_swift=1
    fi
    
    cd ..
    return $build_results_swift
}

# Create release archives
create_releases() {
    print_header "Creating release archives..."
    
    # Create Swift release
    if [ $build_results_swift -eq 0 ]; then
        cd pdf22md-swift
        if ./release.sh; then
            print_info "✓ Swift release archive created"
        else
            print_warning "Swift release archive creation failed"
        fi
        cd ..
    fi
    
    # Create Objective-C release (manual process since no release.sh)
    if [ $build_results_objc -eq 0 ]; then
        print_info "Objective-C binary available at: pdf22md-objc/pdf22md"
    fi
}

# Show build summary
show_summary() {
    print_header "Build Summary"
    
    local total_success=0
    local total_builds=0
    
    if [ "$BUILD_OBJC" = "true" ]; then
        total_builds=$((total_builds + 1))
        if [ $build_results_objc -eq 0 ]; then
            print_info "✓ pdf22md-objc: SUCCESS"
            total_success=$((total_success + 1))
        else
            print_error "✗ pdf22md-objc: FAILED"
        fi
    fi
    
    if [ "$BUILD_SWIFT" = "true" ]; then
        total_builds=$((total_builds + 1))
        if [ $build_results_swift -eq 0 ]; then
            print_info "✓ pdf22md-swift: SUCCESS"
            total_success=$((total_success + 1))
        else
            print_error "✗ pdf22md-swift: FAILED"
        fi
    fi
    
    echo ""
    if [ $total_success -eq $total_builds ]; then
        print_info "🎉 All builds completed successfully! ($total_success/$total_builds)"
        
        if [ "$INSTALL_BINARIES" = "true" ]; then
            echo ""
            print_info "Installed binaries:"
            if [ $build_results_objc -eq 0 ]; then
                print_info "  - pdf22md (Objective-C implementation)"
            fi
            if [ $build_results_swift -eq 0 ]; then
                print_info "  - pdf22md-swift (Swift implementation)"
            fi
            print_info "Run 'man pdf22md' for usage information"
        else
            echo ""
            print_info "Built binaries:"
            if [ $build_results_objc -eq 0 ]; then
                print_info "  - pdf22md-objc/pdf22md"
            fi
            if [ $build_results_swift -eq 0 ]; then
                print_info "  - pdf22md-swift/.build/release/pdf22md"
            fi
        fi
    else
        print_error "Some builds failed ($total_success/$total_builds successful)"
        exit 1
    fi
}

# Show usage information
show_usage() {
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  --test              Run tests after building"
    echo "  --install           Install binaries to /usr/local/bin"
    echo "  --release           Create release archives"
    echo "  --objc-only         Build only Objective-C implementation"
    echo "  --swift-only        Build only Swift implementation"
    echo "  --help              Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0                  # Build both implementations"
    echo "  $0 --test           # Build and test both implementations"
    echo "  $0 --install        # Build and install both implementations"
    echo "  $0 --test --install # Build, test, and install both implementations"
    echo "  $0 --objc-only      # Build only Objective-C implementation"
    echo "  $0 --release        # Build both and create release archives"
}

# Parse command line arguments
parse_args() {
    RUN_TESTS=false
    INSTALL_BINARIES=false
    CREATE_RELEASES=false
    BUILD_OBJC=true
    BUILD_SWIFT=true
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --test)
                RUN_TESTS=true
                shift
                ;;
            --install)
                INSTALL_BINARIES=true
                shift
                ;;
            --release)
                CREATE_RELEASES=true
                shift
                ;;
            --objc-only)
                BUILD_OBJC=true
                BUILD_SWIFT=false
                shift
                ;;
            --swift-only)
                BUILD_OBJC=false
                BUILD_SWIFT=true
                shift
                ;;
            --help)
                show_usage
                exit 0
                ;;
            *)
                print_error "Unknown option: $1"
                show_usage
                exit 1
                ;;
        esac
    done
}

# Main execution
main() {
    parse_args "$@"
    
    print_header "pdf22md - Multi-Implementation Build System"
    print_info "Building$([ "$BUILD_OBJC" = "true" ] && echo " Objective-C")$([ "$BUILD_SWIFT" = "true" ] && echo " Swift") implementation$([ "$BUILD_OBJC" = "true" ] && [ "$BUILD_SWIFT" = "true" ] && echo "s")"
    
    # Check requirements
    check_requirements
    
    # Build implementations
    if [ "$BUILD_OBJC" = "true" ]; then
        build_objc
    fi
    
    if [ "$BUILD_SWIFT" = "true" ]; then
        build_swift
        # If Swift fails and we're building both, suggest continuing with Objective-C only
        if [ $build_results_swift -ne 0 ] && [ "$BUILD_OBJC" = "true" ] && [ $build_results_objc -eq 0 ]; then
            print_warning "Swift build failed but Objective-C build succeeded"
            print_info "The Objective-C implementation is fully functional"
        fi
    fi
    
    # Create releases if requested
    if [ "$CREATE_RELEASES" = "true" ]; then
        create_releases
    fi
    
    # Show summary
    show_summary
}

main "$@"
</file>

<file path="README.md">
# pdf22md

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![macOS](https://img.shields.io/badge/macOS-10.15+-blue.svg)](https://www.apple.com/macos/)
[![Build Status](https://github.com/twardoch/pdf22md/workflows/Build%20and%20Release/badge.svg)](https://github.com/twardoch/pdf22md/actions)

A blazingly fast PDF to Markdown converter for macOS.

`pdf22md` is a command-line tool that extracts all text and image content from a PDF file and converts it into a clean Markdown document. It uses Grand Central Dispatch (GCD) to process pages and save images in parallel, making it exceptionally fast for multi-page documents.

## Architecture

pdf22md is built with modern Objective-C and Swift implementations:

- **pdf22md-objc/**: Modern Objective-C implementation with thread-safe design, nullability annotations, and modular architecture
- **pdf22md-swift/**: Modern Swift implementation with async/await and structured concurrency

### Core Components

```
pdf22md/
├── pdf22md-objc/src/
│   ├── Core/                    # Core conversion logic
│   │   ├── PDF22MDConverter     # Main coordinator
│   │   ├── PDF22MDPageProcessor # Page content extraction
│   │   ├── PDF22MDFontAnalyzer  # Heading detection
│   │   └── PDF22MDError         # Error handling
│   ├── Models/                  # Data models
│   │   ├── PDF22MDTextElement   # Text content
│   │   └── PDF22MDImageElement  # Image content
│   ├── Services/                # Business logic services
│   │   ├── PDF22MDAssetManager  # Image extraction/saving
│   │   └── PDF22MDMarkdownGenerator # Markdown generation
│   └── CLI/                     # Command-line interface
├── pdf22md-swift/               # Swift implementation
└── shared/                      # Common utilities and protocols
```

## Key Features

- **High-Speed Conversion**: Uses all available CPU cores to process PDF pages concurrently
- **Intelligent Heading Detection**: Analyzes font sizes and usage frequency to automatically format titles and headings (`#`, `##`, etc.)
- **Asset Extraction**: Saves raster and vector images into a specified assets folder and links them correctly in the Markdown file
- **Smart Image Formatting**: Automatically chooses between JPEG (for photos) and PNG (for graphics with transparency) to optimize file size and quality
- **Flexible I/O**: Reads from a PDF file or `stdin` and writes to a Markdown file or `stdout`
- **Customizable Rasterization**: Allows setting a custom DPI for converting vector graphics to bitmaps

## Installation

### Using Homebrew (Coming Soon)

```bash
brew tap twardoch/pdf22md
brew install pdf22md
```

### Building from Source

To build the project manually, you need Xcode Command Line Tools installed.

#### Quick Start - Build Everything
```bash
# Clone the repository
git clone https://github.com/twardoch/pdf22md.git
cd pdf22md

# Build both implementations
./build.sh

# Build, test, and install both implementations
./build.sh --test --install

# Build and create release archives
./build.sh --release
```

#### Build Script Options
```bash
./build.sh                    # Build both implementations
./build.sh --test             # Build and test both implementations  
./build.sh --install          # Build and install both to /usr/local/bin
./build.sh --test --install   # Build, test, and install both
./build.sh --objc-only        # Build only Objective-C implementation
./build.sh --swift-only       # Build only Swift implementation
./build.sh --release          # Build both and create release archives
./build.sh --help             # Show all options
```

#### Building Individual Implementations

Each implementation can also be built independently:

**Objective-C Implementation:**
```bash
cd pdf22md-objc
./build.sh                    # Build only
./build.sh --test             # Build and test
./build.sh --install          # Build and install to /usr/local/bin/pdf22md
```

**Swift Implementation:**
```bash
cd pdf22md-swift
./build.sh                    # Build only
./build.sh --test             # Build and test
./build.sh --install          # Build and install to /usr/local/bin/pdf22md-swift
./release.sh                  # Create release archive
```

### Download Pre-built Binary

Pre-built binaries are available from the [Releases](https://github.com/twardoch/pdf22md/releases) page.

## Usage

```
Usage: pdf22md [-i input.pdf] [-o output.md] [-a assets_folder] [-d dpi]
  Converts PDF documents to Markdown format
  -i <path>: Input PDF file (default: stdin)
  -o <path>: Output Markdown file (default: stdout)
  -a <path>: Assets folder for extracted images
  -d <dpi>: DPI for rasterizing vector graphics (default: 144)
```

### Examples

```bash
# Convert a PDF file to Markdown
pdf22md -i document.pdf -o document.md

# Convert with images saved to an 'assets' folder
pdf22md -i report.pdf -o report.md -a ./assets

# Convert with custom DPI for vector graphics
pdf22md -i presentation.pdf -o presentation.md -a ./images -d 300

# Use with pipes
cat document.pdf | pdf22md > document.md

# Convert and view in less
pdf22md -i manual.pdf | less
```

## Requirements

- macOS 10.15 (Catalina) or later
- Xcode Command Line Tools (for building from source)

## Project Structure

```
pdf22md/
├── src/                    # Source code
│   ├── main.m             # Entry point
│   ├── PDFMarkdownConverter.*  # Main conversion logic
│   ├── PDFPageProcessor.*      # PDF page processing
│   ├── ContentElement.*        # Content element definitions
│   └── AssetExtractor.*        # Image extraction logic
├── docs/                   # Additional documentation
├── test/                   # Test files
├── LICENSE                 # MIT License
├── Makefile               # Build configuration
└── README.md              # This file
```

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request. For major changes, please open an issue first to discuss what you would like to change.

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/AmazingFeature`)
3. Commit your changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Acknowledgments

- Built with Apple's PDFKit and Core Graphics frameworks
- Parallel processing powered by Grand Central Dispatch (GCD)
- Inspired by the need for fast, accurate PDF to Markdown conversion

## Related Projects

- [pdfplumber](https://github.com/jsvine/pdfplumber) - Python library for PDF processing
- [pdf2md](https://github.com/axllent/pdf2md) - Another PDF to Markdown converter
- [pandoc](https://pandoc.org/) - Universal document converter

## Changelog

See [CHANGELOG.md](CHANGELOG.md) for a list of changes in each version.

## Support

If you encounter any issues or have questions, please [open an issue](https://github.com/twardoch/pdf22md/issues/new/choose) on GitHub.
</file>

<file path="Makefile">
CC = clang
CFLAGS = -Wall -Wextra -O2 -fobjc-arc
FRAMEWORKS = -framework Foundation -framework PDFKit -framework CoreGraphics -framework ImageIO -framework CoreServices
TARGET = pdf22md

# Version from git tag or fallback
VERSION ?= $(shell git describe --tags --always --dirty 2>/dev/null || echo "dev")

# Define directories
SRC_DIR = pdf22md-objc/src
BUILD_DIR = build

# Source and object files - look in all subdirectories, exclude benchmark
SOURCES = $(filter-out $(BENCHMARK_SRC),$(wildcard $(SRC_DIR)/*/*.m $(SRC_DIR)/*/*/*.m))
SHARED_SOURCES = $(wildcard shared/*/*.m shared/*/*/*.m)
ALL_SOURCES = $(SOURCES) $(SHARED_SOURCES)
OBJECTS = $(patsubst $(SRC_DIR)/%.m,$(BUILD_DIR)/%.o,$(SOURCES)) $(patsubst shared/%.m,$(BUILD_DIR)/shared/%.o,$(SHARED_SOURCES))

# Default prefix for installation
PREFIX ?= /usr/local

# Additional targets
BENCHMARK = pdf22md-benchmark
BENCHMARK_SRC = pdf22md-objc/src/CLI/pdf22md-benchmark.m

all: $(BUILD_DIR) $(TARGET)

$(BUILD_DIR):
	mkdir -p $(BUILD_DIR)

$(TARGET): $(OBJECTS)
	$(CC) $(CFLAGS) $(FRAMEWORKS) -o $(TARGET) $(OBJECTS)

$(BUILD_DIR)/%.o: $(SRC_DIR)/%.m | $(BUILD_DIR)
	@mkdir -p $(dir $@)
	$(CC) $(CFLAGS) -DVERSION=\"$(VERSION)\" -I$(SRC_DIR) -Ishared -c $< -o $@

$(BUILD_DIR)/shared/%.o: shared/%.m | $(BUILD_DIR)
	@mkdir -p $(dir $@)
	$(CC) $(CFLAGS) -DVERSION=\"$(VERSION)\" -I$(SRC_DIR) -Ishared -c $< -o $@

clean:
	rm -rf $(BUILD_DIR) $(TARGET) $(BENCHMARK)

install: $(TARGET)
	install -d $(DESTDIR)$(PREFIX)/bin
	install -m 755 $(TARGET) $(DESTDIR)$(PREFIX)/bin/
	install -d $(DESTDIR)$(PREFIX)/share/man/man1
	install -m 644 pdf22md-objc/docs/pdf22md.1 $(DESTDIR)$(PREFIX)/share/man/man1/

uninstall:
	rm -f $(DESTDIR)$(PREFIX)/bin/$(TARGET)
	rm -f $(DESTDIR)$(PREFIX)/share/man/man1/pdf22md.1

# Testing
test: $(BUILD_DIR)
	@echo "🧪 Running pdf22md test suite..."
	@./run-tests.sh

test-unit: $(BUILD_DIR)
	@echo "🔬 Running unit tests..."
	@mkdir -p build/tests
	@for test in Tests/Unit/*.m; do \
		if [ -f "$$test" ]; then \
			echo "  Building $$test..."; \
			test_name=$$(basename "$$test" .m); \
			$(CC) $(CFLAGS) $(FRAMEWORKS) -Isrc \
				"$$test" src/Core/*.m src/Models/*.m src/Services/*.m \
				-o "build/tests/$$test_name" && \
			echo "  ✓ Compiled $$test_name" || echo "  ✗ Failed to compile $$test_name"; \
		fi; \
	done

test-integration: $(BUILD_DIR)
	@echo "🔬 Running integration tests..."
	@mkdir -p build/tests
	@for test in Tests/Integration/*.m; do \
		if [ -f "$$test" ]; then \
			echo "  Building $$test..."; \
			test_name=$$(basename "$$test" .m); \
			$(CC) $(CFLAGS) $(FRAMEWORKS) -Isrc \
				"$$test" src/Core/*.m src/Models/*.m src/Services/*.m \
				-o "build/tests/$$test_name" && \
			echo "  ✓ Compiled $$test_name" || echo "  ✗ Failed to compile $$test_name"; \
		fi; \
	done

test-clean:
	@echo "🧹 Cleaning test artifacts..."
	@rm -rf build/tests Tests/Resources/*.pdf

# Build benchmark tool
$(BUILD_DIR)/CLI/pdf22md-benchmark.o: $(BENCHMARK_SRC) | $(BUILD_DIR)
	@mkdir -p $(dir $@)
	$(CC) $(CFLAGS) -DVERSION=\"$(VERSION)\" -I$(SRC_DIR) -c $< -o $@

$(BENCHMARK): $(BUILD_DIR) $(BUILD_DIR)/CLI/pdf22md-benchmark.o $(filter-out $(BUILD_DIR)/CLI/main.o, $(OBJECTS))
	@echo "🔨 Building benchmark tool..."
	$(CC) $(CFLAGS) $(FRAMEWORKS) -o $(BENCHMARK) \
		$(BUILD_DIR)/CLI/pdf22md-benchmark.o \
		$(filter-out $(BUILD_DIR)/CLI/main.o, $(OBJECTS))

# Benchmark and profiling
benchmark: $(BENCHMARK)
	@echo "📊 Running performance benchmarks..."
	@mkdir -p test/benchmark
	@if [ -f test/README.pdf ]; then \
		./$(BENCHMARK) --corpus test/ --json benchmark-results.json --iterations 3; \
	else \
		echo "⚠️  No test PDFs found. Add PDFs to test/ directory"; \
		echo "Creating sample benchmark..."; \
		./$(BENCHMARK) --help; \
	fi

memory-check: $(TARGET)
	@echo "🔍 Running memory leak detection..."
	@echo "Note: Install Xcode and run 'leaks' command manually for detailed analysis"
	@echo "Basic memory test with multiple conversions..."
	@for i in 1 2 3 4 5; do \
		echo "  Conversion $$i..."; \
		./$(TARGET) -i test/README.pdf -o /tmp/test_$$i.md; \
	done
	@echo "Memory test complete. Monitor Activity Monitor for memory usage."

.PHONY: all clean install uninstall test test-unit test-integration test-clean benchmark memory-check
</file>

<file path="CHANGELOG.md">
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added
- Comprehensive streamlining plan (PLAN.md) for codebase optimization
- Unified build system using single Makefile and build.sh script
- Shared component library (shared/ directory) for common algorithms
- PDF22MDImageFormatDetection utility for optimal image format selection
- Unified test resource directory (shared/test-resources/) for all implementations
- **PDF22MDErrorFactory**: Unified error creation factory eliminating error handling duplication across 9+ files with specialized methods for configuration, file system, and processing errors
- **PDF22MDConcurrencyManager**: Standardized GCD patterns and queue management for consistent concurrency across implementations with shared queues and parallel processing utilities
- **Complete Modern Objective-C Implementation**: Full feature-parity rewrite in modern Objective-C with nullability annotations, lightweight generics, and proper designated initializers
- **Complete Swift Implementation**: Modern Swift implementation with async/await, actors, and Swift Package Manager support
- **Multi-Implementation Architecture**: Three implementations (C/ObjC, Modern ObjC, Swift) for different use cases and platform requirements
- **Advanced Error Handling**: Custom error domains and comprehensive error reporting across all implementations
- **Thread-Safe Asset Management**: Concurrent image processing with proper synchronization
- **Modern Build Infrastructure**: Support for both Makefile and Xcode/SPM build systems
- TROUBLESHOOTING.md documentation for common build and runtime issues
- Enhanced Swift toolchain detection in build scripts
- Better error messages for SWBBuildService.framework missing issue
- pdf22md-benchmark utility for performance testing
- Builder pattern for PDF22MDConversionOptions configuration
- Verbose logging options for PDF loading and conversion processes
- Timeout handling for conversion process to prevent hangs
- Comprehensive test data with sample PDFs and expected output
- Semantic versioning support based on git tags
- Version display option (-v, -V) in the command-line tool
- Release automation script (release.sh) for macOS
- GitHub Actions workflow for automated releases
- Package installer (.pkg) generation for macOS

### Changed
- Restructured project with separate directories for each implementation (pdf22md-objc, pdf22md-swift)
- Moved test files and resources to implementation-specific directories
- Updated object file compilation commands in build scripts

### Improved
- Build scripts now provide clearer guidance when Swift toolchain is corrupted
- Swift build failures are handled more gracefully with specific remediation steps
- Build process for pdf22md-objc to resolve duplicate symbol errors
- Error reporting now includes process IDs for easier debugging
- Conversion feedback with detailed status messages during operations

### Fixed
- Duplicate symbol errors in pdf22md-objc build process
- Build script compatibility issues with object file handling
- PDF processing hang issue with timeout implementation
- Memory leaks in asset management

### Removed
- Legacy archived-old-implementation directory (2,000+ lines of obsolete code)
- Duplicate build scripts (pdf22md-objc/build.sh, release.sh, run-tests.sh)
- Duplicate README files and documentation
- Duplicate PARALLEL_PROCESSING.md files across implementations
- Resolved issue files (102, 201) after fixing Swift toolchain problems
- Obsolete pdf22md-benchmark binary file from version control
- **210+ duplicate test images** across 3 implementations (58MB saved)
- **Duplicate PDF test files** across implementations
- **Duplicate man pages** from implementation directories
- **Duplicate Swift build scripts** (pdf22md-swift/build.sh, release.sh)

### Streamlined
- Consolidated build system into single authoritative Makefile and build.sh
- Unified documentation in single root README.md
- Removed code duplication between root and implementation directories
- Extracted image format detection algorithm into shared utility (~100 lines deduplicated)
- Build system automatically compiles shared components with proper dependencies
- **Error handling patterns**: Replaced manual NSError creation with standardized factory methods across all validation and processing code (40-60% reduction in error handling boilerplate)
- **Concurrency patterns**: Unified GCD usage with shared queue management and standardized parallel processing patterns (eliminated duplicate queue creation across 4+ files)
- **Shared component architecture**: Established professional foundation with Core/ directory containing ErrorFactory and ConcurrencyManager utilities
- **Test resource consolidation**: Single shared/test-resources/ directory (58MB space saved)
- **Documentation consolidation**: Single man page source (docs/pdf22md.1)
- **Build script unification**: No implementation-specific build scripts
- Universal binary support (Intel and Apple Silicon)
- Man page generation in release packages
- MIT License file for open-source compliance
- GitHub issue templates for bug reports and feature requests
- Comprehensive .gitignore file with proper exclusions
- Build directory structure to separate source from build artifacts
- CHANGELOG.md to track version history
- Professional project documentation standards

### Changed
- **Architectural Modernization**: Complete rewrite of core components using modern Objective-C and Swift patterns
- **Enhanced Font Analysis**: Improved heading detection algorithm with configurable thresholds
- **Robust Asset Processing**: Smart image format selection with transparency detection and quality optimization
- **Memory Management**: Enhanced memory efficiency with proper autorelease pool usage and actor-based resource management (Swift)
- Makefile now supports VERSION variable for build-time versioning
- Makefile now uses a dedicated `build/` directory for object files
- .gitignore updated to properly exclude build artifacts and editor files
- GitHub Actions workflow fixed to use correct binary name
- Project structure reorganized following professional standards

### Fixed
- **Critical Build Issues**: Resolved all compilation errors in modern Objective-C implementation including:
  - Fixed designated initializer chain issues
  - Resolved private instance variable access violations  
  - Fixed NSValue CGRect compatibility issues using NSData approach
  - Corrected deprecated UTType constant usage
  - Fixed method signature mismatches and unused variable warnings
- **Memory Safety**: All CGImageRef memory leaks resolved with proper resource management
- **Concurrency Issues**: Thread-safe operations with proper GCD usage and Swift actor patterns
- Build artifacts (.o files) no longer pollute the repository root
- GitHub Actions workflow now correctly references the pdf22md binary
- Make variable in .gitignore replaced with actual filename
- Removed all DEBUG logging statements from production code
- Fixed CLI deadlock caused by main-queue dispatch in `PDFMarkdownConverter`; completions now called directly
- Fixed hanging issue on certain malformed PDFs by replacing low-level CGPDFScanner-based extraction with PDFKit high-level API (see `PDFPageProcessor`)
- Removed unused CGPDFScanner operator callback functions and PDFScannerState struct that were part of the deprecated implementation
- Fixed segmentation fault during asset extraction (Phase 1a): removed premature CGImageRelease calls in `PDFPageProcessor` that deallocated images still in use
- **Build Script Compatibility**: Fixed bash incompatibility in build.sh by replacing `declare -A` associative arrays with simple variables for broader shell compatibility
- **Swift Build Resilience**: Enhanced build.sh with Swift toolchain health checks and graceful fallback handling when Swift toolchain is corrupted
- **Comprehensive Testing Infrastructure**: Implemented complete test framework with unit tests, integration tests, and working test runner for MVP 1.0 readiness
  - Created PDF22MDConverterTests.m for core conversion logic validation
  - Created PDF22MDAssetManagerTests.m for image extraction and management testing
  - Created PDF22MDFontAnalyzerTests.m for heading detection algorithm validation
  - Created EndToEndConversionTests.m for complete pipeline testing
  - Created SimpleConverterTest.m working test executable proving framework functionality
- **Enhanced Error Handling System**: Expanded error definitions with user-friendly messages and actionable suggestions
  - Added 8 specific error codes including encrypted PDF, memory pressure, and processing timeout
  - Implemented PDF22MDErrorHelper with comprehensive user-friendly error messages
  - Added actionable recovery suggestions for all error conditions (e.g., "Try opening in another PDF viewer to verify it's not corrupted")
  - Fixed API compatibility issues in error method naming

### Removed
- Object files from repository root (moved to build directory)

## [1.0.0] - 2024-01-01

### Added
- Initial release of pdf22md
- PDF to Markdown conversion with parallel processing
- Intelligent heading detection based on font size analysis
- Asset extraction with smart image format selection (JPEG/PNG)
- Support for both file and stdin/stdout I/O
- Customizable DPI for vector graphics rasterization
- Grand Central Dispatch (GCD) for multi-core performance
- Comprehensive documentation
</file>

<file path="TODO.md">
# TODO - Phase 4: Advanced Organization & Final Polish

## 🎯 Mission: Achieve 100% Streamlining Excellence

Complete the transformation to a zero-duplication, professionally organized codebase with shared components and unified tooling.

## 🏆 **MASSIVE ACHIEVEMENTS ACCOMPLISHED**

### ✅ **Phase 1-3 Complete: Foundation, Organization & Polish**
- **Removed 31,000+ lines of duplicate/legacy code** (exceeded goal by 6x!)
- **Eliminated 58MB of duplicate test resources** (87MB → 29MB)  
- **Unified build system** with single Makefile and build.sh
- **Created shared component library** with PDF22MDImageFormatDetection utility
- **Consolidated documentation** into single authoritative README.md
- **Zero duplicate test resources** across implementations
- **Professional directory structure** established

**Current State:** 97% streamlined, professional codebase with shared component infrastructure established

## 📋 **Phase 4: Advanced Organization Tasks**

### Core Infrastructure Enhancement 🎯 **HIGHEST IMPACT**
- [x] Create shared/Core/PDF22MDErrorFactory for unified error handling ✅ **COMPLETED**
- [x] Implement shared/Core/PDF22MDConcurrencyManager for standardized GCD patterns ✅ **COMPLETED**
- [ ] Build shared/Core/PDF22MDFileSystemUtils for common file operations
- [ ] Extract shared/Core/PDF22MDConstants for configuration management

### Testing Framework Unification
- [ ] Create shared/Testing/PDF22MDTestCase base class for test consolidation
- [ ] Implement shared/Testing/PDF22MDTestResourceManager for unified test data access
- [ ] Build cross-implementation validation tests for consistency verification
- [ ] Integrate performance testing into main test suite

### Build System Enhancement
- [ ] Enhance build.sh with full Swift Package Manager integration
- [ ] Create shared/Build/framework-dependencies.mk for dependency management
- [ ] Implement unified testing commands (make test-all, test-objc, test-swift)
- [ ] Add automated cross-implementation validation

### Final Directory Structure Optimization
- [ ] Move pdf22md-objc/ to implementations/objc/
- [ ] Move pdf22md-swift/ to implementations/swift/
- [ ] Create tools/ directory for unified build scripts
- [ ] Establish shared/Build/ for build configuration

## 🏗️ **Phase 5: Production Readiness (Future)**

### Performance & Quality
- [ ] Memory management optimization with standardized autorelease pool usage
- [ ] Unified logging system with log levels and categories  
- [ ] Performance regression testing framework
- [ ] Code coverage measurement and reporting

### Developer Experience
- [ ] Automated setup script for new contributors
- [ ] Unified documentation generation system
- [ ] IDE integration improvements (Xcode project generation)
- [ ] Continuous integration enhancement

## 🎯 **Success Metrics**

### Phase 4 Goals
- [ ] **Zero error handling duplication** (shared error factory)
- [ ] **Standardized concurrency patterns** across all components
- [ ] **Unified testing framework** with cross-implementation validation
- [ ] **Professional project structure** with implementations/ organization
- [ ] **100% streamlining completion** achieved

### Quality Benchmarks
- [x] **Maintainability**: Single location updates ✅
- [x] **Professional Organization**: Clean structure ✅  
- [x] **Developer Experience**: Single entry point ✅
- [x] **Zero Test Duplication**: Shared resources ✅
- [ ] **Zero Code Duplication**: Complete elimination of redundant patterns
- [ ] **Production Ready**: Professional open-source project structure

## 📊 **Progress Tracking**

**Overall Completion**: 97% → **Target: 100%**

- ✅ **Legacy Cleanup**: 100% (Complete)
- ✅ **Build System**: 95% (Swift integration pending)
- ✅ **Test Resources**: 100% (Consolidated)
- ✅ **Documentation**: 100% (Unified)
- ✅ **Error Handling**: 100% (Factory pattern implemented) ✅
- ✅ **Concurrency**: 100% (Standardization completed) ✅
- ❌ **Directory Structure**: 85% (Final reorganization pending)

**Current Phase**: Phase 4 - Advanced Organization  
**Next Milestone**: 100% streamlining, zero duplication  
**Timeline**: Complete Phase 4 within 2 weeks

## 🚀 **Implementation Strategy**

1. **Start with Error Factory** (highest impact, touches 9+ files)
2. **Standardize concurrency patterns** (affects 3 major components)
3. **Create testing framework base** (consolidates 8 test files)
4. **Final directory reorganization** (professional structure)

## 🎯 **Expected Final Results**

**After Phase 4 Completion:**
- **40,000+ total lines removed** through complete streamlining
- **Zero algorithm/pattern duplication** across implementations
- **Professional open-source project structure**
- **Unified development workflow** (build/test/release)
- **Cross-implementation validation** ensuring consistency
- **Foundation for community contribution**

---

*The pdf22md project transformation from 31,000+ lines of duplicate code to a streamlined, professional codebase is 95% complete. Phase 4 will achieve the final 5% to reach zero-duplication excellence.*
</file>

</files>
