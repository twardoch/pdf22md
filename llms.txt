This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    build-release.yml
    release.yml
docs/
  PARALLEL_PROCESSING.md
  pdf22md.1
issues/
  issue102-resolution.txt
  issue102.txt
pdf22md-objc/
  docs/
    pdf22md.1
  src/
    CLI/
      main.m
    Core/
      PDF22MDConversionOptions.h
      PDF22MDConversionOptions.m
      PDF22MDConverter.h
      PDF22MDConverter.m
      PDF22MDError.h
      PDF22MDError.m
      PDF22MDFontAnalyzer.h
      PDF22MDFontAnalyzer.m
      PDF22MDPageProcessor.h
      PDF22MDPageProcessor.m
    Models/
      PDF22MDContentElement.h
      PDF22MDImageElement.h
      PDF22MDImageElement.m
      PDF22MDTextElement.h
      PDF22MDTextElement.m
    Services/
      PDF22MDAssetManager.h
      PDF22MDAssetManager.m
      PDF22MDMarkdownGenerator.h
      PDF22MDMarkdownGenerator.m
    AssetExtractor.h
    AssetExtractor.m
    ContentElement.h
    ContentElement.m
    main.m
    PDF22MDErrorHelper.h
    PDF22MDErrorHelper.m
    PDFMarkdownConverter.h
    PDFMarkdownConverter.m
    PDFPageProcessor.h
    PDFPageProcessor.m
  test/
    README.md
  Tests/
    Integration/
      EndToEndConversionTests.m
    Unit/
      AssetExtractorTests.m
      ContentElementTests.m
      PDFMarkdownConverterTests.m
  build.sh
  Makefile
  README.md
  release.sh
  run-tests.sh
pdf22md-swift/
  docs/
    pdf22md.1
  test/
    README.md
  Tests/
    PDF22MDTests/
      PDF22MDTests.swift
  build.sh
  Package.swift
  README.md
  release.sh
test/
  README.md
.gitignore
AGENTS.md
build.sh
CHANGELOG.md
CLAUDE.md
LICENSE
README.md
TODO.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="issues/issue102-resolution.txt">
ISSUE 102 RESOLUTION
===================

Problem:
--------
Two build script issues were preventing successful builds:

1. `declare -A` bash incompatibility error
   - Error: "declare: -A: invalid option"
   - Root cause: Bash 3.x doesn't support associative arrays

2. SWBBuildService framework loading issue in Swift build
   - Error: "Library not loaded: @rpath/SWBBuildService.framework"
   - Root cause: Corrupted or incomplete Swift toolchain installation

Solutions Implemented:
---------------------

1. Fixed bash incompatibility:
   - Replaced associative array `declare -A build_results` with simple variables
   - Changed from `build_results["objc"]` to `build_results_objc`
   - Updated all references throughout build.sh

2. Enhanced Swift build resilience:
   - Added Swift toolchain health check before attempting build
   - Implemented graceful fallback when Swift toolchain is corrupted
   - Added informative error messages with recovery instructions
   - Modified build.sh to continue with Objective-C when Swift fails

Results:
--------
- Objective-C build: ‚úì WORKING
- Swift build: ‚úó BLOCKED (system Swift toolchain issue)
- Build script: ‚úì ROBUST (handles mixed success gracefully)

The build script now:
- Detects and reports Swift toolchain issues clearly
- Provides recovery instructions (xcode-select --install)
- Continues with successful builds when one implementation fails
- Gives clear status reporting for both implementations

Note: The Swift toolchain issue requires system-level resolution by the user:
`xcode-select --install` or reinstalling Xcode Command Line Tools.
</file>

<file path="issues/issue102.txt">
Othello:pdf22md adam$ ./build.sh
./build.sh: line 17: declare: -A: invalid option
declare: usage: declare [-afFirtx] [-p] [name[=value] ...]
[BUILD] pdf22md - Multi-Implementation Build System
[INFO] Building Objective-C Swift implementations
[BUILD] Building pdf22md-objc...
[INFO] Starting pdf22md-objc build process...
[INFO] Building pdf22md (Objective-C implementation)...
rm -rf build pdf22md
mkdir -p build
clang -Wall -Wextra -O2 -fobjc-arc -DVERSION=\"v1.2.0-1-gba7a7a8-dirty\" -Isrc -c src/CLI/main.m -o build/CLI/main.o
clang -Wall -Wextra -O2 -fobjc-arc -DVERSION=\"v1.2.0-1-gba7a7a8-dirty\" -Isrc -c src/Core/PDF22MDConversionOptions.m -o build/Core/PDF22MDConversionOptions.o
clang -Wall -Wextra -O2 -fobjc-arc -DVERSION=\"v1.2.0-1-gba7a7a8-dirty\" -Isrc -c src/Core/PDF22MDConverter.m -o build/Core/PDF22MDConverter.o
clang -Wall -Wextra -O2 -fobjc-arc -DVERSION=\"v1.2.0-1-gba7a7a8-dirty\" -Isrc -c src/Core/PDF22MDError.m -o build/Core/PDF22MDError.o
clang -Wall -Wextra -O2 -fobjc-arc -DVERSION=\"v1.2.0-1-gba7a7a8-dirty\" -Isrc -c src/Core/PDF22MDFontAnalyzer.m -o build/Core/PDF22MDFontAnalyzer.o
clang -Wall -Wextra -O2 -fobjc-arc -DVERSION=\"v1.2.0-1-gba7a7a8-dirty\" -Isrc -c src/Core/PDF22MDPageProcessor.m -o build/Core/PDF22MDPageProcessor.o
clang -Wall -Wextra -O2 -fobjc-arc -DVERSION=\"v1.2.0-1-gba7a7a8-dirty\" -Isrc -c src/Models/PDF22MDImageElement.m -o build/Models/PDF22MDImageElement.o
clang -Wall -Wextra -O2 -fobjc-arc -DVERSION=\"v1.2.0-1-gba7a7a8-dirty\" -Isrc -c src/Models/PDF22MDTextElement.m -o build/Models/PDF22MDTextElement.o
clang -Wall -Wextra -O2 -fobjc-arc -DVERSION=\"v1.2.0-1-gba7a7a8-dirty\" -Isrc -c src/Services/PDF22MDAssetManager.m -o build/Services/PDF22MDAssetManager.o
clang -Wall -Wextra -O2 -fobjc-arc -DVERSION=\"v1.2.0-1-gba7a7a8-dirty\" -Isrc -c src/Services/PDF22MDMarkdownGenerator.m -o build/Services/PDF22MDMarkdownGenerator.o
clang -Wall -Wextra -O2 -fobjc-arc -framework Foundation -framework PDFKit -framework CoreGraphics -framework ImageIO -framework CoreServices -o pdf22md build/CLI/main.o build/Core/PDF22MDConversionOptions.o build/Core/PDF22MDConverter.o build/Core/PDF22MDError.o build/Core/PDF22MDFontAnalyzer.o build/Core/PDF22MDPageProcessor.o build/Models/PDF22MDImageElement.o build/Models/PDF22MDTextElement.o build/Services/PDF22MDAssetManager.o build/Services/PDF22MDMarkdownGenerator.o
[INFO] ‚úì pdf22md-objc built successfully
[INFO] Build complete!
[INFO] Run './pdf22md --help' for usage information
[INFO] ‚úì pdf22md-objc built successfully
[BUILD] Building pdf22md-swift...
[INFO] Starting pdf22md-swift build process...
[INFO] Building pdf22md (Swift implementation)...
dyld[5982]: Library not loaded: @rpath/SWBBuildService.framework/Versions/A/SWBBuildService
  Referenced from: <DAAB41B3-19E5-3A14-8AFB-1A3635185E81> /Library/Developer/CommandLineTools/usr/bin/swift-package
  Reason: tried: '/Library/../SharedFrameworks/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/../SharedFrameworks/SwiftBuild.framework/Versions/A/PlugIns/SWBBuildService.bundle/Contents/Frameworks/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/../SharedFrameworks/SwiftBuild.framework/Versions/A/PlugIns/SWBBuildSystem.bundle/Contents/Frameworks/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/../Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/../Developer/Toolchains/XcodeDefault.xctoolchain/usr/local/include/SwiftToolsSupport/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/Developer/CommandLineTools/usr/lib/swift/pm/llbuild/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/Developer/CommandLineTools/usr/lib/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/Developer/CommandLineTools/usr/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/../SharedFrameworks/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/../SharedFrameworks/SwiftBuild.framework/Versions/A/PlugIns/SWBBuildService.bundle/Contents/Frameworks/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/../SharedFrameworks/SwiftBuild.framework/Versions/A/PlugIns/SWBBuildSystem.bundle/Contents/Frameworks/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/../Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/../Developer/Toolchains/XcodeDefault.xctoolchain/usr/local/include/SwiftToolsSupport/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/Developer/CommandLineTools/usr/lib/swift/pm/llbuild/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/Developer/CommandLineTools/usr/lib/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file), '/Library/Developer/CommandLineTools/usr/SWBBuildService.framework/Versions/A/SWBBuildService' (no such file)
./build.sh: line 31:  5982 Abort trap: 6           swift build -c release
[ERROR] Failed to build pdf22md-swift
[ERROR] ‚úó pdf22md-swift build failed
[BUILD] Build Summary
[ERROR] ‚úó pdf22md-0: FAILED

[ERROR] Some builds failed (0/1 successful)
Othello:pdf22md adam$
</file>

<file path="pdf22md-objc/docs/pdf22md.1">
.TH PDF22MD 1 "June 2025" "pdf22md v1.0" "User Commands"
.SH NAME
pdf22md \- high-performance PDF to Markdown converter
.SH SYNOPSIS
.B pdf22md
[\fB\-i\fR \fIinput.pdf\fR]
[\fB\-o\fR \fIoutput.md\fR]
[\fB\-a\fR \fIassets_folder\fR]
[\fB\-d\fR \fIdpi\fR]
[\fB\-v\fR]
[\fB\-h\fR]
.SH DESCRIPTION
.B pdf22md
is a blazingly fast PDF to Markdown converter that extracts text and images from PDF documents and converts them into clean, structured Markdown format. It uses parallel processing to achieve high performance on multi-page documents.

The tool automatically detects heading hierarchy based on font size analysis, extracts images with intelligent format optimization (PNG/JPEG), and generates YAML frontmatter with document metadata.

.SH OPTIONS
.TP
\fB\-i\fR \fIinput.pdf\fR
Specify the input PDF file to convert. If not provided, pdf22md reads from standard input (stdin).
.TP
\fB\-o\fR \fIoutput.md\fR
Specify the output Markdown file. If not provided, pdf22md writes to standard output (stdout).
.TP
\fB\-a\fR \fIassets_folder\fR
Specify the folder where extracted images will be saved. The folder will be created if it doesn't exist. Images are automatically referenced in the generated Markdown with relative paths.
.TP
\fB\-d\fR \fIdpi\fR
Set the DPI (dots per inch) for rasterizing vector graphics. Default is 144. Higher values produce better quality but larger file sizes. Common values: 72 (screen), 144 (default), 300 (print quality).
.TP
\fB\-v\fR, \fB\-\-version\fR
Display version information and exit.
.TP
\fB\-h\fR, \fB\-\-help\fR
Display usage information and exit.

.SH EXAMPLES
.TP
Convert a PDF file to Markdown:
.B pdf22md \-i document.pdf \-o document.md

.TP
Extract images to an assets folder:
.B pdf22md \-i document.pdf \-o document.md \-a ./assets

.TP
Use higher DPI for better image quality:
.B pdf22md \-i document.pdf \-o document.md \-a ./assets \-d 300

.TP
Convert using pipes (stdin/stdout):
.B cat document.pdf | pdf22md > document.md

.TP
Process a document with custom settings:
.B pdf22md \-i report.pdf \-o report.md \-a ./images \-d 200

.SH INPUT/OUTPUT
.SS Input Sources
.B pdf22md
accepts PDF input from:
.IP ‚Ä¢ 2
File path specified with \fB\-i\fR flag
.IP ‚Ä¢ 2
Standard input (stdin) when no \fB\-i\fR flag is provided

.SS Output Destinations
Markdown output is written to:
.IP ‚Ä¢ 2
File path specified with \fB\-o\fR flag
.IP ‚Ä¢ 2
Standard output (stdout) when no \fB\-o\fR flag is provided

.SS Image Assets
When the \fB\-a\fR flag is used:
.IP ‚Ä¢ 2
Images are extracted and saved to the specified folder
.IP ‚Ä¢ 2
Filenames follow the pattern: image_001.png, image_002.jpg, etc.
.IP ‚Ä¢ 2
Format selection is automatic (PNG for graphics, JPEG for photos)
.IP ‚Ä¢ 2
Markdown contains relative references to the images

.SH FEATURES
.SS Intelligent Content Processing
.IP ‚Ä¢ 2
\fBHeading Detection\fR: Automatically identifies headings (H1-H6) based on font size analysis
.IP ‚Ä¢ 2
\fBText Extraction\fR: Preserves text formatting and structure
.IP ‚Ä¢ 2
\fBImage Processing\fR: Extracts both raster and vector graphics
.IP ‚Ä¢ 2
\fBSmart Formatting\fR: Maintains document hierarchy and readability

.SS Performance Optimizations
.IP ‚Ä¢ 2
\fBParallel Processing\fR: Uses all available CPU cores for maximum speed
.IP ‚Ä¢ 2
\fBMemory Efficiency\fR: Processes large documents without excessive memory usage
.IP ‚Ä¢ 2
\fBFormat Optimization\fR: Automatic PNG/JPEG selection based on image content

.SS Output Features
.IP ‚Ä¢ 2
\fBYAML Frontmatter\fR: Includes document metadata (title, author, creation date)
.IP ‚Ä¢ 2
\fBClean Markdown\fR: Well-structured output compatible with all Markdown processors
.IP ‚Ä¢ 2
\fBAsset Management\fR: Organized image extraction with proper linking

.SH FILE FORMATS
.SS Supported Input
.IP ‚Ä¢ 2
PDF files (version 1.4 and higher)
.IP ‚Ä¢ 2
Unencrypted PDFs (password-protected PDFs are not supported)
.IP ‚Ä¢ 2
PDFs with text, images, and vector graphics
.IP ‚Ä¢ 2
Multi-page documents of any size

.SS Generated Output
.IP ‚Ä¢ 2
\fBMarkdown (.md)\fR: GitHub Flavored Markdown compatible
.IP ‚Ä¢ 2
\fBImages (.png/.jpg)\fR: Extracted graphics in optimal formats
.IP ‚Ä¢ 2
\fBYAML Frontmatter\fR: Document metadata in standard format

.SH PERFORMANCE
Typical conversion speeds on modern hardware:
.IP ‚Ä¢ 2
Simple text documents: <1 second per page
.IP ‚Ä¢ 2
Complex documents with images: 2-5 seconds per page
.IP ‚Ä¢ 2
Large documents (100+ pages): Scales linearly with parallel processing

Memory usage is optimized for documents up to 1000 pages. Very large documents may require additional system memory.

.SH ERROR HANDLING
.B pdf22md
provides detailed error messages with suggestions for common issues:

.SS Common Errors and Solutions
.TP
\fBInvalid PDF file\fR
.IP ‚Ä¢ 2
Verify the file exists and is a valid PDF
.IP ‚Ä¢ 2
Check if the file is corrupted
.IP ‚Ä¢ 2
Ensure you have read permissions

.TP
\fBCannot create assets folder\fR
.IP ‚Ä¢ 2
Check if the parent directory exists
.IP ‚Ä¢ 2
Verify you have write permissions
.IP ‚Ä¢ 2
Ensure sufficient disk space

.TP
\fBPassword-protected PDF\fR
.IP ‚Ä¢ 2
Remove password protection using another tool first
.IP ‚Ä¢ 2
Use: qpdf \-\-decrypt input.pdf output.pdf

.TP
\fBMemory pressure\fR
.IP ‚Ä¢ 2
Close other applications to free memory
.IP ‚Ä¢ 2
Try using a lower DPI setting (\-d 72)
.IP ‚Ä¢ 2
Process smaller sections of large documents

.SH EXIT STATUS
.TP
.B 0
Successful conversion
.TP
.B 1
Error occurred (invalid input, processing failure, I/O error)

.SH ENVIRONMENT
No special environment variables are required. The tool uses standard macOS frameworks (PDFKit, CoreGraphics) and runs on macOS 10.15 and later.

.SH LIMITATIONS
.IP ‚Ä¢ 2
Password-protected PDFs are not supported
.IP ‚Ä¢ 2
Scanned PDFs without OCR text layer will only extract images
.IP ‚Ä¢ 2
Complex table layouts may not convert perfectly
.IP ‚Ä¢ 2
Some advanced PDF features (forms, annotations) are not preserved

.SH COMPATIBILITY
.SS Platform Support
.IP ‚Ä¢ 2
macOS 10.15 (Catalina) and later
.IP ‚Ä¢ 2
Intel and Apple Silicon processors
.IP ‚Ä¢ 2
Universal binary for optimal performance

.SS Markdown Compatibility
Output is compatible with:
.IP ‚Ä¢ 2
GitHub Flavored Markdown
.IP ‚Ä¢ 2
CommonMark specification
.IP ‚Ä¢ 2
Popular Markdown processors (pandoc, Jekyll, etc.)
.IP ‚Ä¢ 2
Static site generators (Hugo, Jekyll, Gatsby)

.SH FILES
.TP
.I ~/.pdf22md/
User configuration directory (future use)
.TP
.I /usr/local/bin/pdf22md
Default installation location
.TP
.I /usr/local/share/man/man1/pdf22md.1
This manual page

.SH EXAMPLES WORKFLOW
.SS Basic Document Conversion
.nf
# Convert a simple document
pdf22md \-i report.pdf \-o report.md

# Result: clean Markdown with YAML frontmatter
# Output includes: title, headings, body text, metadata
.fi

.SS Academic Paper with Images
.nf
# Convert research paper with figure extraction
pdf22md \-i paper.pdf \-o paper.md \-a figures \-d 300

# Result: 
# - paper.md with structured content
# - figures/ folder with high-quality images
# - Proper cross-references to figures
.fi

.SS Batch Processing
.nf
# Process multiple documents
for pdf in *.pdf; do
    pdf22md \-i "$pdf" \-o "${pdf%.pdf}.md" \-a "assets_${pdf%.pdf}"
done
.fi

.SS Integration with Other Tools
.nf
# Combine with pandoc for further processing
pdf22md \-i document.pdf | pandoc \-f markdown \-t html \-o document.html

# Use with static site generators
pdf22md \-i post.pdf \-o content/posts/post.md \-a static/images
.fi

.SH TROUBLESHOOTING
.SS Performance Issues
If conversion is slow:
.IP ‚Ä¢ 2
Check available memory and CPU usage
.IP ‚Ä¢ 2
Close unnecessary applications
.IP ‚Ä¢ 2
Try lower DPI setting for faster processing
.IP ‚Ä¢ 2
Process documents in smaller batches

.SS Quality Issues
If output quality is poor:
.IP ‚Ä¢ 2
Increase DPI setting (\-d 300) for better images
.IP ‚Ä¢ 2
Verify the source PDF has good quality text
.IP ‚Ä¢ 2
Check if the PDF has a proper text layer (not just scanned images)

.SS Memory Errors
For large documents:
.IP ‚Ä¢ 2
Ensure sufficient RAM (8GB+ recommended for large PDFs)
.IP ‚Ä¢ 2
Close other memory-intensive applications
.IP ‚Ä¢ 2
Split very large PDFs into smaller parts first

.SH REPORTING BUGS
Report bugs and feature requests at:
.UR https://github.com/twardoch/pdf22md/issues
.UE

Include in your report:
.IP ‚Ä¢ 2
pdf22md version (\fBpdf22md \-v\fR)
.IP ‚Ä¢ 2
macOS version
.IP ‚Ä¢ 2
Sample PDF file (if possible)
.IP ‚Ä¢ 2
Complete error message
.IP ‚Ä¢ 2
Steps to reproduce the issue

.SH AUTHORS
Written by Adam Twardoch and contributors.

.SH LICENSE
MIT License. See the LICENSE file for details.

.SH SEE ALSO
.BR pandoc (1),
.BR qpdf (1),
.BR pdftotext (1),
.BR markdown (7)

Project homepage: 
.UR https://github.com/twardoch/pdf22md
.UE
</file>

<file path="pdf22md-objc/src/AssetExtractor.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

@interface AssetExtractor : NSObject

- (nullable instancetype)initWithAssetFolder:(NSString *)folderPath;

- (nullable NSString *)saveImage:(CGImageRef)image
                  isVectorSource:(BOOL)isVector
                      withBaseName:(NSString *)baseName;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/AssetExtractor.m">
#import "AssetExtractor.h"
#import <ImageIO/ImageIO.h>

@interface AssetExtractor ()
@property (nonatomic, strong) NSString *assetFolderPath;
@property (nonatomic, strong) NSFileManager *fileManager;
@end

@implementation AssetExtractor

- (nullable instancetype)initWithAssetFolder:(NSString *)folderPath {
    self = [super init];
    if (self) {
        _assetFolderPath = folderPath;
        _fileManager = [NSFileManager defaultManager];
        
        // Create assets folder if it doesn't exist
        NSError *error = nil;
        BOOL isDirectory = NO;
        BOOL exists = [_fileManager fileExistsAtPath:folderPath isDirectory:&isDirectory];
        
        if (exists && !isDirectory) {
            NSLog(@"Asset path exists but is not a directory: %@", folderPath);
            return nil;
        }
        
        if (!exists) {
            if (![_fileManager createDirectoryAtPath:folderPath
                         withIntermediateDirectories:YES
                                          attributes:nil
                                               error:&error]) {
                NSLog(@"Failed to create assets folder: %@", error);
                return nil;
            }
        }
    }
    return self;
}

- (nullable NSString *)saveImage:(CGImageRef)image
                  isVectorSource:(BOOL)isVector
                      withBaseName:(NSString *)baseName {
    if (!image) {
        return nil;
    }
    
    // Analyze image to determine optimal format
    BOOL shouldUseJPEG = [self shouldUseJPEGForImage:image];
    
    NSString *extension = shouldUseJPEG ? @"jpg" : @"png";
    NSString *fileName = [NSString stringWithFormat:@"%@.%@", baseName, extension];
    NSString *fullPath = [self.assetFolderPath stringByAppendingPathComponent:fileName];
    
    // Create destination
    NSURL *fileURL = [NSURL fileURLWithPath:fullPath];
    CGImageDestinationRef destination = CGImageDestinationCreateWithURL((__bridge CFURLRef)fileURL,
                                                                       shouldUseJPEG ? (__bridge CFStringRef)@"public.jpeg" : (__bridge CFStringRef)@"public.png",
                                                                       1, NULL);
    if (!destination) {
        NSLog(@"Failed to create image destination");
        return nil;
    }
    
    // Set compression options
    NSDictionary *properties = nil;
    if (shouldUseJPEG) {
        properties = @{(__bridge NSString *)kCGImageDestinationLossyCompressionQuality: @0.85};
    }
    
    // Add image to destination
    CGImageDestinationAddImage(destination, image, (__bridge CFDictionaryRef)properties);
    
    // Finalize
    BOOL success = CGImageDestinationFinalize(destination);
    CFRelease(destination);
    
    if (!success) {
        NSLog(@"Failed to save image to %@", fullPath);
        return nil;
    }
    
    // Return relative path (just the filename since it's in the assets folder)
    return fileName;
}

- (BOOL)shouldUseJPEGForImage:(CGImageRef)image {
    // Get image properties
    size_t width = CGImageGetWidth(image);
    size_t height = CGImageGetHeight(image);
    CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(image);
    
    // If image has alpha channel, use PNG
    if (alphaInfo != kCGImageAlphaNone &&
        alphaInfo != kCGImageAlphaNoneSkipFirst &&
        alphaInfo != kCGImageAlphaNoneSkipLast) {
        return NO;
    }
    
    // For small images, use PNG
    if (width * height < 10000) { // Less than 100x100
        return NO;
    }
    
    // Analyze color complexity by sampling pixels
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    size_t bytesPerRow = width * 4;
    size_t sampleSize = MIN(width * height, 10000); // Sample up to 10k pixels
    
    unsigned char *pixelData = calloc(sampleSize * 4, sizeof(unsigned char));
    if (!pixelData) {
        CGColorSpaceRelease(colorSpace);
        return YES; // Default to JPEG if we can't analyze
    }
    
    CGContextRef context = CGBitmapContextCreate(pixelData, width, 1, 8, bytesPerRow, colorSpace,
                                                kCGImageAlphaNoneSkipLast | kCGBitmapByteOrder32Big);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        free(pixelData);
        return YES;
    }
    
    // Sample middle row
    CGContextDrawImage(context, CGRectMake(0, 0, width, 1), image);
    CGContextRelease(context);
    
    // Count unique colors in sample
    NSMutableSet *uniqueColors = [NSMutableSet set];
    for (size_t i = 0; i < width * 4; i += 4) {
        uint32_t color = (pixelData[i] << 24) | (pixelData[i+1] << 16) | 
                        (pixelData[i+2] << 8) | pixelData[i+3];
        [uniqueColors addObject:@(color)];
    }
    
    free(pixelData);
    
    // If we have many unique colors, it's likely a photograph - use JPEG
    return [uniqueColors count] > 256;
}

@end
</file>

<file path="pdf22md-objc/src/ContentElement.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

@protocol ContentElement <NSObject>
@property (nonatomic, readonly) CGRect bounds;
@property (nonatomic, readonly) NSInteger pageIndex;
- (NSString *)markdownRepresentation;
@end

@interface TextElement : NSObject <ContentElement>
@property (nonatomic, strong) NSString *text;
@property (nonatomic, assign) CGRect bounds;
@property (nonatomic, assign) NSInteger pageIndex;
@property (nonatomic, strong, nullable) NSString *fontName;
@property (nonatomic, assign) CGFloat fontSize;
@property (nonatomic, assign) BOOL isBold;
@property (nonatomic, assign) BOOL isItalic;
@property (nonatomic, assign) NSInteger headingLevel;
@end

@interface ImageElement : NSObject <ContentElement>
@property (nonatomic, assign) CGImageRef image;
@property (nonatomic, assign) CGRect bounds;
@property (nonatomic, assign) NSInteger pageIndex;
@property (nonatomic, assign) BOOL isVectorSource;
@property (nonatomic, strong, nullable) NSString *assetRelativePath;
@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/ContentElement.m">
#import "ContentElement.h"

@implementation TextElement

- (NSString *)markdownRepresentation {
    if (!self.text || [self.text length] == 0) {
        return nil;
    }
    
    NSString *trimmedText = [self.text stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    if ([trimmedText length] == 0) {
        return nil;
    }
    
    // Apply heading formatting
    if (self.headingLevel > 0 && self.headingLevel <= 6) {
        NSMutableString *heading = [NSMutableString string];
        for (NSInteger i = 0; i < self.headingLevel; i++) {
            [heading appendString:@"#"];
        }
        [heading appendString:@" "];
        [heading appendString:trimmedText];
        return heading;
    }
    
    // Apply bold/italic formatting
    NSString *formattedText = trimmedText;
    
    if (self.isBold && self.isItalic) {
        formattedText = [NSString stringWithFormat:@"***%@***", formattedText];
    } else if (self.isBold) {
        formattedText = [NSString stringWithFormat:@"**%@**", formattedText];
    } else if (self.isItalic) {
        formattedText = [NSString stringWithFormat:@"*%@*", formattedText];
    }
    
    return formattedText;
}

- (void)dealloc {
    // No need to release CGImageRef here as ARC doesn't manage it
}

@end

@implementation ImageElement

- (NSString *)markdownRepresentation {
    if (!self.assetRelativePath) {
        return @"![Image](image-not-saved)";
    }
    
    return [NSString stringWithFormat:@"![Image](%@)", self.assetRelativePath];
}

- (void)dealloc {
    if (self.image) {
        CGImageRelease(self.image);
    }
}

@end
</file>

<file path="pdf22md-objc/src/main.m">
#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>
#import "PDFMarkdownConverter.h"
#import "PDF22MDErrorHelper.h"

#ifndef VERSION
#define VERSION "dev"
#endif

void printUsage(const char *programName) {
    fprintf(stderr, "Usage: %s [-i input.pdf] [-o output.md] [-a assets_folder] [-d dpi] [-v] [-h]\n", programName);
    fprintf(stderr, "  Converts PDF documents to Markdown format\n");
    fprintf(stderr, "  -i <path>: Input PDF file (default: stdin)\n");
    fprintf(stderr, "  -o <path>: Output Markdown file (default: stdout)\n");
    fprintf(stderr, "  -a <path>: Assets folder for extracted images\n");
    fprintf(stderr, "  -d <dpi>: DPI for rasterizing vector graphics (default: 144)\n");
    fprintf(stderr, "  -v: Display version information\n");
    fprintf(stderr, "  -h: Display this help message\n");
}

void printVersion() {
    printf("pdf22md version %s\n", VERSION);
}

int main(int argc, const char *argv[]) {
    @autoreleasepool {
        NSString *inputPath = nil;
        NSString *outputPath = nil;
        NSString *assetsPath = nil;
        CGFloat dpi = 144.0;
        
        // Parse command line arguments
        int opt;
        while ((opt = getopt(argc, (char * const *)argv, "i:o:a:d:hvV")) != -1) {
            switch (opt) {
                case 'i':
                    inputPath = [NSString stringWithUTF8String:optarg];
                    break;
                case 'o':
                    outputPath = [NSString stringWithUTF8String:optarg];
                    break;
                case 'a':
                    assetsPath = [NSString stringWithUTF8String:optarg];
                    break;
                case 'd':
                    dpi = atof(optarg);
                    if (dpi <= 0) {
                        fprintf(stderr, "Invalid DPI value: %s\n", optarg);
                        return 1;
                    }
                    break;
                case 'h':
                    printUsage(argv[0]);
                    return 0;
                case 'v':
                case 'V':
                    printVersion();
                    return 0;
                default:
                    printUsage(argv[0]);
                    return 1;
            }
        }
        
        // Initialize converter
        PDFMarkdownConverter *converter = nil;
        
        if (inputPath) {
            // Read from file
            NSURL *pdfURL = [NSURL fileURLWithPath:inputPath];
            converter = [[PDFMarkdownConverter alloc] initWithPDFAtURL:pdfURL];
            if (!converter) {
                NSError *error = [PDF22MDErrorHelper invalidPDFErrorWithPath:inputPath];
                NSString *userMessage = [PDF22MDErrorHelper userFriendlyMessageForError:error];
                fprintf(stderr, "%s\n", [userMessage UTF8String]);
                return 1;
            }
        } else {
            // Read from stdin
            NSFileHandle *stdinHandle = [NSFileHandle fileHandleWithStandardInput];
            NSData *pdfData = [stdinHandle readDataToEndOfFile];
            
            if (!pdfData || [pdfData length] == 0) {
                NSError *error = [PDF22MDErrorHelper errorWithCode:PDF22MDErrorIOError
                                                        description:@"No PDF data received from stdin"
                                                         suggestion:@"‚Ä¢ Pipe a valid PDF file to stdin\n"
                                                                   @"‚Ä¢ Example: cat document.pdf | pdf22md > output.md\n"
                                                                   @"‚Ä¢ Check that the input source contains PDF data"];
                NSString *userMessage = [PDF22MDErrorHelper userFriendlyMessageForError:error];
                fprintf(stderr, "%s\n", [userMessage UTF8String]);
                return 1;
            }
            
            converter = [[PDFMarkdownConverter alloc] initWithPDFData:pdfData];
            if (!converter) {
                NSError *error = [PDF22MDErrorHelper errorWithCode:PDF22MDErrorInvalidPDF
                                                        description:@"Failed to create PDF document from stdin data"
                                                         suggestion:@"‚Ä¢ Ensure the piped data is a valid PDF file\n"
                                                                   @"‚Ä¢ Verify the PDF is not corrupted\n"
                                                                   @"‚Ä¢ Check if the PDF is password-protected"];
                NSString *userMessage = [PDF22MDErrorHelper userFriendlyMessageForError:error];
                fprintf(stderr, "%s\n", [userMessage UTF8String]);
                return 1;
            }
        }
        
        // Perform conversion
        __block NSString *markdown = nil;
        __block NSError *conversionError = nil;
        
        dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
        
        [converter convertWithAssetsFolderPath:assetsPath
                                rasterizedDPI:dpi
                                   completion:^(NSString *result, NSError *error) {
            markdown = result;
            conversionError = error;
            dispatch_semaphore_signal(semaphore);
        }];
        
        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
        
        if (conversionError) {
            NSString *userMessage = [PDF22MDErrorHelper userFriendlyMessageForError:conversionError];
            fprintf(stderr, "%s\n", [userMessage UTF8String]);
            return 1;
        }
        
        // Write output
        if (outputPath) {
            // Write to file
            NSError *writeError = nil;
            BOOL success = [markdown writeToFile:outputPath
                                      atomically:YES
                                        encoding:NSUTF8StringEncoding
                                           error:&writeError];
            if (!success) {
                NSError *enhancedError = [PDF22MDErrorHelper ioErrorWithPath:outputPath operation:@"write"];
                if (writeError) {
                    enhancedError = [PDF22MDErrorHelper errorWithCode:PDF22MDErrorIOError
                                                           description:[NSString stringWithFormat:@"Failed to write output file: %@", outputPath]
                                                            suggestion:@"‚Ä¢ Check if you have write permissions for the directory\n"
                                                                      @"‚Ä¢ Ensure sufficient disk space\n"
                                                                      @"‚Ä¢ Verify the path is correct and accessible\n"
                                                                      @"‚Ä¢ Check if the file is locked by another application"
                                                       underlyingError:writeError];
                }
                NSString *userMessage = [PDF22MDErrorHelper userFriendlyMessageForError:enhancedError];
                fprintf(stderr, "%s\n", [userMessage UTF8String]);
                return 1;
            }
        } else {
            // Write to stdout
            NSFileHandle *stdoutHandle = [NSFileHandle fileHandleWithStandardOutput];
            NSData *markdownData = [markdown dataUsingEncoding:NSUTF8StringEncoding];
            [stdoutHandle writeData:markdownData];
        }
        
        return 0;
    }
}
</file>

<file path="pdf22md-objc/src/PDF22MDErrorHelper.h">
//
//  PDF22MDErrorHelper.h
//  pdf22md
//
//  Enhanced error handling with user-friendly messages and suggestions
//

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

// Error domain for pdf22md errors
extern NSErrorDomain const PDF22MDErrorDomain;

// Specific error codes with clear meanings
typedef NS_ENUM(NSInteger, PDF22MDError) {
    PDF22MDErrorInvalidPDF = 1000,          // PDF file is corrupted or invalid
    PDF22MDErrorAssetFolderCreation,        // Cannot create assets folder
    PDF22MDErrorMemoryPressure,            // Insufficient memory
    PDF22MDErrorProcessingTimeout,         // Processing took too long
    PDF22MDErrorEncryptedPDF,              // Password-protected PDF
    PDF22MDErrorEmptyDocument,             // PDF has no readable content
    PDF22MDErrorIOError,                   // File I/O error
    PDF22MDErrorPermissionDenied,          // Insufficient permissions
    PDF22MDErrorUnsupportedFormat          // PDF format not supported
};

/**
 * Helper class for creating user-friendly error messages with actionable suggestions
 */
@interface PDF22MDErrorHelper : NSObject

/**
 * Creates a user-friendly error with description and suggestion
 */
+ (NSError *)errorWithCode:(PDF22MDError)code
               description:(NSString *)description
                suggestion:(NSString *)suggestion;

/**
 * Creates a user-friendly error with underlying error context
 */
+ (NSError *)errorWithCode:(PDF22MDError)code
               description:(NSString *)description
                suggestion:(NSString *)suggestion
           underlyingError:(nullable NSError *)underlyingError;

/**
 * Common error factory methods
 */
+ (NSError *)invalidPDFErrorWithPath:(NSString *)path;
+ (NSError *)assetFolderErrorWithPath:(NSString *)path reason:(NSString *)reason;
+ (NSError *)memoryPressureError;
+ (NSError *)encryptedPDFError;
+ (NSError *)emptyDocumentError;
+ (NSError *)ioErrorWithPath:(NSString *)path operation:(NSString *)operation;
+ (NSError *)permissionErrorWithPath:(NSString *)path;

/**
 * Formats error for command-line display
 */
+ (NSString *)userFriendlyMessageForError:(NSError *)error;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/PDF22MDErrorHelper.m">
//
//  PDF22MDErrorHelper.m
//  pdf22md
//
//  Enhanced error handling with user-friendly messages and suggestions
//

#import "PDF22MDErrorHelper.h"

NSErrorDomain const PDF22MDErrorDomain = @"com.twardoch.pdf22md.error";

@implementation PDF22MDErrorHelper

+ (NSError *)errorWithCode:(PDF22MDError)code
               description:(NSString *)description
                suggestion:(NSString *)suggestion {
    return [self errorWithCode:code
                   description:description
                    suggestion:suggestion
               underlyingError:nil];
}

+ (NSError *)errorWithCode:(PDF22MDError)code
               description:(NSString *)description
                suggestion:(NSString *)suggestion
           underlyingError:(nullable NSError *)underlyingError {
    
    NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];
    
    userInfo[NSLocalizedDescriptionKey] = description;
    userInfo[NSLocalizedRecoverySuggestionErrorKey] = suggestion;
    
    if (underlyingError) {
        userInfo[NSUnderlyingErrorKey] = underlyingError;
    }
    
    // Add additional context based on error code
    switch (code) {
        case PDF22MDErrorInvalidPDF:
            userInfo[NSLocalizedFailureReasonErrorKey] = @"The PDF file appears to be corrupted or in an unsupported format";
            break;
        case PDF22MDErrorAssetFolderCreation:
            userInfo[NSLocalizedFailureReasonErrorKey] = @"Unable to create the specified assets folder";
            break;
        case PDF22MDErrorMemoryPressure:
            userInfo[NSLocalizedFailureReasonErrorKey] = @"Insufficient memory to process this PDF";
            break;
        case PDF22MDErrorProcessingTimeout:
            userInfo[NSLocalizedFailureReasonErrorKey] = @"PDF processing timed out";
            break;
        case PDF22MDErrorEncryptedPDF:
            userInfo[NSLocalizedFailureReasonErrorKey] = @"The PDF is password-protected";
            break;
        case PDF22MDErrorEmptyDocument:
            userInfo[NSLocalizedFailureReasonErrorKey] = @"The PDF contains no readable content";
            break;
        case PDF22MDErrorIOError:
            userInfo[NSLocalizedFailureReasonErrorKey] = @"File input/output error occurred";
            break;
        case PDF22MDErrorPermissionDenied:
            userInfo[NSLocalizedFailureReasonErrorKey] = @"Insufficient permissions to access the file or folder";
            break;
        case PDF22MDErrorUnsupportedFormat:
            userInfo[NSLocalizedFailureReasonErrorKey] = @"The PDF format or version is not supported";
            break;
    }
    
    return [NSError errorWithDomain:PDF22MDErrorDomain code:code userInfo:userInfo];
}

#pragma mark - Factory Methods

+ (NSError *)invalidPDFErrorWithPath:(NSString *)path {
    NSString *description = [NSString stringWithFormat:@"Cannot open PDF file: %@", path];
    NSString *suggestion = @"‚Ä¢ Verify the file exists and is a valid PDF\n"
                          @"‚Ä¢ Check if the file is corrupted\n"
                          @"‚Ä¢ Ensure you have read permissions for the file";
    
    return [self errorWithCode:PDF22MDErrorInvalidPDF
                   description:description
                    suggestion:suggestion];
}

+ (NSError *)assetFolderErrorWithPath:(NSString *)path reason:(NSString *)reason {
    NSString *description = [NSString stringWithFormat:@"Cannot create assets folder: %@", path];
    NSString *suggestion = [NSString stringWithFormat:@"‚Ä¢ Check if the parent directory exists\n"
                                                      @"‚Ä¢ Verify you have write permissions\n"
                                                      @"‚Ä¢ Ensure sufficient disk space\n"
                                                      @"‚Ä¢ Error details: %@", reason];
    
    return [self errorWithCode:PDF22MDErrorAssetFolderCreation
                   description:description
                    suggestion:suggestion];
}

+ (NSError *)memoryPressureError {
    NSString *description = @"Insufficient memory to process this PDF";
    NSString *suggestion = @"‚Ä¢ Close other applications to free memory\n"
                          @"‚Ä¢ Try processing a smaller PDF file\n"
                          @"‚Ä¢ Consider using a lower DPI setting (-d 72)\n"
                          @"‚Ä¢ If the PDF is very large, split it into smaller parts";
    
    return [self errorWithCode:PDF22MDErrorMemoryPressure
                   description:description
                    suggestion:suggestion];
}

+ (NSError *)encryptedPDFError {
    NSString *description = @"Cannot process password-protected PDF";
    NSString *suggestion = @"‚Ä¢ Remove password protection using another tool first\n"
                          @"‚Ä¢ Use Adobe Acrobat or similar to unlock the PDF\n"
                          @"‚Ä¢ Try: qpdf --decrypt input.pdf output.pdf";
    
    return [self errorWithCode:PDF22MDErrorEncryptedPDF
                   description:description
                    suggestion:suggestion];
}

+ (NSError *)emptyDocumentError {
    NSString *description = @"PDF contains no readable text or content";
    NSString *suggestion = @"‚Ä¢ Check if the PDF has text (not just scanned images)\n"
                          @"‚Ä¢ For scanned documents, use OCR software first\n"
                          @"‚Ä¢ Verify the PDF is not corrupted";
    
    return [self errorWithCode:PDF22MDErrorEmptyDocument
                   description:description
                    suggestion:suggestion];
}

+ (NSError *)ioErrorWithPath:(NSString *)path operation:(NSString *)operation {
    NSString *description = [NSString stringWithFormat:@"Failed to %@ file: %@", operation, path];
    NSString *suggestion = @"‚Ä¢ Check if the file path is correct\n"
                          @"‚Ä¢ Verify you have appropriate permissions\n"
                          @"‚Ä¢ Ensure sufficient disk space\n"
                          @"‚Ä¢ Check if the file is in use by another application";
    
    return [self errorWithCode:PDF22MDErrorIOError
                   description:description
                    suggestion:suggestion];
}

+ (NSError *)permissionErrorWithPath:(NSString *)path {
    NSString *description = [NSString stringWithFormat:@"Permission denied accessing: %@", path];
    NSString *suggestion = @"‚Ä¢ Check file permissions with: ls -la\n"
                          @"‚Ä¢ Use: chmod 644 for files, chmod 755 for directories\n"
                          @"‚Ä¢ Ensure you own the file or have appropriate access\n"
                          @"‚Ä¢ Try running with sudo if appropriate";
    
    return [self errorWithCode:PDF22MDErrorPermissionDenied
                   description:description
                    suggestion:suggestion];
}

#pragma mark - User-Friendly Formatting

+ (NSString *)userFriendlyMessageForError:(NSError *)error {
    if (![error.domain isEqualToString:PDF22MDErrorDomain]) {
        // For non-PDF22MD errors, provide basic formatting
        return [NSString stringWithFormat:@"Error: %@", error.localizedDescription];
    }
    
    NSMutableString *message = [NSMutableString string];
    
    // Add main description
    [message appendFormat:@"‚ùå %@\n", error.localizedDescription];
    
    // Add failure reason if available
    NSString *failureReason = error.userInfo[NSLocalizedFailureReasonErrorKey];
    if (failureReason) {
        [message appendFormat:@"\nüí° %@\n", failureReason];
    }
    
    // Add suggestions if available
    NSString *suggestion = error.userInfo[NSLocalizedRecoverySuggestionErrorKey];
    if (suggestion) {
        [message appendFormat:@"\nüîß Try these solutions:\n%@\n", suggestion];
    }
    
    // Add underlying error details if available
    NSError *underlyingError = error.userInfo[NSUnderlyingErrorKey];
    if (underlyingError) {
        [message appendFormat:@"\nüìã Technical details: %@", underlyingError.localizedDescription];
    }
    
    return message;
}

@end
</file>

<file path="pdf22md-objc/src/PDFMarkdownConverter.h">
#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>

NS_ASSUME_NONNULL_BEGIN

@interface PDFMarkdownConverter : NSObject

- (nullable instancetype)initWithPDFData:(NSData *)pdfData;
- (nullable instancetype)initWithPDFAtURL:(NSURL *)pdfURL;

- (void)convertWithAssetsFolderPath:(nullable NSString *)assetsPath
                     rasterizedDPI:(CGFloat)dpi
                        completion:(void (^)(NSString * _Nullable markdown, NSError * _Nullable error))completion;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/PDFMarkdownConverter.m">
#import "PDFMarkdownConverter.h"
#import "PDFPageProcessor.h"
#import "ContentElement.h"
#import "AssetExtractor.h"

@interface PDFMarkdownConverter ()
@property (nonatomic, strong) PDFDocument *pdfDocument;
@property (nonatomic, strong) NSMutableArray<id<ContentElement>> *allElements;
@property (nonatomic, strong) NSMutableDictionary<NSString *, NSNumber *> *fontStats;
@end

@implementation PDFMarkdownConverter

- (nullable instancetype)initWithPDFData:(NSData *)pdfData {
    self = [super init];
    if (self) {
        _pdfDocument = [[PDFDocument alloc] initWithData:pdfData];
        if (!_pdfDocument) {
            return nil;
        }
        _allElements = [NSMutableArray array];
        _fontStats = [NSMutableDictionary dictionary];
    }
    return self;
}

- (nullable instancetype)initWithPDFAtURL:(NSURL *)pdfURL {
    self = [super init];
    if (self) {
        _pdfDocument = [[PDFDocument alloc] initWithURL:pdfURL];
        if (!_pdfDocument) {
            return nil;
        }
        _allElements = [NSMutableArray array];
        _fontStats = [NSMutableDictionary dictionary];
    }
    return self;
}

- (void)convertWithAssetsFolderPath:(nullable NSString *)assetsPath
                     rasterizedDPI:(CGFloat)dpi
                        completion:(void (^)(NSString * _Nullable markdown, NSError * _Nullable error))completion {
    
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSError *error = nil;
        
        // Process all pages in parallel
        NSInteger pageCount = [self.pdfDocument pageCount];
        // DEBUG log suppressed: Starting conversion of pages
        
        // Create thread-safe temporary storage
        NSMutableArray<NSMutableArray<id<ContentElement>> *> *pageElementsArray = [NSMutableArray arrayWithCapacity:pageCount];
        NSMutableArray<NSMutableDictionary *> *pageFontStatsArray = [NSMutableArray arrayWithCapacity:pageCount];
        
        // Initialize arrays
        for (NSInteger i = 0; i < pageCount; i++) {
            [pageElementsArray addObject:[NSMutableArray array]];
            [pageFontStatsArray addObject:[NSMutableDictionary dictionary]];
        }
        
        // Lock for thread safety
        NSObject *lock = [[NSObject alloc] init];
        __block BOOL processingFailed = NO;
        
        // Process pages in parallel using dispatch_apply
        // DEBUG log suppressed: Starting dispatch_apply for pages
        dispatch_apply(pageCount, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t pageIndex) {
            @autoreleasepool {
                // DEBUG log suppressed: Processing page
                // Check if processing has already failed
                @synchronized(lock) {
                    if (processingFailed) return;
                }
                
                PDFPage *page = [self.pdfDocument pageAtIndex:pageIndex];
                if (!page) {
                    @synchronized(lock) {
                        processingFailed = YES;
                    }
                    return;
                }
                
                PDFPageProcessor *processor = [[PDFPageProcessor alloc] initWithPDFPage:page
                                                                               pageIndex:pageIndex
                                                                                     dpi:dpi];
                
                NSArray<id<ContentElement>> *pageElements = [processor extractContentElements];
                // DEBUG log suppressed: Page extracted elements
                
                // Store results in thread-safe arrays
                pageElementsArray[pageIndex] = [pageElements mutableCopy];
                
                // Collect font statistics for this page
                NSMutableDictionary *pageFontStats = pageFontStatsArray[pageIndex];
                for (id<ContentElement> element in pageElements) {
                    if ([element isKindOfClass:[TextElement class]]) {
                        TextElement *textElement = (TextElement *)element;
                        NSString *fontKey = [NSString stringWithFormat:@"%.1f-%@", 
                                           textElement.fontSize, 
                                           textElement.fontName ?: @"Unknown"];
                        
                        NSNumber *count = pageFontStats[fontKey];
                        pageFontStats[fontKey] = @([count integerValue] + 1);
                    }
                }
            }
        });
        
        // DEBUG log suppressed: dispatch_apply completed
        
        // Check if processing failed
        if (processingFailed) {
            error = [NSError errorWithDomain:@"PDFMarkdownConverter"
                                       code:2
                                   userInfo:@{NSLocalizedDescriptionKey: @"Failed to process one or more PDF pages"}];
            completion(nil, error);
            return;
        }
        
        // DEBUG log suppressed: Merging results from all pages
        
        // Merge results from all pages
        for (NSInteger i = 0; i < pageCount; i++) {
            [self.allElements addObjectsFromArray:pageElementsArray[i]];
            
            // Merge font statistics
            NSDictionary *pageFontStats = pageFontStatsArray[i];
            for (NSString *fontKey in pageFontStats) {
                NSNumber *pageCount = pageFontStats[fontKey];
                NSNumber *totalCount = self.fontStats[fontKey];
                self.fontStats[fontKey] = @([totalCount integerValue] + [pageCount integerValue]);
            }
        }
        
        // DEBUG log suppressed: Analyzing font hierarchy
        
        // Analyze font hierarchy
        [self analyzeFontHierarchy];
        
        // DEBUG log suppressed: Sorting elements
        
        // Sort elements by page and position
        [self sortElements];
        
        // DEBUG log suppressed: Sort completed
        
        // Handle assets if needed
        AssetExtractor *assetExtractor = nil;
        if (assetsPath) {
            // DEBUG log suppressed: Starting asset extraction with path:
            assetExtractor = [[AssetExtractor alloc] initWithAssetFolder:assetsPath];
            if (!assetExtractor) {
                error = [NSError errorWithDomain:@"PDFMarkdownConverter"
                                           code:1
                                       userInfo:@{NSLocalizedDescriptionKey: @"Failed to create assets folder"}];
                completion(nil, error);
                return;
            }
            
            // Save images in parallel
            NSMutableArray<ImageElement *> *imageElements = [NSMutableArray array];
            for (id<ContentElement> element in self.allElements) {
                if ([element isKindOfClass:[ImageElement class]]) {
                    [imageElements addObject:(ImageElement *)element];
                }
            }
            
            NSInteger imageCount = [imageElements count];
            // DEBUG log suppressed: Found images to extract
            if (imageCount > 0) {
                // DEBUG log suppressed: Starting parallel image extraction
                dispatch_apply(imageCount, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t index) {
                    @autoreleasepool {
                        ImageElement *imageElement = imageElements[index];
                        NSString *baseName = [NSString stringWithFormat:@"image_%03zu", index];
                        NSString *savedPath = [assetExtractor saveImage:imageElement.image
                                                          isVectorSource:imageElement.isVectorSource
                                                              withBaseName:baseName];
                        if (savedPath) {
                            @synchronized(imageElement) {
                                imageElement.assetRelativePath = savedPath;
                            }
                        }
                    }
                });
                // DEBUG log suppressed: Completed parallel image extraction
            }
        } else {
            // DEBUG log suppressed: No assets path provided, skipping image extraction
        }
        
        // DEBUG log suppressed: Starting markdown generation
        
        // Generate markdown with YAML frontmatter
        NSMutableString *markdown = [NSMutableString string];
        
        // Add YAML frontmatter with metadata
        // DEBUG log suppressed: Generating YAML frontmatter
        NSString *yamlFrontmatter = [self generateYAMLFrontmatter];
        if (yamlFrontmatter) {
            [markdown appendString:yamlFrontmatter];
            [markdown appendString:@"\n"];
        }
        
        // DEBUG log suppressed: Converting elements to markdown
        for (id<ContentElement> element in self.allElements) {
            NSString *elementMarkdown = [element markdownRepresentation];
            if (elementMarkdown) {
                [markdown appendString:elementMarkdown];
                [markdown appendString:@"\n\n"];
            }
        }
        // DEBUG log suppressed: Markdown generation completed
        
        // Clean up extra newlines
        NSString *finalMarkdown = [markdown stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
        
        completion(finalMarkdown, nil);
    });
}

- (void)collectFontStatisticsFromElements:(NSArray<id<ContentElement>> *)elements {
    for (id<ContentElement> element in elements) {
        if ([element isKindOfClass:[TextElement class]]) {
            TextElement *textElement = (TextElement *)element;
            NSString *fontKey = [NSString stringWithFormat:@"%.1f-%@", 
                               textElement.fontSize, 
                               textElement.fontName ?: @"Unknown"];
            
            NSNumber *count = self.fontStats[fontKey];
            self.fontStats[fontKey] = @([count integerValue] + 1);
        }
    }
}

- (void)analyzeFontHierarchy {
    // Sort font sizes to determine heading levels
    NSMutableArray<NSNumber *> *uniqueSizes = [NSMutableArray array];
    NSMutableDictionary<NSNumber *, NSNumber *> *sizeFrequency = [NSMutableDictionary dictionary];
    
    for (NSString *fontKey in self.fontStats) {
        NSArray *components = [fontKey componentsSeparatedByString:@"-"];
        if (components.count > 0) {
            CGFloat fontSize = [components[0] floatValue];
            NSNumber *sizeNum = @(fontSize);
            
            if (![uniqueSizes containsObject:sizeNum]) {
                [uniqueSizes addObject:sizeNum];
            }
            
            NSInteger freq = [sizeFrequency[sizeNum] integerValue] + [self.fontStats[fontKey] integerValue];
            sizeFrequency[sizeNum] = @(freq);
        }
    }
    
    // Sort sizes in descending order
    [uniqueSizes sortUsingComparator:^NSComparisonResult(NSNumber *obj1, NSNumber *obj2) {
        return [obj2 compare:obj1];
    }];
    
    // Assign heading levels based on size hierarchy
    // Assume largest font is H1, second largest is H2, etc.
    NSMutableDictionary<NSNumber *, NSNumber *> *sizeToHeadingLevel = [NSMutableDictionary dictionary];
    NSInteger headingLevel = 1;
    
    for (NSNumber *size in uniqueSizes) {
        // Only assign heading levels to fonts that are significantly larger than average
        // and appear less frequently (typical of headings)
        NSInteger frequency = [sizeFrequency[size] integerValue];
        
        if (headingLevel <= 6 && frequency < 100) { // Adjust threshold as needed
            sizeToHeadingLevel[size] = @(headingLevel);
            headingLevel++;
        } else {
            sizeToHeadingLevel[size] = @(0); // Body text
        }
    }
    
    // Apply heading levels to text elements
    for (id<ContentElement> element in self.allElements) {
        if ([element isKindOfClass:[TextElement class]]) {
            TextElement *textElement = (TextElement *)element;
            NSNumber *sizeNum = @(textElement.fontSize);
            NSNumber *level = sizeToHeadingLevel[sizeNum];
            textElement.headingLevel = level ? [level integerValue] : 0;
        }
    }
}

- (void)sortElements {
    [self.allElements sortUsingComparator:^NSComparisonResult(id<ContentElement> obj1, id<ContentElement> obj2) {
        // First sort by page
        if ([obj1 respondsToSelector:@selector(pageIndex)] && [obj2 respondsToSelector:@selector(pageIndex)]) {
            NSInteger page1 = [(id)obj1 pageIndex];
            NSInteger page2 = [(id)obj2 pageIndex];
            
            if (page1 != page2) {
                return page1 < page2 ? NSOrderedAscending : NSOrderedDescending;
            }
        }
        
        // Then sort by vertical position (top to bottom)
        CGFloat y1 = CGRectGetMaxY(obj1.bounds);
        CGFloat y2 = CGRectGetMaxY(obj2.bounds);
        
        if (fabs(y1 - y2) > 5.0) { // Tolerance for same line
            return y1 > y2 ? NSOrderedAscending : NSOrderedDescending;
        }
        
        // Finally sort by horizontal position (left to right)
        CGFloat x1 = CGRectGetMinX(obj1.bounds);
        CGFloat x2 = CGRectGetMinX(obj2.bounds);
        
        return x1 < x2 ? NSOrderedAscending : NSOrderedDescending;
    }];
}

- (NSString *)generateYAMLFrontmatter {
    NSMutableString *yaml = [NSMutableString string];
    
    // Get PDF metadata
    NSDictionary *docAttributes = [self.pdfDocument documentAttributes];
    
    [yaml appendString:@"---\n"];
    
    // Title
    NSString *title = docAttributes[PDFDocumentTitleAttribute];
    if (title && title.length > 0) {
        [yaml appendFormat:@"title: \"%@\"\n", [self escapeYAMLString:title]];
    }
    
    // Author
    NSString *author = docAttributes[PDFDocumentAuthorAttribute];
    if (author && author.length > 0) {
        [yaml appendFormat:@"author: \"%@\"\n", [self escapeYAMLString:author]];
    }
    
    // Subject
    NSString *subject = docAttributes[PDFDocumentSubjectAttribute];
    if (subject && subject.length > 0) {
        [yaml appendFormat:@"subject: \"%@\"\n", [self escapeYAMLString:subject]];
    }
    
    // Keywords
    NSArray *keywords = docAttributes[PDFDocumentKeywordsAttribute];
    if (keywords && [keywords isKindOfClass:[NSArray class]] && keywords.count > 0) {
        [yaml appendString:@"keywords:\n"];
        for (NSString *keyword in keywords) {
            if ([keyword isKindOfClass:[NSString class]]) {
                [yaml appendFormat:@"  - \"%@\"\n", [self escapeYAMLString:keyword]];
            }
        }
    }
    
    // Creator (PDF producer software)
    NSString *creator = docAttributes[PDFDocumentCreatorAttribute];
    if (creator && creator.length > 0) {
        [yaml appendFormat:@"creator: \"%@\"\n", [self escapeYAMLString:creator]];
    }
    
    // Producer
    NSString *producer = docAttributes[PDFDocumentProducerAttribute];
    if (producer && producer.length > 0) {
        [yaml appendFormat:@"producer: \"%@\"\n", [self escapeYAMLString:producer]];
    }
    
    // Creation date
    NSDate *creationDate = docAttributes[PDFDocumentCreationDateAttribute];
    if (creationDate) {
        NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
        [formatter setDateFormat:@"yyyy-MM-dd'T'HH:mm:ssZZZZZ"];
        [yaml appendFormat:@"created: %@\n", [formatter stringFromDate:creationDate]];
    }
    
    // Modification date
    NSDate *modDate = docAttributes[PDFDocumentModificationDateAttribute];
    if (modDate) {
        NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
        [formatter setDateFormat:@"yyyy-MM-dd'T'HH:mm:ssZZZZZ"];
        [yaml appendFormat:@"modified: %@\n", [formatter stringFromDate:modDate]];
    }
    
    // PDF specific metadata
    [yaml appendString:@"pdf_metadata:\n"];
    [yaml appendFormat:@"  page_count: %ld\n", (long)[self.pdfDocument pageCount]];
    
    // PDF version
    NSString *pdfVersion = [self extractPDFVersion];
    if (pdfVersion) {
        [yaml appendFormat:@"  version: \"%@\"\n", pdfVersion];
    }
    
    // PDF outline (bookmarks/TOC)
    PDFOutline *outline = [self.pdfDocument outlineRoot];
    if (outline && [outline numberOfChildren] > 0) {
        [yaml appendString:@"  outline:\n"];
        [self appendOutlineToYAML:yaml outline:outline indent:@"    "];
    }
    
    // Conversion metadata
    [yaml appendString:@"conversion:\n"];
    [yaml appendString:@"  tool: \"pdf22md\"\n"];
    [yaml appendFormat:@"  version: \"%s\"\n", VERSION];
    
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateFormat:@"yyyy-MM-dd'T'HH:mm:ssZZZZZ"];
    [yaml appendFormat:@"  date: %@\n", [formatter stringFromDate:[NSDate date]]];
    
    [yaml appendString:@"---\n"];
    
    return yaml;
}

- (NSString *)escapeYAMLString:(NSString *)string {
    // Escape quotes and backslashes for YAML
    NSString *escaped = [string stringByReplacingOccurrencesOfString:@"\\" withString:@"\\\\"];
    escaped = [escaped stringByReplacingOccurrencesOfString:@"\"" withString:@"\\\""];
    escaped = [escaped stringByReplacingOccurrencesOfString:@"\n" withString:@"\\n"];
    escaped = [escaped stringByReplacingOccurrencesOfString:@"\r" withString:@"\\r"];
    return escaped;
}

- (NSString *)extractPDFVersion {
    // Try to extract PDF version from document attributes or metadata
    // This is a simplified approach - actual PDF version extraction might require
    // reading the PDF header directly
    NSDictionary *attributes = [self.pdfDocument documentAttributes];
    for (NSString *key in attributes) {
        id value = attributes[key];
        if ([value isKindOfClass:[NSString class]] && 
            [value rangeOfString:@"PDF-" options:NSCaseInsensitiveSearch].location != NSNotFound) {
            return value;
        }
    }
    return nil;
}

- (void)appendOutlineToYAML:(NSMutableString *)yaml outline:(PDFOutline *)outline indent:(NSString *)indent {
    for (NSUInteger i = 0; i < [outline numberOfChildren]; i++) {
        PDFOutline *child = [outline childAtIndex:i];
        NSString *label = [child label];
        if (label && label.length > 0) {
            [yaml appendFormat:@"%@- title: \"%@\"\n", indent, [self escapeYAMLString:label]];
            
            PDFDestination *destination = [child destination];
            if (destination) {
                PDFPage *page = [destination page];
                NSInteger pageIndex = [self.pdfDocument indexForPage:page];
                [yaml appendFormat:@"%@  page: %ld\n", indent, (long)(pageIndex + 1)];
            }
            
            if ([child numberOfChildren] > 0) {
                [yaml appendFormat:@"%@  children:\n", indent];
                NSString *newIndent = [indent stringByAppendingString:@"    "];
                [self appendOutlineToYAML:yaml outline:child indent:newIndent];
            }
        }
    }
}

@end
</file>

<file path="pdf22md-objc/src/PDFPageProcessor.h">
#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

@protocol ContentElement;

@interface PDFPageProcessor : NSObject {
    @public
    NSInteger _pageIndex;
}

- (instancetype)initWithPDFPage:(PDFPage *)pdfPage
                      pageIndex:(NSInteger)pageIndex
                            dpi:(CGFloat)dpi;

- (NSArray<id<ContentElement>> *)extractContentElements;

- (void)captureVectorGraphicsInBounds:(CGRect)bounds
                         withElements:(NSMutableArray *)elements;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/PDFPageProcessor.m">
#import "PDFPageProcessor.h"
#import "ContentElement.h"

@interface PDFPageProcessor ()
@property (nonatomic, strong) PDFPage *pdfPage;
@property (nonatomic, assign) NSInteger pageIndex;
@property (nonatomic, assign) CGFloat dpi;
@property (nonatomic, assign) CGPDFPageRef cgPdfPage;
@end

@implementation PDFPageProcessor

- (instancetype)initWithPDFPage:(PDFPage *)pdfPage
                      pageIndex:(NSInteger)pageIndex
                            dpi:(CGFloat)dpi {
    self = [super init];
    if (self) {
        _pdfPage = pdfPage;
        _pageIndex = pageIndex;
        _dpi = dpi;
        _cgPdfPage = [pdfPage pageRef];
    }
    return self;
}

- (NSArray<id<ContentElement>> *)extractContentElements {
    // -------------------------------------------------------------------------
    // NEW IMPLEMENTATION (2025-06-22)
    // -------------------------------------------------------------------------
    // The previous version relied on low-level CGPDFScanner APIs which could
    // enter an infinite loop on some malformed PDFs, causing the whole tool to
    // hang. We now use PDFKit's high-level API which is both safer and faster
    // for common text extraction tasks. Vector graphics and images will be
    // handled separately in future improvements.
    // -------------------------------------------------------------------------
    
    NSMutableArray<id<ContentElement>> *elements = [NSMutableArray array];
    
    // 1. Extract plain text for the entire page.
    NSString *pageText = [self.pdfPage string]; // PDFKit handles parsing
    if (!pageText || pageText.length == 0) {
        return elements; // Nothing to do
    }
    
    // 2. Split into paragraphs so we keep some structure.
    NSArray<NSString *> *paragraphs = [pageText componentsSeparatedByCharactersInSet:[NSCharacterSet newlineCharacterSet]];
    
    // 3. Prepare some default typography metadata. We no longer have direct
    //    font info ‚Äì set conservative defaults so later heading detection logic
    //    can still run (all body text will share the same size, which is fine
    //    for now; future work can re-introduce advanced heuristics).
    NSString *defaultFontName = @"Helvetica";
    CGFloat   defaultFontSize = 12.0;
    
    // 4. Create a rough vertical cursor so elements have distinct Y positions.
    //    This keeps the existing (page, y, x) sort logic intact.
    CGFloat pageHeight = CGRectGetHeight([self.pdfPage boundsForBox:kPDFDisplayBoxMediaBox]);
    CGFloat cursorY    = pageHeight; // start at the top
    CGFloat lineHeight = defaultFontSize * 1.4; // simple approximation
    
    for (NSString *rawParagraph in paragraphs) {
        NSString *trimmed = [rawParagraph stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
        if (trimmed.length == 0) { continue; }
        
        TextElement *element = [[TextElement alloc] init];
        element.text      = trimmed;
        element.fontName  = defaultFontName;
        element.fontSize  = defaultFontSize;
        element.isBold    = NO;
        element.isItalic  = NO;
        element.pageIndex = self.pageIndex;
        
        CGRect bounds = CGRectMake(0, cursorY - lineHeight, 400, lineHeight);
        element.bounds = bounds;
        
        cursorY -= (lineHeight + 2.0); // simple spacing
        
        [elements addObject:element];
    }
    
    // 5. Extract images using PDFKit annotations
    [self extractImagesFromPageWithElements:elements];
    
    return elements;
}

- (void)captureVectorGraphicsInBounds:(CGRect)bounds
                         withElements:(NSMutableArray *)elements {
    // Expand bounds slightly to ensure we capture everything
    bounds = CGRectInset(bounds, -5, -5);
    
    // Calculate size at specified DPI
    CGFloat scale = self.dpi / 72.0;
    size_t width = (size_t)(CGRectGetWidth(bounds) * scale);
    size_t height = (size_t)(CGRectGetHeight(bounds) * scale);
    
    if (width == 0 || height == 0) {
        return;
    }
    
    // Create bitmap context
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, colorSpace,
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        return;
    }
    
    // Set white background
    CGContextSetRGBFillColor(context, 1.0, 1.0, 1.0, 1.0);
    CGContextFillRect(context, CGRectMake(0, 0, width, height));
    
    // Set up transformation to render just the bounds area
    CGContextSaveGState(context);
    CGContextScaleCTM(context, scale, scale);
    CGContextTranslateCTM(context, -bounds.origin.x, -bounds.origin.y);
    
    // Draw the PDF page
    CGContextDrawPDFPage(context, self.cgPdfPage);
    
    CGContextRestoreGState(context);
    
    // Create image
    CGImageRef image = CGBitmapContextCreateImage(context);
    CGContextRelease(context);
    
    if (image) {
        ImageElement *element = [[ImageElement alloc] init];
        element.image = image;
        element.bounds = bounds;
        element.pageIndex = self.pageIndex;
        element.isVectorSource = YES;
        [elements addObject:element];
    }
}

- (void)extractImagesFromPageWithElements:(NSMutableArray *)elements {
    // Method 1: Extract images from annotations (for embedded images)
    NSArray<PDFAnnotation *> *annotations = [self.pdfPage annotations];
    NSInteger imageIndex = 0;
    
    for (PDFAnnotation *annotation in annotations) {
        // Skip text annotations and other non-image types
        if (![annotation isKindOfClass:[PDFAnnotation class]]) {
            continue;
        }
        
        // Try to get image from annotation appearance
        CGImageRef image = [self imageFromAnnotation:annotation];
        if (image) {
            ImageElement *element = [[ImageElement alloc] init];
            element.image = image;
            element.bounds = [annotation bounds];
            element.pageIndex = self.pageIndex;
            element.isVectorSource = NO;
            [elements addObject:element];
            imageIndex++;
        }
    }
    
    // Method 2: Render page areas that likely contain images
    // This is a fallback approach - render page in sections and detect image-like content
    [self extractImagesByRenderingPageSections:elements startingIndex:imageIndex];
}

- (CGImageRef)imageFromAnnotation:(PDFAnnotation *)annotation {
    // Try to extract image from annotation's appearance stream
    CGRect bounds = [annotation bounds];
    if (CGRectIsEmpty(bounds) || bounds.size.width < 10 || bounds.size.height < 10) {
        return NULL;
    }
    
    // Create a bitmap context to render the annotation
    CGFloat scale = self.dpi / 72.0;
    size_t width = (size_t)(bounds.size.width * scale);
    size_t height = (size_t)(bounds.size.height * scale);
    
    if (width == 0 || height == 0) {
        return NULL;
    }
    
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, colorSpace,
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        return NULL;
    }
    
    // Set white background
    CGContextSetRGBFillColor(context, 1.0, 1.0, 1.0, 1.0);
    CGContextFillRect(context, CGRectMake(0, 0, width, height));
    
    // Transform context to match annotation bounds
    CGContextSaveGState(context);
    CGContextScaleCTM(context, scale, scale);
    
    // Draw just the annotation area from the page
    CGContextClipToRect(context, CGRectMake(0, 0, bounds.size.width, bounds.size.height));
    CGContextTranslateCTM(context, -bounds.origin.x, -bounds.origin.y);
    CGContextDrawPDFPage(context, self.cgPdfPage);
    
    CGContextRestoreGState(context);
    
    // Create image
    CGImageRef image = CGBitmapContextCreateImage(context);
    CGContextRelease(context);
    
    return image;
}

- (void)extractImagesByRenderingPageSections:(NSMutableArray *)elements startingIndex:(NSInteger)startIndex {
    // This method divides the page into a grid and analyzes each section
    // to detect areas that contain primarily image content vs text content
    
    CGRect pageRect = [self.pdfPage boundsForBox:kPDFDisplayBoxMediaBox];
    CGFloat sectionSize = 100.0; // 100 point sections
    
    NSInteger gridX = (NSInteger)ceil(pageRect.size.width / sectionSize);
    NSInteger gridY = (NSInteger)ceil(pageRect.size.height / sectionSize);
    
    NSInteger imageIndex = startIndex;
    
    for (NSInteger x = 0; x < gridX; x++) {
        for (NSInteger y = 0; y < gridY; y++) {
            CGRect sectionRect = CGRectMake(x * sectionSize, y * sectionSize, 
                                          sectionSize, sectionSize);
            
            // Intersect with page bounds
            sectionRect = CGRectIntersection(sectionRect, pageRect);
            if (CGRectIsEmpty(sectionRect) || sectionRect.size.width < 20 || sectionRect.size.height < 20) {
                continue;
            }
            
            // Check if this section contains primarily image content
            if ([self sectionContainsImageContent:sectionRect]) {
                CGImageRef sectionImage = [self renderPageSection:sectionRect];
                if (sectionImage) {
                    ImageElement *element = [[ImageElement alloc] init];
                    element.image = sectionImage;
                    element.bounds = sectionRect;
                    element.pageIndex = self.pageIndex;
                    element.isVectorSource = YES; // Since we're rendering from vector
                    [elements addObject:element];
                    imageIndex++;
                }
            }
        }
    }
}

- (BOOL)sectionContainsImageContent:(CGRect)sectionRect {
    // Simple heuristic: if a section doesn't contain much text, it might be an image
    // This is a simplified approach - we could improve this with more sophisticated analysis
    
    // Get text in this section
    PDFSelection *selection = [self.pdfPage selectionForRect:sectionRect];
    NSString *sectionText = [selection string];
    
    // If there's very little text, it might be an image area
    NSString *trimmedText = [sectionText stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    
    // Threshold: if less than 10 characters, consider it potentially an image area
    return [trimmedText length] < 10;
}

- (CGImageRef)renderPageSection:(CGRect)sectionRect {
    // Render just the specified section of the page
    CGFloat scale = self.dpi / 72.0;
    size_t width = (size_t)(sectionRect.size.width * scale);
    size_t height = (size_t)(sectionRect.size.height * scale);
    
    if (width == 0 || height == 0) {
        return NULL;
    }
    
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, colorSpace,
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        return NULL;
    }
    
    // Set white background
    CGContextSetRGBFillColor(context, 1.0, 1.0, 1.0, 1.0);
    CGContextFillRect(context, CGRectMake(0, 0, width, height));
    
    // Transform context to render just the section
    CGContextSaveGState(context);
    CGContextScaleCTM(context, scale, scale);
    CGContextTranslateCTM(context, -sectionRect.origin.x, -sectionRect.origin.y);
    
    // Draw the PDF page
    CGContextDrawPDFPage(context, self.cgPdfPage);
    
    CGContextRestoreGState(context);
    
    // Create image
    CGImageRef image = CGBitmapContextCreateImage(context);
    CGContextRelease(context);
    
    return image;
}

@end
</file>

<file path="pdf22md-objc/test/README.md">
---
title: "README.md"
creator: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36 Edg/137.0.0.0"
producer: "Skia/PDF m137"
created: 2025-06-23T01:33:53+02:00
modified: 2025-06-23T01:33:53+02:00
pdf_metadata:
  page_count: 2
conversion:
  tool: "pdf22md"
  version: "v1.1.0-dirty"
  date: 2025-06-23T02:28:31+02:00
---

23/06/2025, 01:33 README.md

![Image](image_000.png)

![Image](image_001.png)

pdf22md

MIT

License MIT

License

10.15+

![Image](image_002.png)

![Image](image_003.png)

macOS 10.15+

macOS

Build and Release Build and Release passing passing

A blazingly fast PDF to Markdown converter for macOS.

pdf22md is a command-line tool that extracts all text and image content from a PDF file and converts it into a

![Image](image_004.png)

![Image](image_005.png)

![Image](image_006.png)

clean Markdown document. It uses Grand Central Dispatch (GCD) to process pages and save images in

parallel, making it exceptionally fast for multi-page documents.

Key Features

High-Speed Conversion: Uses all available CPU cores to process PDF pages concurrently

Intelligent Heading Detection: Analyzes font sizes and usage frequency to automatically format titles

![Image](image_007.png)

![Image](image_008.png)

![Image](image_009.png)

and headings ( # , ## , etc.)

Asset Extraction: Saves raster and vector images into a specified assets folder and links them correctly

in the Markdown file

Smart Image Formatting: Automatically chooses between JPEG (for photos) and PNG (for graphics with

transparency) to optimize file size and quality

Flexible I/O: Reads from a PDF file or stdin and writes to a Markdown file or stdout

![Image](image_010.png)

![Image](image_011.png)

![Image](image_012.png)

Customizable Rasterization: Allows setting a custom DPI for converting vector graphics to bitmaps

Installation

Using Homebrew (Coming Soon)

brew tap twardoch/pdf22md

brew install pdf22md

![Image](image_013.png)

![Image](image_014.png)

Building from Source

To build the project manually, you need Xcode Command Line Tools installed.

# Clone the repository

git clone https://github.com/twardoch/pdf22md.git

cd pdf22md

# Compile the tool

make

# Install it to /usr/local/bin (optional)

sudo make install

Download Pre-built Binary

Pre-built binaries are available from the Releases page.

Usage

Usage: pdf22md [-i input.pdf] [-o output.md] [-a assets

_

folder] [-d dpi]

Converts PDF documents to Markdown format

-i <path>: Input PDF file (default: stdin)

-o <path>: Output Markdown file (default: stdout)

-a <path>: Assets folder for extracted images

-d <dpi>: DPI for rasterizing vector graphics (default: 144)

Examples

# Convert a PDF file to Markdown

pdf22md -i document.pdf -o document.md

# Convert with images saved to an 'assets' folder

pdf22md -i report.pdf -o report.md -a ./assets

# Convert with custom DPI for vector graphics

pdf22md -i presentation.pdf -o presentation.md -a ./images -d 300

# Use with pipes

cat document.pdf | pdf22md > document.md

# Convert and view in less

pdf22md -i manual.pdf | less

Requirements

macOS 10.15 (Catalina) or later

Xcode Command Line Tools (for building from source)

Project Structure

pdf22md/

‚îú‚îÄ‚îÄ src/ # Source code

‚îÇ ‚îú‚îÄ‚îÄ main.m # Entry point

‚îÇ ‚îú‚îÄ‚îÄ PDFMarkdownConverter.* # Main conversion logic

‚îÇ ‚îú‚îÄ‚îÄ PDFPageProcessor.* # PDF page processing

‚îÇ ‚îú‚îÄ‚îÄ ContentElement.* # Content element definitions

‚îÇ ‚îî‚îÄ‚îÄ AssetExtractor.* # Image extraction logic

‚îú‚îÄ‚îÄ docs/ # Additional documentation

‚îú‚îÄ‚îÄ test/ # Test files

file:///Users/adam/Developer/vcs/github.twardoch/pub/pdf22md/README.md 1/2

23/06/2025, 01:33 README.md

![Image](image_015.png)

![Image](image_016.png)

‚îú‚îÄ‚îÄ LICENSE # MIT License

‚îú‚îÄ‚îÄ Makefile # Build configuration

‚îî‚îÄ‚îÄ README.md # This file

Contributing

Contributions are welcome! Please feel free to submit a Pull Request. For major changes, please open an

![Image](image_017.png)

![Image](image_018.png)

![Image](image_019.png)

issue first to discuss what you

would like to change.

1. Fork the repository

2. Create your feature branch ( git checkout -b feature/AmazingFeature )

3. Commit your changes ( git commit -m 'Add some AmazingFeature' )

![Image](image_020.png)

![Image](image_021.png)

![Image](image_022.png)

4. Push to the branch ( git push origin feature/AmazingFeature )

5. Open a Pull Request

License

This project is licensed under the MIT License - see the LICENSE file for details.

Acknowledgments

![Image](image_023.png)

![Image](image_024.png)

![Image](image_025.png)

![Image](image_026.png)

![Image](image_027.png)

Built with Apple‚Äôs PDFKit and Core Graphics frameworks

Parallel processing powered by Grand Central Dispatch (GCD)

Inspired by the need for fast, accurate PDF to Markdown conversion

Related Projects

pdfplumber - Python library for PDF processing

![Image](image_028.png)

pdf2md - Another PDF to Markdown converter

![Image](image_029.png)

![Image](image_030.png)

![Image](image_031.png)

![Image](image_032.png)

pandoc - Universal document converter

Changelog

See CHANGELOG.md for a list of changes in each version.

Support

If you encounter any issues or have questions, please open an issue on GitHub.

![Image](image_033.png)

![Image](image_034.png)

file:///Users/adam/Developer/vcs/github.twardoch/pub/pdf22md/README.md 2/2
</file>

<file path="pdf22md-objc/Tests/Integration/EndToEndConversionTests.m">
//
//  EndToEndConversionTests.m
//  pdf22md
//
//  Integration tests for complete PDF to Markdown conversion pipeline
//

#import <XCTest/XCTest.h>
#import "../../src/PDFMarkdownConverter.h"

@interface EndToEndConversionTests : XCTestCase
@property (nonatomic, strong) NSString *testResourcesPath;
@property (nonatomic, strong) NSString *tempOutputPath;
@end

@implementation EndToEndConversionTests

- (void)setUp {
    [super setUp];
    
    // Set up test resources path
    NSBundle *testBundle = [NSBundle bundleForClass:[self class]];
    self.testResourcesPath = [testBundle.bundlePath stringByAppendingPathComponent:@"Resources"];
    
    // Create test resources directory if it doesn't exist
    NSFileManager *fileManager = [NSFileManager defaultManager];
    if (![fileManager fileExistsAtPath:self.testResourcesPath]) {
        [fileManager createDirectoryAtPath:self.testResourcesPath 
               withIntermediateDirectories:YES 
                                attributes:nil 
                                     error:nil];
    }
    
    // Set up temporary output path
    NSString *tempDir = NSTemporaryDirectory();
    self.tempOutputPath = [tempDir stringByAppendingPathComponent:@"pdf22md-test-output"];
    [fileManager createDirectoryAtPath:self.tempOutputPath 
           withIntermediateDirectories:YES 
                            attributes:nil 
                                 error:nil];
}

- (void)tearDown {
    // Clean up temporary output directory
    NSFileManager *fileManager = [NSFileManager defaultManager];
    [fileManager removeItemAtPath:self.tempOutputPath error:nil];
    
    self.testResourcesPath = nil;
    self.tempOutputPath = nil;
    [super tearDown];
}

#pragma mark - Test PDF Creation Helpers

- (NSString *)createSimpleTestPDF {
    // Create a simple PDF for testing purposes
    NSString *pdfPath = [self.testResourcesPath stringByAppendingPathComponent:@"simple-test.pdf"];
    
    // Check if PDF already exists
    if ([[NSFileManager defaultManager] fileExistsAtPath:pdfPath]) {
        return pdfPath;
    }
    
    // Create a minimal PDF using Core Graphics
    CFURLRef url = (__bridge CFURLRef)[NSURL fileURLWithPath:pdfPath];
    CGContextRef context = CGPDFContextCreateWithURL(url, NULL, NULL);
    
    if (context) {
        CGRect pageRect = CGRectMake(0, 0, 612, 792); // US Letter size
        CGContextBeginPage(context, &pageRect);
        
        // Add some text
        CGContextSelectFont(context, "Helvetica", 12, kCGEncodingMacRoman);
        CGContextSetTextDrawingMode(context, kCGTextFill);
        CGContextSetRGBFillColor(context, 0, 0, 0, 1);
        
        const char* text = "Simple Test PDF";
        CGContextShowTextAtPoint(context, 50, 750, text, strlen(text));
        
        const char* bodyText = "This is a simple test PDF created for unit testing purposes.";
        CGContextShowTextAtPoint(context, 50, 700, bodyText, strlen(bodyText));
        
        CGContextEndPage(context);
        CGPDFContextClose(context);
        CGContextRelease(context);
        
        return pdfPath;
    }
    
    return nil;
}

- (void)createTestPDFWithImages {
    // Create a more complex PDF with images for testing
    NSString *pdfPath = [self.testResourcesPath stringByAppendingPathComponent:@"complex-test.pdf"];
    
    // Check if PDF already exists
    if ([[NSFileManager defaultManager] fileExistsAtPath:pdfPath]) {
        return;
    }
    
    CFURLRef url = (__bridge CFURLRef)[NSURL fileURLWithPath:pdfPath];
    CGContextRef context = CGPDFContextCreateWithURL(url, NULL, NULL);
    
    if (context) {
        CGRect pageRect = CGRectMake(0, 0, 612, 792);
        CGContextBeginPage(context, &pageRect);
        
        // Add heading
        CGContextSelectFont(context, "Helvetica-Bold", 18, kCGEncodingMacRoman);
        CGContextSetTextDrawingMode(context, kCGTextFill);
        CGContextSetRGBFillColor(context, 0, 0, 0, 1);
        
        const char* heading = "Test Document with Images";
        CGContextShowTextAtPoint(context, 50, 750, heading, strlen(heading));
        
        // Add body text
        CGContextSelectFont(context, "Helvetica", 12, kCGEncodingMacRoman);
        const char* bodyText = "This document contains both text and images for testing.";
        CGContextShowTextAtPoint(context, 50, 700, bodyText, strlen(bodyText));
        
        // Add a simple colored rectangle as a "image"
        CGContextSetRGBFillColor(context, 1, 0, 0, 1);
        CGContextFillRect(context, CGRectMake(50, 600, 100, 100));
        
        CGContextEndPage(context);
        CGPDFContextClose(context);
        CGContextRelease(context);
    }
}

#pragma mark - Basic Integration Tests

- (void)testSimplePDFConversion {
    NSString *testPDFPath = [self createSimpleTestPDF];
    XCTAssertNotNil(testPDFPath, @"Should be able to create simple test PDF");
    
    // Test the conversion
    PDFMarkdownConverter *converter = [[PDFMarkdownConverter alloc] init];
    NSString *markdown = [converter convertPDFAtPath:testPDFPath 
                                     assetsFolderPath:nil 
                                                  dpi:144];
    
    if (markdown) {
        // Verify basic markdown structure
        XCTAssertTrue([markdown containsString:@"Simple Test PDF"] || 
                     [markdown containsString:@"test"] ||
                     markdown.length > 0, 
                     @"Markdown should contain some content from the PDF");
        
        // Verify it's a string with reasonable content
        XCTAssertTrue(markdown.length > 10, @"Markdown should have reasonable length");
        
        // Basic markdown validation
        XCTAssertTrue([markdown isKindOfClass:[NSString class]], @"Result should be NSString");
    } else {
        // If conversion fails, we should at least verify it fails gracefully
        XCTAssertTrue(YES, @"Conversion may fail gracefully, which is acceptable for now");
    }
}

- (void)testPDFConversionWithAssets {
    [self createTestPDFWithImages];
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"complex-test.pdf"];
    
    // Test conversion with asset extraction
    NSString *assetsFolder = [self.tempOutputPath stringByAppendingPathComponent:@"assets"];
    
    PDFMarkdownConverter *converter = [[PDFMarkdownConverter alloc] init];
    NSString *markdown = [converter convertPDFAtPath:testPDFPath 
                                     assetsFolderPath:assetsFolder 
                                                  dpi:144];
    
    if (markdown) {
        // Verify markdown content
        XCTAssertTrue(markdown.length > 0, @"Should generate some markdown content");
        
        // Check if assets folder was created
        NSFileManager *fileManager = [NSFileManager defaultManager];
        BOOL isDirectory;
        BOOL assetsExist = [fileManager fileExistsAtPath:assetsFolder isDirectory:&isDirectory];
        
        if (assetsExist && isDirectory) {
            // Check for extracted assets
            NSArray *assetFiles = [fileManager contentsOfDirectoryAtPath:assetsFolder error:nil];
            XCTAssertTrue(assetFiles.count >= 0, @"Assets folder should exist and be accessible");
        }
    }
}

#pragma mark - Error Handling Integration Tests

- (void)testNonExistentPDFHandling {
    NSString *nonExistentPath = @"/path/to/nonexistent/file.pdf";
    
    PDFMarkdownConverter *converter = [[PDFMarkdownConverter alloc] init];
    NSString *result = [converter convertPDFAtPath:nonExistentPath 
                                   assetsFolderPath:nil 
                                                dpi:144];
    
    XCTAssertNil(result, @"Should return nil for non-existent PDF");
}

- (void)testInvalidPDFHandling {
    // Create a fake PDF file (actually just text)
    NSString *fakePDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"fake.pdf"];
    NSString *fakeContent = @"This is not a real PDF file";
    [fakeContent writeToFile:fakePDFPath 
                  atomically:YES 
                    encoding:NSUTF8StringEncoding 
                       error:nil];
    
    PDFMarkdownConverter *converter = [[PDFMarkdownConverter alloc] init];
    NSString *result = [converter convertPDFAtPath:fakePDFPath 
                                   assetsFolderPath:nil 
                                                dpi:144];
    
    XCTAssertNil(result, @"Should return nil for invalid PDF file");
    
    // Clean up
    [[NSFileManager defaultManager] removeItemAtPath:fakePDFPath error:nil];
}

#pragma mark - Performance Integration Tests

- (void)testConversionPerformance {
    NSString *testPDFPath = [self createSimpleTestPDF];
    XCTAssertNotNil(testPDFPath, @"Should have test PDF for performance testing");
    
    [self measureBlock:^{
        PDFMarkdownConverter *converter = [[PDFMarkdownConverter alloc] init];
        NSString *markdown = [converter convertPDFAtPath:testPDFPath 
                                         assetsFolderPath:nil 
                                                      dpi:144];
        // Don't assert on the result in performance test, just measure the time
    }];
}

- (void)testMemoryUsageDuringConversion {
    NSString *testPDFPath = [self createSimpleTestPDF];
    
    // Test multiple conversions to check for memory leaks
    for (int i = 0; i < 10; i++) {
        @autoreleasepool {
            PDFMarkdownConverter *converter = [[PDFMarkdownConverter alloc] init];
            NSString *markdown = [converter convertPDFAtPath:testPDFPath 
                                             assetsFolderPath:nil 
                                                          dpi:144];
            converter = nil;
            markdown = nil;
        }
    }
    
    XCTAssertTrue(YES, @"Memory usage test completed without crashes");
}

#pragma mark - DPI Integration Tests

- (void)testDifferentDPISettings {
    NSString *testPDFPath = [self createSimpleTestPDF];
    XCTAssertNotNil(testPDFPath, @"Should have test PDF");
    
    PDFMarkdownConverter *converter = [[PDFMarkdownConverter alloc] init];
    
    // Test different DPI values
    NSArray *dpiValues = @[@72, @144, @300];
    
    for (NSNumber *dpi in dpiValues) {
        NSString *result = [converter convertPDFAtPath:testPDFPath 
                                      assetsFolderPath:nil 
                                                   dpi:[dpi integerValue]];
        
        // Should handle different DPI values gracefully
        // (May return nil if DPI is invalid, but should not crash)
        XCTAssertTrue(YES, @"Should handle DPI %@ without crashing", dpi);
    }
}

#pragma mark - Output Validation Tests

- (void)testMarkdownOutputFormat {
    NSString *testPDFPath = [self createSimpleTestPDF];
    
    PDFMarkdownConverter *converter = [[PDFMarkdownConverter alloc] init];
    NSString *markdown = [converter convertPDFAtPath:testPDFPath 
                                     assetsFolderPath:nil 
                                                  dpi:144];
    
    if (markdown) {
        // Basic markdown format validation
        XCTAssertTrue([markdown isKindOfClass:[NSString class]], @"Output should be NSString");
        
        // Check for reasonable content length
        XCTAssertTrue(markdown.length > 0, @"Markdown should not be empty");
        
        // Validate that it doesn't contain obvious errors
        XCTAssertFalse([markdown containsString:@"<null>"], @"Should not contain null values");
        XCTAssertFalse([markdown containsString:@"ERROR"], @"Should not contain error strings");
    }
}

#pragma mark - Edge Cases Integration Tests

- (void)testEmptyPDFHandling {
    // Create an empty PDF
    NSString *emptyPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"empty.pdf"];
    
    CFURLRef url = (__bridge CFURLRef)[NSURL fileURLWithPath:emptyPDFPath];
    CGContextRef context = CGPDFContextCreateWithURL(url, NULL, NULL);
    
    if (context) {
        // Create a page but add no content
        CGRect pageRect = CGRectMake(0, 0, 612, 792);
        CGContextBeginPage(context, &pageRect);
        CGContextEndPage(context);
        CGPDFContextClose(context);
        CGContextRelease(context);
        
        // Test conversion of empty PDF
        PDFMarkdownConverter *converter = [[PDFMarkdownConverter alloc] init];
        NSString *result = [converter convertPDFAtPath:emptyPDFPath 
                                       assetsFolderPath:nil 
                                                    dpi:144];
        
        // Should handle empty PDF gracefully
        // (May return empty string or nil, but should not crash)
        XCTAssertTrue(YES, @"Should handle empty PDF without crashing");
        
        // Clean up
        [[NSFileManager defaultManager] removeItemAtPath:emptyPDFPath error:nil];
    }
}

@end
</file>

<file path="pdf22md-objc/Tests/Unit/AssetExtractorTests.m">
//
//  AssetExtractorTests.m
//  pdf22md
//
//  Unit tests for asset extraction and image processing functionality
//

#import <XCTest/XCTest.h>
#import <CoreGraphics/CoreGraphics.h>
#import <ImageIO/ImageIO.h>
#import "../../src/AssetExtractor.h"

@interface AssetExtractorTests : XCTestCase
@property (nonatomic, strong) AssetExtractor *extractor;
@property (nonatomic, strong) NSString *testAssetsPath;
@end

@implementation AssetExtractorTests

- (void)setUp {
    [super setUp];
    self.extractor = [[AssetExtractor alloc] init];
    
    // Create temporary test assets directory
    NSString *tempDir = NSTemporaryDirectory();
    self.testAssetsPath = [tempDir stringByAppendingPathComponent:@"pdf22md-test-assets"];
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    [fileManager createDirectoryAtPath:self.testAssetsPath 
           withIntermediateDirectories:YES 
                            attributes:nil 
                                 error:nil];
}

- (void)tearDown {
    // Clean up test assets directory
    NSFileManager *fileManager = [NSFileManager defaultManager];
    [fileManager removeItemAtPath:self.testAssetsPath error:nil];
    
    self.extractor = nil;
    self.testAssetsPath = nil;
    [super tearDown];
}

#pragma mark - Basic Functionality Tests

- (void)testExtractorInitialization {
    XCTAssertNotNil(self.extractor, @"AssetExtractor should initialize successfully");
}

- (void)testSetAssetsFolderPath {
    NSString *testPath = @"/tmp/test-assets";
    [self.extractor setAssetsFolderPath:testPath];
    
    // Note: We can't directly test the private property, but we can test that the method doesn't crash
    // and that subsequent operations work as expected
    XCTAssertTrue(YES, @"setAssetsFolderPath should complete without crashing");
}

#pragma mark - Image Format Detection Tests

- (void)testFormatOptimizationLogic {
    // Test the format optimization logic with synthetic images
    
    // Create a simple test image
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, 100, 100, 8, 0, colorSpace, 
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (context) {
        // Fill with a simple color
        CGContextSetRGBFillColor(context, 1.0, 0.0, 0.0, 1.0);
        CGContextFillRect(context, CGRectMake(0, 0, 100, 100));
        
        CGImageRef testImage = CGBitmapContextCreateImage(context);
        CGContextRelease(context);
        
        if (testImage) {
            // Test format decision logic
            BOOL shouldUseJPEG = [self.extractor shouldUseJPEGForImage:testImage];
            
            // For a simple solid color image, PNG should be preferred
            // (though the exact logic depends on implementation)
            XCTAssertTrue(shouldUseJPEG == YES || shouldUseJPEG == NO, 
                         @"shouldUseJPEGForImage should return a boolean value");
            
            CGImageRelease(testImage);
        }
    }
}

- (void)testImageSaving {
    // Test image saving functionality
    
    // Create a minimal test image
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, 50, 50, 8, 0, colorSpace, 
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (context) {
        // Create a gradient pattern for testing
        CGContextSetRGBFillColor(context, 0.5, 0.5, 1.0, 1.0);
        CGContextFillRect(context, CGRectMake(0, 0, 50, 50));
        
        CGImageRef testImage = CGBitmapContextCreateImage(context);
        CGContextRelease(context);
        
        if (testImage) {
            [self.extractor setAssetsFolderPath:self.testAssetsPath];
            
            NSString *savedPath = [self.extractor saveImage:testImage withBaseName:@"test_image"];
            
            if (savedPath) {
                // Verify the file was created
                NSString *fullPath = [self.testAssetsPath stringByAppendingPathComponent:savedPath];
                NSFileManager *fileManager = [NSFileManager defaultManager];
                XCTAssertTrue([fileManager fileExistsAtPath:fullPath], 
                             @"Saved image file should exist at path: %@", fullPath);
                
                // Verify it's a valid image file
                NSData *imageData = [NSData dataWithContentsOfFile:fullPath];
                XCTAssertNotNil(imageData, @"Should be able to read saved image data");
                XCTAssertTrue(imageData.length > 0, @"Saved image should have non-zero size");
            } else {
                XCTFail(@"saveImage should return a non-nil path");
            }
            
            CGImageRelease(testImage);
        }
    }
}

#pragma mark - File Naming Tests

- (void)testUniqueFileNaming {
    // Test that the extractor generates unique filenames
    [self.extractor setAssetsFolderPath:self.testAssetsPath];
    
    // Create multiple test images and verify unique naming
    for (int i = 0; i < 3; i++) {
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        CGContextRef context = CGBitmapContextCreate(NULL, 20, 20, 8, 0, colorSpace, 
                                                    kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
        CGColorSpaceRelease(colorSpace);
        
        if (context) {
            // Use different colors for each image
            CGFloat red = (i == 0) ? 1.0 : 0.0;
            CGFloat green = (i == 1) ? 1.0 : 0.0;
            CGFloat blue = (i == 2) ? 1.0 : 0.0;
            
            CGContextSetRGBFillColor(context, red, green, blue, 1.0);
            CGContextFillRect(context, CGRectMake(0, 0, 20, 20));
            
            CGImageRef testImage = CGBitmapContextCreateImage(context);
            CGContextRelease(context);
            
            if (testImage) {
                NSString *savedPath = [self.extractor saveImage:testImage withBaseName:@"test"];
                XCTAssertNotNil(savedPath, @"Should get a valid filename for image %d", i);
                
                CGImageRelease(testImage);
            }
        }
    }
    
    // Verify multiple files were created
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSArray *contents = [fileManager contentsOfDirectoryAtPath:self.testAssetsPath error:nil];
    XCTAssertTrue(contents.count >= 1, @"Should have created at least one image file");
}

#pragma mark - Error Handling Tests

- (void)testNilImageHandling {
    [self.extractor setAssetsFolderPath:self.testAssetsPath];
    
    NSString *result = [self.extractor saveImage:NULL withBaseName:@"test"];
    XCTAssertNil(result, @"Should return nil for NULL image");
}

- (void)testInvalidAssetsFolderHandling {
    // Test with invalid assets folder path
    NSString *invalidPath = @"/invalid/path/that/cannot/be/created";
    [self.extractor setAssetsFolderPath:invalidPath];
    
    // Create a test image
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, 10, 10, 8, 0, colorSpace, 
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (context) {
        CGContextSetRGBFillColor(context, 1.0, 1.0, 1.0, 1.0);
        CGContextFillRect(context, CGRectMake(0, 0, 10, 10));
        
        CGImageRef testImage = CGBitmapContextCreateImage(context);
        CGContextRelease(context);
        
        if (testImage) {
            NSString *result = [self.extractor saveImage:testImage withBaseName:@"test"];
            // Should handle the error gracefully (exact behavior depends on implementation)
            // At minimum, should not crash
            
            CGImageRelease(testImage);
        }
    }
}

#pragma mark - Performance Tests

- (void)testImageSavingPerformance {
    [self.extractor setAssetsFolderPath:self.testAssetsPath];
    
    [self measureBlock:^{
        // Create and save a test image
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        CGContextRef context = CGBitmapContextCreate(NULL, 100, 100, 8, 0, colorSpace, 
                                                    kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
        CGColorSpaceRelease(colorSpace);
        
        if (context) {
            CGContextSetRGBFillColor(context, 0.5, 0.5, 0.5, 1.0);
            CGContextFillRect(context, CGRectMake(0, 0, 100, 100));
            
            CGImageRef testImage = CGBitmapContextCreateImage(context);
            CGContextRelease(context);
            
            if (testImage) {
                [self.extractor saveImage:testImage withBaseName:@"perf_test"];
                CGImageRelease(testImage);
            }
        }
    }];
}

#pragma mark - Memory Management Tests

- (void)testMemoryManagement {
    // Test that multiple image operations don't cause memory issues
    [self.extractor setAssetsFolderPath:self.testAssetsPath];
    
    for (int i = 0; i < 10; i++) {
        @autoreleasepool {
            CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
            CGContextRef context = CGBitmapContextCreate(NULL, 50, 50, 8, 0, colorSpace, 
                                                        kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
            CGColorSpaceRelease(colorSpace);
            
            if (context) {
                CGContextSetRGBFillColor(context, (i % 3) / 3.0, ((i + 1) % 3) / 3.0, ((i + 2) % 3) / 3.0, 1.0);
                CGContextFillRect(context, CGRectMake(0, 0, 50, 50));
                
                CGImageRef testImage = CGBitmapContextCreateImage(context);
                CGContextRelease(context);
                
                if (testImage) {
                    NSString *baseName = [NSString stringWithFormat:@"memory_test_%d", i];
                    [self.extractor saveImage:testImage withBaseName:baseName];
                    CGImageRelease(testImage);
                }
            }
        }
    }
    
    // Verify files were created
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSArray *contents = [fileManager contentsOfDirectoryAtPath:self.testAssetsPath error:nil];
    XCTAssertTrue(contents.count > 0, @"Should have created image files during memory test");
}

@end
</file>

<file path="pdf22md-objc/Tests/Unit/ContentElementTests.m">
//
//  ContentElementTests.m
//  pdf22md
//
//  Unit tests for ContentElement model and text/image element functionality
//

#import <XCTest/XCTest.h>
#import <CoreGraphics/CoreGraphics.h>
#import "../../src/ContentElement.h"

@interface ContentElementTests : XCTestCase
@end

@implementation ContentElementTests

- (void)setUp {
    [super setUp];
}

- (void)tearDown {
    [super tearDown];
}

#pragma mark - ContentElement Protocol Tests

- (void)testContentElementProtocolExists {
    // Verify that the ContentElement protocol exists and can be referenced
    Protocol *contentElementProtocol = @protocol(ContentElement);
    XCTAssertNotNil(contentElementProtocol, @"ContentElement protocol should exist");
}

#pragma mark - Text Element Tests

- (void)testTextElementCreation {
    // Test creation of text elements
    NSString *testText = @"Sample text content";
    CGRect testBounds = CGRectMake(10, 20, 200, 30);
    NSInteger testPage = 1;
    
    // Check if TextElement class exists and can be instantiated
    Class textElementClass = NSClassFromString(@"TextElement");
    if (textElementClass) {
        // Test basic instantiation
        id textElement = [[textElementClass alloc] init];
        XCTAssertNotNil(textElement, @"TextElement should be instantiable");
        
        // Test that it conforms to ContentElement protocol
        XCTAssertTrue([textElement conformsToProtocol:@protocol(ContentElement)], 
                     @"TextElement should conform to ContentElement protocol");
    } else {
        XCTFail(@"TextElement class should be available");
    }
}

- (void)testTextElementProperties {
    Class textElementClass = NSClassFromString(@"TextElement");
    if (textElementClass) {
        id textElement = [[textElementClass alloc] init];
        
        // Test basic property access (using KVC since we don't have direct access to the interface)
        NSString *testText = @"Test content";
        
        // Check if text property exists and can be set/get
        if ([textElement respondsToSelector:@selector(setText:)]) {
            [textElement performSelector:@selector(setText:) withObject:testText];
            
            if ([textElement respondsToSelector:@selector(text)]) {
                NSString *retrievedText = [textElement performSelector:@selector(text)];
                XCTAssertEqualObjects(retrievedText, testText, @"Text property should store and retrieve correctly");
            }
        }
        
        // Test bounds property if available
        if ([textElement respondsToSelector:@selector(setBounds:)]) {
            CGRect testBounds = CGRectMake(5, 10, 100, 20);
            NSValue *boundsValue = [NSValue valueWithCGRect:testBounds];
            [textElement performSelector:@selector(setBounds:) withObject:boundsValue];
            
            if ([textElement respondsToSelector:@selector(bounds)]) {
                NSValue *retrievedBounds = [textElement performSelector:@selector(bounds)];
                CGRect retrievedRect = [retrievedBounds CGRectValue];
                XCTAssertTrue(CGRectEqualToRect(retrievedRect, testBounds), 
                             @"Bounds property should store and retrieve correctly");
            }
        }
    }
}

#pragma mark - Image Element Tests

- (void)testImageElementCreation {
    Class imageElementClass = NSClassFromString(@"ImageElement");
    if (imageElementClass) {
        // Test basic instantiation
        id imageElement = [[imageElementClass alloc] init];
        XCTAssertNotNil(imageElement, @"ImageElement should be instantiable");
        
        // Test that it conforms to ContentElement protocol
        XCTAssertTrue([imageElement conformsToProtocol:@protocol(ContentElement)], 
                     @"ImageElement should conform to ContentElement protocol");
    } else {
        XCTFail(@"ImageElement class should be available");
    }
}

- (void)testImageElementWithCGImage {
    Class imageElementClass = NSClassFromString(@"ImageElement");
    if (imageElementClass) {
        // Create a test CGImage
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        CGContextRef context = CGBitmapContextCreate(NULL, 50, 50, 8, 0, colorSpace, 
                                                    kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
        CGColorSpaceRelease(colorSpace);
        
        if (context) {
            CGContextSetRGBFillColor(context, 1.0, 0.0, 0.0, 1.0);
            CGContextFillRect(context, CGRectMake(0, 0, 50, 50));
            
            CGImageRef testImage = CGBitmapContextCreateImage(context);
            CGContextRelease(context);
            
            if (testImage) {
                id imageElement = [[imageElementClass alloc] init];
                
                // Test image property if available
                if ([imageElement respondsToSelector:@selector(setImage:)]) {
                    // Note: CGImageRef is not an object, so we need to handle it appropriately
                    // This test may need adjustment based on the actual implementation
                    XCTAssertTrue(YES, @"Image element should be able to handle CGImageRef");
                }
                
                CGImageRelease(testImage);
            }
        }
    }
}

#pragma mark - Markdown Generation Tests

- (void)testMarkdownGeneration {
    // Test that elements can generate markdown representation
    Class textElementClass = NSClassFromString(@"TextElement");
    if (textElementClass) {
        id textElement = [[textElementClass alloc] init];
        
        if ([textElement respondsToSelector:@selector(markdownRepresentation)]) {
            NSString *markdown = [textElement performSelector:@selector(markdownRepresentation)];
            XCTAssertTrue([markdown isKindOfClass:[NSString class]], 
                         @"markdownRepresentation should return an NSString");
        } else {
            XCTFail(@"TextElement should implement markdownRepresentation method");
        }
    }
}

#pragma mark - Bounds and Positioning Tests

- (void)testBoundsHandling {
    // Test bounds property across different element types
    NSArray *elementClassNames = @[@"TextElement", @"ImageElement"];
    
    for (NSString *className in elementClassNames) {
        Class elementClass = NSClassFromString(className);
        if (elementClass) {
            id element = [[elementClass alloc] init];
            
            // Test bounds property
            if ([element respondsToSelector:@selector(bounds)]) {
                // Default bounds should be valid
                CGRect bounds = CGRectZero;
                if ([element respondsToSelector:@selector(bounds)]) {
                    NSValue *boundsValue = [element performSelector:@selector(bounds)];
                    if (boundsValue) {
                        bounds = [boundsValue CGRectValue];
                    }
                }
                
                // Bounds should be a valid rectangle (finite values)
                XCTAssertTrue(isfinite(bounds.origin.x) && isfinite(bounds.origin.y) && 
                             isfinite(bounds.size.width) && isfinite(bounds.size.height),
                             @"%@ bounds should have finite values", className);
            }
        }
    }
}

#pragma mark - Page Index Tests

- (void)testPageIndexProperty {
    // Test page index property across element types
    NSArray *elementClassNames = @[@"TextElement", @"ImageElement"];
    
    for (NSString *className in elementClassNames) {
        Class elementClass = NSClassFromString(className);
        if (elementClass) {
            id element = [[elementClass alloc] init];
            
            if ([element respondsToSelector:@selector(pageIndex)]) {
                NSInteger pageIndex = [[element performSelector:@selector(pageIndex)] integerValue];
                XCTAssertTrue(pageIndex >= 0, @"%@ pageIndex should be non-negative", className);
            }
            
            // Test setting page index if setter exists
            if ([element respondsToSelector:@selector(setPageIndex:)]) {
                NSInteger testPageIndex = 5;
                [element performSelector:@selector(setPageIndex:) withObject:@(testPageIndex)];
                
                if ([element respondsToSelector:@selector(pageIndex)]) {
                    NSInteger retrievedIndex = [[element performSelector:@selector(pageIndex)] integerValue];
                    XCTAssertEqual(retrievedIndex, testPageIndex, 
                                  @"%@ should store and retrieve pageIndex correctly", className);
                }
            }
        }
    }
}

#pragma mark - Memory Management Tests

- (void)testElementMemoryManagement {
    // Test that elements can be created and destroyed without memory issues
    for (int i = 0; i < 100; i++) {
        @autoreleasepool {
            Class textElementClass = NSClassFromString(@"TextElement");
            if (textElementClass) {
                id textElement = [[textElementClass alloc] init];
                
                // Set some properties to test memory handling
                if ([textElement respondsToSelector:@selector(setText:)]) {
                    NSString *testText = [NSString stringWithFormat:@"Test text %d", i];
                    [textElement performSelector:@selector(setText:) withObject:testText];
                }
                
                textElement = nil;
            }
            
            Class imageElementClass = NSClassFromString(@"ImageElement");
            if (imageElementClass) {
                id imageElement = [[imageElementClass alloc] init];
                imageElement = nil;
            }
        }
    }
    
    XCTAssertTrue(YES, @"Memory management test completed without crashes");
}

#pragma mark - Performance Tests

- (void)testElementCreationPerformance {
    [self measureBlock:^{
        for (int i = 0; i < 1000; i++) {
            @autoreleasepool {
                Class textElementClass = NSClassFromString(@"TextElement");
                if (textElementClass) {
                    id textElement = [[textElementClass alloc] init];
                    textElement = nil;
                }
            }
        }
    }];
}

- (void)testMarkdownGenerationPerformance {
    Class textElementClass = NSClassFromString(@"TextElement");
    if (textElementClass) {
        id textElement = [[textElementClass alloc] init];
        
        if ([textElement respondsToSelector:@selector(setText:)]) {
            [textElement performSelector:@selector(setText:) withObject:@"Sample text for performance testing"];
        }
        
        [self measureBlock:^{
            for (int i = 0; i < 1000; i++) {
                if ([textElement respondsToSelector:@selector(markdownRepresentation)]) {
                    [textElement performSelector:@selector(markdownRepresentation)];
                }
            }
        }];
    }
}

@end
</file>

<file path="pdf22md-objc/Tests/Unit/PDFMarkdownConverterTests.m">
//
//  PDFMarkdownConverterTests.m
//  pdf22md
//
//  Unit tests for core PDF to Markdown conversion functionality
//

#import <XCTest/XCTest.h>
#import "../../src/PDFMarkdownConverter.h"
#import "../../src/AssetExtractor.h"
#import "../../src/ContentElement.h"

@interface PDFMarkdownConverterTests : XCTestCase
@property (nonatomic, strong) PDFMarkdownConverter *converter;
@property (nonatomic, strong) NSString *testResourcesPath;
@end

@implementation PDFMarkdownConverterTests

- (void)setUp {
    [super setUp];
    self.converter = [[PDFMarkdownConverter alloc] init];
    
    // Set up test resources path
    NSBundle *testBundle = [NSBundle bundleForClass:[self class]];
    self.testResourcesPath = [testBundle.bundlePath stringByAppendingPathComponent:@"Resources"];
    
    // Ensure test resources directory exists
    NSFileManager *fileManager = [NSFileManager defaultManager];
    if (![fileManager fileExistsAtPath:self.testResourcesPath]) {
        [fileManager createDirectoryAtPath:self.testResourcesPath 
               withIntermediateDirectories:YES 
                                attributes:nil 
                                     error:nil];
    }
}

- (void)tearDown {
    self.converter = nil;
    self.testResourcesPath = nil;
    [super tearDown];
}

#pragma mark - Basic Functionality Tests

- (void)testConverterInitialization {
    XCTAssertNotNil(self.converter, @"PDFMarkdownConverter should initialize successfully");
}

- (void)testInvalidPDFHandling {
    // Test with nil input
    NSString *result = [self.converter convertPDFAtPath:nil 
                                          assetsFolderPath:nil 
                                                       dpi:144];
    XCTAssertNil(result, @"Converter should return nil for nil input path");
    
    // Test with non-existent file
    NSString *nonExistentPath = @"/path/that/does/not/exist.pdf";
    result = [self.converter convertPDFAtPath:nonExistentPath 
                               assetsFolderPath:nil 
                                            dpi:144];
    XCTAssertNil(result, @"Converter should return nil for non-existent file");
}

- (void)testEmptyStringHandling {
    // Test with empty string
    NSString *result = [self.converter convertPDFAtPath:@"" 
                                          assetsFolderPath:nil 
                                                       dpi:144];
    XCTAssertNil(result, @"Converter should return nil for empty string path");
}

- (void)testDPIParameterValidation {
    // Create a minimal test PDF path (we'll use an existing test file)
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"simple-test.pdf"];
    
    // Test with invalid DPI values
    NSString *result = [self.converter convertPDFAtPath:testPDFPath 
                                          assetsFolderPath:nil 
                                                       dpi:0];
    // Should still work with fallback DPI or return error gracefully
    // The exact behavior depends on implementation, but should not crash
    
    result = [self.converter convertPDFAtPath:testPDFPath 
                               assetsFolderPath:nil 
                                            dpi:-144];
    // Should handle negative DPI gracefully
}

#pragma mark - Asset Folder Tests

- (void)testAssetFolderCreation {
    NSString *tempDir = NSTemporaryDirectory();
    NSString *testAssetsFolder = [tempDir stringByAppendingPathComponent:@"test-assets"];
    
    // Clean up any existing test folder
    NSFileManager *fileManager = [NSFileManager defaultManager];
    [fileManager removeItemAtPath:testAssetsFolder error:nil];
    
    // Verify folder doesn't exist initially
    XCTAssertFalse([fileManager fileExistsAtPath:testAssetsFolder], 
                   @"Test assets folder should not exist initially");
    
    // Test folder creation during conversion (with a valid PDF)
    // For now, just test that the method accepts the parameter
    NSString *testPDFPath = [self.testResourcesPath stringByAppendingPathComponent:@"simple-test.pdf"];
    [self.converter convertPDFAtPath:testPDFPath 
                      assetsFolderPath:testAssetsFolder 
                                   dpi:144];
    
    // Clean up
    [fileManager removeItemAtPath:testAssetsFolder error:nil];
}

#pragma mark - Memory Management Tests

- (void)testMemoryManagement {
    // Test that converter handles multiple conversions without memory issues
    for (int i = 0; i < 10; i++) {
        @autoreleasepool {
            PDFMarkdownConverter *tempConverter = [[PDFMarkdownConverter alloc] init];
            
            // Test with nil path to avoid actual file I/O
            NSString *result = [tempConverter convertPDFAtPath:nil 
                                               assetsFolderPath:nil 
                                                            dpi:144];
            XCTAssertNil(result, @"Should handle nil input gracefully");
            
            tempConverter = nil;
        }
    }
}

#pragma mark - Performance Tests

- (void)testPerformanceBaseline {
    // Simple performance test to establish baseline
    [self measureBlock:^{
        // Test basic object creation and method call
        PDFMarkdownConverter *converter = [[PDFMarkdownConverter alloc] init];
        [converter convertPDFAtPath:nil assetsFolderPath:nil dpi:144];
    }];
}

#pragma mark - Error Handling Tests

- (void)testErrorConditions {
    // Test various error conditions that should be handled gracefully
    NSArray *invalidPaths = @[
        @"",
        @"not-a-pdf.txt",
        @"/dev/null",
        @"~/nonexistent/path/file.pdf"
    ];
    
    for (NSString *invalidPath in invalidPaths) {
        NSString *result = [self.converter convertPDFAtPath:invalidPath 
                                            assetsFolderPath:nil 
                                                         dpi:144];
        XCTAssertNil(result, @"Should handle invalid path gracefully: %@", invalidPath);
    }
}

#pragma mark - Integration Points Tests

- (void)testAssetExtractorIntegration {
    // Test that converter properly integrates with AssetExtractor
    // This is a basic smoke test for the integration
    AssetExtractor *extractor = [[AssetExtractor alloc] init];
    XCTAssertNotNil(extractor, @"AssetExtractor should initialize for integration testing");
}

- (void)testContentElementIntegration {
    // Test that converter properly works with ContentElement classes
    // This verifies the model layer integration
    XCTAssertTrue([NSClassFromString(@"ContentElement") conformsToProtocol:@protocol(NSObject)], 
                  @"ContentElement should be available for integration");
}

@end
</file>

<file path="pdf22md-objc/build.sh">
#!/bin/bash

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Print functions
print_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
print_warning() { echo -e "${YELLOW}[WARN]${NC} $1"; }
print_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Check for required tools
check_requirements() {
    local missing_tools=()

    if ! command -v clang &>/dev/null; then
        missing_tools+=("clang")
    fi

    if ! command -v make &>/dev/null; then
        missing_tools+=("make")
    fi

    if [ ${#missing_tools[@]} -ne 0 ]; then
        print_error "Missing required tools: ${missing_tools[*]}"
        print_info "Please install Xcode Command Line Tools:"
        print_info "xcode-select --install"
        exit 1
    fi
}

# Build pdf22md-objc
build_objc() {
    print_info "Building pdf22md (Objective-C implementation)..."
    make clean
    if make; then
        print_info "‚úì pdf22md-objc built successfully"
        return 0
    else
        print_error "Failed to build pdf22md-objc"
        return 1
    fi
}

# Install binary
install_binary() {
    local install_dir="/usr/local/bin"
    print_info "Installing binary to $install_dir..."

    # Create install directory if it doesn't exist
    sudo mkdir -p "$install_dir"

    # Install pdf22md
    if [ -f "pdf22md" ]; then
        sudo install -m 755 pdf22md "$install_dir/pdf22md"
        print_info "‚úì Installed pdf22md"
    fi

    # Install man pages
    if [ -f "docs/pdf22md.1" ]; then
        sudo mkdir -p /usr/local/share/man/man1
        sudo install -m 644 docs/pdf22md.1 /usr/local/share/man/man1/
        print_info "‚úì Installed man pages"
    fi
}

# Run tests
run_tests() {
    print_info "Running tests..."
    if [ -f "run-tests.sh" ]; then
        ./run-tests.sh
    else
        print_warning "No test script found"
    fi
}

# Main execution
main() {
    print_info "Starting pdf22md-objc build process..."

    # Check requirements
    check_requirements

    # Build component
    build_objc

    # Run tests if requested
    if [ "$1" = "--test" ]; then
        run_tests
    fi

    # Install if requested
    if [ "$1" = "--install" ] || [ "$2" = "--install" ]; then
        install_binary
    fi

    print_info "Build complete!"
    print_info "Run './pdf22md --help' for usage information"
}

main "$@"
</file>

<file path="pdf22md-objc/release.sh">
#!/bin/bash

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to print colored output
print_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

# Function to get the latest semver tag
get_latest_tag() {
    git tag -l 'v*' | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -n1
}

# Function to increment version
increment_version() {
    local version=$1
    local major=$(echo $version | cut -d. -f1)
    local minor=$(echo $version | cut -d. -f2)
    local patch=$(echo $version | cut -d. -f3)
    
    # Increment minor version
    minor=$((minor + 1))
    patch=0
    
    echo "${major}.${minor}.${patch}"
}

# Parse command line arguments
VERSION=""
while [[ $# -gt 0 ]]; do
    case $1 in
        --v)
            VERSION="$2"
            shift 2
            ;;
        -h|--help)
            echo "Usage: $0 [--v VERSION]"
            echo "  --v VERSION   Specify version (e.g., 1.2.3)"
            echo "  -h, --help    Show this help message"
            echo ""
            echo "If no version is specified, the script will increment the minor version"
            echo "of the latest git tag, or use 1.0.0 if no tags exist."
            exit 0
            ;;
        *)
            print_error "Unknown option: $1"
            exit 1
            ;;
    esac
done

# Determine version
if [ -z "$VERSION" ]; then
    LATEST_TAG=$(get_latest_tag)
    if [ -z "$LATEST_TAG" ]; then
        VERSION="1.0.0"
        print_info "No previous tags found. Using version $VERSION"
    else
        # Remove 'v' prefix
        CURRENT_VERSION=${LATEST_TAG#v}
        VERSION=$(increment_version $CURRENT_VERSION)
        print_info "Latest tag: $LATEST_TAG"
        print_info "New version: $VERSION"
    fi
else
    # Validate version format
    if ! echo "$VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
        print_error "Invalid version format. Please use semantic versioning (e.g., 1.2.3)"
        exit 1
    fi
fi

TAG="v$VERSION"

# Check if we're on macOS
if [[ "$OSTYPE" != "darwin"* ]]; then
    print_error "This script must be run on macOS"
    exit 1
fi

# Check if git is clean
if ! git diff-index --quiet HEAD --; then
    print_warning "You have uncommitted changes. Committing them now..."
    git add -A
    git commit -m "Release version $VERSION"
fi

# Check if tag already exists
if git rev-parse "$TAG" >/dev/null 2>&1; then
    print_error "Tag $TAG already exists"
    exit 1
fi

print_info "Building pdf22md version $VERSION..."

# Clean and build with version
make clean
make VERSION="$VERSION"

# Test the binary
if ! ./pdf22md -v | grep -q "$VERSION"; then
    print_error "Version check failed"
    exit 1
fi

print_info "Build successful!"

# Create git tag
print_info "Creating git tag $TAG..."
git tag -a "$TAG" -m "Release version $VERSION"

# Push commits and tags
print_info "Pushing to remote..."
git push origin main
git push origin "$TAG"

print_info "‚úÖ Release $VERSION completed successfully!"
print_info ""
print_info "The GitHub Actions workflow will now:"
print_info "  1. Build the universal binary for Intel and Apple Silicon"
print_info "  2. Create a .pkg installer"
print_info "  3. Create a GitHub release with the artifacts"
print_info ""
print_info "Check the Actions tab on GitHub to monitor the release process."
</file>

<file path="pdf22md-objc/run-tests.sh">
#!/bin/bash

# pdf22md Test Runner
# Compiles and runs unit tests for the pdf22md project

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo -e "${YELLOW}üß™ pdf22md Test Suite${NC}"
echo "=================================="

# Create build directory for tests
TEST_BUILD_DIR="build/tests"
mkdir -p "$TEST_BUILD_DIR"

# Compile flags
CFLAGS="-Wall -Wextra -O2 -fobjc-arc"
FRAMEWORKS="-framework Foundation -framework PDFKit -framework CoreGraphics -framework ImageIO -framework XCTest"
INCLUDES="-I./src"

echo -e "${YELLOW}üì¶ Compiling test framework...${NC}"

# Function to compile and run a test
run_test() {
    local test_file="$1"
    local test_name=$(basename "$test_file" .m)
    local executable="$TEST_BUILD_DIR/$test_name"
    
    echo -e "  ${YELLOW}Building${NC} $test_name..."
    
    # Compile the test
    if clang $CFLAGS $FRAMEWORKS $INCLUDES \
        "$test_file" \
        src/PDFMarkdownConverter.m \
        src/AssetExtractor.m \
        src/ContentElement.m \
        src/PDFPageProcessor.m \
        -o "$executable" 2>/dev/null; then
        
        echo -e "  ${GREEN}‚úì${NC} Compiled $test_name"
        
        # Run the test
        echo -e "  ${YELLOW}Running${NC} $test_name..."
        if "$executable" 2>/dev/null; then
            echo -e "  ${GREEN}‚úì PASSED${NC} $test_name"
            return 0
        else
            echo -e "  ${RED}‚úó FAILED${NC} $test_name"
            return 1
        fi
    else
        echo -e "  ${RED}‚úó COMPILE FAILED${NC} $test_name"
        return 1
    fi
}

# Track test results
TOTAL_TESTS=0
PASSED_TESTS=0
FAILED_TESTS=0

echo -e "\n${YELLOW}üî¨ Running Unit Tests...${NC}"

# Run unit tests
for test_file in Tests/Unit/*.m; do
    if [ -f "$test_file" ]; then
        TOTAL_TESTS=$((TOTAL_TESTS + 1))
        if run_test "$test_file"; then
            PASSED_TESTS=$((PASSED_TESTS + 1))
        else
            FAILED_TESTS=$((FAILED_TESTS + 1))
        fi
        echo
    fi
done

echo -e "${YELLOW}üî¨ Running Integration Tests...${NC}"

# Run integration tests
for test_file in Tests/Integration/*.m; do
    if [ -f "$test_file" ]; then
        TOTAL_TESTS=$((TOTAL_TESTS + 1))
        if run_test "$test_file"; then
            PASSED_TESTS=$((PASSED_TESTS + 1))
        else
            FAILED_TESTS=$((FAILED_TESTS + 1))
        fi
        echo
    fi
done

# Summary
echo "=================================="
echo -e "${YELLOW}üìä Test Summary${NC}"
echo "Total Tests:  $TOTAL_TESTS"
echo -e "Passed:       ${GREEN}$PASSED_TESTS${NC}"

if [ $FAILED_TESTS -gt 0 ]; then
    echo -e "Failed:       ${RED}$FAILED_TESTS${NC}"
    echo -e "\n${RED}‚ùå Some tests failed${NC}"
    exit 1
else
    echo -e "Failed:       ${GREEN}0${NC}"
    echo -e "\n${GREEN}‚úÖ All tests passed!${NC}"
    exit 0
fi
</file>

<file path="pdf22md-swift/docs/pdf22md.1">
.TH PDF22MD 1 "June 2025" "pdf22md v1.0" "User Commands"
.SH NAME
pdf22md \- high-performance PDF to Markdown converter
.SH SYNOPSIS
.B pdf22md
[\fB\-i\fR \fIinput.pdf\fR]
[\fB\-o\fR \fIoutput.md\fR]
[\fB\-a\fR \fIassets_folder\fR]
[\fB\-d\fR \fIdpi\fR]
[\fB\-v\fR]
[\fB\-h\fR]
.SH DESCRIPTION
.B pdf22md
is a blazingly fast PDF to Markdown converter that extracts text and images from PDF documents and converts them into clean, structured Markdown format. It uses parallel processing to achieve high performance on multi-page documents.

The tool automatically detects heading hierarchy based on font size analysis, extracts images with intelligent format optimization (PNG/JPEG), and generates YAML frontmatter with document metadata.

.SH OPTIONS
.TP
\fB\-i\fR \fIinput.pdf\fR
Specify the input PDF file to convert. If not provided, pdf22md reads from standard input (stdin).
.TP
\fB\-o\fR \fIoutput.md\fR
Specify the output Markdown file. If not provided, pdf22md writes to standard output (stdout).
.TP
\fB\-a\fR \fIassets_folder\fR
Specify the folder where extracted images will be saved. The folder will be created if it doesn't exist. Images are automatically referenced in the generated Markdown with relative paths.
.TP
\fB\-d\fR \fIdpi\fR
Set the DPI (dots per inch) for rasterizing vector graphics. Default is 144. Higher values produce better quality but larger file sizes. Common values: 72 (screen), 144 (default), 300 (print quality).
.TP
\fB\-v\fR, \fB\-\-version\fR
Display version information and exit.
.TP
\fB\-h\fR, \fB\-\-help\fR
Display usage information and exit.

.SH EXAMPLES
.TP
Convert a PDF file to Markdown:
.B pdf22md \-i document.pdf \-o document.md

.TP
Extract images to an assets folder:
.B pdf22md \-i document.pdf \-o document.md \-a ./assets

.TP
Use higher DPI for better image quality:
.B pdf22md \-i document.pdf \-o document.md \-a ./assets \-d 300

.TP
Convert using pipes (stdin/stdout):
.B cat document.pdf | pdf22md > document.md

.TP
Process a document with custom settings:
.B pdf22md \-i report.pdf \-o report.md \-a ./images \-d 200

.SH INPUT/OUTPUT
.SS Input Sources
.B pdf22md
accepts PDF input from:
.IP ‚Ä¢ 2
File path specified with \fB\-i\fR flag
.IP ‚Ä¢ 2
Standard input (stdin) when no \fB\-i\fR flag is provided

.SS Output Destinations
Markdown output is written to:
.IP ‚Ä¢ 2
File path specified with \fB\-o\fR flag
.IP ‚Ä¢ 2
Standard output (stdout) when no \fB\-o\fR flag is provided

.SS Image Assets
When the \fB\-a\fR flag is used:
.IP ‚Ä¢ 2
Images are extracted and saved to the specified folder
.IP ‚Ä¢ 2
Filenames follow the pattern: image_001.png, image_002.jpg, etc.
.IP ‚Ä¢ 2
Format selection is automatic (PNG for graphics, JPEG for photos)
.IP ‚Ä¢ 2
Markdown contains relative references to the images

.SH FEATURES
.SS Intelligent Content Processing
.IP ‚Ä¢ 2
\fBHeading Detection\fR: Automatically identifies headings (H1-H6) based on font size analysis
.IP ‚Ä¢ 2
\fBText Extraction\fR: Preserves text formatting and structure
.IP ‚Ä¢ 2
\fBImage Processing\fR: Extracts both raster and vector graphics
.IP ‚Ä¢ 2
\fBSmart Formatting\fR: Maintains document hierarchy and readability

.SS Performance Optimizations
.IP ‚Ä¢ 2
\fBParallel Processing\fR: Uses all available CPU cores for maximum speed
.IP ‚Ä¢ 2
\fBMemory Efficiency\fR: Processes large documents without excessive memory usage
.IP ‚Ä¢ 2
\fBFormat Optimization\fR: Automatic PNG/JPEG selection based on image content

.SS Output Features
.IP ‚Ä¢ 2
\fBYAML Frontmatter\fR: Includes document metadata (title, author, creation date)
.IP ‚Ä¢ 2
\fBClean Markdown\fR: Well-structured output compatible with all Markdown processors
.IP ‚Ä¢ 2
\fBAsset Management\fR: Organized image extraction with proper linking

.SH FILE FORMATS
.SS Supported Input
.IP ‚Ä¢ 2
PDF files (version 1.4 and higher)
.IP ‚Ä¢ 2
Unencrypted PDFs (password-protected PDFs are not supported)
.IP ‚Ä¢ 2
PDFs with text, images, and vector graphics
.IP ‚Ä¢ 2
Multi-page documents of any size

.SS Generated Output
.IP ‚Ä¢ 2
\fBMarkdown (.md)\fR: GitHub Flavored Markdown compatible
.IP ‚Ä¢ 2
\fBImages (.png/.jpg)\fR: Extracted graphics in optimal formats
.IP ‚Ä¢ 2
\fBYAML Frontmatter\fR: Document metadata in standard format

.SH PERFORMANCE
Typical conversion speeds on modern hardware:
.IP ‚Ä¢ 2
Simple text documents: <1 second per page
.IP ‚Ä¢ 2
Complex documents with images: 2-5 seconds per page
.IP ‚Ä¢ 2
Large documents (100+ pages): Scales linearly with parallel processing

Memory usage is optimized for documents up to 1000 pages. Very large documents may require additional system memory.

.SH ERROR HANDLING
.B pdf22md
provides detailed error messages with suggestions for common issues:

.SS Common Errors and Solutions
.TP
\fBInvalid PDF file\fR
.IP ‚Ä¢ 2
Verify the file exists and is a valid PDF
.IP ‚Ä¢ 2
Check if the file is corrupted
.IP ‚Ä¢ 2
Ensure you have read permissions

.TP
\fBCannot create assets folder\fR
.IP ‚Ä¢ 2
Check if the parent directory exists
.IP ‚Ä¢ 2
Verify you have write permissions
.IP ‚Ä¢ 2
Ensure sufficient disk space

.TP
\fBPassword-protected PDF\fR
.IP ‚Ä¢ 2
Remove password protection using another tool first
.IP ‚Ä¢ 2
Use: qpdf \-\-decrypt input.pdf output.pdf

.TP
\fBMemory pressure\fR
.IP ‚Ä¢ 2
Close other applications to free memory
.IP ‚Ä¢ 2
Try using a lower DPI setting (\-d 72)
.IP ‚Ä¢ 2
Process smaller sections of large documents

.SH EXIT STATUS
.TP
.B 0
Successful conversion
.TP
.B 1
Error occurred (invalid input, processing failure, I/O error)

.SH ENVIRONMENT
No special environment variables are required. The tool uses standard macOS frameworks (PDFKit, CoreGraphics) and runs on macOS 10.15 and later.

.SH LIMITATIONS
.IP ‚Ä¢ 2
Password-protected PDFs are not supported
.IP ‚Ä¢ 2
Scanned PDFs without OCR text layer will only extract images
.IP ‚Ä¢ 2
Complex table layouts may not convert perfectly
.IP ‚Ä¢ 2
Some advanced PDF features (forms, annotations) are not preserved

.SH COMPATIBILITY
.SS Platform Support
.IP ‚Ä¢ 2
macOS 10.15 (Catalina) and later
.IP ‚Ä¢ 2
Intel and Apple Silicon processors
.IP ‚Ä¢ 2
Universal binary for optimal performance

.SS Markdown Compatibility
Output is compatible with:
.IP ‚Ä¢ 2
GitHub Flavored Markdown
.IP ‚Ä¢ 2
CommonMark specification
.IP ‚Ä¢ 2
Popular Markdown processors (pandoc, Jekyll, etc.)
.IP ‚Ä¢ 2
Static site generators (Hugo, Jekyll, Gatsby)

.SH FILES
.TP
.I ~/.pdf22md/
User configuration directory (future use)
.TP
.I /usr/local/bin/pdf22md
Default installation location
.TP
.I /usr/local/share/man/man1/pdf22md.1
This manual page

.SH EXAMPLES WORKFLOW
.SS Basic Document Conversion
.nf
# Convert a simple document
pdf22md \-i report.pdf \-o report.md

# Result: clean Markdown with YAML frontmatter
# Output includes: title, headings, body text, metadata
.fi

.SS Academic Paper with Images
.nf
# Convert research paper with figure extraction
pdf22md \-i paper.pdf \-o paper.md \-a figures \-d 300

# Result: 
# - paper.md with structured content
# - figures/ folder with high-quality images
# - Proper cross-references to figures
.fi

.SS Batch Processing
.nf
# Process multiple documents
for pdf in *.pdf; do
    pdf22md \-i "$pdf" \-o "${pdf%.pdf}.md" \-a "assets_${pdf%.pdf}"
done
.fi

.SS Integration with Other Tools
.nf
# Combine with pandoc for further processing
pdf22md \-i document.pdf | pandoc \-f markdown \-t html \-o document.html

# Use with static site generators
pdf22md \-i post.pdf \-o content/posts/post.md \-a static/images
.fi

.SH TROUBLESHOOTING
.SS Performance Issues
If conversion is slow:
.IP ‚Ä¢ 2
Check available memory and CPU usage
.IP ‚Ä¢ 2
Close unnecessary applications
.IP ‚Ä¢ 2
Try lower DPI setting for faster processing
.IP ‚Ä¢ 2
Process documents in smaller batches

.SS Quality Issues
If output quality is poor:
.IP ‚Ä¢ 2
Increase DPI setting (\-d 300) for better images
.IP ‚Ä¢ 2
Verify the source PDF has good quality text
.IP ‚Ä¢ 2
Check if the PDF has a proper text layer (not just scanned images)

.SS Memory Errors
For large documents:
.IP ‚Ä¢ 2
Ensure sufficient RAM (8GB+ recommended for large PDFs)
.IP ‚Ä¢ 2
Close other memory-intensive applications
.IP ‚Ä¢ 2
Split very large PDFs into smaller parts first

.SH REPORTING BUGS
Report bugs and feature requests at:
.UR https://github.com/twardoch/pdf22md/issues
.UE

Include in your report:
.IP ‚Ä¢ 2
pdf22md version (\fBpdf22md \-v\fR)
.IP ‚Ä¢ 2
macOS version
.IP ‚Ä¢ 2
Sample PDF file (if possible)
.IP ‚Ä¢ 2
Complete error message
.IP ‚Ä¢ 2
Steps to reproduce the issue

.SH AUTHORS
Written by Adam Twardoch and contributors.

.SH LICENSE
MIT License. See the LICENSE file for details.

.SH SEE ALSO
.BR pandoc (1),
.BR qpdf (1),
.BR pdftotext (1),
.BR markdown (7)

Project homepage: 
.UR https://github.com/twardoch/pdf22md
.UE
</file>

<file path="pdf22md-swift/test/README.md">
---
title: "README.md"
creator: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36 Edg/137.0.0.0"
producer: "Skia/PDF m137"
created: 2025-06-23T01:33:53+02:00
modified: 2025-06-23T01:33:53+02:00
pdf_metadata:
  page_count: 2
conversion:
  tool: "pdf22md"
  version: "v1.1.0-dirty"
  date: 2025-06-23T02:28:31+02:00
---

23/06/2025, 01:33 README.md

![Image](image_000.png)

![Image](image_001.png)

pdf22md

MIT

License MIT

License

10.15+

![Image](image_002.png)

![Image](image_003.png)

macOS 10.15+

macOS

Build and Release Build and Release passing passing

A blazingly fast PDF to Markdown converter for macOS.

pdf22md is a command-line tool that extracts all text and image content from a PDF file and converts it into a

![Image](image_004.png)

![Image](image_005.png)

![Image](image_006.png)

clean Markdown document. It uses Grand Central Dispatch (GCD) to process pages and save images in

parallel, making it exceptionally fast for multi-page documents.

Key Features

High-Speed Conversion: Uses all available CPU cores to process PDF pages concurrently

Intelligent Heading Detection: Analyzes font sizes and usage frequency to automatically format titles

![Image](image_007.png)

![Image](image_008.png)

![Image](image_009.png)

and headings ( # , ## , etc.)

Asset Extraction: Saves raster and vector images into a specified assets folder and links them correctly

in the Markdown file

Smart Image Formatting: Automatically chooses between JPEG (for photos) and PNG (for graphics with

transparency) to optimize file size and quality

Flexible I/O: Reads from a PDF file or stdin and writes to a Markdown file or stdout

![Image](image_010.png)

![Image](image_011.png)

![Image](image_012.png)

Customizable Rasterization: Allows setting a custom DPI for converting vector graphics to bitmaps

Installation

Using Homebrew (Coming Soon)

brew tap twardoch/pdf22md

brew install pdf22md

![Image](image_013.png)

![Image](image_014.png)

Building from Source

To build the project manually, you need Xcode Command Line Tools installed.

# Clone the repository

git clone https://github.com/twardoch/pdf22md.git

cd pdf22md

# Compile the tool

make

# Install it to /usr/local/bin (optional)

sudo make install

Download Pre-built Binary

Pre-built binaries are available from the Releases page.

Usage

Usage: pdf22md [-i input.pdf] [-o output.md] [-a assets

_

folder] [-d dpi]

Converts PDF documents to Markdown format

-i <path>: Input PDF file (default: stdin)

-o <path>: Output Markdown file (default: stdout)

-a <path>: Assets folder for extracted images

-d <dpi>: DPI for rasterizing vector graphics (default: 144)

Examples

# Convert a PDF file to Markdown

pdf22md -i document.pdf -o document.md

# Convert with images saved to an 'assets' folder

pdf22md -i report.pdf -o report.md -a ./assets

# Convert with custom DPI for vector graphics

pdf22md -i presentation.pdf -o presentation.md -a ./images -d 300

# Use with pipes

cat document.pdf | pdf22md > document.md

# Convert and view in less

pdf22md -i manual.pdf | less

Requirements

macOS 10.15 (Catalina) or later

Xcode Command Line Tools (for building from source)

Project Structure

pdf22md/

‚îú‚îÄ‚îÄ src/ # Source code

‚îÇ ‚îú‚îÄ‚îÄ main.m # Entry point

‚îÇ ‚îú‚îÄ‚îÄ PDFMarkdownConverter.* # Main conversion logic

‚îÇ ‚îú‚îÄ‚îÄ PDFPageProcessor.* # PDF page processing

‚îÇ ‚îú‚îÄ‚îÄ ContentElement.* # Content element definitions

‚îÇ ‚îî‚îÄ‚îÄ AssetExtractor.* # Image extraction logic

‚îú‚îÄ‚îÄ docs/ # Additional documentation

‚îú‚îÄ‚îÄ test/ # Test files

file:///Users/adam/Developer/vcs/github.twardoch/pub/pdf22md/README.md 1/2

23/06/2025, 01:33 README.md

![Image](image_015.png)

![Image](image_016.png)

‚îú‚îÄ‚îÄ LICENSE # MIT License

‚îú‚îÄ‚îÄ Makefile # Build configuration

‚îî‚îÄ‚îÄ README.md # This file

Contributing

Contributions are welcome! Please feel free to submit a Pull Request. For major changes, please open an

![Image](image_017.png)

![Image](image_018.png)

![Image](image_019.png)

issue first to discuss what you

would like to change.

1. Fork the repository

2. Create your feature branch ( git checkout -b feature/AmazingFeature )

3. Commit your changes ( git commit -m 'Add some AmazingFeature' )

![Image](image_020.png)

![Image](image_021.png)

![Image](image_022.png)

4. Push to the branch ( git push origin feature/AmazingFeature )

5. Open a Pull Request

License

This project is licensed under the MIT License - see the LICENSE file for details.

Acknowledgments

![Image](image_023.png)

![Image](image_024.png)

![Image](image_025.png)

![Image](image_026.png)

![Image](image_027.png)

Built with Apple‚Äôs PDFKit and Core Graphics frameworks

Parallel processing powered by Grand Central Dispatch (GCD)

Inspired by the need for fast, accurate PDF to Markdown conversion

Related Projects

pdfplumber - Python library for PDF processing

![Image](image_028.png)

pdf2md - Another PDF to Markdown converter

![Image](image_029.png)

![Image](image_030.png)

![Image](image_031.png)

![Image](image_032.png)

pandoc - Universal document converter

Changelog

See CHANGELOG.md for a list of changes in each version.

Support

If you encounter any issues or have questions, please open an issue on GitHub.

![Image](image_033.png)

![Image](image_034.png)

file:///Users/adam/Developer/vcs/github.twardoch/pub/pdf22md/README.md 2/2
</file>

<file path="pdf22md-swift/build.sh">
#!/bin/bash

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Print functions
print_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
print_warning() { echo -e "${YELLOW}[WARN]${NC} $1"; }
print_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Check for required tools
check_requirements() {
    local missing_tools=()

    if ! command -v swift &>/dev/null; then
        missing_tools+=("swift")
    fi

    if [ ${#missing_tools[@]} -ne 0 ]; then
        print_error "Missing required tools: ${missing_tools[*]}"
        print_info "Please install Xcode Command Line Tools:"
        print_info "xcode-select --install"
        exit 1
    fi
}

# Build pdf22md-swift
build_swift() {
    print_info "Building pdf22md (Swift implementation)..."
    
    # Clean previous builds
    if [ -d ".build" ]; then
        rm -rf .build
        print_info "Cleaned previous build artifacts"
    fi
    
    # Try to detect and fix Swift toolchain issues
    print_info "Checking Swift toolchain..."
    
    # First try: use xcrun to ensure proper toolchain
    if command -v xcrun &>/dev/null && xcrun swift build -c release 2>/dev/null; then
        print_info "‚úì pdf22md-swift built successfully (using xcrun)"
        return 0
    fi
    
    # Second try: standard swift build with error handling for framework issues
    print_warning "xcrun failed, trying direct swift build..."
    if swift build -c release 2>/dev/null; then
        print_info "‚úì pdf22md-swift built successfully"
        return 0
    fi
    
    # Third try: reset package and try again
    print_warning "Standard build failed, attempting package reset..."
    swift package reset 2>/dev/null || true
    
    if swift build -c release; then
        print_info "‚úì pdf22md-swift built successfully (after reset)"
        return 0
    else
        print_error "Failed to build pdf22md-swift"
        print_error "This may indicate a corrupted Swift toolchain."
        print_info "Try running: xcode-select --install"
        print_info "Or reinstall Xcode Command Line Tools"
        return 1
    fi
}

# Install binary
install_binary() {
    local install_dir="/usr/local/bin"
    print_info "Installing binary to $install_dir..."

    # Create install directory if it doesn't exist
    sudo mkdir -p "$install_dir"

    # Install pdf22md
    if [ -f ".build/release/pdf22md" ]; then
        sudo install -m 755 .build/release/pdf22md "$install_dir/pdf22md-swift"
        print_info "‚úì Installed pdf22md-swift"
    else
        print_error "Built binary not found at .build/release/pdf22md"
        return 1
    fi

    # Install man pages
    if [ -f "docs/pdf22md.1" ]; then
        sudo mkdir -p /usr/local/share/man/man1
        sudo install -m 644 docs/pdf22md.1 /usr/local/share/man/man1/
        print_info "‚úì Installed man pages"
    fi
}

# Run tests
run_tests() {
    print_info "Running Swift tests..."
    if swift test; then
        print_info "‚úì Swift tests passed"
        return 0
    else
        print_error "Swift tests failed"
        return 1
    fi
}

# Create local binary symlink for development
create_dev_link() {
    if [ -f ".build/release/pdf22md" ]; then
        ln -sf .build/release/pdf22md pdf22md
        print_info "‚úì Created development symlink './pdf22md'"
    fi
}

# Main execution
main() {
    print_info "Starting pdf22md-swift build process..."

    # Check requirements
    check_requirements

    # Build component
    if ! build_swift; then
        exit 1
    fi

    # Create development symlink
    create_dev_link

    # Run tests if requested
    if [ "$1" = "--test" ] || [ "$2" = "--test" ]; then
        if ! run_tests; then
            print_warning "Tests failed, but build completed"
        fi
    fi

    # Install if requested
    if [ "$1" = "--install" ] || [ "$2" = "--install" ]; then
        install_binary
    fi

    print_info "Build complete!"
    print_info "Run './pdf22md --help' for usage information"
    print_info "Or run 'swift run pdf22md --help' to use Swift Package Manager directly"
}

main "$@"
</file>

<file path="pdf22md-swift/release.sh">
#!/bin/bash

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Print functions
print_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
print_warning() { echo -e "${YELLOW}[WARN]${NC} $1"; }
print_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Configuration
APP_NAME="pdf22md-swift"
BUILD_DIR=".build/release"
ARCHIVE_DIR="archive"

# Get version from git or default
get_version() {
    local version=$(git describe --tags --always --dirty 2>/dev/null || echo "dev")
    echo "$version"
}

# Build release version
build_release() {
    print_info "Building release version..."
    
    # Clean and build
    swift build -c release
    
    if [ $? -eq 0 ]; then
        print_info "‚úì Release build completed successfully"
        return 0
    else
        print_error "Release build failed"
        return 1
    fi
}

# Run tests before release
run_tests() {
    print_info "Running test suite..."
    
    if swift test; then
        print_info "‚úì All tests passed"
        return 0
    else
        print_error "Tests failed"
        return 1
    fi
}

# Create archive
create_archive() {
    local version=$(get_version)
    local archive_name="${APP_NAME}-${version}-macos"
    
    print_info "Creating archive: ${archive_name}"
    
    # Create archive directory
    mkdir -p "$ARCHIVE_DIR"
    
    # Create temporary directory for archive contents
    local temp_dir=$(mktemp -d)
    local archive_path="$temp_dir/$archive_name"
    
    mkdir -p "$archive_path"
    
    # Copy binary
    if [ -f "$BUILD_DIR/pdf22md" ]; then
        cp "$BUILD_DIR/pdf22md" "$archive_path/"
        print_info "‚úì Copied binary"
    else
        print_error "Binary not found at $BUILD_DIR/pdf22md"
        return 1
    fi
    
    # Copy documentation
    if [ -f "README.md" ]; then
        cp "README.md" "$archive_path/"
    fi
    
    if [ -f "docs/pdf22md.1" ]; then
        mkdir -p "$archive_path/man"
        cp "docs/pdf22md.1" "$archive_path/man/"
        print_info "‚úì Copied documentation"
    fi
    
    # Create tarball
    cd "$temp_dir"
    tar -czf "${archive_name}.tar.gz" "$archive_name"
    
    # Move to archive directory
    mv "${archive_name}.tar.gz" "$OLDPWD/$ARCHIVE_DIR/"
    
    # Cleanup
    rm -rf "$temp_dir"
    
    print_info "‚úì Archive created: $ARCHIVE_DIR/${archive_name}.tar.gz"
    
    # Show archive contents
    print_info "Archive contents:"
    tar -tzf "$ARCHIVE_DIR/${archive_name}.tar.gz" | sed 's/^/  /'
}

# Main execution
main() {
    local version=$(get_version)
    
    print_info "Starting release process for $APP_NAME version $version"
    
    # Build release
    if ! build_release; then
        exit 1
    fi
    
    # Run tests
    if ! run_tests; then
        print_error "Tests failed, aborting release"
        exit 1
    fi
    
    # Create archive
    if ! create_archive; then
        print_error "Archive creation failed"
        exit 1
    fi
    
    print_info "üéâ Release complete!"
    print_info "Version: $version"
    print_info "Archive: $ARCHIVE_DIR/${APP_NAME}-${version}-macos.tar.gz"
    print_info ""
    print_info "To install locally:"
    print_info "  tar -xzf $ARCHIVE_DIR/${APP_NAME}-${version}-macos.tar.gz"
    print_info "  sudo cp ${APP_NAME}-${version}-macos/pdf22md /usr/local/bin/pdf22md-swift"
}

main "$@"
</file>

<file path="build.sh">
#!/bin/bash

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Print functions
print_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
print_warning() { echo -e "${YELLOW}[WARN]${NC} $1"; }
print_error() { echo -e "${RED}[ERROR]${NC} $1"; }
print_header() { echo -e "${BLUE}[BUILD]${NC} $1"; }

# Track build results
build_results_objc=0
build_results_swift=0

# Check for required tools
check_requirements() {
    local missing_tools=()

    if ! command -v clang &>/dev/null; then
        missing_tools+=("clang")
    fi

    if ! command -v swift &>/dev/null; then
        missing_tools+=("swift")
    fi

    if ! command -v make &>/dev/null; then
        missing_tools+=("make")
    fi

    if [ ${#missing_tools[@]} -ne 0 ]; then
        print_error "Missing required tools: ${missing_tools[*]}"
        print_info "Please install Xcode Command Line Tools:"
        print_info "xcode-select --install"
        exit 1
    fi
}

# Build pdf22md-objc
build_objc() {
    print_header "Building pdf22md-objc..."
    
    if [ ! -d "pdf22md-objc" ]; then
        print_error "pdf22md-objc directory not found"
        build_results_objc=1
        return 1
    fi
    
    cd pdf22md-objc
    
    # Build with options
    local build_cmd="./build.sh"
    if [ "$RUN_TESTS" = "true" ]; then
        build_cmd="$build_cmd --test"
    fi
    if [ "$INSTALL_BINARIES" = "true" ]; then
        build_cmd="$build_cmd --install"
    fi
    
    if $build_cmd; then
        print_info "‚úì pdf22md-objc built successfully"
        build_results_objc=0
    else
        print_error "‚úó pdf22md-objc build failed"
        build_results_objc=1
    fi
    
    cd ..
    return $build_results_objc
}

# Build pdf22md-swift
build_swift() {
    print_header "Building pdf22md-swift..."
    
    if [ ! -d "pdf22md-swift" ]; then
        print_error "pdf22md-swift directory not found"
        build_results_swift=1
        return 1
    fi
    
    # Check if Swift toolchain is functional before attempting build
    if ! swift --version >/dev/null 2>&1; then
        print_error "Swift toolchain appears to be corrupted or missing"
        print_warning "Skipping Swift build. Install/repair Xcode Command Line Tools:"
        print_info "  xcode-select --install"
        build_results_swift=1
        return 1
    fi
    
    cd pdf22md-swift
    
    # Build with options
    local build_cmd="./build.sh"
    if [ "$RUN_TESTS" = "true" ]; then
        build_cmd="$build_cmd --test"
    fi
    if [ "$INSTALL_BINARIES" = "true" ]; then
        build_cmd="$build_cmd --install"
    fi
    
    if $build_cmd; then
        print_info "‚úì pdf22md-swift built successfully"
        build_results_swift=0
    else
        print_error "‚úó pdf22md-swift build failed"
        print_warning "Swift toolchain may be corrupted. Try:"
        print_info "  xcode-select --install"
        build_results_swift=1
    fi
    
    cd ..
    return $build_results_swift
}

# Create release archives
create_releases() {
    print_header "Creating release archives..."
    
    # Create Swift release
    if [ $build_results_swift -eq 0 ]; then
        cd pdf22md-swift
        if ./release.sh; then
            print_info "‚úì Swift release archive created"
        else
            print_warning "Swift release archive creation failed"
        fi
        cd ..
    fi
    
    # Create Objective-C release (manual process since no release.sh)
    if [ $build_results_objc -eq 0 ]; then
        print_info "Objective-C binary available at: pdf22md-objc/pdf22md"
    fi
}

# Show build summary
show_summary() {
    print_header "Build Summary"
    
    local total_success=0
    local total_builds=0
    
    if [ "$BUILD_OBJC" = "true" ]; then
        total_builds=$((total_builds + 1))
        if [ $build_results_objc -eq 0 ]; then
            print_info "‚úì pdf22md-objc: SUCCESS"
            total_success=$((total_success + 1))
        else
            print_error "‚úó pdf22md-objc: FAILED"
        fi
    fi
    
    if [ "$BUILD_SWIFT" = "true" ]; then
        total_builds=$((total_builds + 1))
        if [ $build_results_swift -eq 0 ]; then
            print_info "‚úì pdf22md-swift: SUCCESS"
            total_success=$((total_success + 1))
        else
            print_error "‚úó pdf22md-swift: FAILED"
        fi
    fi
    
    echo ""
    if [ $total_success -eq $total_builds ]; then
        print_info "üéâ All builds completed successfully! ($total_success/$total_builds)"
        
        if [ "$INSTALL_BINARIES" = "true" ]; then
            echo ""
            print_info "Installed binaries:"
            if [ $build_results_objc -eq 0 ]; then
                print_info "  - pdf22md (Objective-C implementation)"
            fi
            if [ $build_results_swift -eq 0 ]; then
                print_info "  - pdf22md-swift (Swift implementation)"
            fi
            print_info "Run 'man pdf22md' for usage information"
        else
            echo ""
            print_info "Built binaries:"
            if [ $build_results_objc -eq 0 ]; then
                print_info "  - pdf22md-objc/pdf22md"
            fi
            if [ $build_results_swift -eq 0 ]; then
                print_info "  - pdf22md-swift/.build/release/pdf22md"
            fi
        fi
    else
        print_error "Some builds failed ($total_success/$total_builds successful)"
        exit 1
    fi
}

# Show usage information
show_usage() {
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  --test              Run tests after building"
    echo "  --install           Install binaries to /usr/local/bin"
    echo "  --release           Create release archives"
    echo "  --objc-only         Build only Objective-C implementation"
    echo "  --swift-only        Build only Swift implementation"
    echo "  --help              Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0                  # Build both implementations"
    echo "  $0 --test           # Build and test both implementations"
    echo "  $0 --install        # Build and install both implementations"
    echo "  $0 --test --install # Build, test, and install both implementations"
    echo "  $0 --objc-only      # Build only Objective-C implementation"
    echo "  $0 --release        # Build both and create release archives"
}

# Parse command line arguments
parse_args() {
    RUN_TESTS=false
    INSTALL_BINARIES=false
    CREATE_RELEASES=false
    BUILD_OBJC=true
    BUILD_SWIFT=true
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --test)
                RUN_TESTS=true
                shift
                ;;
            --install)
                INSTALL_BINARIES=true
                shift
                ;;
            --release)
                CREATE_RELEASES=true
                shift
                ;;
            --objc-only)
                BUILD_OBJC=true
                BUILD_SWIFT=false
                shift
                ;;
            --swift-only)
                BUILD_OBJC=false
                BUILD_SWIFT=true
                shift
                ;;
            --help)
                show_usage
                exit 0
                ;;
            *)
                print_error "Unknown option: $1"
                show_usage
                exit 1
                ;;
        esac
    done
}

# Main execution
main() {
    parse_args "$@"
    
    print_header "pdf22md - Multi-Implementation Build System"
    print_info "Building$([ "$BUILD_OBJC" = "true" ] && echo " Objective-C")$([ "$BUILD_SWIFT" = "true" ] && echo " Swift") implementation$([ "$BUILD_OBJC" = "true" ] && [ "$BUILD_SWIFT" = "true" ] && echo "s")"
    
    # Check requirements
    check_requirements
    
    # Build implementations
    if [ "$BUILD_OBJC" = "true" ]; then
        build_objc
    fi
    
    if [ "$BUILD_SWIFT" = "true" ]; then
        build_swift
        # If Swift fails and we're building both, suggest continuing with Objective-C only
        if [ $build_results_swift -ne 0 ] && [ "$BUILD_OBJC" = "true" ] && [ $build_results_objc -eq 0 ]; then
            print_warning "Swift build failed but Objective-C build succeeded"
            print_info "The Objective-C implementation is fully functional"
        fi
    fi
    
    # Create releases if requested
    if [ "$CREATE_RELEASES" = "true" ]; then
        create_releases
    fi
    
    # Show summary
    show_summary
}

main "$@"
</file>

<file path=".github/workflows/release.yml">
name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  build-and-release:
    runs-on: macos-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Full history for version tags
    
    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable
    
    - name: Get version from tag
      id: version
      run: |
        VERSION=${GITHUB_REF#refs/tags/v}
        echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
        echo "TAG=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
    
    - name: Build universal binary
      run: |
        # Build for Intel
        make clean
        make VERSION="${{ steps.version.outputs.VERSION }}" CFLAGS="-Wall -Wextra -O2 -fobjc-arc -arch x86_64"
        mv pdf22md pdf22md-x86_64
        
        # Build for Apple Silicon
        make clean
        make VERSION="${{ steps.version.outputs.VERSION }}" CFLAGS="-Wall -Wextra -O2 -fobjc-arc -arch arm64"
        mv pdf22md pdf22md-arm64
        
        # Create universal binary
        lipo -create -output pdf22md pdf22md-x86_64 pdf22md-arm64
        chmod +x pdf22md
        
        # Verify universal binary
        lipo -info pdf22md
        ./pdf22md -v
    
    - name: Create distribution package
      run: |
        # Create directory structure
        mkdir -p dist/usr/local/bin
        mkdir -p dist/usr/local/share/man/man1
        mkdir -p dist/usr/local/share/doc/pdf22md
        
        # Copy files
        cp pdf22md dist/usr/local/bin/
        cp LICENSE dist/usr/local/share/doc/pdf22md/
        cp README.md dist/usr/local/share/doc/pdf22md/
        cp docs/PARALLEL_PROCESSING.md dist/usr/local/share/doc/pdf22md/ || true
        
        # Create man page
        cat > dist/usr/local/share/man/man1/pdf22md.1 << EOF
        .TH PDF22MD 1 "$(date +'%B %Y')" "pdf22md ${{ steps.version.outputs.VERSION }}" "User Commands"
        .SH NAME
        pdf22md \- Convert PDF documents to Markdown format
        .SH SYNOPSIS
        .B pdf22md
        [\fB\-i\fR \fIinput.pdf\fR]
        [\fB\-o\fR \fIoutput.md\fR]
        [\fB\-a\fR \fIassets_folder\fR]
        [\fB\-d\fR \fIdpi\fR]
        [\fB\-v\fR]
        [\fB\-h\fR]
        .SH DESCRIPTION
        .B pdf22md
        is a high-performance PDF to Markdown converter for macOS that uses Grand Central Dispatch (GCD) for parallel processing.
        .SH OPTIONS
        .TP
        .BR \-i " " \fIpath\fR
        Input PDF file (default: stdin)
        .TP
        .BR \-o " " \fIpath\fR
        Output Markdown file (default: stdout)
        .TP
        .BR \-a " " \fIpath\fR
        Assets folder for extracted images
        .TP
        .BR \-d " " \fIdpi\fR
        DPI for rasterizing vector graphics (default: 144)
        .TP
        .BR \-v
        Display version information
        .TP
        .BR \-h
        Display help message
        .SH EXAMPLES
        .TP
        Convert a PDF file to Markdown:
        .B pdf22md -i document.pdf -o document.md
        .TP
        Convert with images saved to an assets folder:
        .B pdf22md -i report.pdf -o report.md -a ./assets
        .TP
        Use with pipes:
        .B cat document.pdf | pdf22md > document.md
        .SH AUTHOR
        Adam Twardoch
        .SH LICENSE
        MIT License
        EOF
    
    - name: Create installer package
      run: |
        # Create package info
        mkdir -p package_resources
        
        # Create postinstall script
        cat > package_resources/postinstall << 'EOF'
        #!/bin/bash
        # Update man database
        if command -v makewhatis >/dev/null 2>&1; then
            makewhatis /usr/local/share/man
        fi
        exit 0
        EOF
        chmod +x package_resources/postinstall
        
        # Build the package
        pkgbuild --root dist \
                 --identifier com.twardoch.pdf22md \
                 --version "${{ steps.version.outputs.VERSION }}" \
                 --scripts package_resources \
                 --ownership recommended \
                 pdf22md-${{ steps.version.outputs.VERSION }}.pkg
        
        # Create a distribution XML for productbuild (optional, for more control)
        cat > distribution.xml << EOF
        <?xml version="1.0" encoding="utf-8" standalone="yes"?>
        <installer-gui-script minSpecVersion="2.0">
            <title>pdf22md ${{ steps.version.outputs.VERSION }}</title>
            <organization>com.twardoch</organization>
            <domains enable_localSystem="true"/>
            <options customize="never" require-scripts="true" rootVolumeOnly="true"/>
            <pkg-ref id="com.twardoch.pdf22md">
                <bundle-version>
                    <bundle CFBundleVersion="${{ steps.version.outputs.VERSION }}" id="com.twardoch.pdf22md" path="pdf22md"/>
                </bundle-version>
            </pkg-ref>
            <choices-outline>
                <line choice="default">
                    <line choice="com.twardoch.pdf22md"/>
                </line>
            </choices-outline>
            <choice id="default" title="pdf22md" description="PDF to Markdown converter"/>
            <choice id="com.twardoch.pdf22md" visible="false">
                <pkg-ref id="com.twardoch.pdf22md"/>
            </choice>
            <pkg-ref id="com.twardoch.pdf22md" version="${{ steps.version.outputs.VERSION }}" onConclusion="none">pdf22md-${{ steps.version.outputs.VERSION }}.pkg</pkg-ref>
        </installer-gui-script>
        EOF
        
        # Sign the package if certificates are available
        if security find-identity -p basic -v | grep -q "Developer ID Installer"; then
            INSTALLER_CERT=$(security find-identity -p basic -v | grep "Developer ID Installer" | head -1 | awk '{print $2}')
            productsign --sign "$INSTALLER_CERT" \
                        pdf22md-${{ steps.version.outputs.VERSION }}.pkg \
                        pdf22md-${{ steps.version.outputs.VERSION }}-signed.pkg
            mv pdf22md-${{ steps.version.outputs.VERSION }}-signed.pkg pdf22md-${{ steps.version.outputs.VERSION }}.pkg
        fi
    
    - name: Create release archives
      run: |
        # Create tarball with binary and docs
        mkdir -p pdf22md-${{ steps.version.outputs.VERSION }}
        cp pdf22md pdf22md-${{ steps.version.outputs.VERSION }}/
        cp README.md LICENSE pdf22md-${{ steps.version.outputs.VERSION }}/
        cp -r docs pdf22md-${{ steps.version.outputs.VERSION }}/ || true
        tar -czf pdf22md-${{ steps.version.outputs.VERSION }}-macos.tar.gz pdf22md-${{ steps.version.outputs.VERSION }}
        
        # Create zip for those who prefer it
        zip -r pdf22md-${{ steps.version.outputs.VERSION }}-macos.zip pdf22md-${{ steps.version.outputs.VERSION }}
    
    - name: Generate release notes
      id: release_notes
      run: |
        # Get previous tag
        PREVIOUS_TAG=$(git tag -l 'v*' | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -2 | head -1)
        
        # Generate changelog
        if [ -n "$PREVIOUS_TAG" ]; then
          echo "## What's Changed" > release_notes.md
          echo "" >> release_notes.md
          git log --pretty=format:"* %s (%h)" ${PREVIOUS_TAG}..HEAD >> release_notes.md
        else
          echo "## Initial Release" > release_notes.md
          echo "" >> release_notes.md
          echo "First release of pdf22md!" >> release_notes.md
        fi
        
        echo "" >> release_notes.md
        echo "## Installation" >> release_notes.md
        echo "" >> release_notes.md
        echo "### Using the installer package (recommended):" >> release_notes.md
        echo '```bash' >> release_notes.md
        echo "curl -LO https://github.com/twardoch/pdf22md/releases/download/${{ steps.version.outputs.TAG }}/pdf22md-${{ steps.version.outputs.VERSION }}.pkg" >> release_notes.md
        echo "sudo installer -pkg pdf22md-${{ steps.version.outputs.VERSION }}.pkg -target /" >> release_notes.md
        echo '```' >> release_notes.md
        echo "" >> release_notes.md
        echo "### Manual installation:" >> release_notes.md
        echo '```bash' >> release_notes.md
        echo "curl -LO https://github.com/twardoch/pdf22md/releases/download/${{ steps.version.outputs.TAG }}/pdf22md-${{ steps.version.outputs.VERSION }}-macos.tar.gz" >> release_notes.md
        echo "tar -xzf pdf22md-${{ steps.version.outputs.VERSION }}-macos.tar.gz" >> release_notes.md
        echo "sudo cp pdf22md-${{ steps.version.outputs.VERSION }}/pdf22md /usr/local/bin/" >> release_notes.md
        echo '```' >> release_notes.md
    
    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        name: pdf22md ${{ steps.version.outputs.VERSION }}
        body_path: release_notes.md
        files: |
          pdf22md-${{ steps.version.outputs.VERSION }}.pkg
          pdf22md-${{ steps.version.outputs.VERSION }}-macos.tar.gz
          pdf22md-${{ steps.version.outputs.VERSION }}-macos.zip
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Update Homebrew formula
      run: |
        # This would typically update a homebrew tap repository
        # For now, we'll just output what should be done
        echo "To update Homebrew formula:"
        echo "1. Update the url to: https://github.com/twardoch/pdf22md/archive/refs/tags/${{ steps.version.outputs.TAG }}.tar.gz"
        echo "2. Update the sha256 hash"
        echo "3. Update the version in the formula"
</file>

<file path="docs/PARALLEL_PROCESSING.md">
# Parallel Processing in `pdf22md`

This document outlines the implementation of parallel processing in the `pdf22md` command-line tool for converting PDF documents to Markdown format.

## 1. Objective

The goal was to accelerate the conversion of multi-page PDF documents by processing multiple pages concurrently and saving extracted images in parallel.

## 2. Technology: Grand Central Dispatch (GCD)

Similar to `pdfupng`, we utilized Apple's **Grand Central Dispatch (GCD)** framework with the `dispatch_apply` function for parallel execution.

## 3. Implementation Details

### 3.1. Parallel Page Processing

The core changes were made within the `convertWithAssetsFolderPath:rasterizedDPI:completion:` method in `PDFMarkdownConverter.m`.

#### From Sequential to Concurrent

The original implementation used a sequential `for` loop:

```objc
for (NSInteger pageIndex = 0; pageIndex < pageCount; pageIndex++) {
    PDFPage *page = [self.pdfDocument pageAtIndex:pageIndex];
    // ... process page ...
}
```

This was replaced with:

```objc
dispatch_apply(pageCount, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t pageIndex) {
    @autoreleasepool {
        PDFPage *page = [self.pdfDocument pageAtIndex:pageIndex];
        // ... process page ...
    }
});
```

### 3.2. Thread Safety Measures

1. **Temporary Storage Arrays**: Instead of directly modifying shared arrays (`allElements`, `fontStats`), we create temporary per-page storage:

```objc
NSMutableArray<NSMutableArray<id<ContentElement>> *> *pageElementsArray = [NSMutableArray arrayWithCapacity:pageCount];
NSMutableArray<NSMutableDictionary *> *pageFontStatsArray = [NSMutableArray arrayWithCapacity:pageCount];
```

2. **Error Handling**: A shared boolean flag with synchronized access:

```objc
__block BOOL processingFailed = NO;
NSObject *lock = [[NSObject alloc] init];

// Inside parallel block
@synchronized(lock) {
    if (processingFailed) return;
}
```

3. **Result Merging**: After parallel processing completes, results are merged sequentially:

```objc
for (NSInteger i = 0; i < pageCount; i++) {
    [self.allElements addObjectsFromArray:pageElementsArray[i]];
    // Merge font statistics...
}
```

### 3.3. Parallel Image Saving

Image saving was also parallelized:

```objc
dispatch_apply(imageCount, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t index) {
    @autoreleasepool {
        ImageElement *imageElement = imageElements[index];
        NSString *savedPath = [assetExtractor saveImage:imageElement.image ...];
        if (savedPath) {
            @synchronized(imageElement) {
                imageElement.assetRelativePath = savedPath;
            }
        }
    }
});
```

### 3.4. Memory Management

Each parallel operation is wrapped in `@autoreleasepool` to ensure prompt deallocation of temporary objects and prevent memory spikes.

## 4. Performance Benefits

- **Multi-core Utilization**: Pages are processed on multiple CPU cores simultaneously
- **Reduced Total Time**: For PDFs with many pages, the speedup is nearly linear with the number of cores
- **Efficient Memory Usage**: Autoreleasepool prevents memory accumulation
- **Scalability**: The implementation automatically adapts to the available hardware

## 5. Considerations

- **Thread Safety**: All shared resources are protected with appropriate synchronization
- **Memory Overhead**: Each parallel task has its own memory footprint, but autoreleasepool keeps it manageable
- **I/O Bottlenecks**: Image saving may be limited by disk I/O speed rather than CPU
</file>

<file path="docs/pdf22md.1">
.TH PDF22MD 1 "June 2025" "pdf22md v1.0" "User Commands"
.SH NAME
pdf22md \- high-performance PDF to Markdown converter
.SH SYNOPSIS
.B pdf22md
[\fB\-i\fR \fIinput.pdf\fR]
[\fB\-o\fR \fIoutput.md\fR]
[\fB\-a\fR \fIassets_folder\fR]
[\fB\-d\fR \fIdpi\fR]
[\fB\-v\fR]
[\fB\-h\fR]
.SH DESCRIPTION
.B pdf22md
is a blazingly fast PDF to Markdown converter that extracts text and images from PDF documents and converts them into clean, structured Markdown format. It uses parallel processing to achieve high performance on multi-page documents.

The tool automatically detects heading hierarchy based on font size analysis, extracts images with intelligent format optimization (PNG/JPEG), and generates YAML frontmatter with document metadata.

.SH OPTIONS
.TP
\fB\-i\fR \fIinput.pdf\fR
Specify the input PDF file to convert. If not provided, pdf22md reads from standard input (stdin).
.TP
\fB\-o\fR \fIoutput.md\fR
Specify the output Markdown file. If not provided, pdf22md writes to standard output (stdout).
.TP
\fB\-a\fR \fIassets_folder\fR
Specify the folder where extracted images will be saved. The folder will be created if it doesn't exist. Images are automatically referenced in the generated Markdown with relative paths.
.TP
\fB\-d\fR \fIdpi\fR
Set the DPI (dots per inch) for rasterizing vector graphics. Default is 144. Higher values produce better quality but larger file sizes. Common values: 72 (screen), 144 (default), 300 (print quality).
.TP
\fB\-v\fR, \fB\-\-version\fR
Display version information and exit.
.TP
\fB\-h\fR, \fB\-\-help\fR
Display usage information and exit.

.SH EXAMPLES
.TP
Convert a PDF file to Markdown:
.B pdf22md \-i document.pdf \-o document.md

.TP
Extract images to an assets folder:
.B pdf22md \-i document.pdf \-o document.md \-a ./assets

.TP
Use higher DPI for better image quality:
.B pdf22md \-i document.pdf \-o document.md \-a ./assets \-d 300

.TP
Convert using pipes (stdin/stdout):
.B cat document.pdf | pdf22md > document.md

.TP
Process a document with custom settings:
.B pdf22md \-i report.pdf \-o report.md \-a ./images \-d 200

.SH INPUT/OUTPUT
.SS Input Sources
.B pdf22md
accepts PDF input from:
.IP ‚Ä¢ 2
File path specified with \fB\-i\fR flag
.IP ‚Ä¢ 2
Standard input (stdin) when no \fB\-i\fR flag is provided

.SS Output Destinations
Markdown output is written to:
.IP ‚Ä¢ 2
File path specified with \fB\-o\fR flag
.IP ‚Ä¢ 2
Standard output (stdout) when no \fB\-o\fR flag is provided

.SS Image Assets
When the \fB\-a\fR flag is used:
.IP ‚Ä¢ 2
Images are extracted and saved to the specified folder
.IP ‚Ä¢ 2
Filenames follow the pattern: image_001.png, image_002.jpg, etc.
.IP ‚Ä¢ 2
Format selection is automatic (PNG for graphics, JPEG for photos)
.IP ‚Ä¢ 2
Markdown contains relative references to the images

.SH FEATURES
.SS Intelligent Content Processing
.IP ‚Ä¢ 2
\fBHeading Detection\fR: Automatically identifies headings (H1-H6) based on font size analysis
.IP ‚Ä¢ 2
\fBText Extraction\fR: Preserves text formatting and structure
.IP ‚Ä¢ 2
\fBImage Processing\fR: Extracts both raster and vector graphics
.IP ‚Ä¢ 2
\fBSmart Formatting\fR: Maintains document hierarchy and readability

.SS Performance Optimizations
.IP ‚Ä¢ 2
\fBParallel Processing\fR: Uses all available CPU cores for maximum speed
.IP ‚Ä¢ 2
\fBMemory Efficiency\fR: Processes large documents without excessive memory usage
.IP ‚Ä¢ 2
\fBFormat Optimization\fR: Automatic PNG/JPEG selection based on image content

.SS Output Features
.IP ‚Ä¢ 2
\fBYAML Frontmatter\fR: Includes document metadata (title, author, creation date)
.IP ‚Ä¢ 2
\fBClean Markdown\fR: Well-structured output compatible with all Markdown processors
.IP ‚Ä¢ 2
\fBAsset Management\fR: Organized image extraction with proper linking

.SH FILE FORMATS
.SS Supported Input
.IP ‚Ä¢ 2
PDF files (version 1.4 and higher)
.IP ‚Ä¢ 2
Unencrypted PDFs (password-protected PDFs are not supported)
.IP ‚Ä¢ 2
PDFs with text, images, and vector graphics
.IP ‚Ä¢ 2
Multi-page documents of any size

.SS Generated Output
.IP ‚Ä¢ 2
\fBMarkdown (.md)\fR: GitHub Flavored Markdown compatible
.IP ‚Ä¢ 2
\fBImages (.png/.jpg)\fR: Extracted graphics in optimal formats
.IP ‚Ä¢ 2
\fBYAML Frontmatter\fR: Document metadata in standard format

.SH PERFORMANCE
Typical conversion speeds on modern hardware:
.IP ‚Ä¢ 2
Simple text documents: <1 second per page
.IP ‚Ä¢ 2
Complex documents with images: 2-5 seconds per page
.IP ‚Ä¢ 2
Large documents (100+ pages): Scales linearly with parallel processing

Memory usage is optimized for documents up to 1000 pages. Very large documents may require additional system memory.

.SH ERROR HANDLING
.B pdf22md
provides detailed error messages with suggestions for common issues:

.SS Common Errors and Solutions
.TP
\fBInvalid PDF file\fR
.IP ‚Ä¢ 2
Verify the file exists and is a valid PDF
.IP ‚Ä¢ 2
Check if the file is corrupted
.IP ‚Ä¢ 2
Ensure you have read permissions

.TP
\fBCannot create assets folder\fR
.IP ‚Ä¢ 2
Check if the parent directory exists
.IP ‚Ä¢ 2
Verify you have write permissions
.IP ‚Ä¢ 2
Ensure sufficient disk space

.TP
\fBPassword-protected PDF\fR
.IP ‚Ä¢ 2
Remove password protection using another tool first
.IP ‚Ä¢ 2
Use: qpdf \-\-decrypt input.pdf output.pdf

.TP
\fBMemory pressure\fR
.IP ‚Ä¢ 2
Close other applications to free memory
.IP ‚Ä¢ 2
Try using a lower DPI setting (\-d 72)
.IP ‚Ä¢ 2
Process smaller sections of large documents

.SH EXIT STATUS
.TP
.B 0
Successful conversion
.TP
.B 1
Error occurred (invalid input, processing failure, I/O error)

.SH ENVIRONMENT
No special environment variables are required. The tool uses standard macOS frameworks (PDFKit, CoreGraphics) and runs on macOS 10.15 and later.

.SH LIMITATIONS
.IP ‚Ä¢ 2
Password-protected PDFs are not supported
.IP ‚Ä¢ 2
Scanned PDFs without OCR text layer will only extract images
.IP ‚Ä¢ 2
Complex table layouts may not convert perfectly
.IP ‚Ä¢ 2
Some advanced PDF features (forms, annotations) are not preserved

.SH COMPATIBILITY
.SS Platform Support
.IP ‚Ä¢ 2
macOS 10.15 (Catalina) and later
.IP ‚Ä¢ 2
Intel and Apple Silicon processors
.IP ‚Ä¢ 2
Universal binary for optimal performance

.SS Markdown Compatibility
Output is compatible with:
.IP ‚Ä¢ 2
GitHub Flavored Markdown
.IP ‚Ä¢ 2
CommonMark specification
.IP ‚Ä¢ 2
Popular Markdown processors (pandoc, Jekyll, etc.)
.IP ‚Ä¢ 2
Static site generators (Hugo, Jekyll, Gatsby)

.SH FILES
.TP
.I ~/.pdf22md/
User configuration directory (future use)
.TP
.I /usr/local/bin/pdf22md
Default installation location
.TP
.I /usr/local/share/man/man1/pdf22md.1
This manual page

.SH EXAMPLES WORKFLOW
.SS Basic Document Conversion
.nf
# Convert a simple document
pdf22md \-i report.pdf \-o report.md

# Result: clean Markdown with YAML frontmatter
# Output includes: title, headings, body text, metadata
.fi

.SS Academic Paper with Images
.nf
# Convert research paper with figure extraction
pdf22md \-i paper.pdf \-o paper.md \-a figures \-d 300

# Result: 
# - paper.md with structured content
# - figures/ folder with high-quality images
# - Proper cross-references to figures
.fi

.SS Batch Processing
.nf
# Process multiple documents
for pdf in *.pdf; do
    pdf22md \-i "$pdf" \-o "${pdf%.pdf}.md" \-a "assets_${pdf%.pdf}"
done
.fi

.SS Integration with Other Tools
.nf
# Combine with pandoc for further processing
pdf22md \-i document.pdf | pandoc \-f markdown \-t html \-o document.html

# Use with static site generators
pdf22md \-i post.pdf \-o content/posts/post.md \-a static/images
.fi

.SH TROUBLESHOOTING
.SS Performance Issues
If conversion is slow:
.IP ‚Ä¢ 2
Check available memory and CPU usage
.IP ‚Ä¢ 2
Close unnecessary applications
.IP ‚Ä¢ 2
Try lower DPI setting for faster processing
.IP ‚Ä¢ 2
Process documents in smaller batches

.SS Quality Issues
If output quality is poor:
.IP ‚Ä¢ 2
Increase DPI setting (\-d 300) for better images
.IP ‚Ä¢ 2
Verify the source PDF has good quality text
.IP ‚Ä¢ 2
Check if the PDF has a proper text layer (not just scanned images)

.SS Memory Errors
For large documents:
.IP ‚Ä¢ 2
Ensure sufficient RAM (8GB+ recommended for large PDFs)
.IP ‚Ä¢ 2
Close other memory-intensive applications
.IP ‚Ä¢ 2
Split very large PDFs into smaller parts first

.SH REPORTING BUGS
Report bugs and feature requests at:
.UR https://github.com/twardoch/pdf22md/issues
.UE

Include in your report:
.IP ‚Ä¢ 2
pdf22md version (\fBpdf22md \-v\fR)
.IP ‚Ä¢ 2
macOS version
.IP ‚Ä¢ 2
Sample PDF file (if possible)
.IP ‚Ä¢ 2
Complete error message
.IP ‚Ä¢ 2
Steps to reproduce the issue

.SH AUTHORS
Written by Adam Twardoch and contributors.

.SH LICENSE
MIT License. See the LICENSE file for details.

.SH SEE ALSO
.BR pandoc (1),
.BR qpdf (1),
.BR pdftotext (1),
.BR markdown (7)

Project homepage: 
.UR https://github.com/twardoch/pdf22md
.UE
</file>

<file path="pdf22md-objc/src/CLI/main.m">
#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>
#import "../Core/PDF22MDConverter.h"
#import "../Core/PDF22MDConversionOptions.h"

#ifndef VERSION
#define VERSION "1.0.0"
#endif

void printUsage(const char *programName) {
    fprintf(stderr, "Usage: %s [-i input.pdf] [-o output.md] [-a assets_folder] [-d dpi] [-v] [-h]\n", programName);
    fprintf(stderr, "  Converts PDF documents to Markdown format\n");
    fprintf(stderr, "  -i <path>: Input PDF file (default: stdin)\n");
    fprintf(stderr, "  -o <path>: Output Markdown file (default: stdout)\n");
    fprintf(stderr, "  -a <path>: Assets folder for extracted images\n");
    fprintf(stderr, "  -d <dpi>: DPI for rasterizing vector graphics (default: 144)\n");
    fprintf(stderr, "  -v: Display version information\n");
    fprintf(stderr, "  -h: Display this help message\n");
}

void printVersion() {
    printf("pdf22md version %s\n", VERSION);
}

int main(int argc, const char *argv[]) {
    @autoreleasepool {
        NSString *inputPath = nil;
        NSString *outputPath = nil;
        NSString *assetsPath = nil;
        CGFloat dpi = 144.0;
        
        // Parse command line arguments
        int opt;
        while ((opt = getopt(argc, (char * const *)argv, "i:o:a:d:hvV")) != -1) {
            switch (opt) {
                case 'i':
                    inputPath = [NSString stringWithUTF8String:optarg];
                    break;
                case 'o':
                    outputPath = [NSString stringWithUTF8String:optarg];
                    break;
                case 'a':
                    assetsPath = [NSString stringWithUTF8String:optarg];
                    break;
                case 'd':
                    dpi = atof(optarg);
                    if (dpi <= 0) {
                        fprintf(stderr, "Invalid DPI value: %s\n", optarg);
                        return 1;
                    }
                    break;
                case 'h':
                    printUsage(argv[0]);
                    return 0;
                case 'v':
                case 'V':
                    printVersion();
                    return 0;
                default:
                    printUsage(argv[0]);
                    return 1;
            }
        }
        
        // Initialize converter
        PDF22MDConverter *converter = nil;
        
        if (inputPath) {
            // Read from file
            NSURL *pdfURL = [NSURL fileURLWithPath:inputPath];
            converter = [[PDF22MDConverter alloc] initWithPDFURL:pdfURL];
            if (!converter) {
                fprintf(stderr, "Failed to load PDF from: %s\n", [inputPath UTF8String]);
                return 1;
            }
        } else {
            // Read from stdin
            NSFileHandle *stdinHandle = [NSFileHandle fileHandleWithStandardInput];
            NSData *pdfData = [stdinHandle readDataToEndOfFile];
            
            if (!pdfData || [pdfData length] == 0) {
                fprintf(stderr, "No PDF data received from stdin\n");
                return 1;
            }
            
            converter = [[PDF22MDConverter alloc] initWithPDFData:pdfData];
            if (!converter) {
                fprintf(stderr, "Failed to create PDF document from stdin data\n");
                return 1;
            }
        }
        
        // Create conversion options
        PDF22MDConversionOptionsBuilder *builder = [[PDF22MDConversionOptionsBuilder alloc] init];
        builder.assetsFolderPath = assetsPath;
        builder.rasterizationDPI = dpi;
        builder.extractImages = (assetsPath != nil);
        
        // Add progress handler for interactive terminals
        if (isatty(STDERR_FILENO)) {
            builder.progressHandler = ^(NSInteger currentPage, NSInteger totalPages) {
                fprintf(stderr, "\rProcessing page %ld of %ld...", (long)currentPage, (long)totalPages);
                fflush(stderr);
            };
        }
        
        PDF22MDConversionOptions *options = [builder build];
        
        // Perform conversion
        __block NSString *markdown = nil;
        __block NSError *conversionError = nil;
        
        dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
        
        [converter convertWithOptions:options
                           completion:^(NSString *result, NSError *error) {
            markdown = result;
            conversionError = error;
            dispatch_semaphore_signal(semaphore);
        }];
        
        // Wait for completion
        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
        
        if (isatty(STDERR_FILENO) && options.progressHandler) {
            fprintf(stderr, "\n"); // Clear progress line
        }
        
        if (conversionError) {
            fprintf(stderr, "Conversion failed: %s\n", 
                    [[conversionError localizedDescription] UTF8String]);
            return 1;
        }
        
        // Write output
        if (outputPath) {
            // Write to file
            NSError *writeError = nil;
            BOOL success = [markdown writeToFile:outputPath
                                      atomically:YES
                                        encoding:NSUTF8StringEncoding
                                           error:&writeError];
            if (!success) {
                fprintf(stderr, "Failed to write output file: %s\n",
                        [[writeError localizedDescription] UTF8String]);
                return 1;
            }
        } else {
            // Write to stdout
            NSFileHandle *stdoutHandle = [NSFileHandle fileHandleWithStandardOutput];
            NSData *markdownData = [markdown dataUsingEncoding:NSUTF8StringEncoding];
            [stdoutHandle writeData:markdownData];
            
            // Add newline if not present
            if (![markdown hasSuffix:@"\n"]) {
                [stdoutHandle writeData:[@"\n" dataUsingEncoding:NSUTF8StringEncoding]];
            }
        }
        
        return 0;
    }
}
</file>

<file path="pdf22md-objc/src/Core/PDF22MDConversionOptions.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

/**
 * Configuration options for PDF to Markdown conversion.
 * This class uses the builder pattern for convenient configuration.
 */
@interface PDF22MDConversionOptions : NSObject <NSCopying>

/**
 * Path to the folder where extracted assets (images) should be saved.
 * If nil, images will not be extracted.
 */
@property (nonatomic, copy, nullable) NSString *assetsFolderPath;

/**
 * DPI for rasterizing vector graphics.
 * Default is 144.0
 */
@property (nonatomic, assign) CGFloat rasterizationDPI;

/**
 * Maximum number of concurrent page processing operations.
 * Default is NSProcessInfo.processInfo.processorCount
 */
@property (nonatomic, assign) NSInteger maxConcurrentPages;

/**
 * Whether to include YAML frontmatter with metadata.
 * Default is YES
 */
@property (nonatomic, assign) BOOL includeMetadata;

/**
 * Whether to extract images from the PDF.
 * Default is YES (if assetsFolderPath is set)
 */
@property (nonatomic, assign) BOOL extractImages;

/**
 * Whether to preserve the PDF outline/bookmarks structure.
 * Default is YES
 */
@property (nonatomic, assign) BOOL preserveOutline;

/**
 * Minimum font size difference to consider for heading detection.
 * Default is 2.0 points
 */
@property (nonatomic, assign) CGFloat headingFontSizeThreshold;

/**
 * Maximum heading level to detect (1-6).
 * Default is 6
 */
@property (nonatomic, assign) NSInteger maxHeadingLevel;

/**
 * Progress handler called during conversion.
 * The handler receives the current page index and total page count.
 */
@property (nonatomic, copy, nullable) void (^progressHandler)(NSInteger currentPage, NSInteger totalPages);

/**
 * Creates default conversion options.
 */
+ (instancetype)defaultOptions;

/**
 * Validates the current options configuration.
 * @param error Set if validation fails
 * @return YES if valid, NO otherwise
 */
- (BOOL)validateWithError:(NSError * _Nullable * _Nullable)error;

@end

/**
 * Builder class for creating PDF22MDConversionOptions instances.
 */
@interface PDF22MDConversionOptionsBuilder : NSObject

@property (nonatomic, copy, nullable) NSString *assetsFolderPath;
@property (nonatomic, assign) CGFloat rasterizationDPI;
@property (nonatomic, assign) NSInteger maxConcurrentPages;
@property (nonatomic, assign) BOOL includeMetadata;
@property (nonatomic, assign) BOOL extractImages;
@property (nonatomic, assign) BOOL preserveOutline;
@property (nonatomic, assign) CGFloat headingFontSizeThreshold;
@property (nonatomic, assign) NSInteger maxHeadingLevel;
@property (nonatomic, copy, nullable) void (^progressHandler)(NSInteger currentPage, NSInteger totalPages);

- (PDF22MDConversionOptions *)build;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/Core/PDF22MDConversionOptions.m">
#import "PDF22MDConversionOptions.h"
#import "PDF22MDError.h"

@implementation PDF22MDConversionOptions

#pragma mark - Initialization

- (instancetype)init {
    self = [super init];
    if (self) {
        // Set default values
        _rasterizationDPI = 144.0;
        _maxConcurrentPages = [[NSProcessInfo processInfo] processorCount];
        _includeMetadata = YES;
        _extractImages = YES;
        _preserveOutline = YES;
        _headingFontSizeThreshold = 2.0;
        _maxHeadingLevel = 6;
    }
    return self;
}

+ (instancetype)defaultOptions {
    return [[self alloc] init];
}

#pragma mark - NSCopying

- (id)copyWithZone:(nullable NSZone *)zone {
    PDF22MDConversionOptions *copy = [[PDF22MDConversionOptions allocWithZone:zone] init];
    
    copy.assetsFolderPath = self.assetsFolderPath;
    copy.rasterizationDPI = self.rasterizationDPI;
    copy.maxConcurrentPages = self.maxConcurrentPages;
    copy.includeMetadata = self.includeMetadata;
    copy.extractImages = self.extractImages;
    copy.preserveOutline = self.preserveOutline;
    copy.headingFontSizeThreshold = self.headingFontSizeThreshold;
    copy.maxHeadingLevel = self.maxHeadingLevel;
    copy.progressHandler = self.progressHandler;
    
    return copy;
}

#pragma mark - Validation

- (BOOL)validateWithError:(NSError * _Nullable * _Nullable)error {
    // Validate DPI
    if (self.rasterizationDPI <= 0 || self.rasterizationDPI > 600) {
        if (error) {
            *error = [NSError errorWithDomain:PDF22MDErrorDomain
                                         code:PDF22MDErrorInvalidConfiguration
                                     userInfo:@{
                NSLocalizedDescriptionKey: @"Invalid rasterization DPI",
                NSLocalizedFailureReasonErrorKey: @"DPI must be between 1 and 600"
            }];
        }
        return NO;
    }
    
    // Validate concurrent pages
    if (self.maxConcurrentPages < 1 || self.maxConcurrentPages > 64) {
        if (error) {
            *error = [NSError errorWithDomain:PDF22MDErrorDomain
                                         code:PDF22MDErrorInvalidConfiguration
                                     userInfo:@{
                NSLocalizedDescriptionKey: @"Invalid max concurrent pages",
                NSLocalizedFailureReasonErrorKey: @"Value must be between 1 and 64"
            }];
        }
        return NO;
    }
    
    // Validate heading level
    if (self.maxHeadingLevel < 1 || self.maxHeadingLevel > 6) {
        if (error) {
            *error = [NSError errorWithDomain:PDF22MDErrorDomain
                                         code:PDF22MDErrorInvalidConfiguration
                                     userInfo:@{
                NSLocalizedDescriptionKey: @"Invalid max heading level",
                NSLocalizedFailureReasonErrorKey: @"Heading level must be between 1 and 6"
            }];
        }
        return NO;
    }
    
    // Validate font size threshold
    if (self.headingFontSizeThreshold < 0.5 || self.headingFontSizeThreshold > 10.0) {
        if (error) {
            *error = [NSError errorWithDomain:PDF22MDErrorDomain
                                         code:PDF22MDErrorInvalidConfiguration
                                     userInfo:@{
                NSLocalizedDescriptionKey: @"Invalid heading font size threshold",
                NSLocalizedFailureReasonErrorKey: @"Threshold must be between 0.5 and 10.0 points"
            }];
        }
        return NO;
    }
    
    // Validate assets path if image extraction is enabled
    if (self.extractImages && self.assetsFolderPath) {
        NSFileManager *fileManager = [NSFileManager defaultManager];
        BOOL isDirectory = NO;
        BOOL exists = [fileManager fileExistsAtPath:self.assetsFolderPath isDirectory:&isDirectory];
        
        if (exists && !isDirectory) {
            if (error) {
                *error = [PDF22MDErrorHelper assetCreationFailedErrorWithPath:self.assetsFolderPath
                                                                         reason:@"Path exists but is not a directory"];
            }
            return NO;
        }
    }
    
    return YES;
}

#pragma mark - Description

- (NSString *)description {
    return [NSString stringWithFormat:@"<%@: %p, assets=%@, dpi=%.0f, concurrent=%ld>",
            NSStringFromClass([self class]),
            self,
            self.assetsFolderPath ?: @"<none>",
            self.rasterizationDPI,
            (long)self.maxConcurrentPages];
}

@end

#pragma mark - Builder Implementation

@implementation PDF22MDConversionOptionsBuilder

- (instancetype)init {
    self = [super init];
    if (self) {
        // Initialize with default values
        PDF22MDConversionOptions *defaults = [PDF22MDConversionOptions defaultOptions];
        _rasterizationDPI = defaults.rasterizationDPI;
        _maxConcurrentPages = defaults.maxConcurrentPages;
        _includeMetadata = defaults.includeMetadata;
        _extractImages = defaults.extractImages;
        _preserveOutline = defaults.preserveOutline;
        _headingFontSizeThreshold = defaults.headingFontSizeThreshold;
        _maxHeadingLevel = defaults.maxHeadingLevel;
    }
    return self;
}

- (PDF22MDConversionOptions *)build {
    PDF22MDConversionOptions *options = [[PDF22MDConversionOptions alloc] init];
    
    options.assetsFolderPath = self.assetsFolderPath;
    options.rasterizationDPI = self.rasterizationDPI;
    options.maxConcurrentPages = self.maxConcurrentPages;
    options.includeMetadata = self.includeMetadata;
    options.extractImages = self.extractImages;
    options.preserveOutline = self.preserveOutline;
    options.headingFontSizeThreshold = self.headingFontSizeThreshold;
    options.maxHeadingLevel = self.maxHeadingLevel;
    options.progressHandler = self.progressHandler;
    
    return options;
}

@end
</file>

<file path="pdf22md-objc/src/Core/PDF22MDConverter.h">
#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>

NS_ASSUME_NONNULL_BEGIN

@class PDF22MDConversionOptions;

/**
 * Main converter class that coordinates the PDF to Markdown conversion process.
 * This class manages the entire conversion pipeline including parallel processing,
 * content extraction, and markdown generation.
 */
@interface PDF22MDConverter : NSObject

/**
 * The PDF document being converted.
 */
@property (nonatomic, strong, readonly) PDFDocument *document;

/**
 * Progress object for tracking conversion progress.
 */
@property (nonatomic, strong, readonly) NSProgress *progress;

/**
 * Initializes a converter with PDF data.
 *
 * @param pdfData The PDF data to convert
 * @return A new converter instance, or nil if the PDF is invalid
 */
- (nullable instancetype)initWithPDFData:(NSData *)pdfData;

/**
 * Initializes a converter with a PDF file URL.
 *
 * @param pdfURL The URL of the PDF file to convert
 * @return A new converter instance, or nil if the PDF is invalid
 */
- (nullable instancetype)initWithPDFURL:(NSURL *)pdfURL;

/**
 * Designated initializer that creates a converter with both URL and document.
 * This is the real designated initializer that other initializers should call.
 *
 * @param pdfURL The URL of the PDF file (may be nil for data-based PDFs)
 * @param document The PDF document instance
 * @return A new converter instance, or nil if invalid
 */
- (nullable instancetype)initWithPDFURL:(nullable NSURL *)pdfURL document:(PDFDocument *)document NS_DESIGNATED_INITIALIZER;

- (instancetype)init NS_UNAVAILABLE;

/**
 * Converts the PDF to Markdown with the given options.
 * This method performs the conversion asynchronously on a background queue.
 *
 * @param options Conversion options (uses defaults if nil)
 * @param completion Completion handler called with the result or error
 */
- (void)convertWithOptions:(nullable PDF22MDConversionOptions *)options
                completion:(void (^)(NSString * _Nullable markdown, NSError * _Nullable error))completion;

/**
 * Cancels an ongoing conversion.
 * The completion handler will be called with a cancellation error.
 */
- (void)cancelConversion;

/**
 * Validates that the PDF can be converted.
 *
 * @param error Set if validation fails
 * @return YES if the PDF is valid for conversion, NO otherwise
 */
- (BOOL)validateDocumentWithError:(NSError * _Nullable * _Nullable)error;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/Core/PDF22MDConverter.m">
#import "PDF22MDConverter.h"
#import "PDF22MDConversionOptions.h"
#import "PDF22MDPageProcessor.h"
#import "../Models/PDF22MDContentElement.h"
#import "../Models/PDF22MDImageElement.h"
#import "../Services/PDF22MDAssetManager.h"
#import "../Services/PDF22MDMarkdownGenerator.h"
#import "PDF22MDFontAnalyzer.h"
#import "PDF22MDError.h"

@interface PDF22MDConverter ()
@property (nonatomic, strong) dispatch_queue_t conversionQueue;
@property (nonatomic, strong) NSMutableArray<id<PDF22MDContentElement>> *allElements;
@property (nonatomic, strong) PDF22MDFontAnalyzer *fontAnalyzer;
@property (nonatomic, assign) BOOL isCancelled;
@end

@implementation PDF22MDConverter

#pragma mark - Initialization

- (nullable instancetype)initWithPDFData:(NSData *)pdfData {
    if (!pdfData || pdfData.length == 0) {
        return nil;
    }
    
    PDFDocument *document = [[PDFDocument alloc] initWithData:pdfData];
    if (!document) {
        return nil;
    }
    
    NSURL *tempURL = [NSURL URLWithString:@"data:application/pdf"];
    return [self initWithPDFURL:tempURL document:document];
}

- (nullable instancetype)initWithPDFURL:(NSURL *)pdfURL {
    if (!pdfURL) {
        return nil;
    }
    
    PDFDocument *document = [[PDFDocument alloc] initWithURL:pdfURL];
    if (!document) {
        return nil;
    }
    
    return [self initWithPDFURL:pdfURL document:document];
}

- (nullable instancetype)initWithPDFURL:(nullable NSURL *)pdfURL document:(PDFDocument *)document {
    if (!document) {
        return nil;
    }
    
    self = [super init];
    if (self) {
        _document = document;
        _conversionQueue = dispatch_queue_create("com.twardoch.pdf22md.converter", DISPATCH_QUEUE_SERIAL);
        _allElements = [NSMutableArray array];
        _fontAnalyzer = [[PDF22MDFontAnalyzer alloc] init];
        _progress = [NSProgress progressWithTotalUnitCount:[document pageCount]];
        _isCancelled = NO;
    }
    return self;
}

#pragma mark - Public Methods

- (void)convertWithOptions:(nullable PDF22MDConversionOptions *)options
                completion:(void (^)(NSString * _Nullable markdown, NSError * _Nullable error))completion {
    // Use default options if none provided
    if (!options) {
        options = [PDF22MDConversionOptions defaultOptions];
    }
    
    // Validate options
    NSError *validationError = nil;
    if (![options validateWithError:&validationError]) {
        completion(nil, validationError);
        return;
    }
    
    // Reset state
    self.isCancelled = NO;
    [self.allElements removeAllObjects];
    [self.fontAnalyzer reset];
    self.progress.completedUnitCount = 0;
    
    // Configure font analyzer
    self.fontAnalyzer.fontSizeThreshold = options.headingFontSizeThreshold;
    self.fontAnalyzer.maxHeadingLevel = options.maxHeadingLevel;
    
    // Perform conversion on background queue
    dispatch_async(self.conversionQueue, ^{
        @autoreleasepool {
            NSError *error = nil;
            NSString *markdown = [self performConversionWithOptions:options error:&error];
            
            // Call completion on main queue
            dispatch_async(dispatch_get_main_queue(), ^{
                completion(markdown, error);
            });
        }
    });
}

- (void)cancelConversion {
    self.isCancelled = YES;
    [self.progress cancel];
}

- (BOOL)validateDocumentWithError:(NSError * _Nullable * _Nullable)error {
    if (!self.document) {
        if (error) {
            *error = [PDF22MDErrorHelper invalidPDFErrorWithReason:@"Document is nil"];
        }
        return NO;
    }
    
    if ([self.document pageCount] == 0) {
        if (error) {
            *error = [PDF22MDErrorHelper invalidPDFErrorWithReason:@"Document has no pages"];
        }
        return NO;
    }
    
    if ([self.document isLocked]) {
        if (error) {
            *error = [PDF22MDErrorHelper invalidPDFErrorWithReason:@"Document is password protected"];
        }
        return NO;
    }
    
    return YES;
}

#pragma mark - Private Methods

- (nullable NSString *)performConversionWithOptions:(PDF22MDConversionOptions *)options
                                              error:(NSError * _Nullable * _Nullable)error {
    // Validate document
    if (![self validateDocumentWithError:error]) {
        return nil;
    }
    
    NSInteger pageCount = [self.document pageCount];
    
    // Create asset manager if needed
    PDF22MDAssetManager *assetManager = nil;
    if (options.extractImages && options.assetsFolderPath) {
        assetManager = [[PDF22MDAssetManager alloc] initWithAssetFolder:options.assetsFolderPath];
        if (!assetManager) {
            if (error) {
                *error = [PDF22MDErrorHelper assetCreationFailedErrorWithPath:options.assetsFolderPath
                                                                          reason:@"Failed to create asset manager"];
            }
            return nil;
        }
    }
    
    // Process pages in parallel
    NSMutableArray<NSMutableArray<id<PDF22MDContentElement>> *> *pageElementsArray = [NSMutableArray arrayWithCapacity:pageCount];
    NSMutableArray<PDF22MDFontAnalyzer *> *pageFontAnalyzers = [NSMutableArray arrayWithCapacity:pageCount];
    
    for (NSInteger i = 0; i < pageCount; i++) {
        [pageElementsArray addObject:[NSMutableArray array]];
        [pageFontAnalyzers addObject:[[PDF22MDFontAnalyzer alloc] init]];
    }
    
    // Create dispatch group for parallel processing
    dispatch_group_t processingGroup = dispatch_group_create();
    __block BOOL processingFailed = NO;
    __block NSError *processingError = nil;
    
    // Limit concurrency based on options
    dispatch_semaphore_t concurrencySemaphore = dispatch_semaphore_create(options.maxConcurrentPages);
    
    for (NSInteger pageIndex = 0; pageIndex < pageCount; pageIndex++) {
        if (self.isCancelled) {
            if (error) {
                *error = [NSError errorWithDomain:PDF22MDErrorDomain
                                             code:PDF22MDErrorCancelled
                                         userInfo:@{NSLocalizedDescriptionKey: @"Conversion was cancelled"}];
            }
            return nil;
        }
        
        dispatch_group_async(processingGroup, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            dispatch_semaphore_wait(concurrencySemaphore, DISPATCH_TIME_FOREVER);
            
            @autoreleasepool {
                if (!processingFailed && !self.isCancelled) {
                    PDFPage *page = [self.document pageAtIndex:pageIndex];
                    if (!page) {
                        processingFailed = YES;
                        processingError = [PDF22MDErrorHelper pageProcessingFailedErrorForPage:pageIndex
                                                                                        reason:@"Failed to get page"
                                                                               underlyingError:nil];
                    } else {
                        // Process page
                        PDF22MDPageProcessor *processor = [[PDF22MDPageProcessor alloc] initWithPDFPage:page
                                                                                             pageIndex:pageIndex
                                                                                                   dpi:options.rasterizationDPI];
                        processor.fontAnalyzer = pageFontAnalyzers[pageIndex];
                        
                        NSArray<id<PDF22MDContentElement>> *pageElements = [processor extractContentElements];
                        [pageElementsArray[pageIndex] addObjectsFromArray:pageElements];
                        
                        // Analyze fonts for this page
                        [pageFontAnalyzers[pageIndex] analyzeElements:pageElements];
                        
                        // Update progress
                        dispatch_async(dispatch_get_main_queue(), ^{
                            self.progress.completedUnitCount = pageIndex + 1;
                            if (options.progressHandler) {
                                options.progressHandler(pageIndex + 1, pageCount);
                            }
                        });
                    }
                }
            }
            
            dispatch_semaphore_signal(concurrencySemaphore);
        });
    }
    
    // Wait for all pages to complete
    dispatch_group_wait(processingGroup, DISPATCH_TIME_FOREVER);
    
    if (processingFailed) {
        if (error) {
            *error = processingError ?: [PDF22MDErrorHelper processingFailedErrorWithReason:@"Unknown processing error"
                                                                              underlyingError:nil];
        }
        return nil;
    }
    
    if (self.isCancelled) {
        if (error) {
            *error = [NSError errorWithDomain:PDF22MDErrorDomain
                                         code:PDF22MDErrorCancelled
                                     userInfo:@{NSLocalizedDescriptionKey: @"Conversion was cancelled"}];
        }
        return nil;
    }
    
    // Merge results from all pages
    for (NSInteger i = 0; i < pageCount; i++) {
        [self.allElements addObjectsFromArray:pageElementsArray[i]];
        [self.fontAnalyzer mergeFontStatisticsFromAnalyzer:pageFontAnalyzers[i]];
    }
    
    // Analyze font hierarchy and assign heading levels
    [self.fontAnalyzer analyzeElements:self.allElements];
    [self.fontAnalyzer assignHeadingLevels:self.allElements];
    
    // Sort elements by page and position
    [self sortElements];
    
    // Extract and save images if needed
    if (assetManager) {
        [self extractImagesWithAssetManager:assetManager];
    }
    
    // Generate markdown
    PDF22MDMarkdownGenerator *generator = [[PDF22MDMarkdownGenerator alloc] initWithOptions:options];
    PDF22MDDocumentMetadata *metadata = [PDF22MDMarkdownGenerator extractMetadataFromDocument:self.document];
    
    NSString *markdown = [generator generateMarkdownFromElements:self.allElements withMetadata:metadata];
    
    return markdown;
}

- (void)sortElements {
    [self.allElements sortUsingComparator:^NSComparisonResult(id<PDF22MDContentElement> obj1, id<PDF22MDContentElement> obj2) {
        // First sort by page
        if (obj1.pageIndex != obj2.pageIndex) {
            return obj1.pageIndex < obj2.pageIndex ? NSOrderedAscending : NSOrderedDescending;
        }
        
        // Then sort by vertical position (top to bottom)
        CGFloat y1 = CGRectGetMaxY(obj1.bounds);
        CGFloat y2 = CGRectGetMaxY(obj2.bounds);
        
        if (fabs(y1 - y2) > 5.0) { // Tolerance for same line
            return y1 > y2 ? NSOrderedAscending : NSOrderedDescending;
        }
        
        // Finally sort by horizontal position (left to right)
        CGFloat x1 = CGRectGetMinX(obj1.bounds);
        CGFloat x2 = CGRectGetMinX(obj2.bounds);
        
        return x1 < x2 ? NSOrderedAscending : NSOrderedDescending;
    }];
}

- (void)extractImagesWithAssetManager:(PDF22MDAssetManager *)assetManager {
    NSMutableArray<PDF22MDImageElement *> *imageElements = [NSMutableArray array];
    
    for (id<PDF22MDContentElement> element in self.allElements) {
        if ([element isKindOfClass:[PDF22MDImageElement class]]) {
            [imageElements addObject:(PDF22MDImageElement *)element];
        }
    }
    
    if (imageElements.count == 0) {
        return;
    }
    
    // Save images in parallel
    dispatch_group_t imageGroup = dispatch_group_create();
    dispatch_queue_t imageQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    
    [imageElements enumerateObjectsUsingBlock:^(PDF22MDImageElement *imageElement, NSUInteger idx, BOOL * __unused stop) {
        dispatch_group_async(imageGroup, imageQueue, ^{
            @autoreleasepool {
                NSString *baseName = [NSString stringWithFormat:@"image_%03lu", (unsigned long)idx];
                [assetManager saveImageElement:imageElement withBaseName:baseName];
            }
        });
    }];
    
    dispatch_group_wait(imageGroup, DISPATCH_TIME_FOREVER);
}

@end
</file>

<file path="pdf22md-objc/src/Core/PDF22MDError.h">
#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

/**
 * Error domain for all PDF22MD errors.
 */
extern NSErrorDomain const PDF22MDErrorDomain;

/**
 * Error codes used throughout the PDF22MD framework.
 */
typedef NS_ERROR_ENUM(PDF22MDErrorDomain, PDF22MDError) {
    /**
     * The provided PDF file or data is invalid or corrupted.
     */
    PDF22MDErrorInvalidPDF = 1000,
    
    /**
     * Failed to create the assets folder or save extracted images.
     */
    PDF22MDErrorAssetCreationFailed = 1001,
    
    /**
     * General processing failure during conversion.
     */
    PDF22MDErrorProcessingFailed = 1002,
    
    /**
     * One or more pages failed to process.
     */
    PDF22MDErrorPageProcessingFailed = 1003,
    
    /**
     * Invalid or missing configuration options.
     */
    PDF22MDErrorInvalidConfiguration = 1004,
    
    /**
     * I/O error reading or writing files.
     */
    PDF22MDErrorIOFailure = 1005,
    
    /**
     * Memory allocation failure.
     */
    PDF22MDErrorMemoryFailure = 1006,
    
    /**
     * Operation was cancelled.
     */
    PDF22MDErrorCancelled = 1007
};

/**
 * Keys for additional information in error's userInfo dictionary.
 */
extern NSString * const PDF22MDErrorPageIndexKey;      // NSNumber containing the failed page index
extern NSString * const PDF22MDErrorFilePathKey;       // NSString containing the problematic file path
extern NSString * const PDF22MDErrorUnderlyingErrorKey; // Original NSError that caused this error

/**
 * Helper class for creating consistent error objects.
 */
@interface PDF22MDErrorHelper : NSObject

/**
 * Creates an error for invalid PDF input.
 */
+ (NSError *)invalidPDFError;

/**
 * Creates an error for invalid PDF input with additional details.
 */
+ (NSError *)invalidPDFErrorWithReason:(nullable NSString *)reason;

/**
 * Creates an error for asset creation failure.
 */
+ (NSError *)assetCreationFailedErrorWithPath:(NSString *)path 
                                         reason:(nullable NSString *)reason;

/**
 * Creates an error for page processing failure.
 */
+ (NSError *)pageProcessingFailedErrorForPage:(NSInteger)pageIndex 
                                        reason:(nullable NSString *)reason
                               underlyingError:(nullable NSError *)underlyingError;

/**
 * Creates an error for general processing failure.
 */
+ (NSError *)processingFailedErrorWithReason:(NSString *)reason 
                              underlyingError:(nullable NSError *)underlyingError;

/**
 * Creates an error for I/O failure.
 */
+ (NSError *)ioFailureErrorWithPath:(nullable NSString *)path 
                              reason:(NSString *)reason
                     underlyingError:(nullable NSError *)underlyingError;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/Core/PDF22MDError.m">
#import "PDF22MDError.h"

NSErrorDomain const PDF22MDErrorDomain = @"com.twardoch.pdf22md.ErrorDomain";

NSString * const PDF22MDErrorPageIndexKey = @"PDF22MDErrorPageIndex";
NSString * const PDF22MDErrorFilePathKey = @"PDF22MDErrorFilePath";
NSString * const PDF22MDErrorUnderlyingErrorKey = @"PDF22MDErrorUnderlyingError";

@implementation PDF22MDErrorHelper

+ (NSError *)invalidPDFError {
    return [self invalidPDFErrorWithReason:nil];
}

+ (NSError *)invalidPDFErrorWithReason:(nullable NSString *)reason {
    NSString *description = @"Invalid or corrupted PDF file";
    NSString *failureReason = reason ?: @"The PDF document could not be opened or parsed";
    
    NSDictionary *userInfo = @{
        NSLocalizedDescriptionKey: description,
        NSLocalizedFailureReasonErrorKey: failureReason,
        NSLocalizedRecoverySuggestionErrorKey: @"Ensure the file is a valid PDF document and is not corrupted"
    };
    
    return [NSError errorWithDomain:PDF22MDErrorDomain
                               code:PDF22MDErrorInvalidPDF
                           userInfo:userInfo];
}

+ (NSError *)assetCreationFailedErrorWithPath:(NSString *)path 
                                         reason:(nullable NSString *)reason {
    NSString *description = @"Failed to create or save asset";
    NSString *failureReason = reason ?: [NSString stringWithFormat:@"Could not save asset to path: %@", path];
    
    NSMutableDictionary *userInfo = [@{
        NSLocalizedDescriptionKey: description,
        NSLocalizedFailureReasonErrorKey: failureReason,
        NSLocalizedRecoverySuggestionErrorKey: @"Check that the directory exists and you have write permissions"
    } mutableCopy];
    
    if (path) {
        userInfo[PDF22MDErrorFilePathKey] = path;
    }
    
    return [NSError errorWithDomain:PDF22MDErrorDomain
                               code:PDF22MDErrorAssetCreationFailed
                           userInfo:userInfo];
}

+ (NSError *)pageProcessingFailedErrorForPage:(NSInteger)pageIndex 
                                        reason:(nullable NSString *)reason
                               underlyingError:(nullable NSError *)underlyingError {
    NSString *description = [NSString stringWithFormat:@"Failed to process page %ld", (long)(pageIndex + 1)];
    NSString *failureReason = reason ?: @"An error occurred while extracting content from the page";
    
    NSMutableDictionary *userInfo = [@{
        NSLocalizedDescriptionKey: description,
        NSLocalizedFailureReasonErrorKey: failureReason,
        NSLocalizedRecoverySuggestionErrorKey: @"The page may contain unsupported content or be corrupted",
        PDF22MDErrorPageIndexKey: @(pageIndex)
    } mutableCopy];
    
    if (underlyingError) {
        userInfo[NSUnderlyingErrorKey] = underlyingError;
        userInfo[PDF22MDErrorUnderlyingErrorKey] = underlyingError;
    }
    
    return [NSError errorWithDomain:PDF22MDErrorDomain
                               code:PDF22MDErrorPageProcessingFailed
                           userInfo:userInfo];
}

+ (NSError *)processingFailedErrorWithReason:(NSString *)reason 
                              underlyingError:(nullable NSError *)underlyingError {
    NSString *description = @"PDF processing failed";
    
    NSMutableDictionary *userInfo = [@{
        NSLocalizedDescriptionKey: description,
        NSLocalizedFailureReasonErrorKey: reason,
        NSLocalizedRecoverySuggestionErrorKey: @"Check the input file and try again"
    } mutableCopy];
    
    if (underlyingError) {
        userInfo[NSUnderlyingErrorKey] = underlyingError;
        userInfo[PDF22MDErrorUnderlyingErrorKey] = underlyingError;
    }
    
    return [NSError errorWithDomain:PDF22MDErrorDomain
                               code:PDF22MDErrorProcessingFailed
                           userInfo:userInfo];
}

+ (NSError *)ioFailureErrorWithPath:(nullable NSString *)path 
                              reason:(NSString *)reason
                     underlyingError:(nullable NSError *)underlyingError {
    NSString *description = @"File I/O operation failed";
    
    NSMutableDictionary *userInfo = [@{
        NSLocalizedDescriptionKey: description,
        NSLocalizedFailureReasonErrorKey: reason,
        NSLocalizedRecoverySuggestionErrorKey: @"Check file permissions and available disk space"
    } mutableCopy];
    
    if (path) {
        userInfo[PDF22MDErrorFilePathKey] = path;
    }
    
    if (underlyingError) {
        userInfo[NSUnderlyingErrorKey] = underlyingError;
        userInfo[PDF22MDErrorUnderlyingErrorKey] = underlyingError;
    }
    
    return [NSError errorWithDomain:PDF22MDErrorDomain
                               code:PDF22MDErrorIOFailure
                           userInfo:userInfo];
}

@end
</file>

<file path="pdf22md-objc/src/Core/PDF22MDFontAnalyzer.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

@protocol PDF22MDContentElement;
@class PDF22MDTextElement;

/**
 * Font statistics for a particular font and size combination.
 */
@interface PDF22MDFontStatistics : NSObject
@property (nonatomic, copy, readonly) NSString *fontKey;
@property (nonatomic, copy, readonly) NSString *fontName;
@property (nonatomic, assign, readonly) CGFloat fontSize;
@property (nonatomic, assign, readonly) NSUInteger occurrenceCount;
@property (nonatomic, assign) NSInteger assignedHeadingLevel; // 0 for body text, 1-6 for headings

- (instancetype)initWithFontKey:(NSString *)fontKey
                       fontName:(NSString *)fontName
                       fontSize:(CGFloat)fontSize;

- (void)incrementOccurrenceCount;
- (void)addOccurrenceCount:(NSUInteger)count;

@end

/**
 * Analyzes font usage in PDF documents to detect heading hierarchy.
 */
@interface PDF22MDFontAnalyzer : NSObject

/**
 * The font size threshold for detecting headings.
 * Text with font size differences greater than this value may be considered headings.
 */
@property (nonatomic, assign) CGFloat fontSizeThreshold;

/**
 * Maximum heading level to assign (1-6).
 */
@property (nonatomic, assign) NSInteger maxHeadingLevel;

/**
 * Dictionary of font statistics keyed by font identifier.
 */
@property (nonatomic, strong, readonly) NSDictionary<NSString *, PDF22MDFontStatistics *> *fontStatistics;

/**
 * Initializes the analyzer with default settings.
 */
- (instancetype)init;

/**
 * Analyzes an array of content elements to build font statistics.
 * This should be called before assignHeadingLevels.
 *
 * @param elements Array of content elements to analyze
 */
- (void)analyzeElements:(NSArray<id<PDF22MDContentElement>> *)elements;

/**
 * Assigns heading levels to text elements based on font analysis.
 * Call this after analyzeElements.
 *
 * @param elements Array of content elements to process
 */
- (void)assignHeadingLevels:(NSArray<id<PDF22MDContentElement>> *)elements;

/**
 * Merges font statistics from another analyzer.
 * Useful for combining statistics from multiple pages.
 *
 * @param otherAnalyzer The analyzer to merge from
 */
- (void)mergeFontStatisticsFromAnalyzer:(PDF22MDFontAnalyzer *)otherAnalyzer;

/**
 * Resets all collected statistics.
 */
- (void)reset;

/**
 * Gets a sorted array of font statistics by size (largest first).
 */
- (NSArray<PDF22MDFontStatistics *> *)sortedFontStatistics;

/**
 * Creates a font key identifier from font properties.
 */
+ (NSString *)fontKeyForFontName:(nullable NSString *)fontName fontSize:(CGFloat)fontSize;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/Core/PDF22MDFontAnalyzer.m">
#import "PDF22MDFontAnalyzer.h"
#import "../Models/PDF22MDContentElement.h"
#import "../Models/PDF22MDTextElement.h"

@implementation PDF22MDFontStatistics

- (instancetype)initWithFontKey:(NSString *)fontKey
                       fontName:(NSString *)fontName
                       fontSize:(CGFloat)fontSize {
    self = [super init];
    if (self) {
        _fontKey = [fontKey copy];
        _fontName = [fontName copy];
        _fontSize = fontSize;
        _occurrenceCount = 0;
        _assignedHeadingLevel = 0;
    }
    return self;
}

- (void)incrementOccurrenceCount {
    _occurrenceCount++;
}

- (void)addOccurrenceCount:(NSUInteger)count {
    _occurrenceCount += count;
}

- (NSString *)description {
    return [NSString stringWithFormat:@"<FontStats: %@ size=%.1f count=%lu level=%ld>",
            self.fontName, self.fontSize, (unsigned long)self.occurrenceCount, (long)self.assignedHeadingLevel];
}

@end

@interface PDF22MDFontAnalyzer ()
@property (nonatomic, strong) NSMutableDictionary<NSString *, PDF22MDFontStatistics *> *mutableFontStatistics;
@end

@implementation PDF22MDFontAnalyzer

#pragma mark - Initialization

- (instancetype)init {
    self = [super init];
    if (self) {
        _fontSizeThreshold = 2.0;
        _maxHeadingLevel = 6;
        _mutableFontStatistics = [NSMutableDictionary dictionary];
    }
    return self;
}

#pragma mark - Public Methods

- (void)analyzeElements:(NSArray<id<PDF22MDContentElement>> *)elements {
    for (id<PDF22MDContentElement> element in elements) {
        if ([element isKindOfClass:[PDF22MDTextElement class]]) {
            PDF22MDTextElement *textElement = (PDF22MDTextElement *)element;
            [self addTextElementToStatistics:textElement];
        }
    }
}

- (void)assignHeadingLevels:(NSArray<id<PDF22MDContentElement>> *)elements {
    // Get sorted font statistics
    NSArray<PDF22MDFontStatistics *> *sortedStats = [self sortedFontStatistics];
    
    if (sortedStats.count == 0) {
        return;
    }
    
    // Find the most common font size (likely body text)
    PDF22MDFontStatistics *mostCommonFont = nil;
    NSUInteger highestCount = 0;
    
    for (PDF22MDFontStatistics *stats in sortedStats) {
        if (stats.occurrenceCount > highestCount) {
            highestCount = stats.occurrenceCount;
            mostCommonFont = stats;
        }
    }
    
    CGFloat bodyFontSize = mostCommonFont ? mostCommonFont.fontSize : 12.0;
    
    // Assign heading levels based on size hierarchy
    NSInteger currentHeadingLevel = 1;
    CGFloat lastHeadingSize = CGFLOAT_MAX;
    
    for (PDF22MDFontStatistics *stats in sortedStats) {
        // Skip if this is likely body text
        if (stats == mostCommonFont) {
            stats.assignedHeadingLevel = 0;
            continue;
        }
        
        // Check if this font is significantly larger than body text
        CGFloat sizeDifference = stats.fontSize - bodyFontSize;
        
        if (sizeDifference >= self.fontSizeThreshold) {
            // This is a potential heading
            // Check if it's significantly different from the last heading size
            if (lastHeadingSize - stats.fontSize >= self.fontSizeThreshold) {
                currentHeadingLevel++;
            }
            
            if (currentHeadingLevel <= self.maxHeadingLevel) {
                stats.assignedHeadingLevel = currentHeadingLevel;
                lastHeadingSize = stats.fontSize;
            } else {
                // Too many heading levels, treat as body text
                stats.assignedHeadingLevel = 0;
            }
        } else {
            // Not large enough to be a heading
            stats.assignedHeadingLevel = 0;
        }
        
        // Additional heuristic: if occurrence count is very high, it's probably not a heading
        if (stats.occurrenceCount > highestCount * 0.5) {
            stats.assignedHeadingLevel = 0;
        }
    }
    
    // Apply heading levels to text elements
    for (id<PDF22MDContentElement> element in elements) {
        if ([element isKindOfClass:[PDF22MDTextElement class]]) {
            PDF22MDTextElement *textElement = (PDF22MDTextElement *)element;
            NSString *fontKey = [[self class] fontKeyForFontName:textElement.fontName 
                                                        fontSize:textElement.fontSize];
            PDF22MDFontStatistics *stats = self.mutableFontStatistics[fontKey];
            if (stats) {
                textElement.headingLevel = stats.assignedHeadingLevel;
            }
        }
    }
}

- (void)mergeFontStatisticsFromAnalyzer:(PDF22MDFontAnalyzer *)otherAnalyzer {
    [otherAnalyzer.fontStatistics enumerateKeysAndObjectsUsingBlock:^(NSString *key, PDF22MDFontStatistics *otherStats, BOOL * __unused stop) {
        PDF22MDFontStatistics *existingStats = self.mutableFontStatistics[key];
        
        if (existingStats) {
            // Merge occurrence counts
            [existingStats addOccurrenceCount:otherStats.occurrenceCount];
        } else {
            // Add new statistics
            PDF22MDFontStatistics *newStats = [[PDF22MDFontStatistics alloc] initWithFontKey:otherStats.fontKey
                                                                                    fontName:otherStats.fontName
                                                                                    fontSize:otherStats.fontSize];
            [newStats addOccurrenceCount:otherStats.occurrenceCount];
            self.mutableFontStatistics[key] = newStats;
        }
    }];
}

- (void)reset {
    [self.mutableFontStatistics removeAllObjects];
}

- (NSArray<PDF22MDFontStatistics *> *)sortedFontStatistics {
    NSArray<PDF22MDFontStatistics *> *allStats = [self.mutableFontStatistics allValues];
    
    // Sort by font size in descending order
    return [allStats sortedArrayUsingComparator:^NSComparisonResult(PDF22MDFontStatistics *obj1, PDF22MDFontStatistics *obj2) {
        if (obj1.fontSize > obj2.fontSize) {
            return NSOrderedAscending;
        } else if (obj1.fontSize < obj2.fontSize) {
            return NSOrderedDescending;
        } else {
            // Same size, sort by occurrence count
            if (obj1.occurrenceCount > obj2.occurrenceCount) {
                return NSOrderedAscending;
            } else if (obj1.occurrenceCount < obj2.occurrenceCount) {
                return NSOrderedDescending;
            }
            return NSOrderedSame;
        }
    }];
}

+ (NSString *)fontKeyForFontName:(nullable NSString *)fontName fontSize:(CGFloat)fontSize {
    NSString *name = fontName ?: @"Unknown";
    return [NSString stringWithFormat:@"%.1f-%@", fontSize, name];
}

#pragma mark - Properties

- (NSDictionary<NSString *, PDF22MDFontStatistics *> *)fontStatistics {
    return [self.mutableFontStatistics copy];
}

#pragma mark - Private Methods

- (void)addTextElementToStatistics:(PDF22MDTextElement *)textElement {
    // Skip empty text
    NSString *trimmedText = [textElement.text stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    if (trimmedText.length == 0) {
        return;
    }
    
    NSString *fontKey = [[self class] fontKeyForFontName:textElement.fontName fontSize:textElement.fontSize];
    
    PDF22MDFontStatistics *stats = self.mutableFontStatistics[fontKey];
    if (!stats) {
        stats = [[PDF22MDFontStatistics alloc] initWithFontKey:fontKey
                                                      fontName:textElement.fontName ?: @"Unknown"
                                                      fontSize:textElement.fontSize];
        self.mutableFontStatistics[fontKey] = stats;
    }
    
    [stats incrementOccurrenceCount];
}

@end
</file>

<file path="pdf22md-objc/src/Core/PDF22MDPageProcessor.h">
#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

@protocol PDF22MDContentElement;
@class PDF22MDFontAnalyzer;

/**
 * Processes individual PDF pages to extract content elements.
 * Uses PDFKit's high-level API for safe and reliable content extraction.
 */
@interface PDF22MDPageProcessor : NSObject

/**
 * The PDF page being processed.
 */
@property (nonatomic, strong, readonly) PDFPage *pdfPage;

/**
 * The zero-based index of the page.
 */
@property (nonatomic, assign, readonly) NSInteger pageIndex;

/**
 * DPI for rasterizing vector graphics.
 */
@property (nonatomic, assign, readonly) CGFloat dpi;

/**
 * Font analyzer for this page (optional).
 */
@property (nonatomic, strong, nullable) PDF22MDFontAnalyzer *fontAnalyzer;

/**
 * Initializes a page processor for the given PDF page.
 *
 * @param pdfPage The PDF page to process
 * @param pageIndex The zero-based page index
 * @param dpi DPI for rasterization (default: 144)
 * @return A new page processor instance
 */
- (instancetype)initWithPDFPage:(PDFPage *)pdfPage
                      pageIndex:(NSInteger)pageIndex
                            dpi:(CGFloat)dpi NS_DESIGNATED_INITIALIZER;

- (instancetype)init NS_UNAVAILABLE;

/**
 * Extracts all content elements from the page.
 * This includes text and images.
 *
 * @return Array of content elements in reading order
 */
- (NSArray<id<PDF22MDContentElement>> *)extractContentElements;

/**
 * Extracts only text elements from the page.
 *
 * @return Array of text elements
 */
- (NSArray<id<PDF22MDContentElement>> *)extractTextElements;

/**
 * Extracts only image elements from the page.
 *
 * @return Array of image elements
 */
- (NSArray<id<PDF22MDContentElement>> *)extractImageElements;

/**
 * Captures vector graphics in the specified bounds as a rasterized image.
 *
 * @param bounds The area to capture
 * @param elements Array to add the captured image element to
 */
- (void)captureVectorGraphicsInBounds:(CGRect)bounds
                         withElements:(NSMutableArray<id<PDF22MDContentElement>> *)elements;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/Core/PDF22MDPageProcessor.m">
#import "PDF22MDPageProcessor.h"
#import "../Models/PDF22MDTextElement.h"
#import "../Models/PDF22MDImageElement.h"
#import "PDF22MDFontAnalyzer.h"
#import <CoreGraphics/CoreGraphics.h>

#if TARGET_OS_MAC && !TARGET_OS_IPHONE
#import <AppKit/AppKit.h>
#else
#import <UIKit/UIKit.h>
#endif

@interface PDF22MDPageProcessor ()
@property (nonatomic, assign) CGPDFPageRef cgPdfPage;
@end

@implementation PDF22MDPageProcessor

#pragma mark - Initialization

- (instancetype)initWithPDFPage:(PDFPage *)pdfPage
                      pageIndex:(NSInteger)pageIndex
                            dpi:(CGFloat)dpi {
    self = [super init];
    if (self) {
        _pdfPage = pdfPage;
        _pageIndex = pageIndex;
        _dpi = dpi;
        _cgPdfPage = [pdfPage pageRef];
    }
    return self;
}

#pragma mark - Public Methods

- (NSArray<id<PDF22MDContentElement>> *)extractContentElements {
    NSMutableArray<id<PDF22MDContentElement>> *elements = [NSMutableArray array];
    
    // Extract text elements
    NSArray *textElements = [self extractTextElements];
    [elements addObjectsFromArray:textElements];
    
    // Extract image elements
    NSArray *imageElements = [self extractImageElements];
    [elements addObjectsFromArray:imageElements];
    
    // Sort elements by position
    [self sortElementsByPosition:elements];
    
    return elements;
}

- (NSArray<id<PDF22MDContentElement>> *)extractTextElements {
    NSMutableArray<id<PDF22MDContentElement>> *elements = [NSMutableArray array];
    
    // Extract text using PDFKit's high-level API
    NSString *pageText = [self.pdfPage string];
    if (!pageText || pageText.length == 0) {
        return elements;
    }
    
    // Get page bounds for positioning
    CGRect pageRect = [self.pdfPage boundsForBox:kPDFDisplayBoxMediaBox];
    CGFloat pageHeight = CGRectGetHeight(pageRect);
    
    // Split into paragraphs while preserving structure
    NSArray<NSString *> *paragraphs = [self extractParagraphsFromPageText:pageText];
    
    // Create text elements with approximate positioning
    CGFloat cursorY = pageHeight - 20; // Start near top with margin
    CGFloat lineHeight = 14.0; // Default line height
    CGFloat paragraphSpacing = lineHeight * 0.5;
    
    for (NSString *paragraph in paragraphs) {
        NSString *trimmed = [paragraph stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
        if (trimmed.length == 0) {
            cursorY -= paragraphSpacing;
            continue;
        }
        
        // Try to extract font information from PDF selections
        PDFSelection *selection = [self.pdfPage selectionForRange:NSMakeRange(0, trimmed.length)];
        NSDictionary *fontInfo = [self extractFontInfoFromSelection:selection];
        
        PDF22MDTextElement *element = [[PDF22MDTextElement alloc] initWithText:trimmed
                                                                        bounds:CGRectMake(20, cursorY - lineHeight, pageRect.size.width - 40, lineHeight)
                                                                     pageIndex:self.pageIndex
                                                                      fontName:fontInfo[@"fontName"]
                                                                      fontSize:[fontInfo[@"fontSize"] doubleValue]
                                                                        isBold:[fontInfo[@"isBold"] boolValue]
                                                                      isItalic:[fontInfo[@"isItalic"] boolValue]];
        
        [elements addObject:element];
        
        // Update cursor position
        NSInteger lineCount = [self estimateLineCountForText:trimmed inWidth:pageRect.size.width - 40];
        cursorY -= (lineHeight * lineCount + paragraphSpacing);
    }
    
    return elements;
}

- (NSArray<id<PDF22MDContentElement>> *)extractImageElements {
    NSMutableArray<id<PDF22MDContentElement>> *elements = [NSMutableArray array];
    
    // Method 1: Extract images from annotations
    NSArray<PDFAnnotation *> *annotations = [self.pdfPage annotations];
    
    for (PDFAnnotation *annotation in annotations) {
        // Check if annotation might contain an image
        if ([self annotationMayContainImage:annotation]) {
            CGImageRef image = [self imageFromAnnotation:annotation];
            if (image) {
                PDF22MDImageElement *element = [[PDF22MDImageElement alloc] initWithImage:image
                                                                                   bounds:[annotation bounds]
                                                                                pageIndex:self.pageIndex
                                                                           isVectorSource:NO];
                [elements addObject:element];
                CGImageRelease(image);
            }
        }
    }
    
    // Method 2: Detect image regions by analyzing page content
    NSArray *imageRegions = [self detectImageRegionsInPage];
    for (NSData *regionData in imageRegions) {
        CGRect region;
        [regionData getBytes:&region length:sizeof(CGRect)];
        [self captureVectorGraphicsInBounds:region withElements:elements];
    }
    
    return elements;
}

- (void)captureVectorGraphicsInBounds:(CGRect)bounds
                         withElements:(NSMutableArray<id<PDF22MDContentElement>> *)elements {
    // Expand bounds slightly to ensure we capture everything
    bounds = CGRectInset(bounds, -5, -5);
    
    // Calculate size at specified DPI
    CGFloat scale = self.dpi / 72.0;
    size_t width = (size_t)(CGRectGetWidth(bounds) * scale);
    size_t height = (size_t)(CGRectGetHeight(bounds) * scale);
    
    if (width == 0 || height == 0 || width > 4096 || height > 4096) {
        return;
    }
    
    // Create bitmap context
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, colorSpace,
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        return;
    }
    
    // Set white background
    CGContextSetRGBFillColor(context, 1.0, 1.0, 1.0, 1.0);
    CGContextFillRect(context, CGRectMake(0, 0, width, height));
    
    // Set up transformation to render just the bounds area
    CGContextSaveGState(context);
    CGContextScaleCTM(context, scale, scale);
    CGContextTranslateCTM(context, -bounds.origin.x, -bounds.origin.y);
    
    // Draw the PDF page
    CGContextDrawPDFPage(context, self.cgPdfPage);
    
    CGContextRestoreGState(context);
    
    // Create image
    CGImageRef image = CGBitmapContextCreateImage(context);
    CGContextRelease(context);
    
    if (image) {
        PDF22MDImageElement *element = [[PDF22MDImageElement alloc] initWithImage:image
                                                                           bounds:bounds
                                                                        pageIndex:self.pageIndex
                                                                   isVectorSource:YES];
        [elements addObject:element];
        CGImageRelease(image);
    }
}

#pragma mark - Private Methods

- (NSArray<NSString *> *)extractParagraphsFromPageText:(NSString *)pageText {
    // Split by multiple newlines to get paragraphs
    NSArray *components = [pageText componentsSeparatedByString:@"\n\n"];
    NSMutableArray *paragraphs = [NSMutableArray array];
    
    for (NSString *component in components) {
        // Further split by single newlines but join short lines
        NSArray *lines = [component componentsSeparatedByString:@"\n"];
        NSMutableString *paragraph = [NSMutableString string];
        
        for (NSString *line in lines) {
            NSString *trimmedLine = [line stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
            if (trimmedLine.length > 0) {
                if (paragraph.length > 0) {
                    // Add space between lines
                    [paragraph appendString:@" "];
                }
                [paragraph appendString:trimmedLine];
            }
        }
        
        if (paragraph.length > 0) {
            [paragraphs addObject:[paragraph copy]];
        }
    }
    
    return paragraphs;
}

- (NSDictionary *)extractFontInfoFromSelection:(PDFSelection *)selection {
    // Default font info
    NSMutableDictionary *fontInfo = [@{
        @"fontName": @"Helvetica",
        @"fontSize": @(12.0),
        @"isBold": @(NO),
        @"isItalic": @(NO)
    } mutableCopy];
    
    // PDFKit doesn't provide direct access to font information
    // This would require lower-level Core Graphics analysis
    // For now, we'll use heuristics based on the text content
    
    NSString *text = [selection string];
    if (text) {
        // Simple heuristic: all caps might indicate a heading
        if ([text isEqualToString:[text uppercaseString]] && text.length > 3) {
            fontInfo[@"fontSize"] = @(14.0);
            fontInfo[@"isBold"] = @(YES);
        }
    }
    
    return fontInfo;
}

- (BOOL)annotationMayContainImage:(PDFAnnotation *)annotation {
    // Check annotation type and bounds
    CGRect bounds = [annotation bounds];
    
    // Images typically have reasonable dimensions
    if (CGRectIsEmpty(bounds) || bounds.size.width < 10 || bounds.size.height < 10) {
        return NO;
    }
    
    // Check if it's not a text annotation
    NSString *contents = [annotation contents];
    if (contents && contents.length > 0) {
        return NO;
    }
    
    return YES;
}

- (CGImageRef)imageFromAnnotation:(PDFAnnotation *)annotation {
    CGRect bounds = [annotation bounds];
    
    // Create a bitmap context to render the annotation
    CGFloat scale = self.dpi / 72.0;
    size_t width = (size_t)(bounds.size.width * scale);
    size_t height = (size_t)(bounds.size.height * scale);
    
    if (width == 0 || height == 0 || width > 4096 || height > 4096) {
        return NULL;
    }
    
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, colorSpace,
                                                kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        return NULL;
    }
    
    // Set white background
    CGContextSetRGBFillColor(context, 1.0, 1.0, 1.0, 1.0);
    CGContextFillRect(context, CGRectMake(0, 0, width, height));
    
    // Transform context to match annotation bounds
    CGContextSaveGState(context);
    CGContextScaleCTM(context, scale, scale);
    
    // Draw just the annotation area from the page
    CGContextClipToRect(context, CGRectMake(0, 0, bounds.size.width, bounds.size.height));
    CGContextTranslateCTM(context, -bounds.origin.x, -bounds.origin.y);
    CGContextDrawPDFPage(context, self.cgPdfPage);
    
    CGContextRestoreGState(context);
    
    // Create image
    CGImageRef image = CGBitmapContextCreateImage(context);
    CGContextRelease(context);
    
    return image;
}

- (NSArray *)detectImageRegionsInPage {
    NSMutableArray *regions = [NSMutableArray array];
    
    // Simple heuristic: divide page into grid and check for non-text regions
    CGRect pageRect = [self.pdfPage boundsForBox:kPDFDisplayBoxMediaBox];
    CGFloat gridSize = 100.0;
    
    NSInteger gridX = (NSInteger)ceil(pageRect.size.width / gridSize);
    NSInteger gridY = (NSInteger)ceil(pageRect.size.height / gridSize);
    
    for (NSInteger x = 0; x < gridX; x++) {
        for (NSInteger y = 0; y < gridY; y++) {
            CGRect gridRect = CGRectMake(x * gridSize, y * gridSize, gridSize, gridSize);
            gridRect = CGRectIntersection(gridRect, pageRect);
            
            if (CGRectIsEmpty(gridRect) || gridRect.size.width < 20 || gridRect.size.height < 20) {
                continue;
            }
            
            // Check if this region contains primarily non-text content
            PDFSelection *selection = [self.pdfPage selectionForRect:gridRect];
            NSString *regionText = [[selection string] stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
            
            // If very little text, might be an image region
            if (regionText.length < 10) {
                NSData *rectData = [NSData dataWithBytes:&gridRect length:sizeof(CGRect)];
                [regions addObject:rectData];
            }
        }
    }
    
    // Merge adjacent regions
    return [self mergeAdjacentRegions:regions];
}

- (NSArray *)mergeAdjacentRegions:(NSArray *)regions {
    if (regions.count <= 1) {
        return regions;
    }
    
    NSMutableArray *mergedRegions = [NSMutableArray array];
    NSMutableSet *processedIndices = [NSMutableSet set];
    
    for (NSUInteger i = 0; i < regions.count; i++) {
        if ([processedIndices containsObject:@(i)]) {
            continue;
        }
        
        CGRect currentRect;
        [regions[i] getBytes:&currentRect length:sizeof(CGRect)];
        [processedIndices addObject:@(i)];
        
        // Try to merge with adjacent regions
        BOOL merged = YES;
        while (merged) {
            merged = NO;
            
            for (NSUInteger j = 0; j < regions.count; j++) {
                if ([processedIndices containsObject:@(j)]) {
                    continue;
                }
                
                CGRect otherRect;
                [regions[j] getBytes:&otherRect length:sizeof(CGRect)];
                
                // Check if rectangles are adjacent
                if (CGRectIntersectsRect(CGRectInset(currentRect, -10, -10), otherRect)) {
                    currentRect = CGRectUnion(currentRect, otherRect);
                    [processedIndices addObject:@(j)];
                    merged = YES;
                }
            }
        }
        
        NSData *rectData = [NSData dataWithBytes:&currentRect length:sizeof(CGRect)];
        [mergedRegions addObject:rectData];
    }
    
    return mergedRegions;
}

- (NSInteger)estimateLineCountForText:(NSString *)text inWidth:(CGFloat)width {
    // Simple estimation based on average character width
    CGFloat avgCharWidth = 7.0; // Approximate for 12pt font
    NSInteger charsPerLine = (NSInteger)(width / avgCharWidth);
    
    if (charsPerLine <= 0) {
        return 1;
    }
    
    return MAX(1, (text.length + charsPerLine - 1) / charsPerLine);
}

- (void)sortElementsByPosition:(NSMutableArray<id<PDF22MDContentElement>> *)elements {
    [elements sortUsingComparator:^NSComparisonResult(id<PDF22MDContentElement> obj1, id<PDF22MDContentElement> obj2) {
        // Sort by vertical position (top to bottom)
        CGFloat y1 = CGRectGetMaxY(obj1.bounds);
        CGFloat y2 = CGRectGetMaxY(obj2.bounds);
        
        if (fabs(y1 - y2) > 5.0) { // Tolerance for same line
            return y1 > y2 ? NSOrderedAscending : NSOrderedDescending;
        }
        
        // Same line, sort by horizontal position (left to right)
        CGFloat x1 = CGRectGetMinX(obj1.bounds);
        CGFloat x2 = CGRectGetMinX(obj2.bounds);
        
        return x1 < x2 ? NSOrderedAscending : NSOrderedDescending;
    }];
}

@end
</file>

<file path="pdf22md-objc/src/Models/PDF22MDContentElement.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

/**
 * Protocol defining the interface for all content elements extracted from a PDF.
 * This includes text elements, image elements, and potentially other content types.
 */
@protocol PDF22MDContentElement <NSObject>

@required
/**
 * The bounding rectangle of this element in PDF coordinate space.
 */
@property (nonatomic, readonly) CGRect bounds;

/**
 * The zero-based index of the page this element was extracted from.
 */
@property (nonatomic, readonly) NSInteger pageIndex;

/**
 * Generates the Markdown representation of this element.
 * @return A string containing the Markdown formatted content, or nil if the element has no valid representation.
 */
- (nullable NSString *)markdownRepresentation;

@optional
/**
 * Additional metadata associated with this element.
 * The dictionary keys and values are element-type specific.
 */
- (NSDictionary<NSString *, id> *)metadata;

/**
 * The original extraction context for debugging purposes.
 */
- (NSString *)debugDescription;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/Models/PDF22MDImageElement.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>
#import "PDF22MDContentElement.h"

NS_ASSUME_NONNULL_BEGIN

/**
 * Represents an image element extracted from a PDF page.
 * Handles both raster and vector graphics.
 */
@interface PDF22MDImageElement : NSObject <PDF22MDContentElement>

/**
 * The extracted image. Ownership is transferred to this object.
 */
@property (nonatomic, readonly) CGImageRef image;

/**
 * The bounding rectangle of this image in the PDF.
 */
@property (nonatomic, assign, readonly) CGRect bounds;

/**
 * The page index where this image was found.
 */
@property (nonatomic, assign, readonly) NSInteger pageIndex;

/**
 * Indicates whether this image was originally vector graphics.
 */
@property (nonatomic, assign, readonly) BOOL isVectorSource;

/**
 * The relative path to the saved asset file, if any.
 * This is set after the image has been extracted and saved.
 */
@property (nonatomic, copy, nullable) NSString *assetRelativePath;

/**
 * Designated initializer for creating an image element.
 *
 * @param image The CGImage (ownership is transferred)
 * @param bounds The bounding rectangle
 * @param pageIndex The page index
 * @param isVectorSource Whether this was originally vector graphics
 * @return A new image element instance
 */
- (instancetype)initWithImage:(CGImageRef)image
                       bounds:(CGRect)bounds
                    pageIndex:(NSInteger)pageIndex
               isVectorSource:(BOOL)isVectorSource NS_DESIGNATED_INITIALIZER;

- (instancetype)init NS_UNAVAILABLE;

/**
 * Analyzes the image to determine if JPEG compression would be suitable.
 * @return YES if JPEG is recommended, NO for PNG
 */
- (BOOL)shouldUseJPEGCompression;

/**
 * Gets the dimensions of the image.
 * @return The size in pixels
 */
- (CGSize)imageDimensions;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/Models/PDF22MDImageElement.m">
#import "PDF22MDImageElement.h"

@implementation PDF22MDImageElement

#pragma mark - Initialization

- (instancetype)initWithImage:(CGImageRef)image
                       bounds:(CGRect)bounds
                    pageIndex:(NSInteger)pageIndex
               isVectorSource:(BOOL)isVectorSource {
    self = [super init];
    if (self) {
        _image = CGImageRetain(image);
        _bounds = bounds;
        _pageIndex = pageIndex;
        _isVectorSource = isVectorSource;
    }
    return self;
}

- (void)dealloc {
    if (_image) {
        CGImageRelease(_image);
    }
}

#pragma mark - PDF22MDContentElement Protocol

- (nullable NSString *)markdownRepresentation {
    if (!self.assetRelativePath) {
        return @"![Image](image-not-saved)";
    }
    
    return [NSString stringWithFormat:@"![Image](%@)", self.assetRelativePath];
}

- (NSDictionary<NSString *, id> *)metadata {
    CGSize dimensions = [self imageDimensions];
    
    return @{
        @"width": @(dimensions.width),
        @"height": @(dimensions.height),
        @"isVectorSource": @(self.isVectorSource),
        @"hasAlpha": @([self imageHasAlpha]),
        @"shouldUseJPEG": @([self shouldUseJPEGCompression])
    };
}

#pragma mark - Public Methods

- (CGSize)imageDimensions {
    if (!self.image) {
        return CGSizeZero;
    }
    
    return CGSizeMake(CGImageGetWidth(self.image), CGImageGetHeight(self.image));
}

- (BOOL)shouldUseJPEGCompression {
    if (!self.image) {
        return NO;
    }
    
    // If image has alpha channel, use PNG
    if ([self imageHasAlpha]) {
        return NO;
    }
    
    // For small images, use PNG
    CGSize dimensions = [self imageDimensions];
    if (dimensions.width * dimensions.height < 10000) { // Less than 100x100
        return NO;
    }
    
    // For vector sources, prefer PNG to maintain quality
    if (self.isVectorSource) {
        return NO;
    }
    
    // Analyze color complexity
    NSUInteger uniqueColors = [self estimateUniqueColorCount];
    
    // If we have many unique colors, it's likely a photograph - use JPEG
    return uniqueColors > 256;
}

#pragma mark - Private Methods

- (BOOL)imageHasAlpha {
    if (!self.image) {
        return NO;
    }
    
    CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(self.image);
    
    return alphaInfo != kCGImageAlphaNone &&
           alphaInfo != kCGImageAlphaNoneSkipFirst &&
           alphaInfo != kCGImageAlphaNoneSkipLast;
}

- (NSUInteger)estimateUniqueColorCount {
    if (!self.image) {
        return 0;
    }
    
    size_t width = CGImageGetWidth(self.image);
    size_t height = CGImageGetHeight(self.image);
    
    // Sample a subset of pixels for performance
    size_t sampleWidth = MIN(width, 100);
    size_t sampleHeight = MIN(height, 100);
    size_t __unused stepX = MAX(1, width / sampleWidth);
    size_t __unused stepY = MAX(1, height / sampleHeight);
    
    // Create a small bitmap context for sampling
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    size_t bytesPerRow = sampleWidth * 4;
    unsigned char *pixelData = calloc(sampleHeight * bytesPerRow, sizeof(unsigned char));
    
    if (!pixelData) {
        CGColorSpaceRelease(colorSpace);
        return 256; // Default to medium complexity
    }
    
    CGContextRef context = CGBitmapContextCreate(pixelData, sampleWidth, sampleHeight, 8, bytesPerRow, colorSpace,
                                                kCGImageAlphaNoneSkipLast | kCGBitmapByteOrder32Big);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        free(pixelData);
        return 256;
    }
    
    // Draw scaled image
    CGContextDrawImage(context, CGRectMake(0, 0, sampleWidth, sampleHeight), self.image);
    CGContextRelease(context);
    
    // Count unique colors
    NSMutableSet *uniqueColors = [NSMutableSet set];
    
    for (size_t y = 0; y < sampleHeight; y++) {
        for (size_t x = 0; x < sampleWidth; x++) {
            size_t offset = (y * bytesPerRow) + (x * 4);
            uint32_t color = (pixelData[offset] << 24) | 
                           (pixelData[offset + 1] << 16) | 
                           (pixelData[offset + 2] << 8) | 
                           pixelData[offset + 3];
            [uniqueColors addObject:@(color)];
            
            // Early exit if we already have many colors
            if (uniqueColors.count > 1000) {
                free(pixelData);
                return uniqueColors.count;
            }
        }
    }
    
    free(pixelData);
    return uniqueColors.count;
}

#pragma mark - NSObject

- (NSString *)description {
    CGSize dimensions = [self imageDimensions];
    return [NSString stringWithFormat:@"<%@: %p, size=%.0fx%.0f, bounds=%@, page=%ld>",
            NSStringFromClass([self class]),
            self,
            dimensions.width,
            dimensions.height,
            [NSString stringWithFormat:@"{{%.1f,%.1f},{%.1f,%.1f}}", self.bounds.origin.x, self.bounds.origin.y, self.bounds.size.width, self.bounds.size.height],
            (long)self.pageIndex];
}

- (NSString *)debugDescription {
    CGSize dimensions = [self imageDimensions];
    return [NSString stringWithFormat:@"<%@: %p> {\n  dimensions: %.0fx%.0f\n  bounds: %@\n  page: %ld\n  vector: %@\n  alpha: %@\n  path: %@\n}",
            NSStringFromClass([self class]),
            self,
            dimensions.width,
            dimensions.height,
            [NSString stringWithFormat:@"{{%.1f,%.1f},{%.1f,%.1f}}", self.bounds.origin.x, self.bounds.origin.y, self.bounds.size.width, self.bounds.size.height],
            (long)self.pageIndex,
            self.isVectorSource ? @"YES" : @"NO",
            [self imageHasAlpha] ? @"YES" : @"NO",
            self.assetRelativePath ?: @"<not saved>"];
}

- (BOOL)isEqual:(id)object {
    if (self == object) {
        return YES;
    }
    
    if (![object isKindOfClass:[PDF22MDImageElement class]]) {
        return NO;
    }
    
    PDF22MDImageElement *other = (PDF22MDImageElement *)object;
    
    return CGRectEqualToRect(self.bounds, other.bounds) &&
           self.pageIndex == other.pageIndex &&
           self.isVectorSource == other.isVectorSource &&
           (self.assetRelativePath == other.assetRelativePath || 
            [self.assetRelativePath isEqualToString:other.assetRelativePath]);
}

- (NSUInteger)hash {
    NSUInteger prime = 31;
    NSUInteger result = 1;
    
    result = prime * result + (NSUInteger)(self.bounds.origin.x + self.bounds.origin.y + self.bounds.size.width + self.bounds.size.height);
    result = prime * result + self.pageIndex;
    result = prime * result + (self.isVectorSource ? 1 : 0);
    result = prime * result + [self.assetRelativePath hash];
    
    return result;
}

@end
</file>

<file path="pdf22md-objc/src/Models/PDF22MDTextElement.h">
#import <Foundation/Foundation.h>
#import "PDF22MDContentElement.h"

NS_ASSUME_NONNULL_BEGIN

/**
 * Represents a text element extracted from a PDF page.
 * Includes text content and associated styling information.
 */
@interface PDF22MDTextElement : NSObject <PDF22MDContentElement>

/**
 * The extracted text content. Never nil, but may be empty.
 */
@property (nonatomic, copy, readonly) NSString *text;

/**
 * The bounding rectangle of this text element.
 */
@property (nonatomic, assign, readonly) CGRect bounds;

/**
 * The page index where this text was found.
 */
@property (nonatomic, assign, readonly) NSInteger pageIndex;

/**
 * The font name used for this text, if available.
 */
@property (nonatomic, copy, nullable, readonly) NSString *fontName;

/**
 * The font size in points.
 */
@property (nonatomic, assign, readonly) CGFloat fontSize;

/**
 * Indicates if the text appears to be bold.
 */
@property (nonatomic, assign, readonly) BOOL isBold;

/**
 * Indicates if the text appears to be italic.
 */
@property (nonatomic, assign, readonly) BOOL isItalic;

/**
 * The detected heading level (0 for body text, 1-6 for headings).
 */
@property (nonatomic, assign) NSInteger headingLevel;

/**
 * Designated initializer for creating a text element.
 *
 * @param text The text content (required)
 * @param bounds The bounding rectangle
 * @param pageIndex The page index
 * @return A new text element instance
 */
- (instancetype)initWithText:(NSString *)text
                      bounds:(CGRect)bounds
                   pageIndex:(NSInteger)pageIndex;

/**
 * Convenience initializer with full styling information.
 *
 * @param text The text content
 * @param bounds The bounding rectangle
 * @param pageIndex The page index
 * @param fontName The font name (optional)
 * @param fontSize The font size
 * @param isBold Bold style flag
 * @param isItalic Italic style flag
 * @return A new text element instance
 */
- (instancetype)initWithText:(NSString *)text
                      bounds:(CGRect)bounds
                   pageIndex:(NSInteger)pageIndex
                    fontName:(nullable NSString *)fontName
                    fontSize:(CGFloat)fontSize
                      isBold:(BOOL)isBold
                    isItalic:(BOOL)isItalic NS_DESIGNATED_INITIALIZER;

- (instancetype)init NS_UNAVAILABLE;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/Models/PDF22MDTextElement.m">
#import "PDF22MDTextElement.h"

@implementation PDF22MDTextElement

#pragma mark - Initialization

- (instancetype)initWithText:(NSString *)text
                      bounds:(CGRect)bounds
                   pageIndex:(NSInteger)pageIndex {
    return [self initWithText:text
                       bounds:bounds
                    pageIndex:pageIndex
                     fontName:nil
                     fontSize:12.0
                       isBold:NO
                     isItalic:NO];
}

- (instancetype)initWithText:(NSString *)text
                      bounds:(CGRect)bounds
                   pageIndex:(NSInteger)pageIndex
                    fontName:(nullable NSString *)fontName
                    fontSize:(CGFloat)fontSize
                      isBold:(BOOL)isBold
                    isItalic:(BOOL)isItalic {
    self = [super init];
    if (self) {
        _text = [text copy];
        _bounds = bounds;
        _pageIndex = pageIndex;
        _fontName = [fontName copy];
        _fontSize = fontSize;
        _isBold = isBold;
        _isItalic = isItalic;
        _headingLevel = 0; // Default to body text
    }
    return self;
}

#pragma mark - PDF22MDContentElement Protocol

- (nullable NSString *)markdownRepresentation {
    if (!self.text || self.text.length == 0) {
        return nil;
    }
    
    NSString *trimmedText = [self.text stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    if (trimmedText.length == 0) {
        return nil;
    }
    
    // Apply heading formatting
    if (self.headingLevel > 0 && self.headingLevel <= 6) {
        NSMutableString *heading = [NSMutableString string];
        for (NSInteger i = 0; i < self.headingLevel; i++) {
            [heading appendString:@"#"];
        }
        [heading appendString:@" "];
        [heading appendString:trimmedText];
        return heading;
    }
    
    // Apply bold/italic formatting
    NSString *formattedText = trimmedText;
    
    if (self.isBold && self.isItalic) {
        formattedText = [NSString stringWithFormat:@"***%@***", formattedText];
    } else if (self.isBold) {
        formattedText = [NSString stringWithFormat:@"**%@**", formattedText];
    } else if (self.isItalic) {
        formattedText = [NSString stringWithFormat:@"*%@*", formattedText];
    }
    
    return formattedText;
}

- (NSDictionary<NSString *, id> *)metadata {
    NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
    
    if (self.fontName) {
        metadata[@"fontName"] = self.fontName;
    }
    metadata[@"fontSize"] = @(self.fontSize);
    metadata[@"isBold"] = @(self.isBold);
    metadata[@"isItalic"] = @(self.isItalic);
    metadata[@"headingLevel"] = @(self.headingLevel);
    
    return [metadata copy];
}

#pragma mark - NSObject

- (NSString *)description {
    return [NSString stringWithFormat:@"<%@: %p, text='%@', bounds=%@, page=%ld>",
            NSStringFromClass([self class]),
            self,
            [self.text length] > 50 ? [[self.text substringToIndex:50] stringByAppendingString:@"..."] : self.text,
            [NSString stringWithFormat:@"{{%.1f,%.1f},{%.1f,%.1f}}", self.bounds.origin.x, self.bounds.origin.y, self.bounds.size.width, self.bounds.size.height],
            (long)self.pageIndex];
}

- (NSString *)debugDescription {
    return [NSString stringWithFormat:@"<%@: %p> {\n  text: '%@'\n  bounds: %@\n  page: %ld\n  font: %@\n  size: %.1f\n  bold: %@\n  italic: %@\n  heading: %ld\n}",
            NSStringFromClass([self class]),
            self,
            self.text,
            [NSString stringWithFormat:@"{{%.1f,%.1f},{%.1f,%.1f}}", self.bounds.origin.x, self.bounds.origin.y, self.bounds.size.width, self.bounds.size.height],
            (long)self.pageIndex,
            self.fontName ?: @"<unknown>",
            self.fontSize,
            self.isBold ? @"YES" : @"NO",
            self.isItalic ? @"YES" : @"NO",
            (long)self.headingLevel];
}

- (BOOL)isEqual:(id)object {
    if (self == object) {
        return YES;
    }
    
    if (![object isKindOfClass:[PDF22MDTextElement class]]) {
        return NO;
    }
    
    PDF22MDTextElement *other = (PDF22MDTextElement *)object;
    
    return [self.text isEqualToString:other.text] &&
           CGRectEqualToRect(self.bounds, other.bounds) &&
           self.pageIndex == other.pageIndex &&
           (self.fontName == other.fontName || [self.fontName isEqualToString:other.fontName]) &&
           self.fontSize == other.fontSize &&
           self.isBold == other.isBold &&
           self.isItalic == other.isItalic &&
           self.headingLevel == other.headingLevel;
}

- (NSUInteger)hash {
    NSUInteger prime = 31;
    NSUInteger result = 1;
    
    result = prime * result + [self.text hash];
    result = prime * result + (NSUInteger)(self.bounds.origin.x + self.bounds.origin.y + self.bounds.size.width + self.bounds.size.height);
    result = prime * result + self.pageIndex;
    result = prime * result + [self.fontName hash];
    result = prime * result + (NSUInteger)self.fontSize;
    result = prime * result + (self.isBold ? 1 : 0);
    result = prime * result + (self.isItalic ? 1 : 0);
    result = prime * result + self.headingLevel;
    
    return result;
}

@end
</file>

<file path="pdf22md-objc/src/Services/PDF22MDAssetManager.h">
#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>

NS_ASSUME_NONNULL_BEGIN

@class PDF22MDImageElement;

/**
 * Manages the extraction and saving of assets (images) from PDF documents.
 * Thread-safe for concurrent image saving operations.
 */
@interface PDF22MDAssetManager : NSObject

/**
 * The base folder path where assets will be saved.
 */
@property (nonatomic, copy, readonly) NSString *assetsFolderPath;

/**
 * Initializes the asset manager with a folder path.
 * Creates the folder if it doesn't exist.
 *
 * @param folderPath The path where assets will be saved
 * @return A new instance, or nil if folder creation fails
 */
- (nullable instancetype)initWithAssetFolder:(NSString *)folderPath NS_DESIGNATED_INITIALIZER;

- (instancetype)init NS_UNAVAILABLE;

/**
 * Saves an image to the assets folder with automatic format selection.
 *
 * @param image The CGImage to save
 * @param isVectorSource Whether this image originated from vector graphics
 * @param baseName The base filename (without extension)
 * @return The relative path to the saved file, or nil on failure
 */
- (nullable NSString *)saveImage:(CGImageRef)image
                  isVectorSource:(BOOL)isVectorSource
                    withBaseName:(NSString *)baseName;

/**
 * Saves an image element to the assets folder.
 * Updates the element's assetRelativePath property on success.
 *
 * @param imageElement The image element to save
 * @param baseName The base filename (without extension)
 * @return The relative path to the saved file, or nil on failure
 */
- (nullable NSString *)saveImageElement:(PDF22MDImageElement *)imageElement
                           withBaseName:(NSString *)baseName;

/**
 * Determines the optimal image format for the given image.
 *
 * @param image The image to analyze
 * @param isVectorSource Whether this originated from vector graphics
 * @return YES for JPEG, NO for PNG
 */
- (BOOL)shouldUseJPEGForImage:(CGImageRef)image
                isVectorSource:(BOOL)isVectorSource;

/**
 * Gets the next available filename for the given base name.
 * Handles conflicts by appending numbers.
 *
 * @param baseName The desired base filename
 * @param extension The file extension (without dot)
 * @return A unique filename
 */
- (NSString *)uniqueFilenameForBaseName:(NSString *)baseName
                          withExtension:(NSString *)extension;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/Services/PDF22MDAssetManager.m">
#import "PDF22MDAssetManager.h"
#import "../Models/PDF22MDImageElement.h"
#import <ImageIO/ImageIO.h>

@interface PDF22MDAssetManager ()
@property (nonatomic, strong) NSFileManager *fileManager;
@property (nonatomic, strong) dispatch_queue_t fileAccessQueue;
@property (nonatomic, strong) NSMutableSet<NSString *> *usedFilenames;
@end

@implementation PDF22MDAssetManager

#pragma mark - Initialization

- (nullable instancetype)initWithAssetFolder:(NSString *)folderPath {
    self = [super init];
    if (self) {
        _assetsFolderPath = [folderPath copy];
        _fileManager = [[NSFileManager alloc] init];
        _fileAccessQueue = dispatch_queue_create("com.twardoch.pdf22md.assetmanager", DISPATCH_QUEUE_SERIAL);
        _usedFilenames = [NSMutableSet set];
        
        // Create assets folder if it doesn't exist
        NSError *error = nil;
        BOOL isDirectory = NO;
        BOOL exists = [_fileManager fileExistsAtPath:folderPath isDirectory:&isDirectory];
        
        if (exists && !isDirectory) {
            NSLog(@"Asset path exists but is not a directory: %@", folderPath);
            return nil;
        }
        
        if (!exists) {
            if (![_fileManager createDirectoryAtPath:folderPath
                         withIntermediateDirectories:YES
                                          attributes:nil
                                               error:&error]) {
                NSLog(@"Failed to create assets folder: %@", error);
                return nil;
            }
        }
    }
    return self;
}

#pragma mark - Public Methods

- (nullable NSString *)saveImage:(CGImageRef)image
                  isVectorSource:(BOOL)isVectorSource
                    withBaseName:(NSString *)baseName {
    if (!image) {
        return nil;
    }
    
    // Determine optimal format
    BOOL shouldUseJPEG = [self shouldUseJPEGForImage:image isVectorSource:isVectorSource];
    
    NSString *extension = shouldUseJPEG ? @"jpg" : @"png";
    NSString *fileName = [self uniqueFilenameForBaseName:baseName withExtension:extension];
    NSString *fullPath = [self.assetsFolderPath stringByAppendingPathComponent:fileName];
    
    // Create destination
    NSURL *fileURL = [NSURL fileURLWithPath:fullPath];
    CGImageDestinationRef destination = CGImageDestinationCreateWithURL(
        (__bridge CFURLRef)fileURL,
        shouldUseJPEG ? (__bridge CFStringRef)@"public.jpeg" : (__bridge CFStringRef)@"public.png",
        1,
        NULL
    );
    
    if (!destination) {
        NSLog(@"Failed to create image destination for %@", fullPath);
        return nil;
    }
    
    // Set compression options
    NSDictionary *properties = nil;
    if (shouldUseJPEG) {
        properties = @{(__bridge NSString *)kCGImageDestinationLossyCompressionQuality: @(0.85)};
    } else {
        // For PNG, we can set compression level
        properties = @{(__bridge NSString *)kCGImagePropertyPNGCompressionFilter: @(1)}; // Best compression
    }
    
    // Add image to destination
    CGImageDestinationAddImage(destination, image, (__bridge CFDictionaryRef)properties);
    
    // Finalize
    BOOL success = CGImageDestinationFinalize(destination);
    CFRelease(destination);
    
    if (!success) {
        NSLog(@"Failed to save image to %@", fullPath);
        return nil;
    }
    
    // Return relative path (just the filename since it's in the assets folder)
    return fileName;
}

- (nullable NSString *)saveImageElement:(PDF22MDImageElement *)imageElement
                           withBaseName:(NSString *)baseName {
    NSString *savedPath = [self saveImage:imageElement.image
                           isVectorSource:imageElement.isVectorSource
                             withBaseName:baseName];
    
    if (savedPath) {
        imageElement.assetRelativePath = savedPath;
    }
    
    return savedPath;
}

- (BOOL)shouldUseJPEGForImage:(CGImageRef)image
                isVectorSource:(BOOL)isVectorSource {
    if (!image) {
        return NO;
    }
    
    // Get image properties
    size_t width = CGImageGetWidth(image);
    size_t height = CGImageGetHeight(image);
    CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(image);
    
    // If image has alpha channel, use PNG
    if (alphaInfo != kCGImageAlphaNone &&
        alphaInfo != kCGImageAlphaNoneSkipFirst &&
        alphaInfo != kCGImageAlphaNoneSkipLast) {
        return NO;
    }
    
    // For small images, use PNG
    if (width * height < 10000) { // Less than 100x100
        return NO;
    }
    
    // For vector sources, prefer PNG to maintain quality
    if (isVectorSource) {
        return NO;
    }
    
    // Analyze color complexity
    NSUInteger uniqueColors = [self estimateUniqueColorCountForImage:image];
    
    // If we have many unique colors, it's likely a photograph - use JPEG
    return uniqueColors > 256;
}

- (NSString *)uniqueFilenameForBaseName:(NSString *)baseName
                          withExtension:(NSString *)extension {
    __block NSString *filename = nil;
    
    dispatch_sync(self.fileAccessQueue, ^{
        NSString *candidate = [NSString stringWithFormat:@"%@.%@", baseName, extension];
        NSInteger counter = 1;
        
        // Check if filename is already used
        while ([self.usedFilenames containsObject:candidate] ||
               [self.fileManager fileExistsAtPath:[self.assetsFolderPath stringByAppendingPathComponent:candidate]]) {
            candidate = [NSString stringWithFormat:@"%@_%03ld.%@", baseName, (long)counter, extension];
            counter++;
        }
        
        [self.usedFilenames addObject:candidate];
        filename = candidate;
    });
    
    return filename;
}

#pragma mark - Private Methods

- (NSUInteger)estimateUniqueColorCountForImage:(CGImageRef)image {
    size_t width = CGImageGetWidth(image);
    size_t height = CGImageGetHeight(image);
    
    // Sample a subset of pixels for performance
    size_t __unused sampleSize = MIN(width * height, 10000);
    size_t stepX = MAX(1, width / 100);
    size_t stepY = MAX(1, height / 100);
    
    // Create a small bitmap context for sampling
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    size_t bytesPerRow = 4; // Single pixel
    unsigned char *pixelData = calloc(4, sizeof(unsigned char));
    
    if (!pixelData) {
        CGColorSpaceRelease(colorSpace);
        return 256; // Default to medium complexity
    }
    
    CGContextRef context = CGBitmapContextCreate(pixelData, 1, 1, 8, bytesPerRow, colorSpace,
                                                kCGImageAlphaNoneSkipLast | kCGBitmapByteOrder32Big);
    CGColorSpaceRelease(colorSpace);
    
    if (!context) {
        free(pixelData);
        return 256;
    }
    
    // Count unique colors by sampling
    NSMutableSet *uniqueColors = [NSMutableSet set];
    
    for (size_t y = 0; y < height; y += stepY) {
        for (size_t x = 0; x < width; x += stepX) {
            // Draw a single pixel
            CGRect __unused sourceRect = CGRectMake(x, y, 1, 1);
            CGContextClearRect(context, CGRectMake(0, 0, 1, 1));
            CGContextDrawImage(context, CGRectMake(-x, -y, width, height), image);
            
            uint32_t color = (pixelData[0] << 24) | (pixelData[1] << 16) | 
                           (pixelData[2] << 8) | pixelData[3];
            [uniqueColors addObject:@(color)];
            
            // Early exit if we already have many colors
            if (uniqueColors.count > 1000) {
                break;
            }
        }
        
        if (uniqueColors.count > 1000) {
            break;
        }
    }
    
    CGContextRelease(context);
    free(pixelData);
    
    return uniqueColors.count;
}

@end
</file>

<file path="pdf22md-objc/src/Services/PDF22MDMarkdownGenerator.h">
#import <Foundation/Foundation.h>
#import <PDFKit/PDFKit.h>

NS_ASSUME_NONNULL_BEGIN

@protocol PDF22MDContentElement;
@class PDF22MDConversionOptions;

/**
 * Metadata structure for YAML frontmatter generation.
 */
@interface PDF22MDDocumentMetadata : NSObject
@property (nonatomic, copy, nullable) NSString *title;
@property (nonatomic, copy, nullable) NSString *author;
@property (nonatomic, copy, nullable) NSString *subject;
@property (nonatomic, copy, nullable) NSArray<NSString *> *keywords;
@property (nonatomic, copy, nullable) NSString *creator;
@property (nonatomic, copy, nullable) NSString *producer;
@property (nonatomic, strong, nullable) NSDate *creationDate;
@property (nonatomic, strong, nullable) NSDate *modificationDate;
@property (nonatomic, assign) NSInteger pageCount;
@property (nonatomic, copy, nullable) NSString *pdfVersion;
@property (nonatomic, strong, nullable) PDFOutline *outline;
@end

/**
 * Generates Markdown output from PDF content elements.
 */
@interface PDF22MDMarkdownGenerator : NSObject

/**
 * Conversion options affecting markdown generation.
 */
@property (nonatomic, strong, readonly) PDF22MDConversionOptions *options;

/**
 * Initializes the generator with conversion options.
 *
 * @param options The conversion options to use
 * @return A new generator instance
 */
- (instancetype)initWithOptions:(PDF22MDConversionOptions *)options NS_DESIGNATED_INITIALIZER;

- (instancetype)init NS_UNAVAILABLE;

/**
 * Generates a complete markdown document from content elements.
 *
 * @param elements Array of content elements in reading order
 * @param metadata Document metadata for frontmatter
 * @return The generated markdown string
 */
- (NSString *)generateMarkdownFromElements:(NSArray<id<PDF22MDContentElement>> *)elements
                              withMetadata:(nullable PDF22MDDocumentMetadata *)metadata;

/**
 * Generates YAML frontmatter from document metadata.
 *
 * @param metadata The document metadata
 * @return YAML frontmatter string, or nil if includeMetadata is NO
 */
- (nullable NSString *)generateYAMLFrontmatter:(PDF22MDDocumentMetadata *)metadata;

/**
 * Generates markdown content from elements without frontmatter.
 *
 * @param elements Array of content elements
 * @return The markdown content
 */
- (NSString *)generateMarkdownContent:(NSArray<id<PDF22MDContentElement>> *)elements;

/**
 * Extracts metadata from a PDF document.
 *
 * @param document The PDF document
 * @return Populated metadata object
 */
+ (PDF22MDDocumentMetadata *)extractMetadataFromDocument:(PDFDocument *)document;

/**
 * Escapes a string for safe inclusion in YAML.
 *
 * @param string The string to escape
 * @return The escaped string
 */
+ (NSString *)escapeYAMLString:(NSString *)string;

@end

NS_ASSUME_NONNULL_END
</file>

<file path="pdf22md-objc/src/Services/PDF22MDMarkdownGenerator.m">
#import "PDF22MDMarkdownGenerator.h"
#import "../Core/PDF22MDConversionOptions.h"
#import "../Models/PDF22MDContentElement.h"
#import "../Models/PDF22MDTextElement.h"

// Version string - should match the compiled version
#ifndef PDF22MD_VERSION
#define PDF22MD_VERSION "1.0.0"
#endif

@implementation PDF22MDDocumentMetadata
@end

@implementation PDF22MDMarkdownGenerator

#pragma mark - Initialization

- (instancetype)initWithOptions:(PDF22MDConversionOptions *)options {
    self = [super init];
    if (self) {
        _options = options;
    }
    return self;
}

#pragma mark - Public Methods

- (NSString *)generateMarkdownFromElements:(NSArray<id<PDF22MDContentElement>> *)elements
                              withMetadata:(nullable PDF22MDDocumentMetadata *)metadata {
    NSMutableString *markdown = [NSMutableString string];
    
    // Add YAML frontmatter if enabled
    if (self.options.includeMetadata && metadata) {
        NSString *frontmatter = [self generateYAMLFrontmatter:metadata];
        if (frontmatter) {
            [markdown appendString:frontmatter];
            [markdown appendString:@"\n"];
        }
    }
    
    // Generate content
    NSString *content = [self generateMarkdownContent:elements];
    [markdown appendString:content];
    
    // Clean up extra newlines
    NSString *finalMarkdown = [markdown stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    
    return finalMarkdown;
}

- (nullable NSString *)generateYAMLFrontmatter:(PDF22MDDocumentMetadata *)metadata {
    if (!self.options.includeMetadata) {
        return nil;
    }
    
    NSMutableString *yaml = [NSMutableString string];
    [yaml appendString:@"---\n"];
    
    // Basic metadata
    if (metadata.title && metadata.title.length > 0) {
        [yaml appendFormat:@"title: \"%@\"\n", [[self class] escapeYAMLString:metadata.title]];
    }
    
    if (metadata.author && metadata.author.length > 0) {
        [yaml appendFormat:@"author: \"%@\"\n", [[self class] escapeYAMLString:metadata.author]];
    }
    
    if (metadata.subject && metadata.subject.length > 0) {
        [yaml appendFormat:@"subject: \"%@\"\n", [[self class] escapeYAMLString:metadata.subject]];
    }
    
    // Keywords
    if (metadata.keywords && metadata.keywords.count > 0) {
        [yaml appendString:@"keywords:\n"];
        for (NSString *keyword in metadata.keywords) {
            [yaml appendFormat:@"  - \"%@\"\n", [[self class] escapeYAMLString:keyword]];
        }
    }
    
    // Creator and producer
    if (metadata.creator && metadata.creator.length > 0) {
        [yaml appendFormat:@"creator: \"%@\"\n", [[self class] escapeYAMLString:metadata.creator]];
    }
    
    if (metadata.producer && metadata.producer.length > 0) {
        [yaml appendFormat:@"producer: \"%@\"\n", [[self class] escapeYAMLString:metadata.producer]];
    }
    
    // Dates
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateFormat:@"yyyy-MM-dd'T'HH:mm:ssZZZZZ"];
    [formatter setLocale:[NSLocale localeWithLocaleIdentifier:@"en_US_POSIX"]];
    
    if (metadata.creationDate) {
        [yaml appendFormat:@"created: %@\n", [formatter stringFromDate:metadata.creationDate]];
    }
    
    if (metadata.modificationDate) {
        [yaml appendFormat:@"modified: %@\n", [formatter stringFromDate:metadata.modificationDate]];
    }
    
    // PDF specific metadata
    [yaml appendString:@"pdf_metadata:\n"];
    [yaml appendFormat:@"  page_count: %ld\n", (long)metadata.pageCount];
    
    if (metadata.pdfVersion && metadata.pdfVersion.length > 0) {
        [yaml appendFormat:@"  version: \"%@\"\n", metadata.pdfVersion];
    }
    
    // Outline/bookmarks
    if (self.options.preserveOutline && metadata.outline && [metadata.outline numberOfChildren] > 0) {
        [yaml appendString:@"  outline:\n"];
        [self appendOutlineToYAML:yaml outline:metadata.outline indent:@"    "];
    }
    
    // Conversion metadata
    [yaml appendString:@"conversion:\n"];
    [yaml appendString:@"  tool: \"pdf22md\"\n"];
    [yaml appendFormat:@"  version: \"%s\"\n", PDF22MD_VERSION];
    [yaml appendFormat:@"  date: %@\n", [formatter stringFromDate:[NSDate date]]];
    
    [yaml appendString:@"---\n"];
    
    return yaml;
}

- (NSString *)generateMarkdownContent:(NSArray<id<PDF22MDContentElement>> *)elements {
    NSMutableString *content = [NSMutableString string];
    
    id<PDF22MDContentElement> previousElement = nil;
    
    for (id<PDF22MDContentElement> element in elements) {
        NSString *elementMarkdown = [element markdownRepresentation];
        
        if (elementMarkdown && elementMarkdown.length > 0) {
            // Add appropriate spacing between elements
            if (previousElement) {
                // Check if we need extra spacing (e.g., between paragraphs)
                if ([self shouldAddExtraSpacingBetween:previousElement and:element]) {
                    [content appendString:@"\n\n"];
                } else {
                    [content appendString:@"\n"];
                }
            }
            
            [content appendString:elementMarkdown];
            previousElement = element;
        }
    }
    
    return content;
}

+ (PDF22MDDocumentMetadata *)extractMetadataFromDocument:(PDFDocument *)document {
    PDF22MDDocumentMetadata *metadata = [[PDF22MDDocumentMetadata alloc] init];
    
    // Get document attributes
    NSDictionary *attributes = [document documentAttributes];
    
    metadata.title = attributes[PDFDocumentTitleAttribute];
    metadata.author = attributes[PDFDocumentAuthorAttribute];
    metadata.subject = attributes[PDFDocumentSubjectAttribute];
    metadata.keywords = attributes[PDFDocumentKeywordsAttribute];
    metadata.creator = attributes[PDFDocumentCreatorAttribute];
    metadata.producer = attributes[PDFDocumentProducerAttribute];
    metadata.creationDate = attributes[PDFDocumentCreationDateAttribute];
    metadata.modificationDate = attributes[PDFDocumentModificationDateAttribute];
    
    metadata.pageCount = [document pageCount];
    metadata.outline = [document outlineRoot];
    
    // Try to extract PDF version
    metadata.pdfVersion = [self extractPDFVersionFromAttributes:attributes];
    
    return metadata;
}

+ (NSString *)escapeYAMLString:(NSString *)string {
    // Escape quotes and backslashes for YAML
    NSString *escaped = [string stringByReplacingOccurrencesOfString:@"\\" withString:@"\\\\"];
    escaped = [escaped stringByReplacingOccurrencesOfString:@"\"" withString:@"\\\""];
    escaped = [escaped stringByReplacingOccurrencesOfString:@"\n" withString:@"\\n"];
    escaped = [escaped stringByReplacingOccurrencesOfString:@"\r" withString:@"\\r"];
    escaped = [escaped stringByReplacingOccurrencesOfString:@"\t" withString:@"\\t"];
    return escaped;
}

#pragma mark - Private Methods

- (void)appendOutlineToYAML:(NSMutableString *)yaml outline:(PDFOutline *)outline indent:(NSString *)indent {
    for (NSUInteger i = 0; i < [outline numberOfChildren]; i++) {
        PDFOutline *child = [outline childAtIndex:i];
        NSString *label = [child label];
        
        if (label && label.length > 0) {
            [yaml appendFormat:@"%@- title: \"%@\"\n", indent, [[self class] escapeYAMLString:label]];
            
            PDFDestination *destination = [child destination];
            if (destination) {
                PDFPage *page = [destination page];
                if (page) {
                    // Note: We need the document to get page index, so this is an approximation
                    [yaml appendFormat:@"%@  page: %ld\n", indent, (long)1];
                }
            }
            
            if ([child numberOfChildren] > 0) {
                [yaml appendFormat:@"%@  children:\n", indent];
                NSString *newIndent = [indent stringByAppendingString:@"    "];
                [self appendOutlineToYAML:yaml outline:child indent:newIndent];
            }
        }
    }
}

+ (NSString *)extractPDFVersionFromAttributes:(NSDictionary *)attributes {
    // Look for PDF version in various attribute keys
    for (NSString *key in attributes) {
        id value = attributes[key];
        if ([value isKindOfClass:[NSString class]]) {
            NSString *stringValue = (NSString *)value;
            
            // Look for PDF version patterns
            NSRange pdfRange = [stringValue rangeOfString:@"PDF-" options:NSCaseInsensitiveSearch];
            if (pdfRange.location != NSNotFound) {
                // Extract version number after "PDF-"
                NSString *versionPart = [stringValue substringFromIndex:pdfRange.location];
                NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"PDF-?(\\d+\\.\\d+)"
                                                                                       options:NSRegularExpressionCaseInsensitive
                                                                                         error:nil];
                NSTextCheckingResult *match = [regex firstMatchInString:versionPart
                                                               options:0
                                                                 range:NSMakeRange(0, versionPart.length)];
                if (match && match.numberOfRanges > 1) {
                    return [versionPart substringWithRange:[match rangeAtIndex:1]];
                }
            }
        }
    }
    
    return nil;
}

- (BOOL)shouldAddExtraSpacingBetween:(id<PDF22MDContentElement>)element1 
                                 and:(id<PDF22MDContentElement>)element2 {
    // Add extra spacing between different element types
    if ([element1 class] != [element2 class]) {
        return YES;
    }
    
    // Add extra spacing after headings
    if ([element1 isKindOfClass:[PDF22MDTextElement class]]) {
        PDF22MDTextElement *textElement = (PDF22MDTextElement *)element1;
        if (textElement.headingLevel > 0) {
            return YES;
        }
    }
    
    // Add extra spacing between elements on different pages
    if (element1.pageIndex != element2.pageIndex) {
        return YES;
    }
    
    // Check vertical distance between elements
    CGFloat verticalDistance = fabs(CGRectGetMinY(element1.bounds) - CGRectGetMaxY(element2.bounds));
    if (verticalDistance > 20.0) { // Significant gap
        return YES;
    }
    
    return NO;
}

@end
</file>

<file path="pdf22md-objc/Makefile">
CC = clang
CFLAGS = -Wall -Wextra -O2 -fobjc-arc
FRAMEWORKS = -framework Foundation -framework PDFKit -framework CoreGraphics -framework ImageIO -framework CoreServices
TARGET = pdf22md

# Version from git tag or fallback
VERSION ?= $(shell git describe --tags --always --dirty 2>/dev/null || echo "dev")

# Define directories
SRC_DIR = src
BUILD_DIR = build

# Source and object files - look in all subdirectories
SOURCES = $(wildcard $(SRC_DIR)/*/*.m $(SRC_DIR)/*/*/*.m)
OBJECTS = $(patsubst $(SRC_DIR)/%.m,$(BUILD_DIR)/%.o,$(SOURCES))

# Default prefix for installation
PREFIX ?= /usr/local

all: $(BUILD_DIR) $(TARGET)

$(BUILD_DIR):
	mkdir -p $(BUILD_DIR)

$(TARGET): $(OBJECTS)
	$(CC) $(CFLAGS) $(FRAMEWORKS) -o $(TARGET) $(OBJECTS)

$(BUILD_DIR)/%.o: $(SRC_DIR)/%.m | $(BUILD_DIR)
	@mkdir -p $(dir $@)
	$(CC) $(CFLAGS) -DVERSION=\"$(VERSION)\" -Isrc -c $< -o $@

clean:
	rm -rf $(BUILD_DIR) $(TARGET)

install: $(TARGET)
	install -d $(DESTDIR)$(PREFIX)/bin
	install -m 755 $(TARGET) $(DESTDIR)$(PREFIX)/bin/
	install -d $(DESTDIR)$(PREFIX)/share/man/man1
	install -m 644 docs/pdf22md.1 $(DESTDIR)$(PREFIX)/share/man/man1/

uninstall:
	rm -f $(DESTDIR)$(PREFIX)/bin/$(TARGET)
	rm -f $(DESTDIR)$(PREFIX)/share/man/man1/pdf22md.1

# Testing
test: $(BUILD_DIR)
	@echo "üß™ Running pdf22md test suite..."
	@./run-tests.sh

test-unit: $(BUILD_DIR)
	@echo "üî¨ Running unit tests..."
	@mkdir -p build/tests
	@for test in Tests/Unit/*.m; do \
		if [ -f "$$test" ]; then \
			echo "  Building $$test..."; \
			test_name=$$(basename "$$test" .m); \
			$(CC) $(CFLAGS) $(FRAMEWORKS) -Isrc \
				"$$test" src/Core/*.m src/Models/*.m src/Services/*.m \
				-o "build/tests/$$test_name" && \
			echo "  ‚úì Compiled $$test_name" || echo "  ‚úó Failed to compile $$test_name"; \
		fi; \
	done

test-integration: $(BUILD_DIR)
	@echo "üî¨ Running integration tests..."
	@mkdir -p build/tests
	@for test in Tests/Integration/*.m; do \
		if [ -f "$$test" ]; then \
			echo "  Building $$test..."; \
			test_name=$$(basename "$$test" .m); \
			$(CC) $(CFLAGS) $(FRAMEWORKS) -Isrc \
				"$$test" src/Core/*.m src/Models/*.m src/Services/*.m \
				-o "build/tests/$$test_name" && \
			echo "  ‚úì Compiled $$test_name" || echo "  ‚úó Failed to compile $$test_name"; \
		fi; \
	done

test-clean:
	@echo "üßπ Cleaning test artifacts..."
	@rm -rf build/tests Tests/Resources/*.pdf

# Benchmark and profiling
benchmark: $(TARGET)
	@echo "üìä Running performance benchmarks..."
	@echo "Creating benchmark test PDF..."
	@mkdir -p test/benchmark
	@echo "Benchmarking conversion speed..."
	@time ./$(TARGET) -i test/README.pdf -o test/benchmark/output.md -a test/benchmark/assets
	@echo "Benchmark complete. Check test/benchmark/ for results."

memory-check: $(TARGET)
	@echo "üîç Running memory leak detection..."
	@echo "Note: Install Xcode and run 'leaks' command manually for detailed analysis"
	@echo "Basic memory test with multiple conversions..."
	@for i in 1 2 3 4 5; do \
		echo "  Conversion $$i..."; \
		./$(TARGET) -i test/README.pdf -o /tmp/test_$$i.md; \
	done
	@echo "Memory test complete. Monitor Activity Monitor for memory usage."

.PHONY: all clean install uninstall test test-unit test-integration test-clean benchmark memory-check
</file>

<file path="pdf22md-objc/README.md">
# pdf22md - Modern Objective-C Implementation

A high-performance PDF to Markdown converter built with modern Objective-C patterns and best practices.

## Features

- **Modern Objective-C**: Uses nullability annotations, lightweight generics, and designated initializers
- **Thread-Safe**: Concurrent page processing with GCD and proper synchronization
- **Memory Efficient**: Automatic reference counting with strategic use of autorelease pools
- **Error Handling**: Comprehensive error reporting with custom error domain
- **Progress Tracking**: NSProgress integration for monitoring conversion status
- **Modular Architecture**: Clean separation of concerns with protocols and services

## Architecture

```
pdf22md-objc/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ Core/                    # Core conversion logic
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PDF22MDConverter     # Main coordinator
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PDF22MDPageProcessor # Page content extraction
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PDF22MDFontAnalyzer  # Heading detection
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ PDF22MDError         # Error handling
‚îÇ   ‚îú‚îÄ‚îÄ Models/                  # Data models
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PDF22MDContentElement # Protocol definition
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PDF22MDTextElement   # Text content
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ PDF22MDImageElement  # Image content
‚îÇ   ‚îú‚îÄ‚îÄ Services/                # Business logic services
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PDF22MDAssetManager  # Image extraction/saving
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ PDF22MDMarkdownGenerator # Markdown generation
‚îÇ   ‚îî‚îÄ‚îÄ CLI/                     # Command-line interface
‚îÇ       ‚îî‚îÄ‚îÄ main.m
```

## Building

### Using the Build Script (Recommended)
```bash
# Build the project
./build.sh

# Build and run tests
./build.sh --test

# Build and install to /usr/local/bin
./build.sh --install

# Build, test, and install
./build.sh --test --install
```

### Using Make Directly
```bash
# Build with make
make

# Build with custom version
make VERSION=1.2.3

# Clean build artifacts
make clean

# Install to /usr/local/bin
sudo make install
```

## Usage

```bash
# Convert a PDF file
./pdf22md -i document.pdf -o document.md

# Extract images to assets folder
./pdf22md -i report.pdf -o report.md -a ./assets

# Customize DPI for vector graphics
./pdf22md -i presentation.pdf -o presentation.md -a ./images -d 300

# Use with pipes
cat document.pdf | ./pdf22md > document.md
```

## Key Implementation Details

### Thread Safety
- Uses dispatch queues for concurrent page processing
- Thread-safe collections with `@synchronized` blocks
- Atomic property access for shared state

### Memory Management
- ARC-enabled with proper ownership semantics
- Strategic `@autoreleasepool` blocks in loops
- Manual Core Graphics memory management where needed

### Error Handling
```objc
typedef NS_ERROR_ENUM(PDF22MDErrorDomain, PDF22MDError) {
    PDF22MDErrorInvalidPDF = 1000,
    PDF22MDErrorAssetCreationFailed,
    PDF22MDErrorProcessingFailed,
    // ...
};
```

### Progress Reporting
```objc
builder.progressHandler = ^(NSInteger currentPage, NSInteger totalPages) {
    NSLog(@"Processing page %ld of %ld", currentPage, totalPages);
};
```

## Modern Objective-C Features Used

1. **Nullability Annotations**
   - `NS_ASSUME_NONNULL_BEGIN/END`
   - `nullable` and `nonnull` qualifiers

2. **Lightweight Generics**
   - `NSArray<id<PDF22MDContentElement>> *`
   - `NSDictionary<NSString *, NSNumber *> *`

3. **Designated Initializers**
   - `NS_DESIGNATED_INITIALIZER`
   - `NS_UNAVAILABLE` for unsupported initializers

4. **Property Attributes**
   - Proper use of `copy`, `strong`, `weak`, `readonly`

5. **Modern Enumerations**
   - `NS_ENUM` and `NS_ERROR_ENUM` macros

## Testing

```bash
# Run basic tests
make test

# Test with sample PDFs
./pdf22md -i ../test/sample.pdf -o output.md -a ./test-assets
```

## Performance

- Utilizes all available CPU cores via GCD
- Concurrent image extraction and saving
- Memory-efficient streaming for large PDFs
- Optimized font analysis with caching

## Requirements

- macOS 10.15 or later
- Xcode Command Line Tools
- ARC enabled

## License

MIT License - see LICENSE file in the root directory
</file>

<file path="pdf22md-swift/Tests/PDF22MDTests/PDF22MDTests.swift">
import XCTest
@testable import PDF22MD

final class PDF22MDTests: XCTestCase {
    
    // MARK: - TextElement Tests
    
    func testTextElementCreation() {
        let element = TextElement(
            text: "Hello, World!",
            bounds: CGRect(x: 0, y: 0, width: 100, height: 20),
            pageIndex: 0
        )
        
        XCTAssertEqual(element.text, "Hello, World!")
        XCTAssertEqual(element.pageIndex, 0)
        XCTAssertEqual(element.headingLevel, 0)
        XCTAssertFalse(element.isBold)
        XCTAssertFalse(element.isItalic)
    }
    
    func testTextElementMarkdownGeneration() {
        // Test regular text
        let regularText = TextElement(
            text: "Regular paragraph text",
            bounds: CGRect.zero,
            pageIndex: 0
        )
        XCTAssertEqual(regularText.markdownRepresentation(), "Regular paragraph text")
        
        // Test heading
        var heading = TextElement(
            text: "Chapter Title",
            bounds: CGRect.zero,
            pageIndex: 0
        )
        heading.headingLevel = 1
        XCTAssertEqual(heading.markdownRepresentation(), "# Chapter Title")
        
        // Test bold text
        let boldText = TextElement(
            text: "Bold text",
            bounds: CGRect.zero,
            pageIndex: 0,
            fontName: "Arial-Bold",
            fontSize: 12.0,
            isBold: true,
            isItalic: false
        )
        XCTAssertEqual(boldText.markdownRepresentation(), "**Bold text**")
        
        // Test italic text
        let italicText = TextElement(
            text: "Italic text",
            bounds: CGRect.zero,
            pageIndex: 0,
            fontName: "Arial-Italic",
            fontSize: 12.0,
            isBold: false,
            isItalic: true
        )
        XCTAssertEqual(italicText.markdownRepresentation(), "*Italic text*")
        
        // Test bold italic text
        let boldItalicText = TextElement(
            text: "Bold italic text",
            bounds: CGRect.zero,
            pageIndex: 0,
            fontName: "Arial-BoldItalic",
            fontSize: 12.0,
            isBold: true,
            isItalic: true
        )
        XCTAssertEqual(boldItalicText.markdownRepresentation(), "***Bold italic text***")
    }
    
    func testTextElementEquality() {
        let element1 = TextElement(
            text: "Test text",
            bounds: CGRect(x: 0, y: 0, width: 100, height: 20),
            pageIndex: 0
        )
        
        let element2 = TextElement(
            text: "Test text",
            bounds: CGRect(x: 0, y: 0, width: 100, height: 20),
            pageIndex: 0
        )
        
        XCTAssertEqual(element1, element2)
    }
    
    // MARK: - ConversionOptions Tests
    
    func testConversionOptionsDefaults() {
        let options = ConversionOptions()
        
        XCTAssertNil(options.assetsFolderPath)
        XCTAssertEqual(options.rasterizationDPI, 144.0)
        XCTAssertTrue(options.includeMetadata)
        XCTAssertTrue(options.extractImages)
        XCTAssertTrue(options.preserveOutline)
        XCTAssertEqual(options.headingFontSizeThreshold, 2.0)
        XCTAssertEqual(options.maxHeadingLevel, 6)
    }
    
    func testConversionOptionsValidation() {
        var options = ConversionOptions()
        
        // Valid options should not throw
        XCTAssertNoThrow(try options.validate())
        
        // Invalid DPI should throw
        options.rasterizationDPI = -1
        XCTAssertThrowsError(try options.validate()) { error in
            XCTAssertTrue(error is PDFError)
            if case .invalidConfiguration = error as! PDFError {
                // Expected error type
            } else {
                XCTFail("Expected invalidConfiguration error")
            }
        }
        
        // Reset to valid value
        options.rasterizationDPI = 144.0
        
        // Invalid max heading level should throw
        options.maxHeadingLevel = 0
        XCTAssertThrowsError(try options.validate())
        
        options.maxHeadingLevel = 7
        XCTAssertThrowsError(try options.validate())
    }
    
    func testConversionOptionsBuilder() {
        let options = ConversionOptionsBuilder()
            .assetsFolderPath("/tmp/assets")
            .rasterizationDPI(300.0)
            .includeMetadata(false)
            .extractImages(true)
            .maxHeadingLevel(3)
            .build()
        
        XCTAssertEqual(options.assetsFolderPath, "/tmp/assets")
        XCTAssertEqual(options.rasterizationDPI, 300.0)
        XCTAssertFalse(options.includeMetadata)
        XCTAssertTrue(options.extractImages)
        XCTAssertEqual(options.maxHeadingLevel, 3)
    }
    
    // MARK: - FontAnalyzer Tests
    
    func testFontKeyGeneration() {
        let key1 = FontAnalyzer.fontKey(forFontName: "Arial", fontSize: 12.0)
        let key2 = FontAnalyzer.fontKey(forFontName: "Arial", fontSize: 12.0)
        let key3 = FontAnalyzer.fontKey(forFontName: "Arial", fontSize: 14.0)
        let key4 = FontAnalyzer.fontKey(forFontName: nil, fontSize: 12.0)
        
        XCTAssertEqual(key1, key2)
        XCTAssertNotEqual(key1, key3)
        XCTAssertEqual(key4, "12.0-Unknown")
    }
    
    func testFontAnalyzerBasicFunctionality() {
        let analyzer = FontAnalyzer()
        
        let elements: [ContentElement] = [
            TextElement(
                text: "Body text",
                bounds: CGRect.zero,
                pageIndex: 0,
                fontName: "Arial",
                fontSize: 12.0,
                isBold: false,
                isItalic: false
            ),
            TextElement(
                text: "Heading",
                bounds: CGRect.zero,
                pageIndex: 0,
                fontName: "Arial-Bold",
                fontSize: 18.0,
                isBold: true,
                isItalic: false
            )
        ]
        
        analyzer.analyzeElements(elements)
        let stats = analyzer.getSortedFontStatistics()
        
        XCTAssertEqual(stats.count, 2)
        // Should be sorted by font size (largest first)
        XCTAssertEqual(stats[0].fontSize, 18.0)
        XCTAssertEqual(stats[1].fontSize, 12.0)
    }
    
    // MARK: - PDFError Tests
    
    func testPDFErrorMessages() {
        let invalidPDFError = PDFError.invalidPDF(reason: "Corrupted file")
        XCTAssertEqual(invalidPDFError.errorDescription, "Invalid or corrupted PDF file: Corrupted file")
        
        let assetError = PDFError.assetCreationFailed(path: "/tmp/test", reason: "No permission")
        XCTAssertEqual(assetError.errorDescription, "Failed to create or save asset at /tmp/test: No permission")
        
        let pageError = PDFError.pageProcessingFailed(page: 5, reason: "Malformed content")
        XCTAssertEqual(pageError.errorDescription, "Failed to process page 6: Malformed content")
        
        let cancelledError = PDFError.cancelled
        XCTAssertEqual(cancelledError.errorDescription, "Operation was cancelled")
    }
    
    // MARK: - MarkdownGenerator Tests
    
    func testMarkdownGeneratorBasic() {
        let options = ConversionOptions()
        let generator = MarkdownGenerator(options: options)
        
        let elements: [ContentElement] = [
            TextElement(text: "First paragraph", bounds: CGRect.zero, pageIndex: 0),
            TextElement(text: "Second paragraph", bounds: CGRect.zero, pageIndex: 0)
        ]
        
        let markdown = generator.generateMarkdownContent(from: elements)
        XCTAssertTrue(markdown.contains("First paragraph"))
        XCTAssertTrue(markdown.contains("Second paragraph"))
    }
    
    func testYAMLEscaping() {
        let options = ConversionOptions()
        let generator = MarkdownGenerator(options: options)
        
        // Test string escaping
        let testString = "Test \"quotes\" and\nnewlines"
        let escaped = generator.generateYAMLFrontmatter(DocumentMetadata(pageCount: 1))
        
        // Basic YAML structure should be present
        XCTAssertTrue(escaped?.contains("---") == true)
        XCTAssertTrue(escaped?.contains("pdf_metadata:") == true)
        XCTAssertTrue(escaped?.contains("page_count: 1") == true)
    }
    
    // MARK: - Performance Tests
    
    func testTextElementPerformance() {
        measure {
            for i in 0..<1000 {
                let element = TextElement(
                    text: "Performance test text \(i)",
                    bounds: CGRect(x: 0, y: CGFloat(i), width: 100, height: 20),
                    pageIndex: i % 10
                )
                _ = element.markdownRepresentation()
            }
        }
    }
    
    func testFontAnalyzerPerformance() {
        let analyzer = FontAnalyzer()
        let elements = (0..<1000).map { i in
            TextElement(
                text: "Text \(i)",
                bounds: CGRect.zero,
                pageIndex: 0,
                fontName: "Arial",
                fontSize: CGFloat(12 + (i % 6)),
                isBold: i % 2 == 0,
                isItalic: i % 3 == 0
            )
        }
        
        measure {
            analyzer.analyzeElements(elements)
            _ = analyzer.getSortedFontStatistics()
        }
    }
}
</file>

<file path="pdf22md-swift/Package.swift">
// swift-tools-version: 5.7
// The swift-tools-version declares the minimum version of Swift required to build this package.

import PackageDescription

let package = Package(
    name: "pdf22md",
    platforms: [
        .macOS(.v12) // Required for async/await
    ],
    products: [
        // Library product for programmatic usage
        .library(
            name: "PDF22MD",
            targets: ["PDF22MD"]
        ),
        // Executable product for CLI
        .executable(
            name: "pdf22md",
            targets: ["pdf22md"]
        )
    ],
    dependencies: [
        // Swift Argument Parser for CLI
        .package(url: "https://github.com/apple/swift-argument-parser", from: "1.2.0")
    ],
    targets: [
        // Main library target
        .target(
            name: "PDF22MD",
            dependencies: [],
            swiftSettings: [
                .define("VERSION", to: "\"1.0.0\"")
            ]
        ),
        // CLI executable target
        .executableTarget(
            name: "pdf22md",
            dependencies: [
                "PDF22MD",
                .product(name: "ArgumentParser", package: "swift-argument-parser")
            ]
        ),
        // Test target
        .testTarget(
            name: "PDF22MDTests",
            dependencies: ["PDF22MD"],
            resources: [
                .process("Resources")
            ]
        )
    ]
)
</file>

<file path="pdf22md-swift/README.md">
# pdf22md - Modern Swift Implementation

A high-performance PDF to Markdown converter built with modern Swift features including async/await, actors, and structured concurrency.

## Features

- **Modern Swift**: Uses Swift 5.7+ features including async/await, actors, and result builders
- **Structured Concurrency**: Concurrent page processing with TaskGroup and proper cancellation
- **Memory Safe**: Automatic memory management with value types where appropriate
- **Type Safe**: Strong typing with enums, associated types, and generic constraints
- **Actor-Based Assets**: Thread-safe image processing with actors
- **Progress Streaming**: Real-time progress updates with AsyncSequence

## Architecture

```
pdf22md-swift/
‚îú‚îÄ‚îÄ Sources/
‚îÇ   ‚îú‚îÄ‚îÄ PDF22MD/                 # Library module
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Core/                # Core conversion logic
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PDFConverter     # Main coordinator
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PDFPageProcessor # Page content extraction
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ FontAnalyzer     # Heading detection
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PDFError         # Error handling
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ConversionOptions # Configuration
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Models/              # Data models
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ContentElement   # Protocol definition
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TextElement      # Text content (struct)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ImageElement     # Image content (class)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Services/            # Business logic services
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ AssetManager     # Image extraction (actor)
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ MarkdownGenerator # Markdown generation
‚îÇ   ‚îî‚îÄ‚îÄ pdf22md/                 # CLI executable
‚îÇ       ‚îî‚îÄ‚îÄ main.swift
‚îú‚îÄ‚îÄ Tests/
‚îÇ   ‚îî‚îÄ‚îÄ PDF22MDTests/
‚îú‚îÄ‚îÄ Package.swift
‚îî‚îÄ‚îÄ README.md
```

## Building

### Using the Build Script (Recommended)
```bash
# Build the project
./build.sh

# Build and run tests
./build.sh --test

# Build and install to /usr/local/bin
./build.sh --install

# Build, test, and install
./build.sh --test --install

# Create release archive
./release.sh
```

### Using Swift Package Manager Directly
```bash
# Build with Swift Package Manager
swift build

# Build optimized release
swift build -c release

# Run tests
swift test

# Generate documentation
swift package generate-documentation
```

## Installation

### Swift Package Manager

Add to your `Package.swift`:

```swift
dependencies: [
    .package(url: "https://github.com/twardoch/pdf22md-swift", from: "1.0.0")
]
```

### Executable

```bash
# Build executable
swift build -c release

# Copy to PATH
cp .build/release/pdf22md /usr/local/bin/
```

## Usage

### Command Line

```bash
# Convert a PDF file
pdf22md -i document.pdf -o document.md

# Extract images to assets folder
pdf22md -i report.pdf -o report.md -a ./assets

# Customize DPI and concurrency
pdf22md -i large.pdf -o large.md -d 300 --max-concurrency 8

# Use with pipes
cat document.pdf | pdf22md > document.md

# Verbose output with progress
pdf22md -i document.pdf -o document.md --verbose
```

### Programmatic Usage

```swift
import PDF22MD

// Simple conversion
let converter = try PDFConverter(url: inputURL)
let markdown = try await converter.convert()

// With custom options
let options = ConversionOptions(
    assetsFolderPath: "./assets",
    rasterizationDPI: 300.0,
    includeMetadata: true
)

let markdown = try await converter.convert(options: options)

// Using builder pattern
let options = ConversionOptionsBuilder()
    .assetsFolderPath("./images")
    .rasterizationDPI(300)
    .maxConcurrentPages(4)
    .progressHandler { page, total in
        print("Processing \(page)/\(total)")
    }
    .build()

// Convenience method
try await PDFConverter.convert(
    inputURL: inputURL,
    outputURL: outputURL,
    options: options
)
```

## Key Swift Features Used

### 1. Async/Await
```swift
public func convert(options: ConversionOptions = .default) async throws -> String {
    return try await withThrowingTaskGroup(of: (Int, [ContentElement]).self) { group in
        // Process pages concurrently
    }
}
```

### 2. Actors for Thread Safety
```swift
public actor AssetManager {
    private var usedFilenames: Set<String> = []
    
    public func saveImage(_ image: CGImage) async throws -> String {
        // Thread-safe image saving
    }
}
```

### 3. Result Types
```swift
public enum PDFError: LocalizedError {
    case invalidPDF(reason: String?)
    case processingFailed(reason: String, underlyingError: Error?)
    // ...
}
```

### 4. Value Types
```swift
public struct TextElement: ContentElement, Equatable, Hashable {
    public let text: String
    public let bounds: CGRect
    // Immutable by default
}
```

### 5. Protocol Extensions
```swift
public extension ContentElement {
    func isOnSameLine(as other: ContentElement) -> Bool {
        // Default implementation
    }
}
```

### 6. Structured Concurrency
```swift
return try await withThrowingTaskGroup(of: (Int, [ContentElement]).self) { group in
    for pageIndex in 0..<pageCount {
        group.addTask {
            // Process page concurrently
        }
    }
    // Collect results
}
```

## Testing

```bash
# Run all tests
swift test

# Run specific test
swift test --filter PDF22MDTests.testTextElementCreation

# Run tests with coverage
swift test --enable-code-coverage

# Performance tests
swift test --filter Performance
```

## Performance

- Utilizes all available CPU cores with structured concurrency
- Actor-based asset management for thread-safe operations
- Memory-efficient with proper value/reference type usage
- Cancellation support for long-running operations
- Streaming progress updates

## Error Handling

```swift
do {
    let markdown = try await converter.convert()
} catch PDFError.invalidPDF(let reason) {
    print("Invalid PDF: \(reason ?? "Unknown error")")
} catch PDFError.processingFailed(let reason, let underlying) {
    print("Processing failed: \(reason)")
    if let underlying = underlying {
        print("Underlying error: \(underlying)")
    }
} catch {
    print("Unexpected error: \(error)")
}
```

## Requirements

- macOS 12.0 or later (for async/await)
- Swift 5.7 or later
- Xcode 14.0 or later

## Documentation

Generate documentation with:

```bash
swift package generate-documentation
```

View documentation:

```bash
swift package preview-documentation
```

## License

MIT License - see LICENSE file in the root directory
</file>

<file path="test/README.md">
---
title: "README.md"
creator: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36 Edg/137.0.0.0"
producer: "Skia/PDF m137"
created: 2025-06-23T01:33:53+02:00
modified: 2025-06-23T01:33:53+02:00
pdf_metadata:
  page_count: 2
conversion:
  tool: "pdf22md"
  version: "v1.1.0-dirty"
  date: 2025-06-23T02:28:31+02:00
---

23/06/2025, 01:33 README.md

![Image](image_000.png)

![Image](image_001.png)

pdf22md

MIT

License MIT

License

10.15+

![Image](image_002.png)

![Image](image_003.png)

macOS 10.15+

macOS

Build and Release Build and Release passing passing

A blazingly fast PDF to Markdown converter for macOS.

pdf22md is a command-line tool that extracts all text and image content from a PDF file and converts it into a

![Image](image_004.png)

![Image](image_005.png)

![Image](image_006.png)

clean Markdown document. It uses Grand Central Dispatch (GCD) to process pages and save images in

parallel, making it exceptionally fast for multi-page documents.

Key Features

High-Speed Conversion: Uses all available CPU cores to process PDF pages concurrently

Intelligent Heading Detection: Analyzes font sizes and usage frequency to automatically format titles

![Image](image_007.png)

![Image](image_008.png)

![Image](image_009.png)

and headings ( # , ## , etc.)

Asset Extraction: Saves raster and vector images into a specified assets folder and links them correctly

in the Markdown file

Smart Image Formatting: Automatically chooses between JPEG (for photos) and PNG (for graphics with

transparency) to optimize file size and quality

Flexible I/O: Reads from a PDF file or stdin and writes to a Markdown file or stdout

![Image](image_010.png)

![Image](image_011.png)

![Image](image_012.png)

Customizable Rasterization: Allows setting a custom DPI for converting vector graphics to bitmaps

Installation

Using Homebrew (Coming Soon)

brew tap twardoch/pdf22md

brew install pdf22md

![Image](image_013.png)

![Image](image_014.png)

Building from Source

To build the project manually, you need Xcode Command Line Tools installed.

# Clone the repository

git clone https://github.com/twardoch/pdf22md.git

cd pdf22md

# Compile the tool

make

# Install it to /usr/local/bin (optional)

sudo make install

Download Pre-built Binary

Pre-built binaries are available from the Releases page.

Usage

Usage: pdf22md [-i input.pdf] [-o output.md] [-a assets

_

folder] [-d dpi]

Converts PDF documents to Markdown format

-i <path>: Input PDF file (default: stdin)

-o <path>: Output Markdown file (default: stdout)

-a <path>: Assets folder for extracted images

-d <dpi>: DPI for rasterizing vector graphics (default: 144)

Examples

# Convert a PDF file to Markdown

pdf22md -i document.pdf -o document.md

# Convert with images saved to an 'assets' folder

pdf22md -i report.pdf -o report.md -a ./assets

# Convert with custom DPI for vector graphics

pdf22md -i presentation.pdf -o presentation.md -a ./images -d 300

# Use with pipes

cat document.pdf | pdf22md > document.md

# Convert and view in less

pdf22md -i manual.pdf | less

Requirements

macOS 10.15 (Catalina) or later

Xcode Command Line Tools (for building from source)

Project Structure

pdf22md/

‚îú‚îÄ‚îÄ src/ # Source code

‚îÇ ‚îú‚îÄ‚îÄ main.m # Entry point

‚îÇ ‚îú‚îÄ‚îÄ PDFMarkdownConverter.* # Main conversion logic

‚îÇ ‚îú‚îÄ‚îÄ PDFPageProcessor.* # PDF page processing

‚îÇ ‚îú‚îÄ‚îÄ ContentElement.* # Content element definitions

‚îÇ ‚îî‚îÄ‚îÄ AssetExtractor.* # Image extraction logic

‚îú‚îÄ‚îÄ docs/ # Additional documentation

‚îú‚îÄ‚îÄ test/ # Test files

file:///Users/adam/Developer/vcs/github.twardoch/pub/pdf22md/README.md 1/2

23/06/2025, 01:33 README.md

![Image](image_015.png)

![Image](image_016.png)

‚îú‚îÄ‚îÄ LICENSE # MIT License

‚îú‚îÄ‚îÄ Makefile # Build configuration

‚îî‚îÄ‚îÄ README.md # This file

Contributing

Contributions are welcome! Please feel free to submit a Pull Request. For major changes, please open an

![Image](image_017.png)

![Image](image_018.png)

![Image](image_019.png)

issue first to discuss what you

would like to change.

1. Fork the repository

2. Create your feature branch ( git checkout -b feature/AmazingFeature )

3. Commit your changes ( git commit -m 'Add some AmazingFeature' )

![Image](image_020.png)

![Image](image_021.png)

![Image](image_022.png)

4. Push to the branch ( git push origin feature/AmazingFeature )

5. Open a Pull Request

License

This project is licensed under the MIT License - see the LICENSE file for details.

Acknowledgments

![Image](image_023.png)

![Image](image_024.png)

![Image](image_025.png)

![Image](image_026.png)

![Image](image_027.png)

Built with Apple‚Äôs PDFKit and Core Graphics frameworks

Parallel processing powered by Grand Central Dispatch (GCD)

Inspired by the need for fast, accurate PDF to Markdown conversion

Related Projects

pdfplumber - Python library for PDF processing

![Image](image_028.png)

pdf2md - Another PDF to Markdown converter

![Image](image_029.png)

![Image](image_030.png)

![Image](image_031.png)

![Image](image_032.png)

pandoc - Universal document converter

Changelog

See CHANGELOG.md for a list of changes in each version.

Support

If you encounter any issues or have questions, please open an issue on GitHub.

![Image](image_033.png)

![Image](image_034.png)

file:///Users/adam/Developer/vcs/github.twardoch/pub/pdf22md/README.md 2/2
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2024 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path=".github/workflows/build-release.yml">
name: Build and Release

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  release:
    types: [ created ]

jobs:
  build:
    runs-on: macos-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Build the tool
      run: make

    - name: Run a basic check
      run: ./pdf22md -h

  create-release:
    if: github.event_name == 'release'
    runs-on: macos-latest
    needs: build

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Build the binary
      run: make

    - name: Create Tarball Archive
      run: |
        tar -czvf pdf22md-macos-x86_64.tar.gz pdf22md

    - name: Upload Release Asset
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ github.event.release.upload_url }}
        asset_path: ./pdf22md-macos-x86_64.tar.gz
        asset_name: pdf22md-macos-x86_64.tar.gz
        asset_content_type: application/gzip
</file>

<file path=".gitignore">
# Build products
build/
*.o
pdf22md

# macOS
.DS_Store
.AppleDouble
.LSOverride

# Thumbnails
._*

# Files that might appear on external disk
.Spotlight-V100
.Trashes

# Editor-specific
.vscode/
*.swp
.idea/
*.xcodeproj/
*.xcworkspace/

# Cursor and other AI assistants
.cursor/
.cursorrules
.cursorindexingignore
.giga/
.specstory/

# Test artifacts
test/out/
*.md
!README.md
!TODO.md
!CLAUDE.md
!AGENTS.md
!CHANGELOG.md
!docs/*.md
</file>

<file path="CLAUDE.md">
# pdf22md

A blazingly fast PDF to Markdown converter for macOS.

`pdf22md` is a command-line tool that extracts all text and image content from a PDF file and converts it into a clean Markdown document. It uses Grand Central Dispatch (GCD) to process pages and save images in parallel, making it exceptionally fast for multi-page documents.

### Key Features

  * **High-Speed Conversion**: Uses all available CPU cores to process PDF pages concurrently.
  * **Intelligent Heading Detection**: Analyzes font sizes and usage frequency to automatically format titles and headings (`#`, `##`, etc.).
  * **Asset Extraction**: Saves raster and vector images into a specified assets folder and links them correctly in the Markdown file.
  * **Smart Image Formatting**: Automatically chooses between JPEG (for photos) and PNG (for graphics with transparency) to optimize file size and quality.
  * **Flexible I/O**: Reads from a PDF file or `stdin` and writes to a Markdown file or `stdout`.
  * **Customizable Rasterization**: Allows setting a custom DPI for converting vector graphics to bitmaps.

### Installation

Once the Homebrew tap is set up (see plan below), installation is simple:

```bash
brew install <your-username>/pdf22md/pdf22md
```

### Building from Source

To build the project manually, you need Xcode Command Line Tools installed.

```bash
# Clone the repository (once it's public)
git clone https://github.com/<your-username>/pdf22md.git
cd pdf22md

# Compile the tool
make

# Install it to /usr/local/bin
sudo make install
```

### Usage

```
Usage: pdf22md [-i input.pdf] [-o output.md] [-a assets_folder] [-d dpi]
  Converts PDF documents to Markdown format
  -i <path>: Input PDF file (default: stdin)
  -o <path>: Output Markdown file (default: stdout)
  -a <path>: Assets folder for extracted images
  -d <dpi>: DPI for rasterizing vector graphics (default: 144)
```

**Example:**

```bash
# Convert a local PDF file and save images to an 'assets' folder
pdf22md -i report.pdf -o report.md -a ./assets
```

---


# main-overview

## Development Guidelines

- Only modify code directly relevant to the specific request. Avoid changing unrelated functionality.
- Never replace code with placeholders like `# ... rest of the processing ...`. Always include complete code.
- Break problems into smaller steps. Think through each step separately before implementing.
- Always provide a complete PLAN with REASONING based on evidence from code and logs before making changes.
- Explain your OBSERVATIONS clearly, then provide REASONING to identify the exact issue. Add console logs when needed to gather more information.


pdf22md is a PDF to Markdown converter that transforms PDF documents while preserving their semantic structure and content relationships.

Core Business Components:

1. Document Structure Analysis (Importance: 95)
- Hierarchical heading detection using font statistics
- Document structure preservation through positional element sorting
- Automated heading level assignment (H1-H6) based on font usage patterns

2. Content Classification System (Importance: 85)
- TextElement: Handles formatted text with style attributes
- ImageElement: Manages both raster and vector graphics
- Content relationship tracking between elements

3. Asset Processing Pipeline (Importance: 80)
- Intelligent format selection between PNG/JPEG based on:
  * Transparency detection
  * Color complexity analysis
  * Dimension-based optimization
- Asset extraction with maintained document references

4. PDF Content Processing (Importance: 90)
- Text styling and formatting context preservation
- Vector graphics path construction tracking
- Coordinate system transformation management
- Element bounds calculation for layout fidelity

Key Integration Points:

1. Content Extraction Layer
- Connects PDF parsing with markdown generation
- Maintains element relationships and hierarchy
- Preserves formatting context across transformations

2. Asset Management Layer
- Links extracted images with markdown references
- Maintains asset organization structure
- Handles format conversions while preserving quality

The system organizes business logic around content transformation pipelines while maintaining document semantic structure throughout the conversion process.

‚Äî‚Äî When you‚Äôre done with a round of updates, update CHANGELOG.md with the changes, remove done things from TODO.md, identify new things that need to be done and add them to TODO.md. Then build the app or run ./release.sh and then continue updates.
</file>

<file path="AGENTS.md">
# pdf22md

A blazingly fast PDF to Markdown converter for macOS.

`pdf22md` is a command-line tool that extracts all text and image content from a PDF file and converts it into a clean Markdown document. It uses Grand Central Dispatch (GCD) to process pages and save images in parallel, making it exceptionally fast for multi-page documents.

### Key Features

  * **High-Speed Conversion**: Uses all available CPU cores to process PDF pages concurrently.
  * **Intelligent Heading Detection**: Analyzes font sizes and usage frequency to automatically format titles and headings (`#`, `##`, etc.).
  * **Asset Extraction**: Saves raster and vector images into a specified assets folder and links them correctly in the Markdown file.
  * **Smart Image Formatting**: Automatically chooses between JPEG (for photos) and PNG (for graphics with transparency) to optimize file size and quality.
  * **Flexible I/O**: Reads from a PDF file or `stdin` and writes to a Markdown file or `stdout`.
  * **Customizable Rasterization**: Allows setting a custom DPI for converting vector graphics to bitmaps.

### Installation

Once the Homebrew tap is set up (see plan below), installation is simple:

```bash
brew install <your-username>/pdf22md/pdf22md
```

### Building from Source

To build the project manually, you need Xcode Command Line Tools installed.

```bash
# Clone the repository (once it's public)
git clone https://github.com/<your-username>/pdf22md.git
cd pdf22md

# Compile the tool
make

# Install it to /usr/local/bin
sudo make install
```

### Usage

```
Usage: pdf22md [-i input.pdf] [-o output.md] [-a assets_folder] [-d dpi]
  Converts PDF documents to Markdown format
  -i <path>: Input PDF file (default: stdin)
  -o <path>: Output Markdown file (default: stdout)
  -a <path>: Assets folder for extracted images
  -d <dpi>: DPI for rasterizing vector graphics (default: 144)
```

**Example:**

```bash
# Convert a local PDF file and save images to an 'assets' folder
pdf22md -i report.pdf -o report.md -a ./assets
```

---


# main-overview

## Development Guidelines

- Only modify code directly relevant to the specific request. Avoid changing unrelated functionality.
- Never replace code with placeholders like `# ... rest of the processing ...`. Always include complete code.
- Break problems into smaller steps. Think through each step separately before implementing.
- Always provide a complete PLAN with REASONING based on evidence from code and logs before making changes.
- Explain your OBSERVATIONS clearly, then provide REASONING to identify the exact issue. Add console logs when needed to gather more information.


pdf22md is a PDF to Markdown converter that transforms PDF documents while preserving their semantic structure and content relationships.

Core Business Components:

1. Document Structure Analysis (Importance: 95)
- Hierarchical heading detection using font statistics
- Document structure preservation through positional element sorting
- Automated heading level assignment (H1-H6) based on font usage patterns

2. Content Classification System (Importance: 85)
- TextElement: Handles formatted text with style attributes
- ImageElement: Manages both raster and vector graphics
- Content relationship tracking between elements

3. Asset Processing Pipeline (Importance: 80)
- Intelligent format selection between PNG/JPEG based on:
  * Transparency detection
  * Color complexity analysis
  * Dimension-based optimization
- Asset extraction with maintained document references

4. PDF Content Processing (Importance: 90)
- Text styling and formatting context preservation
- Vector graphics path construction tracking
- Coordinate system transformation management
- Element bounds calculation for layout fidelity

Key Integration Points:

1. Content Extraction Layer
- Connects PDF parsing with markdown generation
- Maintains element relationships and hierarchy
- Preserves formatting context across transformations

2. Asset Management Layer
- Links extracted images with markdown references
- Maintains asset organization structure
- Handles format conversions while preserving quality

The system organizes business logic around content transformation pipelines while maintaining document semantic structure throughout the conversion process.

‚Äî‚Äî When you‚Äôre done with a round of updates, update CHANGELOG.md with the changes, remove done things from TODO.md, identify new things that need to be done and add them to TODO.md. Then build the app or run ./release.sh and then continue updates.
</file>

<file path="CHANGELOG.md">
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added
- **Complete Modern Objective-C Implementation**: Full feature-parity rewrite in modern Objective-C with nullability annotations, lightweight generics, and proper designated initializers
- **Complete Swift Implementation**: Modern Swift implementation with async/await, actors, and Swift Package Manager support
- **Multi-Implementation Architecture**: Three implementations (C/ObjC, Modern ObjC, Swift) for different use cases and platform requirements
- **Advanced Error Handling**: Custom error domains and comprehensive error reporting across all implementations
- **Thread-Safe Asset Management**: Concurrent image processing with proper synchronization
- **Modern Build Infrastructure**: Support for both Makefile and Xcode/SPM build systems
- Semantic versioning support based on git tags
- Version display option (-v, -V) in the command-line tool
- Release automation script (release.sh) for macOS
- GitHub Actions workflow for automated releases
- Package installer (.pkg) generation for macOS
- Universal binary support (Intel and Apple Silicon)
- Man page generation in release packages
- MIT License file for open-source compliance
- GitHub issue templates for bug reports and feature requests
- Comprehensive .gitignore file with proper exclusions
- Build directory structure to separate source from build artifacts
- CHANGELOG.md to track version history
- Professional project documentation standards

### Changed
- **Architectural Modernization**: Complete rewrite of core components using modern Objective-C and Swift patterns
- **Enhanced Font Analysis**: Improved heading detection algorithm with configurable thresholds
- **Robust Asset Processing**: Smart image format selection with transparency detection and quality optimization
- **Memory Management**: Enhanced memory efficiency with proper autorelease pool usage and actor-based resource management (Swift)
- Makefile now supports VERSION variable for build-time versioning
- Makefile now uses a dedicated `build/` directory for object files
- .gitignore updated to properly exclude build artifacts and editor files
- GitHub Actions workflow fixed to use correct binary name
- Project structure reorganized following professional standards

### Fixed
- **Critical Build Issues**: Resolved all compilation errors in modern Objective-C implementation including:
  - Fixed designated initializer chain issues
  - Resolved private instance variable access violations  
  - Fixed NSValue CGRect compatibility issues using NSData approach
  - Corrected deprecated UTType constant usage
  - Fixed method signature mismatches and unused variable warnings
- **Memory Safety**: All CGImageRef memory leaks resolved with proper resource management
- **Concurrency Issues**: Thread-safe operations with proper GCD usage and Swift actor patterns
- Build artifacts (.o files) no longer pollute the repository root
- GitHub Actions workflow now correctly references the pdf22md binary
- Make variable in .gitignore replaced with actual filename
- Removed all DEBUG logging statements from production code
- Fixed CLI deadlock caused by main-queue dispatch in `PDFMarkdownConverter`; completions now called directly
- Fixed hanging issue on certain malformed PDFs by replacing low-level CGPDFScanner-based extraction with PDFKit high-level API (see `PDFPageProcessor`)
- Removed unused CGPDFScanner operator callback functions and PDFScannerState struct that were part of the deprecated implementation
- Fixed segmentation fault during asset extraction (Phase 1a): removed premature CGImageRelease calls in `PDFPageProcessor` that deallocated images still in use
- **Build Script Compatibility**: Fixed bash incompatibility in build.sh by replacing `declare -A` associative arrays with simple variables for broader shell compatibility
- **Swift Build Resilience**: Enhanced build.sh with Swift toolchain health checks and graceful fallback handling when Swift toolchain is corrupted

### Removed
- Object files from repository root (moved to build directory)

## [1.0.0] - 2024-01-01

### Added
- Initial release of pdf22md
- PDF to Markdown conversion with parallel processing
- Intelligent heading detection based on font size analysis
- Asset extraction with smart image format selection (JPEG/PNG)
- Support for both file and stdin/stdout I/O
- Customizable DPI for vector graphics rasterization
- Grand Central Dispatch (GCD) for multi-core performance
- Comprehensive documentation
</file>

<file path="README.md">
# pdf22md

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![macOS](https://img.shields.io/badge/macOS-10.15+-blue.svg)](https://www.apple.com/macos/)
[![Build Status](https://github.com/twardoch/pdf22md/workflows/Build%20and%20Release/badge.svg)](https://github.com/twardoch/pdf22md/actions)

A blazingly fast PDF to Markdown converter for macOS.

`pdf22md` is a command-line tool that extracts all text and image content from a PDF file and converts it into a clean Markdown document. It uses Grand Central Dispatch (GCD) to process pages and save images in parallel, making it exceptionally fast for multi-page documents.

## Project Structure

This repository contains two separate implementations of pdf22md:

- **[pdf22md-objc/](./pdf22md-objc/)**: Modern Objective-C implementation with thread-safe design
- **[pdf22md-swift/](./pdf22md-swift/)**: Modern Swift implementation with async/await and structured concurrency

Both implementations provide the same core functionality with different architectural approaches.

## Key Features

- **High-Speed Conversion**: Uses all available CPU cores to process PDF pages concurrently
- **Intelligent Heading Detection**: Analyzes font sizes and usage frequency to automatically format titles and headings (`#`, `##`, etc.)
- **Asset Extraction**: Saves raster and vector images into a specified assets folder and links them correctly in the Markdown file
- **Smart Image Formatting**: Automatically chooses between JPEG (for photos) and PNG (for graphics with transparency) to optimize file size and quality
- **Flexible I/O**: Reads from a PDF file or `stdin` and writes to a Markdown file or `stdout`
- **Customizable Rasterization**: Allows setting a custom DPI for converting vector graphics to bitmaps

## Installation

### Using Homebrew (Coming Soon)

```bash
brew tap twardoch/pdf22md
brew install pdf22md
```

### Building from Source

To build the project manually, you need Xcode Command Line Tools installed.

#### Quick Start - Build Everything
```bash
# Clone the repository
git clone https://github.com/twardoch/pdf22md.git
cd pdf22md

# Build both implementations
./build.sh

# Build, test, and install both implementations
./build.sh --test --install

# Build and create release archives
./build.sh --release
```

#### Build Script Options
```bash
./build.sh                    # Build both implementations
./build.sh --test             # Build and test both implementations  
./build.sh --install          # Build and install both to /usr/local/bin
./build.sh --test --install   # Build, test, and install both
./build.sh --objc-only        # Build only Objective-C implementation
./build.sh --swift-only       # Build only Swift implementation
./build.sh --release          # Build both and create release archives
./build.sh --help             # Show all options
```

#### Building Individual Implementations

Each implementation can also be built independently:

**Objective-C Implementation:**
```bash
cd pdf22md-objc
./build.sh                    # Build only
./build.sh --test             # Build and test
./build.sh --install          # Build and install to /usr/local/bin/pdf22md
```

**Swift Implementation:**
```bash
cd pdf22md-swift
./build.sh                    # Build only
./build.sh --test             # Build and test
./build.sh --install          # Build and install to /usr/local/bin/pdf22md-swift
./release.sh                  # Create release archive
```

### Download Pre-built Binary

Pre-built binaries are available from the [Releases](https://github.com/twardoch/pdf22md/releases) page.

## Usage

```
Usage: pdf22md [-i input.pdf] [-o output.md] [-a assets_folder] [-d dpi]
  Converts PDF documents to Markdown format
  -i <path>: Input PDF file (default: stdin)
  -o <path>: Output Markdown file (default: stdout)
  -a <path>: Assets folder for extracted images
  -d <dpi>: DPI for rasterizing vector graphics (default: 144)
```

### Examples

```bash
# Convert a PDF file to Markdown
pdf22md -i document.pdf -o document.md

# Convert with images saved to an 'assets' folder
pdf22md -i report.pdf -o report.md -a ./assets

# Convert with custom DPI for vector graphics
pdf22md -i presentation.pdf -o presentation.md -a ./images -d 300

# Use with pipes
cat document.pdf | pdf22md > document.md

# Convert and view in less
pdf22md -i manual.pdf | less
```

## Requirements

- macOS 10.15 (Catalina) or later
- Xcode Command Line Tools (for building from source)

## Project Structure

```
pdf22md/
‚îú‚îÄ‚îÄ src/                    # Source code
‚îÇ   ‚îú‚îÄ‚îÄ main.m             # Entry point
‚îÇ   ‚îú‚îÄ‚îÄ PDFMarkdownConverter.*  # Main conversion logic
‚îÇ   ‚îú‚îÄ‚îÄ PDFPageProcessor.*      # PDF page processing
‚îÇ   ‚îú‚îÄ‚îÄ ContentElement.*        # Content element definitions
‚îÇ   ‚îî‚îÄ‚îÄ AssetExtractor.*        # Image extraction logic
‚îú‚îÄ‚îÄ docs/                   # Additional documentation
‚îú‚îÄ‚îÄ test/                   # Test files
‚îú‚îÄ‚îÄ LICENSE                 # MIT License
‚îú‚îÄ‚îÄ Makefile               # Build configuration
‚îî‚îÄ‚îÄ README.md              # This file
```

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request. For major changes, please open an issue first to discuss what you would like to change.

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/AmazingFeature`)
3. Commit your changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Acknowledgments

- Built with Apple's PDFKit and Core Graphics frameworks
- Parallel processing powered by Grand Central Dispatch (GCD)
- Inspired by the need for fast, accurate PDF to Markdown conversion

## Related Projects

- [pdfplumber](https://github.com/jsvine/pdfplumber) - Python library for PDF processing
- [pdf2md](https://github.com/axllent/pdf2md) - Another PDF to Markdown converter
- [pandoc](https://pandoc.org/) - Universal document converter

## Changelog

See [CHANGELOG.md](CHANGELOG.md) for a list of changes in each version.

## Support

If you encounter any issues or have questions, please [open an issue](https://github.com/twardoch/pdf22md/issues/new/choose) on GitHub.
</file>

<file path="TODO.md">
# TODO - MVP 1.0 Production Readiness

## üéØ MVP 1.0 Mission
Transform pdf22md from a solid foundation (85% ready) into a production-ready, professionally tested tool users can trust for critical workflows.

## ‚úÖ COMPLETED (Recent Achievements)
- [x] **Core Functionality**: PDF to Markdown conversion with parallel processing
- [x] **Multi-Implementation Architecture**: C/ObjC, Modern ObjC, and Swift versions all building
- [x] **Build Infrastructure**: Professional CI/CD, versioning, packaging, release automation
- [x] **Memory Safety**: Fixed all segmentation faults and memory leaks
- [x] **CLI Interface**: Functional command-line tool with proper argument parsing
- [x] **Documentation**: Comprehensive README, CHANGELOG, project documentation

---

## üö® CRITICAL PATH - MUST COMPLETE FOR MVP 1.0

### Phase 1: Foundation (Week 1) - Cannot Ship Without These

#### Testing Infrastructure [BLOCKING]
- [ ] **Create Tests directory structure**
  ```
  Tests/
  ‚îú‚îÄ‚îÄ Unit/PDFMarkdownConverterTests.m
  ‚îú‚îÄ‚îÄ Unit/AssetExtractorTests.m  
  ‚îú‚îÄ‚îÄ Unit/ContentElementTests.m
  ‚îú‚îÄ‚îÄ Unit/FontAnalyzerTests.m
  ‚îú‚îÄ‚îÄ Integration/EndToEndConversionTests.m
  ‚îú‚îÄ‚îÄ Integration/PerformanceBenchmarks.m
  ‚îú‚îÄ‚îÄ Integration/ErrorHandlingTests.m
  ‚îî‚îÄ‚îÄ Resources/[test PDFs]
  ```

- [ ] **Unit Tests Implementation**
  - [ ] PDF parsing validation tests
  - [ ] Markdown generation accuracy tests  
  - [ ] Asset extraction logic tests
  - [ ] Font analysis algorithm tests
  - [ ] Target: 80%+ code coverage on critical paths

- [ ] **Integration Tests Implementation**
  - [ ] End-to-end conversion validation
  - [ ] Performance baseline establishment
  - [ ] Memory leak detection tests
  - [ ] Error handling validation

- [ ] **CI/CD Integration**
  - [ ] Add test execution to GitHub Actions
  - [ ] Automated test reporting
  - [ ] Test failure blocking for releases

#### Enhanced Error Handling [BLOCKING]
- [ ] **Expand Error Definitions**
  ```objc
  PDF22MDErrorInvalidPDF,
  PDF22MDErrorAssetFolderCreation,
  PDF22MDErrorMemoryPressure,
  PDF22MDErrorProcessingTimeout,
  PDF22MDErrorEncryptedPDF,
  PDF22MDErrorEmptyDocument
  ```

- [ ] **User-Friendly Error Messages**
  - [ ] Implement PDF22MDErrorHelper class
  - [ ] Add actionable error suggestions
  - [ ] Replace generic "failed" with specific guidance

- [ ] **Graceful Error Recovery**
  - [ ] Handle malformed PDFs without crashes
  - [ ] Partial processing capabilities
  - [ ] Resource cleanup on failures

#### Performance Validation [BLOCKING]
- [ ] **Benchmarking Infrastructure**
  - [ ] Create pdf22md-benchmark utility
  - [ ] Implement baseline measurement
  - [ ] Add memory profiling capability
  - [ ] Performance regression testing

- [ ] **Validate "Blazingly Fast" Claims**
  - [ ] Benchmark against pandoc
  - [ ] Document performance characteristics
  - [ ] Establish performance targets (<2s for 10-page PDF)

---

## üîß HIGH PRIORITY - Required for Professional Product

### Phase 2: User Experience (Week 2)

#### Progress Reporting Enhancement
- [ ] **Real-time Progress Updates**
  - [ ] Implement PDF22MDProgressDelegate protocol
  - [ ] Add meaningful status messages ("Processing page 5 of 23...")
  - [ ] Phase completion notifications

#### CLI User Experience
- [ ] **Enhanced Command-Line Interface**
  - [ ] Add --verbose flag for detailed output
  - [ ] Add --validate flag to check PDF processability
  - [ ] Add --benchmark flag for performance profiling
  - [ ] Improve --version output with build info

#### Documentation Completion
- [ ] **Complete Man Page**
  - [ ] Write comprehensive manual with examples
  - [ ] Add troubleshooting section
  - [ ] Include performance characteristics
  - [ ] Test man page installation

---

## üì¶ MEDIUM PRIORITY - Enhance Distribution

### Phase 3: Distribution & Polish (Week 3)

#### Homebrew Integration
- [ ] **Create Homebrew Formula**
  - [ ] Write pdf22md.rb formula
  - [ ] Test installation process
  - [ ] Add automated verification tests
  - [ ] Submit to homebrew-core or create tap

#### Quality Assurance
- [ ] **Automated Quality Checks**
  - [ ] Implement `make test` target
  - [ ] Add `make benchmark` target  
  - [ ] Add `make memory-check` target
  - [ ] Add `make integration` target

#### Documentation Polish
- [ ] **Enhanced Project Documentation**
  - [ ] Add performance benchmarks to README
  - [ ] Create ARCHITECTURE.md for contributors
  - [ ] Write CONTRIBUTING.md with setup instructions
  - [ ] Add SECURITY.md for responsible disclosure

---

## üéØ MVP 1.0 SUCCESS CRITERIA

### Quality Gates (All Must Pass)
- [ ] **Test Coverage**: ‚â•80% unit test coverage on critical paths
- [ ] **Performance**: Measurably faster than pandoc on test corpus  
- [ ] **Reliability**: 99%+ success rate on diverse PDF collection
- [ ] **Memory**: Zero leaks detected in 24-hour stress test
- [ ] **Documentation**: Complete man page and troubleshooting guide
- [ ] **CI/CD**: All automated tests passing on multiple macOS versions
- [ ] **User Testing**: Manual validation on real-world documents

### Success Metrics
- [ ] **Technical**: Build succeeds on clean system, all tests pass
- [ ] **Performance**: <2 seconds for typical 10-page PDF with images
- [ ] **Reliability**: Handles malformed PDFs gracefully without crashes  
- [ ] **Usability**: New users can install and use successfully within 5 minutes
- [ ] **Maintainability**: New contributors can set up development environment in <30 minutes

---

## üöÄ POST-MVP 1.0 (Future Releases)

### Version 1.1 Enhancements
- [ ] **Advanced Features**
  - [ ] Table detection and formatting
  - [ ] List formatting improvements
  - [ ] Form/annotation support
  - [ ] Bookmark/outline preservation

- [ ] **Platform Expansion**
  - [ ] Linux support (GNUstep)
  - [ ] Docker containerization
  - [ ] Windows WSL support

- [ ] **Developer Experience**  
  - [ ] API documentation with HeaderDoc/DocC
  - [ ] Plugin architecture for extensibility
  - [ ] Python/Node.js bindings

---

## üéØ CURRENT FOCUS

**Week 1 Priority**: Testing Infrastructure
1. Set up test framework and directory structure
2. Implement core unit tests with 80% coverage
3. Create integration test suite with performance baselines
4. Add CI/CD test automation

**Next Milestone**: MVP 1.0 Release
- **Target Date**: 3 weeks from start of testing implementation
- **Success Indicator**: All quality gates passed, professional-grade tool ready for production use

---

## üìä PROGRESS TRACKING

**Overall MVP 1.0 Readiness**: 85% ‚Üí Target: 100%

- ‚úÖ **Core Functionality**: 100% (Complete)
- ‚úÖ **Architecture**: 95% (Excellent) 
- ‚ùå **Testing**: 0% (Critical Gap)
- ‚ùå **Error Handling**: 30% (Needs Enhancement)
- ‚ùå **Performance Validation**: 0% (No Benchmarks)
- ‚úÖ **Documentation**: 80% (Good Foundation)
- ‚úÖ **Build/Release**: 95% (Professional)

**Critical Path**: Testing Infrastructure ‚Üí Error Handling ‚Üí Performance Validation ‚Üí MVP 1.0 Release
</file>

</files>
